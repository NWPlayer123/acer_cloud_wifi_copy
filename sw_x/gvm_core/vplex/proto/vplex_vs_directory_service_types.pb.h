// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vplex_vs_directory_service_types.proto

#ifndef PROTOBUF_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto__INCLUDED
#define PROTOBUF_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "vplex_common_types.pb.h"
// @@protoc_insertion_point(includes)

namespace vplex {
namespace vsDirectory {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();

class APIVersion;
class Error;
class SessionInfo;
class ETicketData;
class Localization;
class TitleData;
class TitleDetail;
class ContentDetail;
class SaveData;
class TitleTicket;
class Subscription;
class SyncDirectory;
class DatasetData;
class DatasetDetail;
class StoredDataset;
class DeviceInfo;
class StorageAccessPort;
class StorageAccess;
class DeviceAccessTicket;
class UserStorage;
class UpdatedDataset;
class DatasetFilter;
class MssDetail;
class StorageUnitDetail;
class BrsDetail;
class BrsStorageUnitDetail;
class BackupStatus;
class GetSaveTicketsInput;
class GetSaveTicketsOutput;
class GetSaveDataInput;
class GetSaveDataOutput;
class GetOwnedTitlesInput;
class GetOwnedTitlesOutput;
class GetTitlesInput;
class GetTitlesOutput;
class GetTitleDetailsInput;
class GetTitleDetailsOutput;
class GetAttestationChallengeInput;
class GetAttestationChallengeOutput;
class AuthenticateDeviceInput;
class AuthenticateDeviceOutput;
class GetOnlineTitleTicketInput;
class GetOnlineTitleTicketOutput;
class GetOfflineTitleTicketsInput;
class GetOfflineTitleTicketsOutput;
class ListOwnedDataSetsInput;
class ListOwnedDataSetsOutput;
class GetDatasetDetailsInput;
class GetDatasetDetailsOutput;
class AddDataSetInput;
class AddDataSetOutput;
class AddCameraDatasetInput;
class AddCameraDatasetOutput;
class DeleteDataSetInput;
class DeleteDataSetOutput;
class RenameDataSetInput;
class RenameDataSetOutput;
class SetDataSetCacheInput;
class SetDataSetCacheOutput;
class RemoveDeviceFromSubscriptionsInput;
class RemoveDeviceFromSubscriptionsOutput;
class ListSubscriptionsInput;
class ListSubscriptionsOutput;
class AddSubscriptionsInput;
class AddSubscriptionsOutput;
class AddUserDatasetSubscriptionInput;
class AddUserDatasetSubscriptionOutput;
class AddCameraSubscriptionInput;
class AddCameraSubscriptionOutput;
class AddDatasetSubscriptionInput;
class AddDatasetSubscriptionOutput;
class DeleteSubscriptionsInput;
class DeleteSubscriptionsOutput;
class UpdateSubscriptionFilterInput;
class UpdateSubscriptionFilterOutput;
class UpdateSubscriptionLimitsInput;
class UpdateSubscriptionLimitsOutput;
class GetSubscriptionDetailsForDeviceInput;
class GetSubscriptionDetailsForDeviceOutput;
class GetCloudInfoInput;
class GetCloudInfoOutput;
class GetSubscribedDatasetsInput;
class GetSubscribedDatasetsOutput;
class GetSubscriptionDetailsInput;
class GetSubscriptionDetailsOutput;
class LinkDeviceInput;
class LinkDeviceOutput;
class UnlinkDeviceInput;
class UnlinkDeviceOutput;
class SetDeviceNameInput;
class SetDeviceNameOutput;
class UpdateDeviceInfoInput;
class UpdateDeviceInfoOutput;
class GetDeviceLinkStateInput;
class GetDeviceLinkStateOutput;
class GetDeviceNameInput;
class GetDeviceNameOutput;
class GetLinkedDevicesInput;
class GetLinkedDevicesOutput;
class GetLoginSessionInput;
class GetLoginSessionOutput;
class CreatePersonalStorageNodeInput;
class CreatePersonalStorageNodeOutput;
class GetAsyncNoticeServerInput;
class GetAsyncNoticeServerOutput;
class UpdateStorageNodeConnectionInput;
class UpdateStorageNodeConnectionOutput;
class UpdateStorageNodeFeaturesInput;
class UpdateStorageNodeFeaturesOutput;
class GetPSNDatasetLocationInput;
class GetPSNDatasetLocationOutput;
class UpdatePSNDatasetStatusInput;
class UpdatePSNDatasetStatusOutput;
class AddUserStorageInput;
class AddUserStorageOutput;
class DeleteUserStorageInput;
class DeleteUserStorageOutput;
class ChangeUserStorageNameInput;
class ChangeUserStorageNameOutput;
class ChangeUserStorageQuotaInput;
class ChangeUserStorageQuotaOutput;
class ListUserStorageInput;
class ListUserStorageOutput;
class GetUserStorageAddressInput;
class UserStorageAddress;
class GetUserStorageAddressOutput;
class AssignUserDatacenterStorageInput;
class AssignUserDatacenterStorageOutput;
class GetStorageUnitForDatasetInput;
class GetStorageUnitForDatasetOutput;
class GetStoredDatasetsInput;
class GetStoredDatasetsOutput;
class GetProxyConnectionForClusterInput;
class GetProxyConnectionForClusterOutput;
class SendMessageToPSNInput;
class SendMessageToPSNOutput;
class ChangeStorageUnitForDatasetInput;
class ChangeStorageUnitForDatasetOutput;
class CreateStorageClusterInput;
class CreateStorageClusterOutput;
class GetMssInstancesForClusterInput;
class GetMssInstancesForClusterOutput;
class GetStorageUnitsForClusterInput;
class GetStorageUnitsForClusterOutput;
class GetBrsInstancesForClusterInput;
class GetBrsInstancesForClusterOutput;
class GetBrsStorageUnitsForClusterInput;
class GetBrsStorageUnitsForClusterOutput;
class ChangeStorageAssignmentsForDatasetInput;
class ChangeStorageAssignmentsForDatasetOutput;
class UpdateDatasetStatusInput;
class UpdateDatasetStatusOutput;
class UpdateDatasetBackupStatusInput;
class UpdateDatasetBackupStatusOutput;
class UpdateDatasetArchiveStatusInput;
class UpdateDatasetArchiveStatusOutput;
class GetDatasetStatusInput;
class GetDatasetStatusOutput;
class StoreDeviceEventInput;
class StoreDeviceEventOutput;
class EventInfo;
class GetLinkedDatasetStatusInput;
class GetLinkedDatasetStatusOutput;
class GetUserQuotaStatusInput;
class GetUserQuotaStatusOutput;
class GetDatasetsToBackupInput;
class GetDatasetsToBackupOutput;
class GetBRSHostNameInput;
class GetBRSHostNameOutput;
class GetBackupStorageUnitsForBrsInput;
class GetBackupStorageUnitsForBrsOutput;
class GetUpdatedDatasetsInput;
class GetUpdatedDatasetsOutput;
class AddDatasetArchiveStorageDeviceInput;
class AddDatasetArchiveStorageDeviceOutput;
class RemoveDatasetArchiveStorageDeviceInput;
class RemoveDatasetArchiveStorageDeviceOutput;

enum DatasetType {
  USER = 1,
  CAMERA = 2,
  CLEAR_FI = 3,
  CR_UP = 4,
  CR_DOWN = 5,
  PIM = 6,
  CACHE = 7,
  PIM_CONTACTS = 8,
  PIM_EVENTS = 9,
  PIM_NOTES = 10,
  PIM_TASKS = 11,
  PIM_FAVORITES = 12,
  MEDIA = 13,
  MEDIA_METADATA = 14,
  FS = 15,
  VIRT_DRIVE = 16,
  CLEARFI_MEDIA = 17,
  USER_CONTENT_METADATA = 18,
  SYNCBOX = 19,
  SBM = 20,
  SWM = 21
};
bool DatasetType_IsValid(int value);
const DatasetType DatasetType_MIN = USER;
const DatasetType DatasetType_MAX = SWM;
const int DatasetType_ARRAYSIZE = DatasetType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DatasetType_descriptor();
inline const ::std::string& DatasetType_Name(DatasetType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DatasetType_descriptor(), value);
}
inline bool DatasetType_Parse(
    const ::std::string& name, DatasetType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DatasetType>(
    DatasetType_descriptor(), name, value);
}
enum RouteType {
  INVALID_ROUTE = 0,
  DIRECT_INTERNAL = 1,
  DIRECT_EXTERNAL = 2,
  PROXY = 3
};
bool RouteType_IsValid(int value);
const RouteType RouteType_MIN = INVALID_ROUTE;
const RouteType RouteType_MAX = PROXY;
const int RouteType_ARRAYSIZE = RouteType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RouteType_descriptor();
inline const ::std::string& RouteType_Name(RouteType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RouteType_descriptor(), value);
}
inline bool RouteType_Parse(
    const ::std::string& name, RouteType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RouteType>(
    RouteType_descriptor(), name, value);
}
enum ProtocolType {
  INVALID_PROTOCOL = 0,
  VS = 1
};
bool ProtocolType_IsValid(int value);
const ProtocolType ProtocolType_MIN = INVALID_PROTOCOL;
const ProtocolType ProtocolType_MAX = VS;
const int ProtocolType_ARRAYSIZE = ProtocolType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ProtocolType_descriptor();
inline const ::std::string& ProtocolType_Name(ProtocolType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ProtocolType_descriptor(), value);
}
inline bool ProtocolType_Parse(
    const ::std::string& name, ProtocolType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ProtocolType>(
    ProtocolType_descriptor(), name, value);
}
enum PortType {
  INVALID_PORT = 0,
  PORT_VSSI = 1,
  PORT_HTTP = 2,
  PORT_CLEARFI = 3,
  PORT_CLEARFI_SECURE = 4
};
bool PortType_IsValid(int value);
const PortType PortType_MIN = INVALID_PORT;
const PortType PortType_MAX = PORT_CLEARFI_SECURE;
const int PortType_ARRAYSIZE = PortType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PortType_descriptor();
inline const ::std::string& PortType_Name(PortType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PortType_descriptor(), value);
}
inline bool PortType_Parse(
    const ::std::string& name, PortType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PortType>(
    PortType_descriptor(), name, value);
}
enum SubscriptionRole {
  GENERAL = 0,
  PRODUCER = 1,
  CONSUMER = 2,
  CLEARFI_SERVER = 3,
  CLEARFI_CLIENT = 4,
  WRITER = 5,
  READER = 6
};
bool SubscriptionRole_IsValid(int value);
const SubscriptionRole SubscriptionRole_MIN = GENERAL;
const SubscriptionRole SubscriptionRole_MAX = READER;
const int SubscriptionRole_ARRAYSIZE = SubscriptionRole_MAX + 1;

const ::google::protobuf::EnumDescriptor* SubscriptionRole_descriptor();
inline const ::std::string& SubscriptionRole_Name(SubscriptionRole value) {
  return ::google::protobuf::internal::NameOfEnum(
    SubscriptionRole_descriptor(), value);
}
inline bool SubscriptionRole_Parse(
    const ::std::string& name, SubscriptionRole* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SubscriptionRole>(
    SubscriptionRole_descriptor(), name, value);
}
// ===================================================================

class APIVersion : public ::google::protobuf::Message {
 public:
  APIVersion();
  virtual ~APIVersion();
  
  APIVersion(const APIVersion& from);
  
  inline APIVersion& operator=(const APIVersion& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const APIVersion& default_instance();
  
  void Swap(APIVersion* other);
  
  // implements Message ----------------------------------------------
  
  APIVersion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const APIVersion& from);
  void MergeFrom(const APIVersion& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string version = 1 [default = "1.0"];
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.APIVersion)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* version_;
  static const ::std::string _default_version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static APIVersion* default_instance_;
};
// -------------------------------------------------------------------

class Error : public ::google::protobuf::Message {
 public:
  Error();
  virtual ~Error();
  
  Error(const Error& from);
  
  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Error& default_instance();
  
  void Swap(Error* other);
  
  // implements Message ----------------------------------------------
  
  Error* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Error& from);
  void MergeFrom(const Error& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 errorCode = 1;
  inline bool has_errorcode() const;
  inline void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::int32 errorcode() const;
  inline void set_errorcode(::google::protobuf::int32 value);
  
  // optional string errorDetail = 2;
  inline bool has_errordetail() const;
  inline void clear_errordetail();
  static const int kErrorDetailFieldNumber = 2;
  inline const ::std::string& errordetail() const;
  inline void set_errordetail(const ::std::string& value);
  inline void set_errordetail(const char* value);
  inline void set_errordetail(const char* value, size_t size);
  inline ::std::string* mutable_errordetail();
  inline ::std::string* release_errordetail();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.Error)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_errordetail();
  inline void clear_has_errordetail();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* errordetail_;
  ::google::protobuf::int32 errorcode_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static Error* default_instance_;
};
// -------------------------------------------------------------------

class SessionInfo : public ::google::protobuf::Message {
 public:
  SessionInfo();
  virtual ~SessionInfo();
  
  SessionInfo(const SessionInfo& from);
  
  inline SessionInfo& operator=(const SessionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SessionInfo& default_instance();
  
  void Swap(SessionInfo* other);
  
  // implements Message ----------------------------------------------
  
  SessionInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SessionInfo& from);
  void MergeFrom(const SessionInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed64 sessionHandle = 1;
  inline bool has_sessionhandle() const;
  inline void clear_sessionhandle();
  static const int kSessionHandleFieldNumber = 1;
  inline ::google::protobuf::uint64 sessionhandle() const;
  inline void set_sessionhandle(::google::protobuf::uint64 value);
  
  // required bytes serviceTicket = 2;
  inline bool has_serviceticket() const;
  inline void clear_serviceticket();
  static const int kServiceTicketFieldNumber = 2;
  inline const ::std::string& serviceticket() const;
  inline void set_serviceticket(const ::std::string& value);
  inline void set_serviceticket(const char* value);
  inline void set_serviceticket(const void* value, size_t size);
  inline ::std::string* mutable_serviceticket();
  inline ::std::string* release_serviceticket();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.SessionInfo)
 private:
  inline void set_has_sessionhandle();
  inline void clear_has_sessionhandle();
  inline void set_has_serviceticket();
  inline void clear_has_serviceticket();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 sessionhandle_;
  ::std::string* serviceticket_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static SessionInfo* default_instance_;
};
// -------------------------------------------------------------------

class ETicketData : public ::google::protobuf::Message {
 public:
  ETicketData();
  virtual ~ETicketData();
  
  ETicketData(const ETicketData& from);
  
  inline ETicketData& operator=(const ETicketData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ETicketData& default_instance();
  
  void Swap(ETicketData* other);
  
  // implements Message ----------------------------------------------
  
  ETicketData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ETicketData& from);
  void MergeFrom(const ETicketData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes eTicket = 1;
  inline bool has_eticket() const;
  inline void clear_eticket();
  static const int kETicketFieldNumber = 1;
  inline const ::std::string& eticket() const;
  inline void set_eticket(const ::std::string& value);
  inline void set_eticket(const char* value);
  inline void set_eticket(const void* value, size_t size);
  inline ::std::string* mutable_eticket();
  inline ::std::string* release_eticket();
  
  // repeated bytes certificate = 2;
  inline int certificate_size() const;
  inline void clear_certificate();
  static const int kCertificateFieldNumber = 2;
  inline const ::std::string& certificate(int index) const;
  inline ::std::string* mutable_certificate(int index);
  inline void set_certificate(int index, const ::std::string& value);
  inline void set_certificate(int index, const char* value);
  inline void set_certificate(int index, const void* value, size_t size);
  inline ::std::string* add_certificate();
  inline void add_certificate(const ::std::string& value);
  inline void add_certificate(const char* value);
  inline void add_certificate(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& certificate() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_certificate();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.ETicketData)
 private:
  inline void set_has_eticket();
  inline void clear_has_eticket();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* eticket_;
  ::google::protobuf::RepeatedPtrField< ::std::string> certificate_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static ETicketData* default_instance_;
};
// -------------------------------------------------------------------

class Localization : public ::google::protobuf::Message {
 public:
  Localization();
  virtual ~Localization();
  
  Localization(const Localization& from);
  
  inline Localization& operator=(const Localization& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Localization& default_instance();
  
  void Swap(Localization* other);
  
  // implements Message ----------------------------------------------
  
  Localization* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Localization& from);
  void MergeFrom(const Localization& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string language = 1;
  inline bool has_language() const;
  inline void clear_language();
  static const int kLanguageFieldNumber = 1;
  inline const ::std::string& language() const;
  inline void set_language(const ::std::string& value);
  inline void set_language(const char* value);
  inline void set_language(const char* value, size_t size);
  inline ::std::string* mutable_language();
  inline ::std::string* release_language();
  
  // required string country = 2;
  inline bool has_country() const;
  inline void clear_country();
  static const int kCountryFieldNumber = 2;
  inline const ::std::string& country() const;
  inline void set_country(const ::std::string& value);
  inline void set_country(const char* value);
  inline void set_country(const char* value, size_t size);
  inline ::std::string* mutable_country();
  inline ::std::string* release_country();
  
  // required string region = 3;
  inline bool has_region() const;
  inline void clear_region();
  static const int kRegionFieldNumber = 3;
  inline const ::std::string& region() const;
  inline void set_region(const ::std::string& value);
  inline void set_region(const char* value);
  inline void set_region(const char* value, size_t size);
  inline ::std::string* mutable_region();
  inline ::std::string* release_region();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.Localization)
 private:
  inline void set_has_language();
  inline void clear_has_language();
  inline void set_has_country();
  inline void clear_has_country();
  inline void set_has_region();
  inline void clear_has_region();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* language_;
  ::std::string* country_;
  ::std::string* region_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static Localization* default_instance_;
};
// -------------------------------------------------------------------

class TitleData : public ::google::protobuf::Message {
 public:
  TitleData();
  virtual ~TitleData();
  
  TitleData(const TitleData& from);
  
  inline TitleData& operator=(const TitleData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TitleData& default_instance();
  
  void Swap(TitleData* other);
  
  // implements Message ----------------------------------------------
  
  TitleData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TitleData& from);
  void MergeFrom(const TitleData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string titleId = 1;
  inline bool has_titleid() const;
  inline void clear_titleid();
  static const int kTitleIdFieldNumber = 1;
  inline const ::std::string& titleid() const;
  inline void set_titleid(const ::std::string& value);
  inline void set_titleid(const char* value);
  inline void set_titleid(const char* value, size_t size);
  inline ::std::string* mutable_titleid();
  inline ::std::string* release_titleid();
  
  // required int32 detailHash = 2;
  inline bool has_detailhash() const;
  inline void clear_detailhash();
  static const int kDetailHashFieldNumber = 2;
  inline ::google::protobuf::int32 detailhash() const;
  inline void set_detailhash(::google::protobuf::int32 value);
  
  // required int32 ticketVersion = 3;
  inline bool has_ticketversion() const;
  inline void clear_ticketversion();
  static const int kTicketVersionFieldNumber = 3;
  inline ::google::protobuf::int32 ticketversion() const;
  inline void set_ticketversion(::google::protobuf::int32 value);
  
  // required bool useOnlineETicket = 4;
  inline bool has_useonlineeticket() const;
  inline void clear_useonlineeticket();
  static const int kUseOnlineETicketFieldNumber = 4;
  inline bool useonlineeticket() const;
  inline void set_useonlineeticket(bool value);
  
  // required bool useOfflineETicket = 5;
  inline bool has_useofflineeticket() const;
  inline void clear_useofflineeticket();
  static const int kUseOfflineETicketFieldNumber = 5;
  inline bool useofflineeticket() const;
  inline void set_useofflineeticket(bool value);
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.TitleData)
 private:
  inline void set_has_titleid();
  inline void clear_has_titleid();
  inline void set_has_detailhash();
  inline void clear_has_detailhash();
  inline void set_has_ticketversion();
  inline void clear_has_ticketversion();
  inline void set_has_useonlineeticket();
  inline void clear_has_useonlineeticket();
  inline void set_has_useofflineeticket();
  inline void clear_has_useofflineeticket();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* titleid_;
  ::google::protobuf::int32 detailhash_;
  ::google::protobuf::int32 ticketversion_;
  bool useonlineeticket_;
  bool useofflineeticket_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static TitleData* default_instance_;
};
// -------------------------------------------------------------------

class TitleDetail : public ::google::protobuf::Message {
 public:
  TitleDetail();
  virtual ~TitleDetail();
  
  TitleDetail(const TitleDetail& from);
  
  inline TitleDetail& operator=(const TitleDetail& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TitleDetail& default_instance();
  
  void Swap(TitleDetail* other);
  
  // implements Message ----------------------------------------------
  
  TitleDetail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TitleDetail& from);
  void MergeFrom(const TitleDetail& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string titleId = 1;
  inline bool has_titleid() const;
  inline void clear_titleid();
  static const int kTitleIdFieldNumber = 1;
  inline const ::std::string& titleid() const;
  inline void set_titleid(const ::std::string& value);
  inline void set_titleid(const char* value);
  inline void set_titleid(const char* value, size_t size);
  inline ::std::string* mutable_titleid();
  inline ::std::string* release_titleid();
  
  // required string titleVersion = 2;
  inline bool has_titleversion() const;
  inline void clear_titleversion();
  static const int kTitleVersionFieldNumber = 2;
  inline const ::std::string& titleversion() const;
  inline void set_titleversion(const ::std::string& value);
  inline void set_titleversion(const char* value);
  inline void set_titleversion(const char* value, size_t size);
  inline ::std::string* mutable_titleversion();
  inline ::std::string* release_titleversion();
  
  // required string tmdUrl = 3;
  inline bool has_tmdurl() const;
  inline void clear_tmdurl();
  static const int kTmdUrlFieldNumber = 3;
  inline const ::std::string& tmdurl() const;
  inline void set_tmdurl(const ::std::string& value);
  inline void set_tmdurl(const char* value);
  inline void set_tmdurl(const char* value, size_t size);
  inline ::std::string* mutable_tmdurl();
  inline ::std::string* release_tmdurl();
  
  // repeated .vplex.vsDirectory.ContentDetail contents = 4;
  inline int contents_size() const;
  inline void clear_contents();
  static const int kContentsFieldNumber = 4;
  inline const ::vplex::vsDirectory::ContentDetail& contents(int index) const;
  inline ::vplex::vsDirectory::ContentDetail* mutable_contents(int index);
  inline ::vplex::vsDirectory::ContentDetail* add_contents();
  inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::ContentDetail >&
      contents() const;
  inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::ContentDetail >*
      mutable_contents();
  
  // optional string name = 5;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 5;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional string iconUrl = 6;
  inline bool has_iconurl() const;
  inline void clear_iconurl();
  static const int kIconUrlFieldNumber = 6;
  inline const ::std::string& iconurl() const;
  inline void set_iconurl(const ::std::string& value);
  inline void set_iconurl(const char* value);
  inline void set_iconurl(const char* value, size_t size);
  inline ::std::string* mutable_iconurl();
  inline ::std::string* release_iconurl();
  
  // optional string imageUrl = 7;
  inline bool has_imageurl() const;
  inline void clear_imageurl();
  static const int kImageUrlFieldNumber = 7;
  inline const ::std::string& imageurl() const;
  inline void set_imageurl(const ::std::string& value);
  inline void set_imageurl(const char* value);
  inline void set_imageurl(const char* value, size_t size);
  inline ::std::string* mutable_imageurl();
  inline ::std::string* release_imageurl();
  
  // optional string publisher = 8;
  inline bool has_publisher() const;
  inline void clear_publisher();
  static const int kPublisherFieldNumber = 8;
  inline const ::std::string& publisher() const;
  inline void set_publisher(const ::std::string& value);
  inline void set_publisher(const char* value);
  inline void set_publisher(const char* value, size_t size);
  inline ::std::string* mutable_publisher();
  inline ::std::string* release_publisher();
  
  // optional string genre = 9;
  inline bool has_genre() const;
  inline void clear_genre();
  static const int kGenreFieldNumber = 9;
  inline const ::std::string& genre() const;
  inline void set_genre(const ::std::string& value);
  inline void set_genre(const char* value);
  inline void set_genre(const char* value, size_t size);
  inline ::std::string* mutable_genre();
  inline ::std::string* release_genre();
  
  // optional .vplex.common.ContentRating contentRating = 10;
  inline bool has_contentrating() const;
  inline void clear_contentrating();
  static const int kContentRatingFieldNumber = 10;
  inline const ::vplex::common::ContentRating& contentrating() const;
  inline ::vplex::common::ContentRating* mutable_contentrating();
  inline ::vplex::common::ContentRating* release_contentrating();
  
  // optional .vplex.common.ContentRating altContentRating = 11;
  inline bool has_altcontentrating() const;
  inline void clear_altcontentrating();
  static const int kAltContentRatingFieldNumber = 11;
  inline const ::vplex::common::ContentRating& altcontentrating() const;
  inline ::vplex::common::ContentRating* mutable_altcontentrating();
  inline ::vplex::common::ContentRating* release_altcontentrating();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.TitleDetail)
 private:
  inline void set_has_titleid();
  inline void clear_has_titleid();
  inline void set_has_titleversion();
  inline void clear_has_titleversion();
  inline void set_has_tmdurl();
  inline void clear_has_tmdurl();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_iconurl();
  inline void clear_has_iconurl();
  inline void set_has_imageurl();
  inline void clear_has_imageurl();
  inline void set_has_publisher();
  inline void clear_has_publisher();
  inline void set_has_genre();
  inline void clear_has_genre();
  inline void set_has_contentrating();
  inline void clear_has_contentrating();
  inline void set_has_altcontentrating();
  inline void clear_has_altcontentrating();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* titleid_;
  ::std::string* titleversion_;
  ::std::string* tmdurl_;
  ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::ContentDetail > contents_;
  ::std::string* name_;
  ::std::string* iconurl_;
  ::std::string* imageurl_;
  ::std::string* publisher_;
  ::std::string* genre_;
  ::vplex::common::ContentRating* contentrating_;
  ::vplex::common::ContentRating* altcontentrating_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static TitleDetail* default_instance_;
};
// -------------------------------------------------------------------

class ContentDetail : public ::google::protobuf::Message {
 public:
  ContentDetail();
  virtual ~ContentDetail();
  
  ContentDetail(const ContentDetail& from);
  
  inline ContentDetail& operator=(const ContentDetail& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ContentDetail& default_instance();
  
  void Swap(ContentDetail* other);
  
  // implements Message ----------------------------------------------
  
  ContentDetail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContentDetail& from);
  void MergeFrom(const ContentDetail& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string contentId = 1;
  inline bool has_contentid() const;
  inline void clear_contentid();
  static const int kContentIdFieldNumber = 1;
  inline const ::std::string& contentid() const;
  inline void set_contentid(const ::std::string& value);
  inline void set_contentid(const char* value);
  inline void set_contentid(const char* value, size_t size);
  inline ::std::string* mutable_contentid();
  inline ::std::string* release_contentid();
  
  // required string contentLocation = 2;
  inline bool has_contentlocation() const;
  inline void clear_contentlocation();
  static const int kContentLocationFieldNumber = 2;
  inline const ::std::string& contentlocation() const;
  inline void set_contentlocation(const ::std::string& value);
  inline void set_contentlocation(const char* value);
  inline void set_contentlocation(const char* value, size_t size);
  inline ::std::string* mutable_contentlocation();
  inline ::std::string* release_contentlocation();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.ContentDetail)
 private:
  inline void set_has_contentid();
  inline void clear_has_contentid();
  inline void set_has_contentlocation();
  inline void clear_has_contentlocation();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* contentid_;
  ::std::string* contentlocation_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static ContentDetail* default_instance_;
};
// -------------------------------------------------------------------

class SaveData : public ::google::protobuf::Message {
 public:
  SaveData();
  virtual ~SaveData();
  
  SaveData(const SaveData& from);
  
  inline SaveData& operator=(const SaveData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SaveData& default_instance();
  
  void Swap(SaveData* other);
  
  // implements Message ----------------------------------------------
  
  SaveData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SaveData& from);
  void MergeFrom(const SaveData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string titleId = 1;
  inline bool has_titleid() const;
  inline void clear_titleid();
  static const int kTitleIdFieldNumber = 1;
  inline const ::std::string& titleid() const;
  inline void set_titleid(const ::std::string& value);
  inline void set_titleid(const char* value);
  inline void set_titleid(const char* value, size_t size);
  inline ::std::string* mutable_titleid();
  inline ::std::string* release_titleid();
  
  // required string saveLocation = 2;
  inline bool has_savelocation() const;
  inline void clear_savelocation();
  static const int kSaveLocationFieldNumber = 2;
  inline const ::std::string& savelocation() const;
  inline void set_savelocation(const ::std::string& value);
  inline void set_savelocation(const char* value);
  inline void set_savelocation(const char* value, size_t size);
  inline ::std::string* mutable_savelocation();
  inline ::std::string* release_savelocation();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.SaveData)
 private:
  inline void set_has_titleid();
  inline void clear_has_titleid();
  inline void set_has_savelocation();
  inline void clear_has_savelocation();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* titleid_;
  ::std::string* savelocation_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static SaveData* default_instance_;
};
// -------------------------------------------------------------------

class TitleTicket : public ::google::protobuf::Message {
 public:
  TitleTicket();
  virtual ~TitleTicket();
  
  TitleTicket(const TitleTicket& from);
  
  inline TitleTicket& operator=(const TitleTicket& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TitleTicket& default_instance();
  
  void Swap(TitleTicket* other);
  
  // implements Message ----------------------------------------------
  
  TitleTicket* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TitleTicket& from);
  void MergeFrom(const TitleTicket& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string titleId = 1;
  inline bool has_titleid() const;
  inline void clear_titleid();
  static const int kTitleIdFieldNumber = 1;
  inline const ::std::string& titleid() const;
  inline void set_titleid(const ::std::string& value);
  inline void set_titleid(const char* value);
  inline void set_titleid(const char* value, size_t size);
  inline ::std::string* mutable_titleid();
  inline ::std::string* release_titleid();
  
  // required .vplex.vsDirectory.ETicketData eTicket = 2;
  inline bool has_eticket() const;
  inline void clear_eticket();
  static const int kETicketFieldNumber = 2;
  inline const ::vplex::vsDirectory::ETicketData& eticket() const;
  inline ::vplex::vsDirectory::ETicketData* mutable_eticket();
  inline ::vplex::vsDirectory::ETicketData* release_eticket();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.TitleTicket)
 private:
  inline void set_has_titleid();
  inline void clear_has_titleid();
  inline void set_has_eticket();
  inline void clear_has_eticket();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* titleid_;
  ::vplex::vsDirectory::ETicketData* eticket_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static TitleTicket* default_instance_;
};
// -------------------------------------------------------------------

class Subscription : public ::google::protobuf::Message {
 public:
  Subscription();
  virtual ~Subscription();
  
  Subscription(const Subscription& from);
  
  inline Subscription& operator=(const Subscription& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Subscription& default_instance();
  
  void Swap(Subscription* other);
  
  // implements Message ----------------------------------------------
  
  Subscription* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Subscription& from);
  void MergeFrom(const Subscription& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional fixed64 datasetId = 1;
  inline bool has_datasetid() const;
  inline void clear_datasetid();
  static const int kDatasetIdFieldNumber = 1;
  inline ::google::protobuf::uint64 datasetid() const;
  inline void set_datasetid(::google::protobuf::uint64 value);
  
  // optional string datasetName = 2;
  inline bool has_datasetname() const;
  inline void clear_datasetname();
  static const int kDatasetNameFieldNumber = 2;
  inline const ::std::string& datasetname() const;
  inline void set_datasetname(const ::std::string& value);
  inline void set_datasetname(const char* value);
  inline void set_datasetname(const char* value, size_t size);
  inline ::std::string* mutable_datasetname();
  inline ::std::string* release_datasetname();
  
  // optional string filter = 3;
  inline bool has_filter() const;
  inline void clear_filter();
  static const int kFilterFieldNumber = 3;
  inline const ::std::string& filter() const;
  inline void set_filter(const ::std::string& value);
  inline void set_filter(const char* value);
  inline void set_filter(const char* value, size_t size);
  inline ::std::string* mutable_filter();
  inline ::std::string* release_filter();
  
  // optional string deviceRoot = 4;
  inline bool has_deviceroot() const;
  inline void clear_deviceroot();
  static const int kDeviceRootFieldNumber = 4;
  inline const ::std::string& deviceroot() const;
  inline void set_deviceroot(const ::std::string& value);
  inline void set_deviceroot(const char* value);
  inline void set_deviceroot(const char* value, size_t size);
  inline ::std::string* mutable_deviceroot();
  inline ::std::string* release_deviceroot();
  
  // optional string datasetRoot = 5;
  inline bool has_datasetroot() const;
  inline void clear_datasetroot();
  static const int kDatasetRootFieldNumber = 5;
  inline const ::std::string& datasetroot() const;
  inline void set_datasetroot(const ::std::string& value);
  inline void set_datasetroot(const char* value);
  inline void set_datasetroot(const char* value, size_t size);
  inline ::std::string* mutable_datasetroot();
  inline ::std::string* release_datasetroot();
  
  // optional bool uploadOk = 6;
  inline bool has_uploadok() const;
  inline void clear_uploadok();
  static const int kUploadOkFieldNumber = 6;
  inline bool uploadok() const;
  inline void set_uploadok(bool value);
  
  // optional bool downloadOk = 7;
  inline bool has_downloadok() const;
  inline void clear_downloadok();
  static const int kDownloadOkFieldNumber = 7;
  inline bool downloadok() const;
  inline void set_downloadok(bool value);
  
  // optional bool uploadDeleteOk = 8;
  inline bool has_uploaddeleteok() const;
  inline void clear_uploaddeleteok();
  static const int kUploadDeleteOkFieldNumber = 8;
  inline bool uploaddeleteok() const;
  inline void set_uploaddeleteok(bool value);
  
  // optional bool downloadDeleteOk = 9;
  inline bool has_downloaddeleteok() const;
  inline void clear_downloaddeleteok();
  static const int kDownloadDeleteOkFieldNumber = 9;
  inline bool downloaddeleteok() const;
  inline void set_downloaddeleteok(bool value);
  
  // optional string datasetLocation = 10;
  inline bool has_datasetlocation() const;
  inline void clear_datasetlocation();
  static const int kDatasetLocationFieldNumber = 10;
  inline const ::std::string& datasetlocation() const;
  inline void set_datasetlocation(const ::std::string& value);
  inline void set_datasetlocation(const char* value);
  inline void set_datasetlocation(const char* value, size_t size);
  inline ::std::string* mutable_datasetlocation();
  inline ::std::string* release_datasetlocation();
  
  // optional string contentType = 11;
  inline bool has_contenttype() const;
  inline void clear_contenttype();
  static const int kContentTypeFieldNumber = 11;
  inline const ::std::string& contenttype() const;
  inline void set_contenttype(const ::std::string& value);
  inline void set_contenttype(const char* value);
  inline void set_contenttype(const char* value, size_t size);
  inline ::std::string* mutable_contenttype();
  inline ::std::string* release_contenttype();
  
  // optional string createdFor = 12;
  inline bool has_createdfor() const;
  inline void clear_createdfor();
  static const int kCreatedForFieldNumber = 12;
  inline const ::std::string& createdfor() const;
  inline void set_createdfor(const ::std::string& value);
  inline void set_createdfor(const char* value);
  inline void set_createdfor(const char* value, size_t size);
  inline ::std::string* mutable_createdfor();
  inline ::std::string* release_createdfor();
  
  // optional fixed64 maxSize = 13;
  inline bool has_maxsize() const;
  inline void clear_maxsize();
  static const int kMaxSizeFieldNumber = 13;
  inline ::google::protobuf::uint64 maxsize() const;
  inline void set_maxsize(::google::protobuf::uint64 value);
  
  // optional fixed64 maxFiles = 14;
  inline bool has_maxfiles() const;
  inline void clear_maxfiles();
  static const int kMaxFilesFieldNumber = 14;
  inline ::google::protobuf::uint64 maxfiles() const;
  inline void set_maxfiles(::google::protobuf::uint64 value);
  
  // optional fixed64 creationTime = 15;
  inline bool has_creationtime() const;
  inline void clear_creationtime();
  static const int kCreationTimeFieldNumber = 15;
  inline ::google::protobuf::uint64 creationtime() const;
  inline void set_creationtime(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.Subscription)
 private:
  inline void set_has_datasetid();
  inline void clear_has_datasetid();
  inline void set_has_datasetname();
  inline void clear_has_datasetname();
  inline void set_has_filter();
  inline void clear_has_filter();
  inline void set_has_deviceroot();
  inline void clear_has_deviceroot();
  inline void set_has_datasetroot();
  inline void clear_has_datasetroot();
  inline void set_has_uploadok();
  inline void clear_has_uploadok();
  inline void set_has_downloadok();
  inline void clear_has_downloadok();
  inline void set_has_uploaddeleteok();
  inline void clear_has_uploaddeleteok();
  inline void set_has_downloaddeleteok();
  inline void clear_has_downloaddeleteok();
  inline void set_has_datasetlocation();
  inline void clear_has_datasetlocation();
  inline void set_has_contenttype();
  inline void clear_has_contenttype();
  inline void set_has_createdfor();
  inline void clear_has_createdfor();
  inline void set_has_maxsize();
  inline void clear_has_maxsize();
  inline void set_has_maxfiles();
  inline void clear_has_maxfiles();
  inline void set_has_creationtime();
  inline void clear_has_creationtime();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 datasetid_;
  ::std::string* datasetname_;
  ::std::string* filter_;
  ::std::string* deviceroot_;
  ::std::string* datasetroot_;
  ::std::string* datasetlocation_;
  ::std::string* contenttype_;
  ::std::string* createdfor_;
  ::google::protobuf::uint64 maxsize_;
  ::google::protobuf::uint64 maxfiles_;
  ::google::protobuf::uint64 creationtime_;
  bool uploadok_;
  bool downloadok_;
  bool uploaddeleteok_;
  bool downloaddeleteok_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static Subscription* default_instance_;
};
// -------------------------------------------------------------------

class SyncDirectory : public ::google::protobuf::Message {
 public:
  SyncDirectory();
  virtual ~SyncDirectory();
  
  SyncDirectory(const SyncDirectory& from);
  
  inline SyncDirectory& operator=(const SyncDirectory& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SyncDirectory& default_instance();
  
  void Swap(SyncDirectory* other);
  
  // implements Message ----------------------------------------------
  
  SyncDirectory* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SyncDirectory& from);
  void MergeFrom(const SyncDirectory& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string localPath = 1;
  inline bool has_localpath() const;
  inline void clear_localpath();
  static const int kLocalPathFieldNumber = 1;
  inline const ::std::string& localpath() const;
  inline void set_localpath(const ::std::string& value);
  inline void set_localpath(const char* value);
  inline void set_localpath(const char* value, size_t size);
  inline ::std::string* mutable_localpath();
  inline ::std::string* release_localpath();
  
  // required string serverPath = 2;
  inline bool has_serverpath() const;
  inline void clear_serverpath();
  static const int kServerPathFieldNumber = 2;
  inline const ::std::string& serverpath() const;
  inline void set_serverpath(const ::std::string& value);
  inline void set_serverpath(const char* value);
  inline void set_serverpath(const char* value, size_t size);
  inline ::std::string* mutable_serverpath();
  inline ::std::string* release_serverpath();
  
  // required bool privateFlag = 3;
  inline bool has_privateflag() const;
  inline void clear_privateflag();
  static const int kPrivateFlagFieldNumber = 3;
  inline bool privateflag() const;
  inline void set_privateflag(bool value);
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.SyncDirectory)
 private:
  inline void set_has_localpath();
  inline void clear_has_localpath();
  inline void set_has_serverpath();
  inline void clear_has_serverpath();
  inline void set_has_privateflag();
  inline void clear_has_privateflag();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* localpath_;
  ::std::string* serverpath_;
  bool privateflag_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static SyncDirectory* default_instance_;
};
// -------------------------------------------------------------------

class DatasetData : public ::google::protobuf::Message {
 public:
  DatasetData();
  virtual ~DatasetData();
  
  DatasetData(const DatasetData& from);
  
  inline DatasetData& operator=(const DatasetData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DatasetData& default_instance();
  
  void Swap(DatasetData* other);
  
  // implements Message ----------------------------------------------
  
  DatasetData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DatasetData& from);
  void MergeFrom(const DatasetData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed64 datasetId = 1;
  inline bool has_datasetid() const;
  inline void clear_datasetid();
  static const int kDatasetIdFieldNumber = 1;
  inline ::google::protobuf::uint64 datasetid() const;
  inline void set_datasetid(::google::protobuf::uint64 value);
  
  // required int32 detailHash = 2;
  inline bool has_detailhash() const;
  inline void clear_detailhash();
  static const int kDetailHashFieldNumber = 2;
  inline ::google::protobuf::int32 detailhash() const;
  inline void set_detailhash(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.DatasetData)
 private:
  inline void set_has_datasetid();
  inline void clear_has_datasetid();
  inline void set_has_detailhash();
  inline void clear_has_detailhash();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 datasetid_;
  ::google::protobuf::int32 detailhash_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static DatasetData* default_instance_;
};
// -------------------------------------------------------------------

class DatasetDetail : public ::google::protobuf::Message {
 public:
  DatasetDetail();
  virtual ~DatasetDetail();
  
  DatasetDetail(const DatasetDetail& from);
  
  inline DatasetDetail& operator=(const DatasetDetail& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DatasetDetail& default_instance();
  
  void Swap(DatasetDetail* other);
  
  // implements Message ----------------------------------------------
  
  DatasetDetail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DatasetDetail& from);
  void MergeFrom(const DatasetDetail& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed64 datasetId = 1;
  inline bool has_datasetid() const;
  inline void clear_datasetid();
  static const int kDatasetIdFieldNumber = 1;
  inline ::google::protobuf::uint64 datasetid() const;
  inline void set_datasetid(::google::protobuf::uint64 value);
  
  // required string datasetName = 2;
  inline bool has_datasetname() const;
  inline void clear_datasetname();
  static const int kDatasetNameFieldNumber = 2;
  inline const ::std::string& datasetname() const;
  inline void set_datasetname(const ::std::string& value);
  inline void set_datasetname(const char* value);
  inline void set_datasetname(const char* value, size_t size);
  inline ::std::string* mutable_datasetname();
  inline ::std::string* release_datasetname();
  
  // required string contentType = 3;
  inline bool has_contenttype() const;
  inline void clear_contenttype();
  static const int kContentTypeFieldNumber = 3;
  inline const ::std::string& contenttype() const;
  inline void set_contenttype(const ::std::string& value);
  inline void set_contenttype(const char* value);
  inline void set_contenttype(const char* value, size_t size);
  inline ::std::string* mutable_contenttype();
  inline ::std::string* release_contenttype();
  
  // optional string createdFor = 4;
  inline bool has_createdfor() const;
  inline void clear_createdfor();
  static const int kCreatedForFieldNumber = 4;
  inline const ::std::string& createdfor() const;
  inline void set_createdfor(const ::std::string& value);
  inline void set_createdfor(const char* value);
  inline void set_createdfor(const char* value, size_t size);
  inline ::std::string* mutable_createdfor();
  inline ::std::string* release_createdfor();
  
  // optional string externalId = 5;
  inline bool has_externalid() const;
  inline void clear_externalid();
  static const int kExternalIdFieldNumber = 5;
  inline const ::std::string& externalid() const;
  inline void set_externalid(const ::std::string& value);
  inline void set_externalid(const char* value);
  inline void set_externalid(const char* value, size_t size);
  inline ::std::string* mutable_externalid();
  inline ::std::string* release_externalid();
  
  // required fixed64 lastUpdated = 6;
  inline bool has_lastupdated() const;
  inline void clear_lastupdated();
  static const int kLastUpdatedFieldNumber = 6;
  inline ::google::protobuf::uint64 lastupdated() const;
  inline void set_lastupdated(::google::protobuf::uint64 value);
  
  // optional string storageClusterName = 7;
  inline bool has_storageclustername() const;
  inline void clear_storageclustername();
  static const int kStorageClusterNameFieldNumber = 7;
  inline const ::std::string& storageclustername() const;
  inline void set_storageclustername(const ::std::string& value);
  inline void set_storageclustername(const char* value);
  inline void set_storageclustername(const char* value, size_t size);
  inline ::std::string* mutable_storageclustername();
  inline ::std::string* release_storageclustername();
  
  // optional string storageClusterHostName = 8;
  inline bool has_storageclusterhostname() const;
  inline void clear_storageclusterhostname();
  static const int kStorageClusterHostNameFieldNumber = 8;
  inline const ::std::string& storageclusterhostname() const;
  inline void set_storageclusterhostname(const ::std::string& value);
  inline void set_storageclusterhostname(const char* value);
  inline void set_storageclusterhostname(const char* value, size_t size);
  inline ::std::string* mutable_storageclusterhostname();
  inline ::std::string* release_storageclusterhostname();
  
  // optional int32 storageClusterPort = 9;
  inline bool has_storageclusterport() const;
  inline void clear_storageclusterport();
  static const int kStorageClusterPortFieldNumber = 9;
  inline ::google::protobuf::int32 storageclusterport() const;
  inline void set_storageclusterport(::google::protobuf::int32 value);
  
  // optional string datasetLocation = 10;
  inline bool has_datasetlocation() const;
  inline void clear_datasetlocation();
  static const int kDatasetLocationFieldNumber = 10;
  inline const ::std::string& datasetlocation() const;
  inline void set_datasetlocation(const ::std::string& value);
  inline void set_datasetlocation(const char* value);
  inline void set_datasetlocation(const char* value, size_t size);
  inline ::std::string* mutable_datasetlocation();
  inline ::std::string* release_datasetlocation();
  
  // optional fixed64 sizeOnDisk = 11;
  inline bool has_sizeondisk() const;
  inline void clear_sizeondisk();
  static const int kSizeOnDiskFieldNumber = 11;
  inline ::google::protobuf::uint64 sizeondisk() const;
  inline void set_sizeondisk(::google::protobuf::uint64 value);
  
  // optional .vplex.vsDirectory.DatasetType datasetType = 12;
  inline bool has_datasettype() const;
  inline void clear_datasettype();
  static const int kDatasetTypeFieldNumber = 12;
  inline vplex::vsDirectory::DatasetType datasettype() const;
  inline void set_datasettype(vplex::vsDirectory::DatasetType value);
  
  // optional fixed64 linkedTo = 13;
  inline bool has_linkedto() const;
  inline void clear_linkedto();
  static const int kLinkedToFieldNumber = 13;
  inline ::google::protobuf::uint64 linkedto() const;
  inline void set_linkedto(::google::protobuf::uint64 value);
  
  // optional fixed64 clusterId = 14;
  inline bool has_clusterid() const;
  inline void clear_clusterid();
  static const int kClusterIdFieldNumber = 14;
  inline ::google::protobuf::uint64 clusterid() const;
  inline void set_clusterid(::google::protobuf::uint64 value);
  
  // optional fixed64 userId = 15;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 15;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // optional bool suspendedFlag = 16;
  inline bool has_suspendedflag() const;
  inline void clear_suspendedflag();
  static const int kSuspendedFlagFieldNumber = 16;
  inline bool suspendedflag() const;
  inline void set_suspendedflag(bool value);
  
  // optional fixed64 primaryStorageId = 17;
  inline bool has_primarystorageid() const;
  inline void clear_primarystorageid();
  static const int kPrimaryStorageIdFieldNumber = 17;
  inline ::google::protobuf::uint64 primarystorageid() const;
  inline void set_primarystorageid(::google::protobuf::uint64 value);
  
  // optional fixed64 deleteDataAfter = 18;
  inline bool has_deletedataafter() const;
  inline void clear_deletedataafter();
  static const int kDeleteDataAfterFieldNumber = 18;
  inline ::google::protobuf::uint64 deletedataafter() const;
  inline void set_deletedataafter(::google::protobuf::uint64 value);
  
  // repeated fixed64 archiveStorageDeviceId = 19;
  inline int archivestoragedeviceid_size() const;
  inline void clear_archivestoragedeviceid();
  static const int kArchiveStorageDeviceIdFieldNumber = 19;
  inline ::google::protobuf::uint64 archivestoragedeviceid(int index) const;
  inline void set_archivestoragedeviceid(int index, ::google::protobuf::uint64 value);
  inline void add_archivestoragedeviceid(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      archivestoragedeviceid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_archivestoragedeviceid();
  
  // optional string displayName = 20;
  inline bool has_displayname() const;
  inline void clear_displayname();
  static const int kDisplayNameFieldNumber = 20;
  inline const ::std::string& displayname() const;
  inline void set_displayname(const ::std::string& value);
  inline void set_displayname(const char* value);
  inline void set_displayname(const char* value, size_t size);
  inline ::std::string* mutable_displayname();
  inline ::std::string* release_displayname();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.DatasetDetail)
 private:
  inline void set_has_datasetid();
  inline void clear_has_datasetid();
  inline void set_has_datasetname();
  inline void clear_has_datasetname();
  inline void set_has_contenttype();
  inline void clear_has_contenttype();
  inline void set_has_createdfor();
  inline void clear_has_createdfor();
  inline void set_has_externalid();
  inline void clear_has_externalid();
  inline void set_has_lastupdated();
  inline void clear_has_lastupdated();
  inline void set_has_storageclustername();
  inline void clear_has_storageclustername();
  inline void set_has_storageclusterhostname();
  inline void clear_has_storageclusterhostname();
  inline void set_has_storageclusterport();
  inline void clear_has_storageclusterport();
  inline void set_has_datasetlocation();
  inline void clear_has_datasetlocation();
  inline void set_has_sizeondisk();
  inline void clear_has_sizeondisk();
  inline void set_has_datasettype();
  inline void clear_has_datasettype();
  inline void set_has_linkedto();
  inline void clear_has_linkedto();
  inline void set_has_clusterid();
  inline void clear_has_clusterid();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_suspendedflag();
  inline void clear_has_suspendedflag();
  inline void set_has_primarystorageid();
  inline void clear_has_primarystorageid();
  inline void set_has_deletedataafter();
  inline void clear_has_deletedataafter();
  inline void set_has_displayname();
  inline void clear_has_displayname();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 datasetid_;
  ::std::string* datasetname_;
  ::std::string* contenttype_;
  ::std::string* createdfor_;
  ::std::string* externalid_;
  ::google::protobuf::uint64 lastupdated_;
  ::std::string* storageclustername_;
  ::std::string* storageclusterhostname_;
  ::std::string* datasetlocation_;
  ::google::protobuf::int32 storageclusterport_;
  int datasettype_;
  ::google::protobuf::uint64 sizeondisk_;
  ::google::protobuf::uint64 linkedto_;
  ::google::protobuf::uint64 clusterid_;
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 primarystorageid_;
  ::google::protobuf::uint64 deletedataafter_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > archivestoragedeviceid_;
  ::std::string* displayname_;
  bool suspendedflag_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(20 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static DatasetDetail* default_instance_;
};
// -------------------------------------------------------------------

class StoredDataset : public ::google::protobuf::Message {
 public:
  StoredDataset();
  virtual ~StoredDataset();
  
  StoredDataset(const StoredDataset& from);
  
  inline StoredDataset& operator=(const StoredDataset& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StoredDataset& default_instance();
  
  void Swap(StoredDataset* other);
  
  // implements Message ----------------------------------------------
  
  StoredDataset* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StoredDataset& from);
  void MergeFrom(const StoredDataset& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed64 userId = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required fixed64 datasetId = 2;
  inline bool has_datasetid() const;
  inline void clear_datasetid();
  static const int kDatasetIdFieldNumber = 2;
  inline ::google::protobuf::uint64 datasetid() const;
  inline void set_datasetid(::google::protobuf::uint64 value);
  
  // required .vplex.vsDirectory.DatasetType datasetType = 3;
  inline bool has_datasettype() const;
  inline void clear_datasettype();
  static const int kDatasetTypeFieldNumber = 3;
  inline vplex::vsDirectory::DatasetType datasettype() const;
  inline void set_datasettype(vplex::vsDirectory::DatasetType value);
  
  // required fixed64 dataRetentionTime = 4;
  inline bool has_dataretentiontime() const;
  inline void clear_dataretentiontime();
  static const int kDataRetentionTimeFieldNumber = 4;
  inline ::google::protobuf::uint64 dataretentiontime() const;
  inline void set_dataretentiontime(::google::protobuf::uint64 value);
  
  // optional fixed64 storageClusterId = 5;
  inline bool has_storageclusterid() const;
  inline void clear_storageclusterid();
  static const int kStorageClusterIdFieldNumber = 5;
  inline ::google::protobuf::uint64 storageclusterid() const;
  inline void set_storageclusterid(::google::protobuf::uint64 value);
  
  // optional fixed64 primaryStorageId = 6;
  inline bool has_primarystorageid() const;
  inline void clear_primarystorageid();
  static const int kPrimaryStorageIdFieldNumber = 6;
  inline ::google::protobuf::uint64 primarystorageid() const;
  inline void set_primarystorageid(::google::protobuf::uint64 value);
  
  // optional fixed64 secondaryStorageId = 7;
  inline bool has_secondarystorageid() const;
  inline void clear_secondarystorageid();
  static const int kSecondaryStorageIdFieldNumber = 7;
  inline ::google::protobuf::uint64 secondarystorageid() const;
  inline void set_secondarystorageid(::google::protobuf::uint64 value);
  
  // optional fixed64 backupStorageId = 8;
  inline bool has_backupstorageid() const;
  inline void clear_backupstorageid();
  static const int kBackupStorageIdFieldNumber = 8;
  inline ::google::protobuf::uint64 backupstorageid() const;
  inline void set_backupstorageid(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.StoredDataset)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_datasetid();
  inline void clear_has_datasetid();
  inline void set_has_datasettype();
  inline void clear_has_datasettype();
  inline void set_has_dataretentiontime();
  inline void clear_has_dataretentiontime();
  inline void set_has_storageclusterid();
  inline void clear_has_storageclusterid();
  inline void set_has_primarystorageid();
  inline void clear_has_primarystorageid();
  inline void set_has_secondarystorageid();
  inline void clear_has_secondarystorageid();
  inline void set_has_backupstorageid();
  inline void clear_has_backupstorageid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 datasetid_;
  ::google::protobuf::uint64 dataretentiontime_;
  ::google::protobuf::uint64 storageclusterid_;
  ::google::protobuf::uint64 primarystorageid_;
  ::google::protobuf::uint64 secondarystorageid_;
  ::google::protobuf::uint64 backupstorageid_;
  int datasettype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static StoredDataset* default_instance_;
};
// -------------------------------------------------------------------

class DeviceInfo : public ::google::protobuf::Message {
 public:
  DeviceInfo();
  virtual ~DeviceInfo();
  
  DeviceInfo(const DeviceInfo& from);
  
  inline DeviceInfo& operator=(const DeviceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceInfo& default_instance();
  
  void Swap(DeviceInfo* other);
  
  // implements Message ----------------------------------------------
  
  DeviceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceInfo& from);
  void MergeFrom(const DeviceInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed64 deviceId = 1;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIdFieldNumber = 1;
  inline ::google::protobuf::uint64 deviceid() const;
  inline void set_deviceid(::google::protobuf::uint64 value);
  
  // required string deviceClass = 2;
  inline bool has_deviceclass() const;
  inline void clear_deviceclass();
  static const int kDeviceClassFieldNumber = 2;
  inline const ::std::string& deviceclass() const;
  inline void set_deviceclass(const ::std::string& value);
  inline void set_deviceclass(const char* value);
  inline void set_deviceclass(const char* value, size_t size);
  inline ::std::string* mutable_deviceclass();
  inline ::std::string* release_deviceclass();
  
  // optional string deviceName = 3;
  inline bool has_devicename() const;
  inline void clear_devicename();
  static const int kDeviceNameFieldNumber = 3;
  inline const ::std::string& devicename() const;
  inline void set_devicename(const ::std::string& value);
  inline void set_devicename(const char* value);
  inline void set_devicename(const char* value, size_t size);
  inline ::std::string* mutable_devicename();
  inline ::std::string* release_devicename();
  
  // optional bool isAcer = 4;
  inline bool has_isacer() const;
  inline void clear_isacer();
  static const int kIsAcerFieldNumber = 4;
  inline bool isacer() const;
  inline void set_isacer(bool value);
  
  // optional bool hasCamera = 5;
  inline bool has_hascamera() const;
  inline void clear_hascamera();
  static const int kHasCameraFieldNumber = 5;
  inline bool hascamera() const;
  inline void set_hascamera(bool value);
  
  // optional string osVersion = 6;
  inline bool has_osversion() const;
  inline void clear_osversion();
  static const int kOsVersionFieldNumber = 6;
  inline const ::std::string& osversion() const;
  inline void set_osversion(const ::std::string& value);
  inline void set_osversion(const char* value);
  inline void set_osversion(const char* value, size_t size);
  inline ::std::string* mutable_osversion();
  inline ::std::string* release_osversion();
  
  // optional string protocolVersion = 7;
  inline bool has_protocolversion() const;
  inline void clear_protocolversion();
  static const int kProtocolVersionFieldNumber = 7;
  inline const ::std::string& protocolversion() const;
  inline void set_protocolversion(const ::std::string& value);
  inline void set_protocolversion(const char* value);
  inline void set_protocolversion(const char* value, size_t size);
  inline ::std::string* mutable_protocolversion();
  inline ::std::string* release_protocolversion();
  
  // optional bool isVirtDrive = 8;
  inline bool has_isvirtdrive() const;
  inline void clear_isvirtdrive();
  static const int kIsVirtDriveFieldNumber = 8;
  inline bool isvirtdrive() const;
  inline void set_isvirtdrive(bool value);
  
  // optional bool isMediaServer = 9;
  inline bool has_ismediaserver() const;
  inline void clear_ismediaserver();
  static const int kIsMediaServerFieldNumber = 9;
  inline bool ismediaserver() const;
  inline void set_ismediaserver(bool value);
  
  // optional bool featureMediaServerCapable = 10;
  inline bool has_featuremediaservercapable() const;
  inline void clear_featuremediaservercapable();
  static const int kFeatureMediaServerCapableFieldNumber = 10;
  inline bool featuremediaservercapable() const;
  inline void set_featuremediaservercapable(bool value);
  
  // optional bool featureVirtDriveCapable = 11;
  inline bool has_featurevirtdrivecapable() const;
  inline void clear_featurevirtdrivecapable();
  static const int kFeatureVirtDriveCapableFieldNumber = 11;
  inline bool featurevirtdrivecapable() const;
  inline void set_featurevirtdrivecapable(bool value);
  
  // optional bool featureRemoteFileAccessCapable = 12;
  inline bool has_featureremotefileaccesscapable() const;
  inline void clear_featureremotefileaccesscapable();
  static const int kFeatureRemoteFileAccessCapableFieldNumber = 12;
  inline bool featureremotefileaccesscapable() const;
  inline void set_featureremotefileaccesscapable(bool value);
  
  // optional bool featureFSDatasetTypeCapable = 13;
  inline bool has_featurefsdatasettypecapable() const;
  inline void clear_featurefsdatasettypecapable();
  static const int kFeatureFSDatasetTypeCapableFieldNumber = 13;
  inline bool featurefsdatasettypecapable() const;
  inline void set_featurefsdatasettypecapable(bool value);
  
  // optional string modelNumber = 14;
  inline bool has_modelnumber() const;
  inline void clear_modelnumber();
  static const int kModelNumberFieldNumber = 14;
  inline const ::std::string& modelnumber() const;
  inline void set_modelnumber(const ::std::string& value);
  inline void set_modelnumber(const char* value);
  inline void set_modelnumber(const char* value, size_t size);
  inline ::std::string* mutable_modelnumber();
  inline ::std::string* release_modelnumber();
  
  // optional string buildInfo = 15;
  inline bool has_buildinfo() const;
  inline void clear_buildinfo();
  static const int kBuildInfoFieldNumber = 15;
  inline const ::std::string& buildinfo() const;
  inline void set_buildinfo(const ::std::string& value);
  inline void set_buildinfo(const char* value);
  inline void set_buildinfo(const char* value, size_t size);
  inline ::std::string* mutable_buildinfo();
  inline ::std::string* release_buildinfo();
  
  // optional bool featureVirtSyncCapable = 16;
  inline bool has_featurevirtsynccapable() const;
  inline void clear_featurevirtsynccapable();
  static const int kFeatureVirtSyncCapableFieldNumber = 16;
  inline bool featurevirtsynccapable() const;
  inline void set_featurevirtsynccapable(bool value);
  
  // optional bool featureMyStorageServerCapable = 17;
  inline bool has_featuremystorageservercapable() const;
  inline void clear_featuremystorageservercapable();
  static const int kFeatureMyStorageServerCapableFieldNumber = 17;
  inline bool featuremystorageservercapable() const;
  inline void set_featuremystorageservercapable(bool value);
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.DeviceInfo)
 private:
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_deviceclass();
  inline void clear_has_deviceclass();
  inline void set_has_devicename();
  inline void clear_has_devicename();
  inline void set_has_isacer();
  inline void clear_has_isacer();
  inline void set_has_hascamera();
  inline void clear_has_hascamera();
  inline void set_has_osversion();
  inline void clear_has_osversion();
  inline void set_has_protocolversion();
  inline void clear_has_protocolversion();
  inline void set_has_isvirtdrive();
  inline void clear_has_isvirtdrive();
  inline void set_has_ismediaserver();
  inline void clear_has_ismediaserver();
  inline void set_has_featuremediaservercapable();
  inline void clear_has_featuremediaservercapable();
  inline void set_has_featurevirtdrivecapable();
  inline void clear_has_featurevirtdrivecapable();
  inline void set_has_featureremotefileaccesscapable();
  inline void clear_has_featureremotefileaccesscapable();
  inline void set_has_featurefsdatasettypecapable();
  inline void clear_has_featurefsdatasettypecapable();
  inline void set_has_modelnumber();
  inline void clear_has_modelnumber();
  inline void set_has_buildinfo();
  inline void clear_has_buildinfo();
  inline void set_has_featurevirtsynccapable();
  inline void clear_has_featurevirtsynccapable();
  inline void set_has_featuremystorageservercapable();
  inline void clear_has_featuremystorageservercapable();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 deviceid_;
  ::std::string* deviceclass_;
  ::std::string* devicename_;
  ::std::string* osversion_;
  ::std::string* protocolversion_;
  bool isacer_;
  bool hascamera_;
  bool isvirtdrive_;
  bool ismediaserver_;
  bool featuremediaservercapable_;
  bool featurevirtdrivecapable_;
  bool featureremotefileaccesscapable_;
  bool featurefsdatasettypecapable_;
  ::std::string* modelnumber_;
  ::std::string* buildinfo_;
  bool featurevirtsynccapable_;
  bool featuremystorageservercapable_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static DeviceInfo* default_instance_;
};
// -------------------------------------------------------------------

class StorageAccessPort : public ::google::protobuf::Message {
 public:
  StorageAccessPort();
  virtual ~StorageAccessPort();
  
  StorageAccessPort(const StorageAccessPort& from);
  
  inline StorageAccessPort& operator=(const StorageAccessPort& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StorageAccessPort& default_instance();
  
  void Swap(StorageAccessPort* other);
  
  // implements Message ----------------------------------------------
  
  StorageAccessPort* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StorageAccessPort& from);
  void MergeFrom(const StorageAccessPort& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.PortType portType = 1;
  inline bool has_porttype() const;
  inline void clear_porttype();
  static const int kPortTypeFieldNumber = 1;
  inline vplex::vsDirectory::PortType porttype() const;
  inline void set_porttype(vplex::vsDirectory::PortType value);
  
  // required int32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.StorageAccessPort)
 private:
  inline void set_has_porttype();
  inline void clear_has_porttype();
  inline void set_has_port();
  inline void clear_has_port();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int porttype_;
  ::google::protobuf::int32 port_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static StorageAccessPort* default_instance_;
};
// -------------------------------------------------------------------

class StorageAccess : public ::google::protobuf::Message {
 public:
  StorageAccess();
  virtual ~StorageAccess();
  
  StorageAccess(const StorageAccess& from);
  
  inline StorageAccess& operator=(const StorageAccess& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StorageAccess& default_instance();
  
  void Swap(StorageAccess* other);
  
  // implements Message ----------------------------------------------
  
  StorageAccess* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StorageAccess& from);
  void MergeFrom(const StorageAccess& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.RouteType routeType = 1;
  inline bool has_routetype() const;
  inline void clear_routetype();
  static const int kRouteTypeFieldNumber = 1;
  inline vplex::vsDirectory::RouteType routetype() const;
  inline void set_routetype(vplex::vsDirectory::RouteType value);
  
  // required .vplex.vsDirectory.ProtocolType protocol = 2;
  inline bool has_protocol() const;
  inline void clear_protocol();
  static const int kProtocolFieldNumber = 2;
  inline vplex::vsDirectory::ProtocolType protocol() const;
  inline void set_protocol(vplex::vsDirectory::ProtocolType value);
  
  // required string server = 3;
  inline bool has_server() const;
  inline void clear_server();
  static const int kServerFieldNumber = 3;
  inline const ::std::string& server() const;
  inline void set_server(const ::std::string& value);
  inline void set_server(const char* value);
  inline void set_server(const char* value, size_t size);
  inline ::std::string* mutable_server();
  inline ::std::string* release_server();
  
  // repeated .vplex.vsDirectory.StorageAccessPort ports = 4;
  inline int ports_size() const;
  inline void clear_ports();
  static const int kPortsFieldNumber = 4;
  inline const ::vplex::vsDirectory::StorageAccessPort& ports(int index) const;
  inline ::vplex::vsDirectory::StorageAccessPort* mutable_ports(int index);
  inline ::vplex::vsDirectory::StorageAccessPort* add_ports();
  inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::StorageAccessPort >&
      ports() const;
  inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::StorageAccessPort >*
      mutable_ports();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.StorageAccess)
 private:
  inline void set_has_routetype();
  inline void clear_has_routetype();
  inline void set_has_protocol();
  inline void clear_has_protocol();
  inline void set_has_server();
  inline void clear_has_server();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int routetype_;
  int protocol_;
  ::std::string* server_;
  ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::StorageAccessPort > ports_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static StorageAccess* default_instance_;
};
// -------------------------------------------------------------------

class DeviceAccessTicket : public ::google::protobuf::Message {
 public:
  DeviceAccessTicket();
  virtual ~DeviceAccessTicket();
  
  DeviceAccessTicket(const DeviceAccessTicket& from);
  
  inline DeviceAccessTicket& operator=(const DeviceAccessTicket& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceAccessTicket& default_instance();
  
  void Swap(DeviceAccessTicket* other);
  
  // implements Message ----------------------------------------------
  
  DeviceAccessTicket* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceAccessTicket& from);
  void MergeFrom(const DeviceAccessTicket& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed64 deviceId = 1;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIdFieldNumber = 1;
  inline ::google::protobuf::uint64 deviceid() const;
  inline void set_deviceid(::google::protobuf::uint64 value);
  
  // required bytes accessTicket = 2;
  inline bool has_accessticket() const;
  inline void clear_accessticket();
  static const int kAccessTicketFieldNumber = 2;
  inline const ::std::string& accessticket() const;
  inline void set_accessticket(const ::std::string& value);
  inline void set_accessticket(const char* value);
  inline void set_accessticket(const void* value, size_t size);
  inline ::std::string* mutable_accessticket();
  inline ::std::string* release_accessticket();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.DeviceAccessTicket)
 private:
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_accessticket();
  inline void clear_has_accessticket();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 deviceid_;
  ::std::string* accessticket_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static DeviceAccessTicket* default_instance_;
};
// -------------------------------------------------------------------

class UserStorage : public ::google::protobuf::Message {
 public:
  UserStorage();
  virtual ~UserStorage();
  
  UserStorage(const UserStorage& from);
  
  inline UserStorage& operator=(const UserStorage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserStorage& default_instance();
  
  void Swap(UserStorage* other);
  
  // implements Message ----------------------------------------------
  
  UserStorage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserStorage& from);
  void MergeFrom(const UserStorage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed64 storageClusterId = 1;
  inline bool has_storageclusterid() const;
  inline void clear_storageclusterid();
  static const int kStorageClusterIdFieldNumber = 1;
  inline ::google::protobuf::uint64 storageclusterid() const;
  inline void set_storageclusterid(::google::protobuf::uint64 value);
  
  // optional string storageName = 2;
  inline bool has_storagename() const;
  inline void clear_storagename();
  static const int kStorageNameFieldNumber = 2;
  inline const ::std::string& storagename() const;
  inline void set_storagename(const ::std::string& value);
  inline void set_storagename(const char* value);
  inline void set_storagename(const char* value, size_t size);
  inline ::std::string* mutable_storagename();
  inline ::std::string* release_storagename();
  
  // optional int32 storageType = 3;
  inline bool has_storagetype() const;
  inline void clear_storagetype();
  static const int kStorageTypeFieldNumber = 3;
  inline ::google::protobuf::int32 storagetype() const;
  inline void set_storagetype(::google::protobuf::int32 value);
  
  // required fixed64 usageLimit = 4;
  inline bool has_usagelimit() const;
  inline void clear_usagelimit();
  static const int kUsageLimitFieldNumber = 4;
  inline ::google::protobuf::uint64 usagelimit() const;
  inline void set_usagelimit(::google::protobuf::uint64 value);
  
  // optional bool isVirtDrive = 5;
  inline bool has_isvirtdrive() const;
  inline void clear_isvirtdrive();
  static const int kIsVirtDriveFieldNumber = 5;
  inline bool isvirtdrive() const;
  inline void set_isvirtdrive(bool value);
  
  // optional bool isMediaServer = 6;
  inline bool has_ismediaserver() const;
  inline void clear_ismediaserver();
  static const int kIsMediaServerFieldNumber = 6;
  inline bool ismediaserver() const;
  inline void set_ismediaserver(bool value);
  
  // optional fixed64 accessHandle = 7;
  inline bool has_accesshandle() const;
  inline void clear_accesshandle();
  static const int kAccessHandleFieldNumber = 7;
  inline ::google::protobuf::uint64 accesshandle() const;
  inline void set_accesshandle(::google::protobuf::uint64 value);
  
  // optional bytes accessTicket = 8;
  inline bool has_accessticket() const;
  inline void clear_accessticket();
  static const int kAccessTicketFieldNumber = 8;
  inline const ::std::string& accessticket() const;
  inline void set_accessticket(const ::std::string& value);
  inline void set_accessticket(const char* value);
  inline void set_accessticket(const void* value, size_t size);
  inline ::std::string* mutable_accessticket();
  inline ::std::string* release_accessticket();
  
  // repeated .vplex.vsDirectory.StorageAccess storageAccess = 9;
  inline int storageaccess_size() const;
  inline void clear_storageaccess();
  static const int kStorageAccessFieldNumber = 9;
  inline const ::vplex::vsDirectory::StorageAccess& storageaccess(int index) const;
  inline ::vplex::vsDirectory::StorageAccess* mutable_storageaccess(int index);
  inline ::vplex::vsDirectory::StorageAccess* add_storageaccess();
  inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::StorageAccess >&
      storageaccess() const;
  inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::StorageAccess >*
      mutable_storageaccess();
  
  // optional bool featureMediaServerEnabled = 10;
  inline bool has_featuremediaserverenabled() const;
  inline void clear_featuremediaserverenabled();
  static const int kFeatureMediaServerEnabledFieldNumber = 10;
  inline bool featuremediaserverenabled() const;
  inline void set_featuremediaserverenabled(bool value);
  
  // optional bool featureVirtDriveEnabled = 11;
  inline bool has_featurevirtdriveenabled() const;
  inline void clear_featurevirtdriveenabled();
  static const int kFeatureVirtDriveEnabledFieldNumber = 11;
  inline bool featurevirtdriveenabled() const;
  inline void set_featurevirtdriveenabled(bool value);
  
  // optional bool featureRemoteFileAccessEnabled = 12;
  inline bool has_featureremotefileaccessenabled() const;
  inline void clear_featureremotefileaccessenabled();
  static const int kFeatureRemoteFileAccessEnabledFieldNumber = 12;
  inline bool featureremotefileaccessenabled() const;
  inline void set_featureremotefileaccessenabled(bool value);
  
  // optional bool featureFSDatasetTypeEnabled = 13;
  inline bool has_featurefsdatasettypeenabled() const;
  inline void clear_featurefsdatasettypeenabled();
  static const int kFeatureFSDatasetTypeEnabledFieldNumber = 13;
  inline bool featurefsdatasettypeenabled() const;
  inline void set_featurefsdatasettypeenabled(bool value);
  
  // optional bytes devSpecAccessTicket = 14;
  inline bool has_devspecaccessticket() const;
  inline void clear_devspecaccessticket();
  static const int kDevSpecAccessTicketFieldNumber = 14;
  inline const ::std::string& devspecaccessticket() const;
  inline void set_devspecaccessticket(const ::std::string& value);
  inline void set_devspecaccessticket(const char* value);
  inline void set_devspecaccessticket(const void* value, size_t size);
  inline ::std::string* mutable_devspecaccessticket();
  inline ::std::string* release_devspecaccessticket();
  
  // optional bool featureCloudDocEnabled = 15;
  inline bool has_featureclouddocenabled() const;
  inline void clear_featureclouddocenabled();
  static const int kFeatureCloudDocEnabledFieldNumber = 15;
  inline bool featureclouddocenabled() const;
  inline void set_featureclouddocenabled(bool value);
  
  // optional bool featureVirtSyncEnabled = 16;
  inline bool has_featurevirtsyncenabled() const;
  inline void clear_featurevirtsyncenabled();
  static const int kFeatureVirtSyncEnabledFieldNumber = 16;
  inline bool featurevirtsyncenabled() const;
  inline void set_featurevirtsyncenabled(bool value);
  
  // optional bool featureMyStorageServerEnabled = 17;
  inline bool has_featuremystorageserverenabled() const;
  inline void clear_featuremystorageserverenabled();
  static const int kFeatureMyStorageServerEnabledFieldNumber = 17;
  inline bool featuremystorageserverenabled() const;
  inline void set_featuremystorageserverenabled(bool value);
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.UserStorage)
 private:
  inline void set_has_storageclusterid();
  inline void clear_has_storageclusterid();
  inline void set_has_storagename();
  inline void clear_has_storagename();
  inline void set_has_storagetype();
  inline void clear_has_storagetype();
  inline void set_has_usagelimit();
  inline void clear_has_usagelimit();
  inline void set_has_isvirtdrive();
  inline void clear_has_isvirtdrive();
  inline void set_has_ismediaserver();
  inline void clear_has_ismediaserver();
  inline void set_has_accesshandle();
  inline void clear_has_accesshandle();
  inline void set_has_accessticket();
  inline void clear_has_accessticket();
  inline void set_has_featuremediaserverenabled();
  inline void clear_has_featuremediaserverenabled();
  inline void set_has_featurevirtdriveenabled();
  inline void clear_has_featurevirtdriveenabled();
  inline void set_has_featureremotefileaccessenabled();
  inline void clear_has_featureremotefileaccessenabled();
  inline void set_has_featurefsdatasettypeenabled();
  inline void clear_has_featurefsdatasettypeenabled();
  inline void set_has_devspecaccessticket();
  inline void clear_has_devspecaccessticket();
  inline void set_has_featureclouddocenabled();
  inline void clear_has_featureclouddocenabled();
  inline void set_has_featurevirtsyncenabled();
  inline void clear_has_featurevirtsyncenabled();
  inline void set_has_featuremystorageserverenabled();
  inline void clear_has_featuremystorageserverenabled();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 storageclusterid_;
  ::std::string* storagename_;
  ::google::protobuf::uint64 usagelimit_;
  ::google::protobuf::uint64 accesshandle_;
  ::google::protobuf::int32 storagetype_;
  bool isvirtdrive_;
  bool ismediaserver_;
  bool featuremediaserverenabled_;
  bool featurevirtdriveenabled_;
  ::std::string* accessticket_;
  ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::StorageAccess > storageaccess_;
  ::std::string* devspecaccessticket_;
  bool featureremotefileaccessenabled_;
  bool featurefsdatasettypeenabled_;
  bool featureclouddocenabled_;
  bool featurevirtsyncenabled_;
  bool featuremystorageserverenabled_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static UserStorage* default_instance_;
};
// -------------------------------------------------------------------

class UpdatedDataset : public ::google::protobuf::Message {
 public:
  UpdatedDataset();
  virtual ~UpdatedDataset();
  
  UpdatedDataset(const UpdatedDataset& from);
  
  inline UpdatedDataset& operator=(const UpdatedDataset& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdatedDataset& default_instance();
  
  void Swap(UpdatedDataset* other);
  
  // implements Message ----------------------------------------------
  
  UpdatedDataset* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdatedDataset& from);
  void MergeFrom(const UpdatedDataset& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed64 datasetId = 1;
  inline bool has_datasetid() const;
  inline void clear_datasetid();
  static const int kDatasetIdFieldNumber = 1;
  inline ::google::protobuf::uint64 datasetid() const;
  inline void set_datasetid(::google::protobuf::uint64 value);
  
  // required fixed64 clusterId = 2;
  inline bool has_clusterid() const;
  inline void clear_clusterid();
  static const int kClusterIdFieldNumber = 2;
  inline ::google::protobuf::uint64 clusterid() const;
  inline void set_clusterid(::google::protobuf::uint64 value);
  
  // required fixed64 userId = 3;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 3;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required .vplex.vsDirectory.DatasetType datasetType = 4;
  inline bool has_datasettype() const;
  inline void clear_datasettype();
  static const int kDatasetTypeFieldNumber = 4;
  inline vplex::vsDirectory::DatasetType datasettype() const;
  inline void set_datasettype(vplex::vsDirectory::DatasetType value);
  
  // required string datasetName = 5;
  inline bool has_datasetname() const;
  inline void clear_datasetname();
  static const int kDatasetNameFieldNumber = 5;
  inline const ::std::string& datasetname() const;
  inline void set_datasetname(const ::std::string& value);
  inline void set_datasetname(const char* value);
  inline void set_datasetname(const char* value, size_t size);
  inline ::std::string* mutable_datasetname();
  inline ::std::string* release_datasetname();
  
  // required fixed64 lastUpdated = 6;
  inline bool has_lastupdated() const;
  inline void clear_lastupdated();
  static const int kLastUpdatedFieldNumber = 6;
  inline ::google::protobuf::uint64 lastupdated() const;
  inline void set_lastupdated(::google::protobuf::uint64 value);
  
  // optional fixed64 destDatasetId = 7;
  inline bool has_destdatasetid() const;
  inline void clear_destdatasetid();
  static const int kDestDatasetIdFieldNumber = 7;
  inline ::google::protobuf::uint64 destdatasetid() const;
  inline void set_destdatasetid(::google::protobuf::uint64 value);
  
  // optional fixed64 primaryVersion = 8;
  inline bool has_primaryversion() const;
  inline void clear_primaryversion();
  static const int kPrimaryVersionFieldNumber = 8;
  inline ::google::protobuf::uint64 primaryversion() const;
  inline void set_primaryversion(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.UpdatedDataset)
 private:
  inline void set_has_datasetid();
  inline void clear_has_datasetid();
  inline void set_has_clusterid();
  inline void clear_has_clusterid();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_datasettype();
  inline void clear_has_datasettype();
  inline void set_has_datasetname();
  inline void clear_has_datasetname();
  inline void set_has_lastupdated();
  inline void clear_has_lastupdated();
  inline void set_has_destdatasetid();
  inline void clear_has_destdatasetid();
  inline void set_has_primaryversion();
  inline void clear_has_primaryversion();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 datasetid_;
  ::google::protobuf::uint64 clusterid_;
  ::google::protobuf::uint64 userid_;
  ::std::string* datasetname_;
  ::google::protobuf::uint64 lastupdated_;
  ::google::protobuf::uint64 destdatasetid_;
  ::google::protobuf::uint64 primaryversion_;
  int datasettype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static UpdatedDataset* default_instance_;
};
// -------------------------------------------------------------------

class DatasetFilter : public ::google::protobuf::Message {
 public:
  DatasetFilter();
  virtual ~DatasetFilter();
  
  DatasetFilter(const DatasetFilter& from);
  
  inline DatasetFilter& operator=(const DatasetFilter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DatasetFilter& default_instance();
  
  void Swap(DatasetFilter* other);
  
  // implements Message ----------------------------------------------
  
  DatasetFilter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DatasetFilter& from);
  void MergeFrom(const DatasetFilter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.DatasetFilter)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::std::string* value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static DatasetFilter* default_instance_;
};
// -------------------------------------------------------------------

class MssDetail : public ::google::protobuf::Message {
 public:
  MssDetail();
  virtual ~MssDetail();
  
  MssDetail(const MssDetail& from);
  
  inline MssDetail& operator=(const MssDetail& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MssDetail& default_instance();
  
  void Swap(MssDetail* other);
  
  // implements Message ----------------------------------------------
  
  MssDetail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MssDetail& from);
  void MergeFrom(const MssDetail& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed64 mssId = 1;
  inline bool has_mssid() const;
  inline void clear_mssid();
  static const int kMssIdFieldNumber = 1;
  inline ::google::protobuf::uint64 mssid() const;
  inline void set_mssid(::google::protobuf::uint64 value);
  
  // required string mssName = 2;
  inline bool has_mssname() const;
  inline void clear_mssname();
  static const int kMssNameFieldNumber = 2;
  inline const ::std::string& mssname() const;
  inline void set_mssname(const ::std::string& value);
  inline void set_mssname(const char* value);
  inline void set_mssname(const char* value, size_t size);
  inline ::std::string* mutable_mssname();
  inline ::std::string* release_mssname();
  
  // optional bool inactiveFlag = 3;
  inline bool has_inactiveflag() const;
  inline void clear_inactiveflag();
  static const int kInactiveFlagFieldNumber = 3;
  inline bool inactiveflag() const;
  inline void set_inactiveflag(bool value);
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.MssDetail)
 private:
  inline void set_has_mssid();
  inline void clear_has_mssid();
  inline void set_has_mssname();
  inline void clear_has_mssname();
  inline void set_has_inactiveflag();
  inline void clear_has_inactiveflag();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 mssid_;
  ::std::string* mssname_;
  bool inactiveflag_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static MssDetail* default_instance_;
};
// -------------------------------------------------------------------

class StorageUnitDetail : public ::google::protobuf::Message {
 public:
  StorageUnitDetail();
  virtual ~StorageUnitDetail();
  
  StorageUnitDetail(const StorageUnitDetail& from);
  
  inline StorageUnitDetail& operator=(const StorageUnitDetail& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StorageUnitDetail& default_instance();
  
  void Swap(StorageUnitDetail* other);
  
  // implements Message ----------------------------------------------
  
  StorageUnitDetail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StorageUnitDetail& from);
  void MergeFrom(const StorageUnitDetail& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed64 storageId = 1;
  inline bool has_storageid() const;
  inline void clear_storageid();
  static const int kStorageIdFieldNumber = 1;
  inline ::google::protobuf::uint64 storageid() const;
  inline void set_storageid(::google::protobuf::uint64 value);
  
  // repeated fixed64 mssIds = 2;
  inline int mssids_size() const;
  inline void clear_mssids();
  static const int kMssIdsFieldNumber = 2;
  inline ::google::protobuf::uint64 mssids(int index) const;
  inline void set_mssids(int index, ::google::protobuf::uint64 value);
  inline void add_mssids(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      mssids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_mssids();
  
  // optional bool inactiveFlag = 3;
  inline bool has_inactiveflag() const;
  inline void clear_inactiveflag();
  static const int kInactiveFlagFieldNumber = 3;
  inline bool inactiveflag() const;
  inline void set_inactiveflag(bool value);
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.StorageUnitDetail)
 private:
  inline void set_has_storageid();
  inline void clear_has_storageid();
  inline void set_has_inactiveflag();
  inline void clear_has_inactiveflag();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 storageid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > mssids_;
  bool inactiveflag_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static StorageUnitDetail* default_instance_;
};
// -------------------------------------------------------------------

class BrsDetail : public ::google::protobuf::Message {
 public:
  BrsDetail();
  virtual ~BrsDetail();
  
  BrsDetail(const BrsDetail& from);
  
  inline BrsDetail& operator=(const BrsDetail& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BrsDetail& default_instance();
  
  void Swap(BrsDetail* other);
  
  // implements Message ----------------------------------------------
  
  BrsDetail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BrsDetail& from);
  void MergeFrom(const BrsDetail& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed64 brsId = 1;
  inline bool has_brsid() const;
  inline void clear_brsid();
  static const int kBrsIdFieldNumber = 1;
  inline ::google::protobuf::uint64 brsid() const;
  inline void set_brsid(::google::protobuf::uint64 value);
  
  // required string brsName = 2;
  inline bool has_brsname() const;
  inline void clear_brsname();
  static const int kBrsNameFieldNumber = 2;
  inline const ::std::string& brsname() const;
  inline void set_brsname(const ::std::string& value);
  inline void set_brsname(const char* value);
  inline void set_brsname(const char* value, size_t size);
  inline ::std::string* mutable_brsname();
  inline ::std::string* release_brsname();
  
  // optional bool inactiveFlag = 3;
  inline bool has_inactiveflag() const;
  inline void clear_inactiveflag();
  static const int kInactiveFlagFieldNumber = 3;
  inline bool inactiveflag() const;
  inline void set_inactiveflag(bool value);
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.BrsDetail)
 private:
  inline void set_has_brsid();
  inline void clear_has_brsid();
  inline void set_has_brsname();
  inline void clear_has_brsname();
  inline void set_has_inactiveflag();
  inline void clear_has_inactiveflag();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 brsid_;
  ::std::string* brsname_;
  bool inactiveflag_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static BrsDetail* default_instance_;
};
// -------------------------------------------------------------------

class BrsStorageUnitDetail : public ::google::protobuf::Message {
 public:
  BrsStorageUnitDetail();
  virtual ~BrsStorageUnitDetail();
  
  BrsStorageUnitDetail(const BrsStorageUnitDetail& from);
  
  inline BrsStorageUnitDetail& operator=(const BrsStorageUnitDetail& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BrsStorageUnitDetail& default_instance();
  
  void Swap(BrsStorageUnitDetail* other);
  
  // implements Message ----------------------------------------------
  
  BrsStorageUnitDetail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BrsStorageUnitDetail& from);
  void MergeFrom(const BrsStorageUnitDetail& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed64 brsStorageId = 1;
  inline bool has_brsstorageid() const;
  inline void clear_brsstorageid();
  static const int kBrsStorageIdFieldNumber = 1;
  inline ::google::protobuf::uint64 brsstorageid() const;
  inline void set_brsstorageid(::google::protobuf::uint64 value);
  
  // required fixed64 brsId = 2;
  inline bool has_brsid() const;
  inline void clear_brsid();
  static const int kBrsIdFieldNumber = 2;
  inline ::google::protobuf::uint64 brsid() const;
  inline void set_brsid(::google::protobuf::uint64 value);
  
  // optional bool inactiveFlag = 3;
  inline bool has_inactiveflag() const;
  inline void clear_inactiveflag();
  static const int kInactiveFlagFieldNumber = 3;
  inline bool inactiveflag() const;
  inline void set_inactiveflag(bool value);
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.BrsStorageUnitDetail)
 private:
  inline void set_has_brsstorageid();
  inline void clear_has_brsstorageid();
  inline void set_has_brsid();
  inline void clear_has_brsid();
  inline void set_has_inactiveflag();
  inline void clear_has_inactiveflag();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 brsstorageid_;
  ::google::protobuf::uint64 brsid_;
  bool inactiveflag_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static BrsStorageUnitDetail* default_instance_;
};
// -------------------------------------------------------------------

class BackupStatus : public ::google::protobuf::Message {
 public:
  BackupStatus();
  virtual ~BackupStatus();
  
  BackupStatus(const BackupStatus& from);
  
  inline BackupStatus& operator=(const BackupStatus& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BackupStatus& default_instance();
  
  void Swap(BackupStatus* other);
  
  // implements Message ----------------------------------------------
  
  BackupStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BackupStatus& from);
  void MergeFrom(const BackupStatus& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed64 userId = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required fixed64 datasetId = 2;
  inline bool has_datasetid() const;
  inline void clear_datasetid();
  static const int kDatasetIdFieldNumber = 2;
  inline ::google::protobuf::uint64 datasetid() const;
  inline void set_datasetid(::google::protobuf::uint64 value);
  
  // required fixed64 lastBackupTime = 3;
  inline bool has_lastbackuptime() const;
  inline void clear_lastbackuptime();
  static const int kLastBackupTimeFieldNumber = 3;
  inline ::google::protobuf::uint64 lastbackuptime() const;
  inline void set_lastbackuptime(::google::protobuf::uint64 value);
  
  // required fixed64 lastBackupVersion = 4;
  inline bool has_lastbackupversion() const;
  inline void clear_lastbackupversion();
  static const int kLastBackupVersionFieldNumber = 4;
  inline ::google::protobuf::uint64 lastbackupversion() const;
  inline void set_lastbackupversion(::google::protobuf::uint64 value);
  
  // optional fixed64 lastArchiveTime = 5;
  inline bool has_lastarchivetime() const;
  inline void clear_lastarchivetime();
  static const int kLastArchiveTimeFieldNumber = 5;
  inline ::google::protobuf::uint64 lastarchivetime() const;
  inline void set_lastarchivetime(::google::protobuf::uint64 value);
  
  // optional fixed64 lastArchiveVersion = 6;
  inline bool has_lastarchiveversion() const;
  inline void clear_lastarchiveversion();
  static const int kLastArchiveVersionFieldNumber = 6;
  inline ::google::protobuf::uint64 lastarchiveversion() const;
  inline void set_lastarchiveversion(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.BackupStatus)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_datasetid();
  inline void clear_has_datasetid();
  inline void set_has_lastbackuptime();
  inline void clear_has_lastbackuptime();
  inline void set_has_lastbackupversion();
  inline void clear_has_lastbackupversion();
  inline void set_has_lastarchivetime();
  inline void clear_has_lastarchivetime();
  inline void set_has_lastarchiveversion();
  inline void clear_has_lastarchiveversion();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 datasetid_;
  ::google::protobuf::uint64 lastbackuptime_;
  ::google::protobuf::uint64 lastbackupversion_;
  ::google::protobuf::uint64 lastarchivetime_;
  ::google::protobuf::uint64 lastarchiveversion_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static BackupStatus* default_instance_;
};
// -------------------------------------------------------------------

class GetSaveTicketsInput : public ::google::protobuf::Message {
 public:
  GetSaveTicketsInput();
  virtual ~GetSaveTicketsInput();
  
  GetSaveTicketsInput(const GetSaveTicketsInput& from);
  
  inline GetSaveTicketsInput& operator=(const GetSaveTicketsInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSaveTicketsInput& default_instance();
  
  void Swap(GetSaveTicketsInput* other);
  
  // implements Message ----------------------------------------------
  
  GetSaveTicketsInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetSaveTicketsInput& from);
  void MergeFrom(const GetSaveTicketsInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 deviceId = 2;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIdFieldNumber = 2;
  inline ::google::protobuf::uint64 deviceid() const;
  inline void set_deviceid(::google::protobuf::uint64 value);
  
  // required bytes certificate = 3;
  inline bool has_certificate() const;
  inline void clear_certificate();
  static const int kCertificateFieldNumber = 3;
  inline const ::std::string& certificate() const;
  inline void set_certificate(const ::std::string& value);
  inline void set_certificate(const char* value);
  inline void set_certificate(const void* value, size_t size);
  inline ::std::string* mutable_certificate();
  inline ::std::string* release_certificate();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetSaveTicketsInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_certificate();
  inline void clear_has_certificate();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 deviceid_;
  ::std::string* certificate_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetSaveTicketsInput* default_instance_;
};
// -------------------------------------------------------------------

class GetSaveTicketsOutput : public ::google::protobuf::Message {
 public:
  GetSaveTicketsOutput();
  virtual ~GetSaveTicketsOutput();
  
  GetSaveTicketsOutput(const GetSaveTicketsOutput& from);
  
  inline GetSaveTicketsOutput& operator=(const GetSaveTicketsOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSaveTicketsOutput& default_instance();
  
  void Swap(GetSaveTicketsOutput* other);
  
  // implements Message ----------------------------------------------
  
  GetSaveTicketsOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetSaveTicketsOutput& from);
  void MergeFrom(const GetSaveTicketsOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // optional .vplex.vsDirectory.ETicketData encryptionTicket = 2;
  inline bool has_encryptionticket() const;
  inline void clear_encryptionticket();
  static const int kEncryptionTicketFieldNumber = 2;
  inline const ::vplex::vsDirectory::ETicketData& encryptionticket() const;
  inline ::vplex::vsDirectory::ETicketData* mutable_encryptionticket();
  inline ::vplex::vsDirectory::ETicketData* release_encryptionticket();
  
  // optional .vplex.vsDirectory.ETicketData signingTicket = 3;
  inline bool has_signingticket() const;
  inline void clear_signingticket();
  static const int kSigningTicketFieldNumber = 3;
  inline const ::vplex::vsDirectory::ETicketData& signingticket() const;
  inline ::vplex::vsDirectory::ETicketData* mutable_signingticket();
  inline ::vplex::vsDirectory::ETicketData* release_signingticket();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetSaveTicketsOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_encryptionticket();
  inline void clear_has_encryptionticket();
  inline void set_has_signingticket();
  inline void clear_has_signingticket();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  ::vplex::vsDirectory::ETicketData* encryptionticket_;
  ::vplex::vsDirectory::ETicketData* signingticket_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetSaveTicketsOutput* default_instance_;
};
// -------------------------------------------------------------------

class GetSaveDataInput : public ::google::protobuf::Message {
 public:
  GetSaveDataInput();
  virtual ~GetSaveDataInput();
  
  GetSaveDataInput(const GetSaveDataInput& from);
  
  inline GetSaveDataInput& operator=(const GetSaveDataInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSaveDataInput& default_instance();
  
  void Swap(GetSaveDataInput* other);
  
  // implements Message ----------------------------------------------
  
  GetSaveDataInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetSaveDataInput& from);
  void MergeFrom(const GetSaveDataInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // repeated string titleIds = 2;
  inline int titleids_size() const;
  inline void clear_titleids();
  static const int kTitleIdsFieldNumber = 2;
  inline const ::std::string& titleids(int index) const;
  inline ::std::string* mutable_titleids(int index);
  inline void set_titleids(int index, const ::std::string& value);
  inline void set_titleids(int index, const char* value);
  inline void set_titleids(int index, const char* value, size_t size);
  inline ::std::string* add_titleids();
  inline void add_titleids(const ::std::string& value);
  inline void add_titleids(const char* value);
  inline void add_titleids(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& titleids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_titleids();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetSaveDataInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::RepeatedPtrField< ::std::string> titleids_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetSaveDataInput* default_instance_;
};
// -------------------------------------------------------------------

class GetSaveDataOutput : public ::google::protobuf::Message {
 public:
  GetSaveDataOutput();
  virtual ~GetSaveDataOutput();
  
  GetSaveDataOutput(const GetSaveDataOutput& from);
  
  inline GetSaveDataOutput& operator=(const GetSaveDataOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSaveDataOutput& default_instance();
  
  void Swap(GetSaveDataOutput* other);
  
  // implements Message ----------------------------------------------
  
  GetSaveDataOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetSaveDataOutput& from);
  void MergeFrom(const GetSaveDataOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // repeated .vplex.vsDirectory.SaveData data = 2;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::vplex::vsDirectory::SaveData& data(int index) const;
  inline ::vplex::vsDirectory::SaveData* mutable_data(int index);
  inline ::vplex::vsDirectory::SaveData* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::SaveData >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::SaveData >*
      mutable_data();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetSaveDataOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::SaveData > data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetSaveDataOutput* default_instance_;
};
// -------------------------------------------------------------------

class GetOwnedTitlesInput : public ::google::protobuf::Message {
 public:
  GetOwnedTitlesInput();
  virtual ~GetOwnedTitlesInput();
  
  GetOwnedTitlesInput(const GetOwnedTitlesInput& from);
  
  inline GetOwnedTitlesInput& operator=(const GetOwnedTitlesInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetOwnedTitlesInput& default_instance();
  
  void Swap(GetOwnedTitlesInput* other);
  
  // implements Message ----------------------------------------------
  
  GetOwnedTitlesInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetOwnedTitlesInput& from);
  void MergeFrom(const GetOwnedTitlesInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required .vplex.vsDirectory.Localization l10n = 2;
  inline bool has_l10n() const;
  inline void clear_l10n();
  static const int kL10NFieldNumber = 2;
  inline const ::vplex::vsDirectory::Localization& l10n() const;
  inline ::vplex::vsDirectory::Localization* mutable_l10n();
  inline ::vplex::vsDirectory::Localization* release_l10n();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetOwnedTitlesInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_l10n();
  inline void clear_has_l10n();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::vplex::vsDirectory::Localization* l10n_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetOwnedTitlesInput* default_instance_;
};
// -------------------------------------------------------------------

class GetOwnedTitlesOutput : public ::google::protobuf::Message {
 public:
  GetOwnedTitlesOutput();
  virtual ~GetOwnedTitlesOutput();
  
  GetOwnedTitlesOutput(const GetOwnedTitlesOutput& from);
  
  inline GetOwnedTitlesOutput& operator=(const GetOwnedTitlesOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetOwnedTitlesOutput& default_instance();
  
  void Swap(GetOwnedTitlesOutput* other);
  
  // implements Message ----------------------------------------------
  
  GetOwnedTitlesOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetOwnedTitlesOutput& from);
  void MergeFrom(const GetOwnedTitlesOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // repeated .vplex.vsDirectory.TitleData titleData = 2;
  inline int titledata_size() const;
  inline void clear_titledata();
  static const int kTitleDataFieldNumber = 2;
  inline const ::vplex::vsDirectory::TitleData& titledata(int index) const;
  inline ::vplex::vsDirectory::TitleData* mutable_titledata(int index);
  inline ::vplex::vsDirectory::TitleData* add_titledata();
  inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::TitleData >&
      titledata() const;
  inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::TitleData >*
      mutable_titledata();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetOwnedTitlesOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::TitleData > titledata_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetOwnedTitlesOutput* default_instance_;
};
// -------------------------------------------------------------------

class GetTitlesInput : public ::google::protobuf::Message {
 public:
  GetTitlesInput();
  virtual ~GetTitlesInput();
  
  GetTitlesInput(const GetTitlesInput& from);
  
  inline GetTitlesInput& operator=(const GetTitlesInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTitlesInput& default_instance();
  
  void Swap(GetTitlesInput* other);
  
  // implements Message ----------------------------------------------
  
  GetTitlesInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetTitlesInput& from);
  void MergeFrom(const GetTitlesInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required .vplex.vsDirectory.Localization l10n = 2;
  inline bool has_l10n() const;
  inline void clear_l10n();
  static const int kL10NFieldNumber = 2;
  inline const ::vplex::vsDirectory::Localization& l10n() const;
  inline ::vplex::vsDirectory::Localization* mutable_l10n();
  inline ::vplex::vsDirectory::Localization* release_l10n();
  
  // repeated string titleIds = 3;
  inline int titleids_size() const;
  inline void clear_titleids();
  static const int kTitleIdsFieldNumber = 3;
  inline const ::std::string& titleids(int index) const;
  inline ::std::string* mutable_titleids(int index);
  inline void set_titleids(int index, const ::std::string& value);
  inline void set_titleids(int index, const char* value);
  inline void set_titleids(int index, const char* value, size_t size);
  inline ::std::string* add_titleids();
  inline void add_titleids(const ::std::string& value);
  inline void add_titleids(const char* value);
  inline void add_titleids(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& titleids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_titleids();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetTitlesInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_l10n();
  inline void clear_has_l10n();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::vplex::vsDirectory::Localization* l10n_;
  ::google::protobuf::RepeatedPtrField< ::std::string> titleids_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetTitlesInput* default_instance_;
};
// -------------------------------------------------------------------

class GetTitlesOutput : public ::google::protobuf::Message {
 public:
  GetTitlesOutput();
  virtual ~GetTitlesOutput();
  
  GetTitlesOutput(const GetTitlesOutput& from);
  
  inline GetTitlesOutput& operator=(const GetTitlesOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTitlesOutput& default_instance();
  
  void Swap(GetTitlesOutput* other);
  
  // implements Message ----------------------------------------------
  
  GetTitlesOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetTitlesOutput& from);
  void MergeFrom(const GetTitlesOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // repeated .vplex.vsDirectory.TitleData titleData = 2;
  inline int titledata_size() const;
  inline void clear_titledata();
  static const int kTitleDataFieldNumber = 2;
  inline const ::vplex::vsDirectory::TitleData& titledata(int index) const;
  inline ::vplex::vsDirectory::TitleData* mutable_titledata(int index);
  inline ::vplex::vsDirectory::TitleData* add_titledata();
  inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::TitleData >&
      titledata() const;
  inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::TitleData >*
      mutable_titledata();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetTitlesOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::TitleData > titledata_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetTitlesOutput* default_instance_;
};
// -------------------------------------------------------------------

class GetTitleDetailsInput : public ::google::protobuf::Message {
 public:
  GetTitleDetailsInput();
  virtual ~GetTitleDetailsInput();
  
  GetTitleDetailsInput(const GetTitleDetailsInput& from);
  
  inline GetTitleDetailsInput& operator=(const GetTitleDetailsInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTitleDetailsInput& default_instance();
  
  void Swap(GetTitleDetailsInput* other);
  
  // implements Message ----------------------------------------------
  
  GetTitleDetailsInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetTitleDetailsInput& from);
  void MergeFrom(const GetTitleDetailsInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required .vplex.vsDirectory.Localization l10n = 2;
  inline bool has_l10n() const;
  inline void clear_l10n();
  static const int kL10NFieldNumber = 2;
  inline const ::vplex::vsDirectory::Localization& l10n() const;
  inline ::vplex::vsDirectory::Localization* mutable_l10n();
  inline ::vplex::vsDirectory::Localization* release_l10n();
  
  // repeated string titleIds = 3;
  inline int titleids_size() const;
  inline void clear_titleids();
  static const int kTitleIdsFieldNumber = 3;
  inline const ::std::string& titleids(int index) const;
  inline ::std::string* mutable_titleids(int index);
  inline void set_titleids(int index, const ::std::string& value);
  inline void set_titleids(int index, const char* value);
  inline void set_titleids(int index, const char* value, size_t size);
  inline ::std::string* add_titleids();
  inline void add_titleids(const ::std::string& value);
  inline void add_titleids(const char* value);
  inline void add_titleids(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& titleids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_titleids();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetTitleDetailsInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_l10n();
  inline void clear_has_l10n();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::vplex::vsDirectory::Localization* l10n_;
  ::google::protobuf::RepeatedPtrField< ::std::string> titleids_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetTitleDetailsInput* default_instance_;
};
// -------------------------------------------------------------------

class GetTitleDetailsOutput : public ::google::protobuf::Message {
 public:
  GetTitleDetailsOutput();
  virtual ~GetTitleDetailsOutput();
  
  GetTitleDetailsOutput(const GetTitleDetailsOutput& from);
  
  inline GetTitleDetailsOutput& operator=(const GetTitleDetailsOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTitleDetailsOutput& default_instance();
  
  void Swap(GetTitleDetailsOutput* other);
  
  // implements Message ----------------------------------------------
  
  GetTitleDetailsOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetTitleDetailsOutput& from);
  void MergeFrom(const GetTitleDetailsOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // repeated .vplex.vsDirectory.TitleDetail titleDetails = 2;
  inline int titledetails_size() const;
  inline void clear_titledetails();
  static const int kTitleDetailsFieldNumber = 2;
  inline const ::vplex::vsDirectory::TitleDetail& titledetails(int index) const;
  inline ::vplex::vsDirectory::TitleDetail* mutable_titledetails(int index);
  inline ::vplex::vsDirectory::TitleDetail* add_titledetails();
  inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::TitleDetail >&
      titledetails() const;
  inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::TitleDetail >*
      mutable_titledetails();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetTitleDetailsOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::TitleDetail > titledetails_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetTitleDetailsOutput* default_instance_;
};
// -------------------------------------------------------------------

class GetAttestationChallengeInput : public ::google::protobuf::Message {
 public:
  GetAttestationChallengeInput();
  virtual ~GetAttestationChallengeInput();
  
  GetAttestationChallengeInput(const GetAttestationChallengeInput& from);
  
  inline GetAttestationChallengeInput& operator=(const GetAttestationChallengeInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAttestationChallengeInput& default_instance();
  
  void Swap(GetAttestationChallengeInput* other);
  
  // implements Message ----------------------------------------------
  
  GetAttestationChallengeInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetAttestationChallengeInput& from);
  void MergeFrom(const GetAttestationChallengeInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 deviceId = 2;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIdFieldNumber = 2;
  inline ::google::protobuf::uint64 deviceid() const;
  inline void set_deviceid(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetAttestationChallengeInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 deviceid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetAttestationChallengeInput* default_instance_;
};
// -------------------------------------------------------------------

class GetAttestationChallengeOutput : public ::google::protobuf::Message {
 public:
  GetAttestationChallengeOutput();
  virtual ~GetAttestationChallengeOutput();
  
  GetAttestationChallengeOutput(const GetAttestationChallengeOutput& from);
  
  inline GetAttestationChallengeOutput& operator=(const GetAttestationChallengeOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAttestationChallengeOutput& default_instance();
  
  void Swap(GetAttestationChallengeOutput* other);
  
  // implements Message ----------------------------------------------
  
  GetAttestationChallengeOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetAttestationChallengeOutput& from);
  void MergeFrom(const GetAttestationChallengeOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // optional bytes challenge = 2;
  inline bool has_challenge() const;
  inline void clear_challenge();
  static const int kChallengeFieldNumber = 2;
  inline const ::std::string& challenge() const;
  inline void set_challenge(const ::std::string& value);
  inline void set_challenge(const char* value);
  inline void set_challenge(const void* value, size_t size);
  inline ::std::string* mutable_challenge();
  inline ::std::string* release_challenge();
  
  // optional bytes challengeTmd = 3;
  inline bool has_challengetmd() const;
  inline void clear_challengetmd();
  static const int kChallengeTmdFieldNumber = 3;
  inline const ::std::string& challengetmd() const;
  inline void set_challengetmd(const ::std::string& value);
  inline void set_challengetmd(const char* value);
  inline void set_challengetmd(const void* value, size_t size);
  inline ::std::string* mutable_challengetmd();
  inline ::std::string* release_challengetmd();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetAttestationChallengeOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_challenge();
  inline void clear_has_challenge();
  inline void set_has_challengetmd();
  inline void clear_has_challengetmd();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  ::std::string* challenge_;
  ::std::string* challengetmd_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetAttestationChallengeOutput* default_instance_;
};
// -------------------------------------------------------------------

class AuthenticateDeviceInput : public ::google::protobuf::Message {
 public:
  AuthenticateDeviceInput();
  virtual ~AuthenticateDeviceInput();
  
  AuthenticateDeviceInput(const AuthenticateDeviceInput& from);
  
  inline AuthenticateDeviceInput& operator=(const AuthenticateDeviceInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthenticateDeviceInput& default_instance();
  
  void Swap(AuthenticateDeviceInput* other);
  
  // implements Message ----------------------------------------------
  
  AuthenticateDeviceInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AuthenticateDeviceInput& from);
  void MergeFrom(const AuthenticateDeviceInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required bytes challengeResponse = 2;
  inline bool has_challengeresponse() const;
  inline void clear_challengeresponse();
  static const int kChallengeResponseFieldNumber = 2;
  inline const ::std::string& challengeresponse() const;
  inline void set_challengeresponse(const ::std::string& value);
  inline void set_challengeresponse(const char* value);
  inline void set_challengeresponse(const void* value, size_t size);
  inline ::std::string* mutable_challengeresponse();
  inline ::std::string* release_challengeresponse();
  
  // required bytes deviceCertificate = 3;
  inline bool has_devicecertificate() const;
  inline void clear_devicecertificate();
  static const int kDeviceCertificateFieldNumber = 3;
  inline const ::std::string& devicecertificate() const;
  inline void set_devicecertificate(const ::std::string& value);
  inline void set_devicecertificate(const char* value);
  inline void set_devicecertificate(const void* value, size_t size);
  inline ::std::string* mutable_devicecertificate();
  inline ::std::string* release_devicecertificate();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.AuthenticateDeviceInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_challengeresponse();
  inline void clear_has_challengeresponse();
  inline void set_has_devicecertificate();
  inline void clear_has_devicecertificate();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::std::string* challengeresponse_;
  ::std::string* devicecertificate_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static AuthenticateDeviceInput* default_instance_;
};
// -------------------------------------------------------------------

class AuthenticateDeviceOutput : public ::google::protobuf::Message {
 public:
  AuthenticateDeviceOutput();
  virtual ~AuthenticateDeviceOutput();
  
  AuthenticateDeviceOutput(const AuthenticateDeviceOutput& from);
  
  inline AuthenticateDeviceOutput& operator=(const AuthenticateDeviceOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthenticateDeviceOutput& default_instance();
  
  void Swap(AuthenticateDeviceOutput* other);
  
  // implements Message ----------------------------------------------
  
  AuthenticateDeviceOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AuthenticateDeviceOutput& from);
  void MergeFrom(const AuthenticateDeviceOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.AuthenticateDeviceOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static AuthenticateDeviceOutput* default_instance_;
};
// -------------------------------------------------------------------

class GetOnlineTitleTicketInput : public ::google::protobuf::Message {
 public:
  GetOnlineTitleTicketInput();
  virtual ~GetOnlineTitleTicketInput();
  
  GetOnlineTitleTicketInput(const GetOnlineTitleTicketInput& from);
  
  inline GetOnlineTitleTicketInput& operator=(const GetOnlineTitleTicketInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetOnlineTitleTicketInput& default_instance();
  
  void Swap(GetOnlineTitleTicketInput* other);
  
  // implements Message ----------------------------------------------
  
  GetOnlineTitleTicketInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetOnlineTitleTicketInput& from);
  void MergeFrom(const GetOnlineTitleTicketInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 deviceId = 2;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIdFieldNumber = 2;
  inline ::google::protobuf::uint64 deviceid() const;
  inline void set_deviceid(::google::protobuf::uint64 value);
  
  // required bytes deviceCertificate = 3;
  inline bool has_devicecertificate() const;
  inline void clear_devicecertificate();
  static const int kDeviceCertificateFieldNumber = 3;
  inline const ::std::string& devicecertificate() const;
  inline void set_devicecertificate(const ::std::string& value);
  inline void set_devicecertificate(const char* value);
  inline void set_devicecertificate(const void* value, size_t size);
  inline ::std::string* mutable_devicecertificate();
  inline ::std::string* release_devicecertificate();
  
  // required string titleId = 4;
  inline bool has_titleid() const;
  inline void clear_titleid();
  static const int kTitleIdFieldNumber = 4;
  inline const ::std::string& titleid() const;
  inline void set_titleid(const ::std::string& value);
  inline void set_titleid(const char* value);
  inline void set_titleid(const char* value, size_t size);
  inline ::std::string* mutable_titleid();
  inline ::std::string* release_titleid();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetOnlineTitleTicketInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_devicecertificate();
  inline void clear_has_devicecertificate();
  inline void set_has_titleid();
  inline void clear_has_titleid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 deviceid_;
  ::std::string* devicecertificate_;
  ::std::string* titleid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetOnlineTitleTicketInput* default_instance_;
};
// -------------------------------------------------------------------

class GetOnlineTitleTicketOutput : public ::google::protobuf::Message {
 public:
  GetOnlineTitleTicketOutput();
  virtual ~GetOnlineTitleTicketOutput();
  
  GetOnlineTitleTicketOutput(const GetOnlineTitleTicketOutput& from);
  
  inline GetOnlineTitleTicketOutput& operator=(const GetOnlineTitleTicketOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetOnlineTitleTicketOutput& default_instance();
  
  void Swap(GetOnlineTitleTicketOutput* other);
  
  // implements Message ----------------------------------------------
  
  GetOnlineTitleTicketOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetOnlineTitleTicketOutput& from);
  void MergeFrom(const GetOnlineTitleTicketOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // optional .vplex.vsDirectory.ETicketData eTicket = 2;
  inline bool has_eticket() const;
  inline void clear_eticket();
  static const int kETicketFieldNumber = 2;
  inline const ::vplex::vsDirectory::ETicketData& eticket() const;
  inline ::vplex::vsDirectory::ETicketData* mutable_eticket();
  inline ::vplex::vsDirectory::ETicketData* release_eticket();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetOnlineTitleTicketOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_eticket();
  inline void clear_has_eticket();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  ::vplex::vsDirectory::ETicketData* eticket_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetOnlineTitleTicketOutput* default_instance_;
};
// -------------------------------------------------------------------

class GetOfflineTitleTicketsInput : public ::google::protobuf::Message {
 public:
  GetOfflineTitleTicketsInput();
  virtual ~GetOfflineTitleTicketsInput();
  
  GetOfflineTitleTicketsInput(const GetOfflineTitleTicketsInput& from);
  
  inline GetOfflineTitleTicketsInput& operator=(const GetOfflineTitleTicketsInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetOfflineTitleTicketsInput& default_instance();
  
  void Swap(GetOfflineTitleTicketsInput* other);
  
  // implements Message ----------------------------------------------
  
  GetOfflineTitleTicketsInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetOfflineTitleTicketsInput& from);
  void MergeFrom(const GetOfflineTitleTicketsInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 deviceId = 2;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIdFieldNumber = 2;
  inline ::google::protobuf::uint64 deviceid() const;
  inline void set_deviceid(::google::protobuf::uint64 value);
  
  // required bytes deviceCertificate = 3;
  inline bool has_devicecertificate() const;
  inline void clear_devicecertificate();
  static const int kDeviceCertificateFieldNumber = 3;
  inline const ::std::string& devicecertificate() const;
  inline void set_devicecertificate(const ::std::string& value);
  inline void set_devicecertificate(const char* value);
  inline void set_devicecertificate(const void* value, size_t size);
  inline ::std::string* mutable_devicecertificate();
  inline ::std::string* release_devicecertificate();
  
  // repeated string titleIds = 4;
  inline int titleids_size() const;
  inline void clear_titleids();
  static const int kTitleIdsFieldNumber = 4;
  inline const ::std::string& titleids(int index) const;
  inline ::std::string* mutable_titleids(int index);
  inline void set_titleids(int index, const ::std::string& value);
  inline void set_titleids(int index, const char* value);
  inline void set_titleids(int index, const char* value, size_t size);
  inline ::std::string* add_titleids();
  inline void add_titleids(const ::std::string& value);
  inline void add_titleids(const char* value);
  inline void add_titleids(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& titleids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_titleids();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetOfflineTitleTicketsInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_devicecertificate();
  inline void clear_has_devicecertificate();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 deviceid_;
  ::std::string* devicecertificate_;
  ::google::protobuf::RepeatedPtrField< ::std::string> titleids_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetOfflineTitleTicketsInput* default_instance_;
};
// -------------------------------------------------------------------

class GetOfflineTitleTicketsOutput : public ::google::protobuf::Message {
 public:
  GetOfflineTitleTicketsOutput();
  virtual ~GetOfflineTitleTicketsOutput();
  
  GetOfflineTitleTicketsOutput(const GetOfflineTitleTicketsOutput& from);
  
  inline GetOfflineTitleTicketsOutput& operator=(const GetOfflineTitleTicketsOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetOfflineTitleTicketsOutput& default_instance();
  
  void Swap(GetOfflineTitleTicketsOutput* other);
  
  // implements Message ----------------------------------------------
  
  GetOfflineTitleTicketsOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetOfflineTitleTicketsOutput& from);
  void MergeFrom(const GetOfflineTitleTicketsOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // repeated .vplex.vsDirectory.TitleTicket titleTickets = 2;
  inline int titletickets_size() const;
  inline void clear_titletickets();
  static const int kTitleTicketsFieldNumber = 2;
  inline const ::vplex::vsDirectory::TitleTicket& titletickets(int index) const;
  inline ::vplex::vsDirectory::TitleTicket* mutable_titletickets(int index);
  inline ::vplex::vsDirectory::TitleTicket* add_titletickets();
  inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::TitleTicket >&
      titletickets() const;
  inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::TitleTicket >*
      mutable_titletickets();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetOfflineTitleTicketsOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::TitleTicket > titletickets_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetOfflineTitleTicketsOutput* default_instance_;
};
// -------------------------------------------------------------------

class ListOwnedDataSetsInput : public ::google::protobuf::Message {
 public:
  ListOwnedDataSetsInput();
  virtual ~ListOwnedDataSetsInput();
  
  ListOwnedDataSetsInput(const ListOwnedDataSetsInput& from);
  
  inline ListOwnedDataSetsInput& operator=(const ListOwnedDataSetsInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListOwnedDataSetsInput& default_instance();
  
  void Swap(ListOwnedDataSetsInput* other);
  
  // implements Message ----------------------------------------------
  
  ListOwnedDataSetsInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListOwnedDataSetsInput& from);
  void MergeFrom(const ListOwnedDataSetsInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // optional fixed64 deviceId = 3;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIdFieldNumber = 3;
  inline ::google::protobuf::uint64 deviceid() const;
  inline void set_deviceid(::google::protobuf::uint64 value);
  
  // optional string version = 4;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 4;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.ListOwnedDataSetsInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 deviceid_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static ListOwnedDataSetsInput* default_instance_;
};
// -------------------------------------------------------------------

class ListOwnedDataSetsOutput : public ::google::protobuf::Message {
 public:
  ListOwnedDataSetsOutput();
  virtual ~ListOwnedDataSetsOutput();
  
  ListOwnedDataSetsOutput(const ListOwnedDataSetsOutput& from);
  
  inline ListOwnedDataSetsOutput& operator=(const ListOwnedDataSetsOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListOwnedDataSetsOutput& default_instance();
  
  void Swap(ListOwnedDataSetsOutput* other);
  
  // implements Message ----------------------------------------------
  
  ListOwnedDataSetsOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListOwnedDataSetsOutput& from);
  void MergeFrom(const ListOwnedDataSetsOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // repeated .vplex.vsDirectory.DatasetDetail datasets = 2;
  inline int datasets_size() const;
  inline void clear_datasets();
  static const int kDatasetsFieldNumber = 2;
  inline const ::vplex::vsDirectory::DatasetDetail& datasets(int index) const;
  inline ::vplex::vsDirectory::DatasetDetail* mutable_datasets(int index);
  inline ::vplex::vsDirectory::DatasetDetail* add_datasets();
  inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::DatasetDetail >&
      datasets() const;
  inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::DatasetDetail >*
      mutable_datasets();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.ListOwnedDataSetsOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::DatasetDetail > datasets_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static ListOwnedDataSetsOutput* default_instance_;
};
// -------------------------------------------------------------------

class GetDatasetDetailsInput : public ::google::protobuf::Message {
 public:
  GetDatasetDetailsInput();
  virtual ~GetDatasetDetailsInput();
  
  GetDatasetDetailsInput(const GetDatasetDetailsInput& from);
  
  inline GetDatasetDetailsInput& operator=(const GetDatasetDetailsInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetDatasetDetailsInput& default_instance();
  
  void Swap(GetDatasetDetailsInput* other);
  
  // implements Message ----------------------------------------------
  
  GetDatasetDetailsInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetDatasetDetailsInput& from);
  void MergeFrom(const GetDatasetDetailsInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required fixed64 datasetId = 3;
  inline bool has_datasetid() const;
  inline void clear_datasetid();
  static const int kDatasetIdFieldNumber = 3;
  inline ::google::protobuf::uint64 datasetid() const;
  inline void set_datasetid(::google::protobuf::uint64 value);
  
  // optional string version = 4;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 4;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetDatasetDetailsInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_datasetid();
  inline void clear_has_datasetid();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 datasetid_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetDatasetDetailsInput* default_instance_;
};
// -------------------------------------------------------------------

class GetDatasetDetailsOutput : public ::google::protobuf::Message {
 public:
  GetDatasetDetailsOutput();
  virtual ~GetDatasetDetailsOutput();
  
  GetDatasetDetailsOutput(const GetDatasetDetailsOutput& from);
  
  inline GetDatasetDetailsOutput& operator=(const GetDatasetDetailsOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetDatasetDetailsOutput& default_instance();
  
  void Swap(GetDatasetDetailsOutput* other);
  
  // implements Message ----------------------------------------------
  
  GetDatasetDetailsOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetDatasetDetailsOutput& from);
  void MergeFrom(const GetDatasetDetailsOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // optional .vplex.vsDirectory.DatasetDetail datasetDetail = 2;
  inline bool has_datasetdetail() const;
  inline void clear_datasetdetail();
  static const int kDatasetDetailFieldNumber = 2;
  inline const ::vplex::vsDirectory::DatasetDetail& datasetdetail() const;
  inline ::vplex::vsDirectory::DatasetDetail* mutable_datasetdetail();
  inline ::vplex::vsDirectory::DatasetDetail* release_datasetdetail();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetDatasetDetailsOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_datasetdetail();
  inline void clear_has_datasetdetail();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  ::vplex::vsDirectory::DatasetDetail* datasetdetail_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetDatasetDetailsOutput* default_instance_;
};
// -------------------------------------------------------------------

class AddDataSetInput : public ::google::protobuf::Message {
 public:
  AddDataSetInput();
  virtual ~AddDataSetInput();
  
  AddDataSetInput(const AddDataSetInput& from);
  
  inline AddDataSetInput& operator=(const AddDataSetInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddDataSetInput& default_instance();
  
  void Swap(AddDataSetInput* other);
  
  // implements Message ----------------------------------------------
  
  AddDataSetInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddDataSetInput& from);
  void MergeFrom(const AddDataSetInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required string datasetName = 3;
  inline bool has_datasetname() const;
  inline void clear_datasetname();
  static const int kDatasetNameFieldNumber = 3;
  inline const ::std::string& datasetname() const;
  inline void set_datasetname(const ::std::string& value);
  inline void set_datasetname(const char* value);
  inline void set_datasetname(const char* value, size_t size);
  inline ::std::string* mutable_datasetname();
  inline ::std::string* release_datasetname();
  
  // required .vplex.vsDirectory.DatasetType datasetTypeId = 4;
  inline bool has_datasettypeid() const;
  inline void clear_datasettypeid();
  static const int kDatasetTypeIdFieldNumber = 4;
  inline vplex::vsDirectory::DatasetType datasettypeid() const;
  inline void set_datasettypeid(vplex::vsDirectory::DatasetType value);
  
  // optional fixed64 storageClusterId = 5;
  inline bool has_storageclusterid() const;
  inline void clear_storageclusterid();
  static const int kStorageClusterIdFieldNumber = 5;
  inline ::google::protobuf::uint64 storageclusterid() const;
  inline void set_storageclusterid(::google::protobuf::uint64 value);
  
  // optional string version = 6;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 6;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.AddDataSetInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_datasetname();
  inline void clear_has_datasetname();
  inline void set_has_datasettypeid();
  inline void clear_has_datasettypeid();
  inline void set_has_storageclusterid();
  inline void clear_has_storageclusterid();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 userid_;
  ::std::string* datasetname_;
  ::google::protobuf::uint64 storageclusterid_;
  ::std::string* version_;
  int datasettypeid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static AddDataSetInput* default_instance_;
};
// -------------------------------------------------------------------

class AddDataSetOutput : public ::google::protobuf::Message {
 public:
  AddDataSetOutput();
  virtual ~AddDataSetOutput();
  
  AddDataSetOutput(const AddDataSetOutput& from);
  
  inline AddDataSetOutput& operator=(const AddDataSetOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddDataSetOutput& default_instance();
  
  void Swap(AddDataSetOutput* other);
  
  // implements Message ----------------------------------------------
  
  AddDataSetOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddDataSetOutput& from);
  void MergeFrom(const AddDataSetOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // optional fixed64 datasetId = 2;
  inline bool has_datasetid() const;
  inline void clear_datasetid();
  static const int kDatasetIdFieldNumber = 2;
  inline ::google::protobuf::uint64 datasetid() const;
  inline void set_datasetid(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.AddDataSetOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_datasetid();
  inline void clear_has_datasetid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  ::google::protobuf::uint64 datasetid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static AddDataSetOutput* default_instance_;
};
// -------------------------------------------------------------------

class AddCameraDatasetInput : public ::google::protobuf::Message {
 public:
  AddCameraDatasetInput();
  virtual ~AddCameraDatasetInput();
  
  AddCameraDatasetInput(const AddCameraDatasetInput& from);
  
  inline AddCameraDatasetInput& operator=(const AddCameraDatasetInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddCameraDatasetInput& default_instance();
  
  void Swap(AddCameraDatasetInput* other);
  
  // implements Message ----------------------------------------------
  
  AddCameraDatasetInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddCameraDatasetInput& from);
  void MergeFrom(const AddCameraDatasetInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required string datasetName = 3;
  inline bool has_datasetname() const;
  inline void clear_datasetname();
  static const int kDatasetNameFieldNumber = 3;
  inline const ::std::string& datasetname() const;
  inline void set_datasetname(const ::std::string& value);
  inline void set_datasetname(const char* value);
  inline void set_datasetname(const char* value, size_t size);
  inline ::std::string* mutable_datasetname();
  inline ::std::string* release_datasetname();
  
  // required string createdFor = 4;
  inline bool has_createdfor() const;
  inline void clear_createdfor();
  static const int kCreatedForFieldNumber = 4;
  inline const ::std::string& createdfor() const;
  inline void set_createdfor(const ::std::string& value);
  inline void set_createdfor(const char* value);
  inline void set_createdfor(const char* value, size_t size);
  inline ::std::string* mutable_createdfor();
  inline ::std::string* release_createdfor();
  
  // optional string version = 5;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 5;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.AddCameraDatasetInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_datasetname();
  inline void clear_has_datasetname();
  inline void set_has_createdfor();
  inline void clear_has_createdfor();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 userid_;
  ::std::string* datasetname_;
  ::std::string* createdfor_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static AddCameraDatasetInput* default_instance_;
};
// -------------------------------------------------------------------

class AddCameraDatasetOutput : public ::google::protobuf::Message {
 public:
  AddCameraDatasetOutput();
  virtual ~AddCameraDatasetOutput();
  
  AddCameraDatasetOutput(const AddCameraDatasetOutput& from);
  
  inline AddCameraDatasetOutput& operator=(const AddCameraDatasetOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddCameraDatasetOutput& default_instance();
  
  void Swap(AddCameraDatasetOutput* other);
  
  // implements Message ----------------------------------------------
  
  AddCameraDatasetOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddCameraDatasetOutput& from);
  void MergeFrom(const AddCameraDatasetOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // optional fixed64 datasetId = 2;
  inline bool has_datasetid() const;
  inline void clear_datasetid();
  static const int kDatasetIdFieldNumber = 2;
  inline ::google::protobuf::uint64 datasetid() const;
  inline void set_datasetid(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.AddCameraDatasetOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_datasetid();
  inline void clear_has_datasetid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  ::google::protobuf::uint64 datasetid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static AddCameraDatasetOutput* default_instance_;
};
// -------------------------------------------------------------------

class DeleteDataSetInput : public ::google::protobuf::Message {
 public:
  DeleteDataSetInput();
  virtual ~DeleteDataSetInput();
  
  DeleteDataSetInput(const DeleteDataSetInput& from);
  
  inline DeleteDataSetInput& operator=(const DeleteDataSetInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteDataSetInput& default_instance();
  
  void Swap(DeleteDataSetInput* other);
  
  // implements Message ----------------------------------------------
  
  DeleteDataSetInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteDataSetInput& from);
  void MergeFrom(const DeleteDataSetInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // optional fixed64 datasetId = 3;
  inline bool has_datasetid() const;
  inline void clear_datasetid();
  static const int kDatasetIdFieldNumber = 3;
  inline ::google::protobuf::uint64 datasetid() const;
  inline void set_datasetid(::google::protobuf::uint64 value);
  
  // optional string datasetName = 4;
  inline bool has_datasetname() const;
  inline void clear_datasetname();
  static const int kDatasetNameFieldNumber = 4;
  inline const ::std::string& datasetname() const;
  inline void set_datasetname(const ::std::string& value);
  inline void set_datasetname(const char* value);
  inline void set_datasetname(const char* value, size_t size);
  inline ::std::string* mutable_datasetname();
  inline ::std::string* release_datasetname();
  
  // optional string version = 5;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 5;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.DeleteDataSetInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_datasetid();
  inline void clear_has_datasetid();
  inline void set_has_datasetname();
  inline void clear_has_datasetname();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 datasetid_;
  ::std::string* datasetname_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static DeleteDataSetInput* default_instance_;
};
// -------------------------------------------------------------------

class DeleteDataSetOutput : public ::google::protobuf::Message {
 public:
  DeleteDataSetOutput();
  virtual ~DeleteDataSetOutput();
  
  DeleteDataSetOutput(const DeleteDataSetOutput& from);
  
  inline DeleteDataSetOutput& operator=(const DeleteDataSetOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteDataSetOutput& default_instance();
  
  void Swap(DeleteDataSetOutput* other);
  
  // implements Message ----------------------------------------------
  
  DeleteDataSetOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteDataSetOutput& from);
  void MergeFrom(const DeleteDataSetOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.DeleteDataSetOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static DeleteDataSetOutput* default_instance_;
};
// -------------------------------------------------------------------

class RenameDataSetInput : public ::google::protobuf::Message {
 public:
  RenameDataSetInput();
  virtual ~RenameDataSetInput();
  
  RenameDataSetInput(const RenameDataSetInput& from);
  
  inline RenameDataSetInput& operator=(const RenameDataSetInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RenameDataSetInput& default_instance();
  
  void Swap(RenameDataSetInput* other);
  
  // implements Message ----------------------------------------------
  
  RenameDataSetInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RenameDataSetInput& from);
  void MergeFrom(const RenameDataSetInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // optional fixed64 datasetId = 3;
  inline bool has_datasetid() const;
  inline void clear_datasetid();
  static const int kDatasetIdFieldNumber = 3;
  inline ::google::protobuf::uint64 datasetid() const;
  inline void set_datasetid(::google::protobuf::uint64 value);
  
  // optional string datasetName = 4;
  inline bool has_datasetname() const;
  inline void clear_datasetname();
  static const int kDatasetNameFieldNumber = 4;
  inline const ::std::string& datasetname() const;
  inline void set_datasetname(const ::std::string& value);
  inline void set_datasetname(const char* value);
  inline void set_datasetname(const char* value, size_t size);
  inline ::std::string* mutable_datasetname();
  inline ::std::string* release_datasetname();
  
  // required string datasetNameNew = 5;
  inline bool has_datasetnamenew() const;
  inline void clear_datasetnamenew();
  static const int kDatasetNameNewFieldNumber = 5;
  inline const ::std::string& datasetnamenew() const;
  inline void set_datasetnamenew(const ::std::string& value);
  inline void set_datasetnamenew(const char* value);
  inline void set_datasetnamenew(const char* value, size_t size);
  inline ::std::string* mutable_datasetnamenew();
  inline ::std::string* release_datasetnamenew();
  
  // optional string version = 6;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 6;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.RenameDataSetInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_datasetid();
  inline void clear_has_datasetid();
  inline void set_has_datasetname();
  inline void clear_has_datasetname();
  inline void set_has_datasetnamenew();
  inline void clear_has_datasetnamenew();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 datasetid_;
  ::std::string* datasetname_;
  ::std::string* datasetnamenew_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static RenameDataSetInput* default_instance_;
};
// -------------------------------------------------------------------

class RenameDataSetOutput : public ::google::protobuf::Message {
 public:
  RenameDataSetOutput();
  virtual ~RenameDataSetOutput();
  
  RenameDataSetOutput(const RenameDataSetOutput& from);
  
  inline RenameDataSetOutput& operator=(const RenameDataSetOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RenameDataSetOutput& default_instance();
  
  void Swap(RenameDataSetOutput* other);
  
  // implements Message ----------------------------------------------
  
  RenameDataSetOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RenameDataSetOutput& from);
  void MergeFrom(const RenameDataSetOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.RenameDataSetOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static RenameDataSetOutput* default_instance_;
};
// -------------------------------------------------------------------

class SetDataSetCacheInput : public ::google::protobuf::Message {
 public:
  SetDataSetCacheInput();
  virtual ~SetDataSetCacheInput();
  
  SetDataSetCacheInput(const SetDataSetCacheInput& from);
  
  inline SetDataSetCacheInput& operator=(const SetDataSetCacheInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SetDataSetCacheInput& default_instance();
  
  void Swap(SetDataSetCacheInput* other);
  
  // implements Message ----------------------------------------------
  
  SetDataSetCacheInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetDataSetCacheInput& from);
  void MergeFrom(const SetDataSetCacheInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required fixed64 datasetId = 3;
  inline bool has_datasetid() const;
  inline void clear_datasetid();
  static const int kDatasetIdFieldNumber = 3;
  inline ::google::protobuf::uint64 datasetid() const;
  inline void set_datasetid(::google::protobuf::uint64 value);
  
  // optional fixed64 cacheDatasetId = 4;
  inline bool has_cachedatasetid() const;
  inline void clear_cachedatasetid();
  static const int kCacheDatasetIdFieldNumber = 4;
  inline ::google::protobuf::uint64 cachedatasetid() const;
  inline void set_cachedatasetid(::google::protobuf::uint64 value);
  
  // optional string version = 5;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 5;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.SetDataSetCacheInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_datasetid();
  inline void clear_has_datasetid();
  inline void set_has_cachedatasetid();
  inline void clear_has_cachedatasetid();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 datasetid_;
  ::google::protobuf::uint64 cachedatasetid_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static SetDataSetCacheInput* default_instance_;
};
// -------------------------------------------------------------------

class SetDataSetCacheOutput : public ::google::protobuf::Message {
 public:
  SetDataSetCacheOutput();
  virtual ~SetDataSetCacheOutput();
  
  SetDataSetCacheOutput(const SetDataSetCacheOutput& from);
  
  inline SetDataSetCacheOutput& operator=(const SetDataSetCacheOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SetDataSetCacheOutput& default_instance();
  
  void Swap(SetDataSetCacheOutput* other);
  
  // implements Message ----------------------------------------------
  
  SetDataSetCacheOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetDataSetCacheOutput& from);
  void MergeFrom(const SetDataSetCacheOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.SetDataSetCacheOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static SetDataSetCacheOutput* default_instance_;
};
// -------------------------------------------------------------------

class RemoveDeviceFromSubscriptionsInput : public ::google::protobuf::Message {
 public:
  RemoveDeviceFromSubscriptionsInput();
  virtual ~RemoveDeviceFromSubscriptionsInput();
  
  RemoveDeviceFromSubscriptionsInput(const RemoveDeviceFromSubscriptionsInput& from);
  
  inline RemoveDeviceFromSubscriptionsInput& operator=(const RemoveDeviceFromSubscriptionsInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoveDeviceFromSubscriptionsInput& default_instance();
  
  void Swap(RemoveDeviceFromSubscriptionsInput* other);
  
  // implements Message ----------------------------------------------
  
  RemoveDeviceFromSubscriptionsInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemoveDeviceFromSubscriptionsInput& from);
  void MergeFrom(const RemoveDeviceFromSubscriptionsInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required fixed64 deviceId = 3;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIdFieldNumber = 3;
  inline ::google::protobuf::uint64 deviceid() const;
  inline void set_deviceid(::google::protobuf::uint64 value);
  
  // optional string version = 4;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 4;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.RemoveDeviceFromSubscriptionsInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 deviceid_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static RemoveDeviceFromSubscriptionsInput* default_instance_;
};
// -------------------------------------------------------------------

class RemoveDeviceFromSubscriptionsOutput : public ::google::protobuf::Message {
 public:
  RemoveDeviceFromSubscriptionsOutput();
  virtual ~RemoveDeviceFromSubscriptionsOutput();
  
  RemoveDeviceFromSubscriptionsOutput(const RemoveDeviceFromSubscriptionsOutput& from);
  
  inline RemoveDeviceFromSubscriptionsOutput& operator=(const RemoveDeviceFromSubscriptionsOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoveDeviceFromSubscriptionsOutput& default_instance();
  
  void Swap(RemoveDeviceFromSubscriptionsOutput* other);
  
  // implements Message ----------------------------------------------
  
  RemoveDeviceFromSubscriptionsOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemoveDeviceFromSubscriptionsOutput& from);
  void MergeFrom(const RemoveDeviceFromSubscriptionsOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.RemoveDeviceFromSubscriptionsOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static RemoveDeviceFromSubscriptionsOutput* default_instance_;
};
// -------------------------------------------------------------------

class ListSubscriptionsInput : public ::google::protobuf::Message {
 public:
  ListSubscriptionsInput();
  virtual ~ListSubscriptionsInput();
  
  ListSubscriptionsInput(const ListSubscriptionsInput& from);
  
  inline ListSubscriptionsInput& operator=(const ListSubscriptionsInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListSubscriptionsInput& default_instance();
  
  void Swap(ListSubscriptionsInput* other);
  
  // implements Message ----------------------------------------------
  
  ListSubscriptionsInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListSubscriptionsInput& from);
  void MergeFrom(const ListSubscriptionsInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required fixed64 deviceId = 3;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIdFieldNumber = 3;
  inline ::google::protobuf::uint64 deviceid() const;
  inline void set_deviceid(::google::protobuf::uint64 value);
  
  // optional string version = 4;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 4;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.ListSubscriptionsInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 deviceid_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static ListSubscriptionsInput* default_instance_;
};
// -------------------------------------------------------------------

class ListSubscriptionsOutput : public ::google::protobuf::Message {
 public:
  ListSubscriptionsOutput();
  virtual ~ListSubscriptionsOutput();
  
  ListSubscriptionsOutput(const ListSubscriptionsOutput& from);
  
  inline ListSubscriptionsOutput& operator=(const ListSubscriptionsOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListSubscriptionsOutput& default_instance();
  
  void Swap(ListSubscriptionsOutput* other);
  
  // implements Message ----------------------------------------------
  
  ListSubscriptionsOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListSubscriptionsOutput& from);
  void MergeFrom(const ListSubscriptionsOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // repeated .vplex.vsDirectory.Subscription subscriptions = 2;
  inline int subscriptions_size() const;
  inline void clear_subscriptions();
  static const int kSubscriptionsFieldNumber = 2;
  inline const ::vplex::vsDirectory::Subscription& subscriptions(int index) const;
  inline ::vplex::vsDirectory::Subscription* mutable_subscriptions(int index);
  inline ::vplex::vsDirectory::Subscription* add_subscriptions();
  inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::Subscription >&
      subscriptions() const;
  inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::Subscription >*
      mutable_subscriptions();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.ListSubscriptionsOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::Subscription > subscriptions_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static ListSubscriptionsOutput* default_instance_;
};
// -------------------------------------------------------------------

class AddSubscriptionsInput : public ::google::protobuf::Message {
 public:
  AddSubscriptionsInput();
  virtual ~AddSubscriptionsInput();
  
  AddSubscriptionsInput(const AddSubscriptionsInput& from);
  
  inline AddSubscriptionsInput& operator=(const AddSubscriptionsInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddSubscriptionsInput& default_instance();
  
  void Swap(AddSubscriptionsInput* other);
  
  // implements Message ----------------------------------------------
  
  AddSubscriptionsInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddSubscriptionsInput& from);
  void MergeFrom(const AddSubscriptionsInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required fixed64 deviceId = 3;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIdFieldNumber = 3;
  inline ::google::protobuf::uint64 deviceid() const;
  inline void set_deviceid(::google::protobuf::uint64 value);
  
  // repeated .vplex.vsDirectory.Subscription subscriptions = 4;
  inline int subscriptions_size() const;
  inline void clear_subscriptions();
  static const int kSubscriptionsFieldNumber = 4;
  inline const ::vplex::vsDirectory::Subscription& subscriptions(int index) const;
  inline ::vplex::vsDirectory::Subscription* mutable_subscriptions(int index);
  inline ::vplex::vsDirectory::Subscription* add_subscriptions();
  inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::Subscription >&
      subscriptions() const;
  inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::Subscription >*
      mutable_subscriptions();
  
  // optional string version = 5;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 5;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.AddSubscriptionsInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 deviceid_;
  ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::Subscription > subscriptions_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static AddSubscriptionsInput* default_instance_;
};
// -------------------------------------------------------------------

class AddSubscriptionsOutput : public ::google::protobuf::Message {
 public:
  AddSubscriptionsOutput();
  virtual ~AddSubscriptionsOutput();
  
  AddSubscriptionsOutput(const AddSubscriptionsOutput& from);
  
  inline AddSubscriptionsOutput& operator=(const AddSubscriptionsOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddSubscriptionsOutput& default_instance();
  
  void Swap(AddSubscriptionsOutput* other);
  
  // implements Message ----------------------------------------------
  
  AddSubscriptionsOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddSubscriptionsOutput& from);
  void MergeFrom(const AddSubscriptionsOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.AddSubscriptionsOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static AddSubscriptionsOutput* default_instance_;
};
// -------------------------------------------------------------------

class AddUserDatasetSubscriptionInput : public ::google::protobuf::Message {
 public:
  AddUserDatasetSubscriptionInput();
  virtual ~AddUserDatasetSubscriptionInput();
  
  AddUserDatasetSubscriptionInput(const AddUserDatasetSubscriptionInput& from);
  
  inline AddUserDatasetSubscriptionInput& operator=(const AddUserDatasetSubscriptionInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddUserDatasetSubscriptionInput& default_instance();
  
  void Swap(AddUserDatasetSubscriptionInput* other);
  
  // implements Message ----------------------------------------------
  
  AddUserDatasetSubscriptionInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddUserDatasetSubscriptionInput& from);
  void MergeFrom(const AddUserDatasetSubscriptionInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required fixed64 deviceId = 3;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIdFieldNumber = 3;
  inline ::google::protobuf::uint64 deviceid() const;
  inline void set_deviceid(::google::protobuf::uint64 value);
  
  // required fixed64 datasetId = 4;
  inline bool has_datasetid() const;
  inline void clear_datasetid();
  static const int kDatasetIdFieldNumber = 4;
  inline ::google::protobuf::uint64 datasetid() const;
  inline void set_datasetid(::google::protobuf::uint64 value);
  
  // optional string deviceRoot = 5;
  inline bool has_deviceroot() const;
  inline void clear_deviceroot();
  static const int kDeviceRootFieldNumber = 5;
  inline const ::std::string& deviceroot() const;
  inline void set_deviceroot(const ::std::string& value);
  inline void set_deviceroot(const char* value);
  inline void set_deviceroot(const char* value, size_t size);
  inline ::std::string* mutable_deviceroot();
  inline ::std::string* release_deviceroot();
  
  // optional string filter = 6;
  inline bool has_filter() const;
  inline void clear_filter();
  static const int kFilterFieldNumber = 6;
  inline const ::std::string& filter() const;
  inline void set_filter(const ::std::string& value);
  inline void set_filter(const char* value);
  inline void set_filter(const char* value, size_t size);
  inline ::std::string* mutable_filter();
  inline ::std::string* release_filter();
  
  // optional string version = 7;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 7;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.AddUserDatasetSubscriptionInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_datasetid();
  inline void clear_has_datasetid();
  inline void set_has_deviceroot();
  inline void clear_has_deviceroot();
  inline void set_has_filter();
  inline void clear_has_filter();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 deviceid_;
  ::google::protobuf::uint64 datasetid_;
  ::std::string* deviceroot_;
  ::std::string* filter_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static AddUserDatasetSubscriptionInput* default_instance_;
};
// -------------------------------------------------------------------

class AddUserDatasetSubscriptionOutput : public ::google::protobuf::Message {
 public:
  AddUserDatasetSubscriptionOutput();
  virtual ~AddUserDatasetSubscriptionOutput();
  
  AddUserDatasetSubscriptionOutput(const AddUserDatasetSubscriptionOutput& from);
  
  inline AddUserDatasetSubscriptionOutput& operator=(const AddUserDatasetSubscriptionOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddUserDatasetSubscriptionOutput& default_instance();
  
  void Swap(AddUserDatasetSubscriptionOutput* other);
  
  // implements Message ----------------------------------------------
  
  AddUserDatasetSubscriptionOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddUserDatasetSubscriptionOutput& from);
  void MergeFrom(const AddUserDatasetSubscriptionOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.AddUserDatasetSubscriptionOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static AddUserDatasetSubscriptionOutput* default_instance_;
};
// -------------------------------------------------------------------

class AddCameraSubscriptionInput : public ::google::protobuf::Message {
 public:
  AddCameraSubscriptionInput();
  virtual ~AddCameraSubscriptionInput();
  
  AddCameraSubscriptionInput(const AddCameraSubscriptionInput& from);
  
  inline AddCameraSubscriptionInput& operator=(const AddCameraSubscriptionInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddCameraSubscriptionInput& default_instance();
  
  void Swap(AddCameraSubscriptionInput* other);
  
  // implements Message ----------------------------------------------
  
  AddCameraSubscriptionInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddCameraSubscriptionInput& from);
  void MergeFrom(const AddCameraSubscriptionInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required fixed64 deviceId = 3;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIdFieldNumber = 3;
  inline ::google::protobuf::uint64 deviceid() const;
  inline void set_deviceid(::google::protobuf::uint64 value);
  
  // required fixed64 datasetId = 4;
  inline bool has_datasetid() const;
  inline void clear_datasetid();
  static const int kDatasetIdFieldNumber = 4;
  inline ::google::protobuf::uint64 datasetid() const;
  inline void set_datasetid(::google::protobuf::uint64 value);
  
  // optional string deviceRoot = 5;
  inline bool has_deviceroot() const;
  inline void clear_deviceroot();
  static const int kDeviceRootFieldNumber = 5;
  inline const ::std::string& deviceroot() const;
  inline void set_deviceroot(const ::std::string& value);
  inline void set_deviceroot(const char* value);
  inline void set_deviceroot(const char* value, size_t size);
  inline ::std::string* mutable_deviceroot();
  inline ::std::string* release_deviceroot();
  
  // optional string filter = 6;
  inline bool has_filter() const;
  inline void clear_filter();
  static const int kFilterFieldNumber = 6;
  inline const ::std::string& filter() const;
  inline void set_filter(const ::std::string& value);
  inline void set_filter(const char* value);
  inline void set_filter(const char* value, size_t size);
  inline ::std::string* mutable_filter();
  inline ::std::string* release_filter();
  
  // optional string version = 7;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 7;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.AddCameraSubscriptionInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_datasetid();
  inline void clear_has_datasetid();
  inline void set_has_deviceroot();
  inline void clear_has_deviceroot();
  inline void set_has_filter();
  inline void clear_has_filter();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 deviceid_;
  ::google::protobuf::uint64 datasetid_;
  ::std::string* deviceroot_;
  ::std::string* filter_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static AddCameraSubscriptionInput* default_instance_;
};
// -------------------------------------------------------------------

class AddCameraSubscriptionOutput : public ::google::protobuf::Message {
 public:
  AddCameraSubscriptionOutput();
  virtual ~AddCameraSubscriptionOutput();
  
  AddCameraSubscriptionOutput(const AddCameraSubscriptionOutput& from);
  
  inline AddCameraSubscriptionOutput& operator=(const AddCameraSubscriptionOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddCameraSubscriptionOutput& default_instance();
  
  void Swap(AddCameraSubscriptionOutput* other);
  
  // implements Message ----------------------------------------------
  
  AddCameraSubscriptionOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddCameraSubscriptionOutput& from);
  void MergeFrom(const AddCameraSubscriptionOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.AddCameraSubscriptionOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static AddCameraSubscriptionOutput* default_instance_;
};
// -------------------------------------------------------------------

class AddDatasetSubscriptionInput : public ::google::protobuf::Message {
 public:
  AddDatasetSubscriptionInput();
  virtual ~AddDatasetSubscriptionInput();
  
  AddDatasetSubscriptionInput(const AddDatasetSubscriptionInput& from);
  
  inline AddDatasetSubscriptionInput& operator=(const AddDatasetSubscriptionInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddDatasetSubscriptionInput& default_instance();
  
  void Swap(AddDatasetSubscriptionInput* other);
  
  // implements Message ----------------------------------------------
  
  AddDatasetSubscriptionInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddDatasetSubscriptionInput& from);
  void MergeFrom(const AddDatasetSubscriptionInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required fixed64 deviceId = 3;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIdFieldNumber = 3;
  inline ::google::protobuf::uint64 deviceid() const;
  inline void set_deviceid(::google::protobuf::uint64 value);
  
  // required fixed64 datasetId = 4;
  inline bool has_datasetid() const;
  inline void clear_datasetid();
  static const int kDatasetIdFieldNumber = 4;
  inline ::google::protobuf::uint64 datasetid() const;
  inline void set_datasetid(::google::protobuf::uint64 value);
  
  // optional .vplex.vsDirectory.DatasetType datasetType = 5;
  inline bool has_datasettype() const;
  inline void clear_datasettype();
  static const int kDatasetTypeFieldNumber = 5;
  inline vplex::vsDirectory::DatasetType datasettype() const;
  inline void set_datasettype(vplex::vsDirectory::DatasetType value);
  
  // optional .vplex.vsDirectory.SubscriptionRole role = 6 [default = GENERAL];
  inline bool has_role() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 6;
  inline vplex::vsDirectory::SubscriptionRole role() const;
  inline void set_role(vplex::vsDirectory::SubscriptionRole value);
  
  // optional string deviceRoot = 7;
  inline bool has_deviceroot() const;
  inline void clear_deviceroot();
  static const int kDeviceRootFieldNumber = 7;
  inline const ::std::string& deviceroot() const;
  inline void set_deviceroot(const ::std::string& value);
  inline void set_deviceroot(const char* value);
  inline void set_deviceroot(const char* value, size_t size);
  inline ::std::string* mutable_deviceroot();
  inline ::std::string* release_deviceroot();
  
  // optional string filter = 8;
  inline bool has_filter() const;
  inline void clear_filter();
  static const int kFilterFieldNumber = 8;
  inline const ::std::string& filter() const;
  inline void set_filter(const ::std::string& value);
  inline void set_filter(const char* value);
  inline void set_filter(const char* value, size_t size);
  inline ::std::string* mutable_filter();
  inline ::std::string* release_filter();
  
  // optional fixed64 maxSize = 9;
  inline bool has_maxsize() const;
  inline void clear_maxsize();
  static const int kMaxSizeFieldNumber = 9;
  inline ::google::protobuf::uint64 maxsize() const;
  inline void set_maxsize(::google::protobuf::uint64 value);
  
  // optional fixed64 maxFiles = 10;
  inline bool has_maxfiles() const;
  inline void clear_maxfiles();
  static const int kMaxFilesFieldNumber = 10;
  inline ::google::protobuf::uint64 maxfiles() const;
  inline void set_maxfiles(::google::protobuf::uint64 value);
  
  // optional string version = 11;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 11;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.AddDatasetSubscriptionInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_datasetid();
  inline void clear_has_datasetid();
  inline void set_has_datasettype();
  inline void clear_has_datasettype();
  inline void set_has_role();
  inline void clear_has_role();
  inline void set_has_deviceroot();
  inline void clear_has_deviceroot();
  inline void set_has_filter();
  inline void clear_has_filter();
  inline void set_has_maxsize();
  inline void clear_has_maxsize();
  inline void set_has_maxfiles();
  inline void clear_has_maxfiles();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 deviceid_;
  ::google::protobuf::uint64 datasetid_;
  int datasettype_;
  int role_;
  ::std::string* deviceroot_;
  ::std::string* filter_;
  ::google::protobuf::uint64 maxsize_;
  ::google::protobuf::uint64 maxfiles_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static AddDatasetSubscriptionInput* default_instance_;
};
// -------------------------------------------------------------------

class AddDatasetSubscriptionOutput : public ::google::protobuf::Message {
 public:
  AddDatasetSubscriptionOutput();
  virtual ~AddDatasetSubscriptionOutput();
  
  AddDatasetSubscriptionOutput(const AddDatasetSubscriptionOutput& from);
  
  inline AddDatasetSubscriptionOutput& operator=(const AddDatasetSubscriptionOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddDatasetSubscriptionOutput& default_instance();
  
  void Swap(AddDatasetSubscriptionOutput* other);
  
  // implements Message ----------------------------------------------
  
  AddDatasetSubscriptionOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddDatasetSubscriptionOutput& from);
  void MergeFrom(const AddDatasetSubscriptionOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.AddDatasetSubscriptionOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static AddDatasetSubscriptionOutput* default_instance_;
};
// -------------------------------------------------------------------

class DeleteSubscriptionsInput : public ::google::protobuf::Message {
 public:
  DeleteSubscriptionsInput();
  virtual ~DeleteSubscriptionsInput();
  
  DeleteSubscriptionsInput(const DeleteSubscriptionsInput& from);
  
  inline DeleteSubscriptionsInput& operator=(const DeleteSubscriptionsInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteSubscriptionsInput& default_instance();
  
  void Swap(DeleteSubscriptionsInput* other);
  
  // implements Message ----------------------------------------------
  
  DeleteSubscriptionsInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteSubscriptionsInput& from);
  void MergeFrom(const DeleteSubscriptionsInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required fixed64 deviceId = 3;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIdFieldNumber = 3;
  inline ::google::protobuf::uint64 deviceid() const;
  inline void set_deviceid(::google::protobuf::uint64 value);
  
  // repeated string datasetNames = 4;
  inline int datasetnames_size() const;
  inline void clear_datasetnames();
  static const int kDatasetNamesFieldNumber = 4;
  inline const ::std::string& datasetnames(int index) const;
  inline ::std::string* mutable_datasetnames(int index);
  inline void set_datasetnames(int index, const ::std::string& value);
  inline void set_datasetnames(int index, const char* value);
  inline void set_datasetnames(int index, const char* value, size_t size);
  inline ::std::string* add_datasetnames();
  inline void add_datasetnames(const ::std::string& value);
  inline void add_datasetnames(const char* value);
  inline void add_datasetnames(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& datasetnames() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_datasetnames();
  
  // repeated fixed64 datasetIds = 5;
  inline int datasetids_size() const;
  inline void clear_datasetids();
  static const int kDatasetIdsFieldNumber = 5;
  inline ::google::protobuf::uint64 datasetids(int index) const;
  inline void set_datasetids(int index, ::google::protobuf::uint64 value);
  inline void add_datasetids(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      datasetids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_datasetids();
  
  // optional string version = 6;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 6;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.DeleteSubscriptionsInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 deviceid_;
  ::google::protobuf::RepeatedPtrField< ::std::string> datasetnames_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > datasetids_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static DeleteSubscriptionsInput* default_instance_;
};
// -------------------------------------------------------------------

class DeleteSubscriptionsOutput : public ::google::protobuf::Message {
 public:
  DeleteSubscriptionsOutput();
  virtual ~DeleteSubscriptionsOutput();
  
  DeleteSubscriptionsOutput(const DeleteSubscriptionsOutput& from);
  
  inline DeleteSubscriptionsOutput& operator=(const DeleteSubscriptionsOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteSubscriptionsOutput& default_instance();
  
  void Swap(DeleteSubscriptionsOutput* other);
  
  // implements Message ----------------------------------------------
  
  DeleteSubscriptionsOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteSubscriptionsOutput& from);
  void MergeFrom(const DeleteSubscriptionsOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.DeleteSubscriptionsOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static DeleteSubscriptionsOutput* default_instance_;
};
// -------------------------------------------------------------------

class UpdateSubscriptionFilterInput : public ::google::protobuf::Message {
 public:
  UpdateSubscriptionFilterInput();
  virtual ~UpdateSubscriptionFilterInput();
  
  UpdateSubscriptionFilterInput(const UpdateSubscriptionFilterInput& from);
  
  inline UpdateSubscriptionFilterInput& operator=(const UpdateSubscriptionFilterInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateSubscriptionFilterInput& default_instance();
  
  void Swap(UpdateSubscriptionFilterInput* other);
  
  // implements Message ----------------------------------------------
  
  UpdateSubscriptionFilterInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateSubscriptionFilterInput& from);
  void MergeFrom(const UpdateSubscriptionFilterInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required fixed64 deviceId = 3;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIdFieldNumber = 3;
  inline ::google::protobuf::uint64 deviceid() const;
  inline void set_deviceid(::google::protobuf::uint64 value);
  
  // optional string datasetName = 4;
  inline bool has_datasetname() const;
  inline void clear_datasetname();
  static const int kDatasetNameFieldNumber = 4;
  inline const ::std::string& datasetname() const;
  inline void set_datasetname(const ::std::string& value);
  inline void set_datasetname(const char* value);
  inline void set_datasetname(const char* value, size_t size);
  inline ::std::string* mutable_datasetname();
  inline ::std::string* release_datasetname();
  
  // optional fixed64 datasetId = 5;
  inline bool has_datasetid() const;
  inline void clear_datasetid();
  static const int kDatasetIdFieldNumber = 5;
  inline ::google::protobuf::uint64 datasetid() const;
  inline void set_datasetid(::google::protobuf::uint64 value);
  
  // optional string filter = 6;
  inline bool has_filter() const;
  inline void clear_filter();
  static const int kFilterFieldNumber = 6;
  inline const ::std::string& filter() const;
  inline void set_filter(const ::std::string& value);
  inline void set_filter(const char* value);
  inline void set_filter(const char* value, size_t size);
  inline ::std::string* mutable_filter();
  inline ::std::string* release_filter();
  
  // optional string version = 7;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 7;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.UpdateSubscriptionFilterInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_datasetname();
  inline void clear_has_datasetname();
  inline void set_has_datasetid();
  inline void clear_has_datasetid();
  inline void set_has_filter();
  inline void clear_has_filter();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 deviceid_;
  ::std::string* datasetname_;
  ::google::protobuf::uint64 datasetid_;
  ::std::string* filter_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static UpdateSubscriptionFilterInput* default_instance_;
};
// -------------------------------------------------------------------

class UpdateSubscriptionFilterOutput : public ::google::protobuf::Message {
 public:
  UpdateSubscriptionFilterOutput();
  virtual ~UpdateSubscriptionFilterOutput();
  
  UpdateSubscriptionFilterOutput(const UpdateSubscriptionFilterOutput& from);
  
  inline UpdateSubscriptionFilterOutput& operator=(const UpdateSubscriptionFilterOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateSubscriptionFilterOutput& default_instance();
  
  void Swap(UpdateSubscriptionFilterOutput* other);
  
  // implements Message ----------------------------------------------
  
  UpdateSubscriptionFilterOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateSubscriptionFilterOutput& from);
  void MergeFrom(const UpdateSubscriptionFilterOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.UpdateSubscriptionFilterOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static UpdateSubscriptionFilterOutput* default_instance_;
};
// -------------------------------------------------------------------

class UpdateSubscriptionLimitsInput : public ::google::protobuf::Message {
 public:
  UpdateSubscriptionLimitsInput();
  virtual ~UpdateSubscriptionLimitsInput();
  
  UpdateSubscriptionLimitsInput(const UpdateSubscriptionLimitsInput& from);
  
  inline UpdateSubscriptionLimitsInput& operator=(const UpdateSubscriptionLimitsInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateSubscriptionLimitsInput& default_instance();
  
  void Swap(UpdateSubscriptionLimitsInput* other);
  
  // implements Message ----------------------------------------------
  
  UpdateSubscriptionLimitsInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateSubscriptionLimitsInput& from);
  void MergeFrom(const UpdateSubscriptionLimitsInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required fixed64 deviceId = 3;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIdFieldNumber = 3;
  inline ::google::protobuf::uint64 deviceid() const;
  inline void set_deviceid(::google::protobuf::uint64 value);
  
  // optional string datasetName = 4;
  inline bool has_datasetname() const;
  inline void clear_datasetname();
  static const int kDatasetNameFieldNumber = 4;
  inline const ::std::string& datasetname() const;
  inline void set_datasetname(const ::std::string& value);
  inline void set_datasetname(const char* value);
  inline void set_datasetname(const char* value, size_t size);
  inline ::std::string* mutable_datasetname();
  inline ::std::string* release_datasetname();
  
  // optional fixed64 datasetId = 5;
  inline bool has_datasetid() const;
  inline void clear_datasetid();
  static const int kDatasetIdFieldNumber = 5;
  inline ::google::protobuf::uint64 datasetid() const;
  inline void set_datasetid(::google::protobuf::uint64 value);
  
  // optional string filter = 6;
  inline bool has_filter() const;
  inline void clear_filter();
  static const int kFilterFieldNumber = 6;
  inline const ::std::string& filter() const;
  inline void set_filter(const ::std::string& value);
  inline void set_filter(const char* value);
  inline void set_filter(const char* value, size_t size);
  inline ::std::string* mutable_filter();
  inline ::std::string* release_filter();
  
  // optional fixed64 maxSize = 7;
  inline bool has_maxsize() const;
  inline void clear_maxsize();
  static const int kMaxSizeFieldNumber = 7;
  inline ::google::protobuf::uint64 maxsize() const;
  inline void set_maxsize(::google::protobuf::uint64 value);
  
  // optional fixed64 maxFiles = 8;
  inline bool has_maxfiles() const;
  inline void clear_maxfiles();
  static const int kMaxFilesFieldNumber = 8;
  inline ::google::protobuf::uint64 maxfiles() const;
  inline void set_maxfiles(::google::protobuf::uint64 value);
  
  // optional string version = 9;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 9;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.UpdateSubscriptionLimitsInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_datasetname();
  inline void clear_has_datasetname();
  inline void set_has_datasetid();
  inline void clear_has_datasetid();
  inline void set_has_filter();
  inline void clear_has_filter();
  inline void set_has_maxsize();
  inline void clear_has_maxsize();
  inline void set_has_maxfiles();
  inline void clear_has_maxfiles();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 deviceid_;
  ::std::string* datasetname_;
  ::google::protobuf::uint64 datasetid_;
  ::std::string* filter_;
  ::google::protobuf::uint64 maxsize_;
  ::google::protobuf::uint64 maxfiles_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static UpdateSubscriptionLimitsInput* default_instance_;
};
// -------------------------------------------------------------------

class UpdateSubscriptionLimitsOutput : public ::google::protobuf::Message {
 public:
  UpdateSubscriptionLimitsOutput();
  virtual ~UpdateSubscriptionLimitsOutput();
  
  UpdateSubscriptionLimitsOutput(const UpdateSubscriptionLimitsOutput& from);
  
  inline UpdateSubscriptionLimitsOutput& operator=(const UpdateSubscriptionLimitsOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateSubscriptionLimitsOutput& default_instance();
  
  void Swap(UpdateSubscriptionLimitsOutput* other);
  
  // implements Message ----------------------------------------------
  
  UpdateSubscriptionLimitsOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateSubscriptionLimitsOutput& from);
  void MergeFrom(const UpdateSubscriptionLimitsOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.UpdateSubscriptionLimitsOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static UpdateSubscriptionLimitsOutput* default_instance_;
};
// -------------------------------------------------------------------

class GetSubscriptionDetailsForDeviceInput : public ::google::protobuf::Message {
 public:
  GetSubscriptionDetailsForDeviceInput();
  virtual ~GetSubscriptionDetailsForDeviceInput();
  
  GetSubscriptionDetailsForDeviceInput(const GetSubscriptionDetailsForDeviceInput& from);
  
  inline GetSubscriptionDetailsForDeviceInput& operator=(const GetSubscriptionDetailsForDeviceInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSubscriptionDetailsForDeviceInput& default_instance();
  
  void Swap(GetSubscriptionDetailsForDeviceInput* other);
  
  // implements Message ----------------------------------------------
  
  GetSubscriptionDetailsForDeviceInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetSubscriptionDetailsForDeviceInput& from);
  void MergeFrom(const GetSubscriptionDetailsForDeviceInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required fixed64 deviceId = 3;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIdFieldNumber = 3;
  inline ::google::protobuf::uint64 deviceid() const;
  inline void set_deviceid(::google::protobuf::uint64 value);
  
  // optional string version = 4;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 4;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetSubscriptionDetailsForDeviceInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 deviceid_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetSubscriptionDetailsForDeviceInput* default_instance_;
};
// -------------------------------------------------------------------

class GetSubscriptionDetailsForDeviceOutput : public ::google::protobuf::Message {
 public:
  GetSubscriptionDetailsForDeviceOutput();
  virtual ~GetSubscriptionDetailsForDeviceOutput();
  
  GetSubscriptionDetailsForDeviceOutput(const GetSubscriptionDetailsForDeviceOutput& from);
  
  inline GetSubscriptionDetailsForDeviceOutput& operator=(const GetSubscriptionDetailsForDeviceOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSubscriptionDetailsForDeviceOutput& default_instance();
  
  void Swap(GetSubscriptionDetailsForDeviceOutput* other);
  
  // implements Message ----------------------------------------------
  
  GetSubscriptionDetailsForDeviceOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetSubscriptionDetailsForDeviceOutput& from);
  void MergeFrom(const GetSubscriptionDetailsForDeviceOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // repeated .vplex.vsDirectory.Subscription subscriptions = 2;
  inline int subscriptions_size() const;
  inline void clear_subscriptions();
  static const int kSubscriptionsFieldNumber = 2;
  inline const ::vplex::vsDirectory::Subscription& subscriptions(int index) const;
  inline ::vplex::vsDirectory::Subscription* mutable_subscriptions(int index);
  inline ::vplex::vsDirectory::Subscription* add_subscriptions();
  inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::Subscription >&
      subscriptions() const;
  inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::Subscription >*
      mutable_subscriptions();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetSubscriptionDetailsForDeviceOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::Subscription > subscriptions_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetSubscriptionDetailsForDeviceOutput* default_instance_;
};
// -------------------------------------------------------------------

class GetCloudInfoInput : public ::google::protobuf::Message {
 public:
  GetCloudInfoInput();
  virtual ~GetCloudInfoInput();
  
  GetCloudInfoInput(const GetCloudInfoInput& from);
  
  inline GetCloudInfoInput& operator=(const GetCloudInfoInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetCloudInfoInput& default_instance();
  
  void Swap(GetCloudInfoInput* other);
  
  // implements Message ----------------------------------------------
  
  GetCloudInfoInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetCloudInfoInput& from);
  void MergeFrom(const GetCloudInfoInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required fixed64 deviceId = 3;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIdFieldNumber = 3;
  inline ::google::protobuf::uint64 deviceid() const;
  inline void set_deviceid(::google::protobuf::uint64 value);
  
  // optional string version = 4;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 4;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetCloudInfoInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 deviceid_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetCloudInfoInput* default_instance_;
};
// -------------------------------------------------------------------

class GetCloudInfoOutput : public ::google::protobuf::Message {
 public:
  GetCloudInfoOutput();
  virtual ~GetCloudInfoOutput();
  
  GetCloudInfoOutput(const GetCloudInfoOutput& from);
  
  inline GetCloudInfoOutput& operator=(const GetCloudInfoOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetCloudInfoOutput& default_instance();
  
  void Swap(GetCloudInfoOutput* other);
  
  // implements Message ----------------------------------------------
  
  GetCloudInfoOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetCloudInfoOutput& from);
  void MergeFrom(const GetCloudInfoOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // repeated .vplex.vsDirectory.DeviceInfo devices = 2;
  inline int devices_size() const;
  inline void clear_devices();
  static const int kDevicesFieldNumber = 2;
  inline const ::vplex::vsDirectory::DeviceInfo& devices(int index) const;
  inline ::vplex::vsDirectory::DeviceInfo* mutable_devices(int index);
  inline ::vplex::vsDirectory::DeviceInfo* add_devices();
  inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::DeviceInfo >&
      devices() const;
  inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::DeviceInfo >*
      mutable_devices();
  
  // repeated .vplex.vsDirectory.DatasetDetail datasets = 3;
  inline int datasets_size() const;
  inline void clear_datasets();
  static const int kDatasetsFieldNumber = 3;
  inline const ::vplex::vsDirectory::DatasetDetail& datasets(int index) const;
  inline ::vplex::vsDirectory::DatasetDetail* mutable_datasets(int index);
  inline ::vplex::vsDirectory::DatasetDetail* add_datasets();
  inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::DatasetDetail >&
      datasets() const;
  inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::DatasetDetail >*
      mutable_datasets();
  
  // repeated .vplex.vsDirectory.Subscription subscriptions = 4;
  inline int subscriptions_size() const;
  inline void clear_subscriptions();
  static const int kSubscriptionsFieldNumber = 4;
  inline const ::vplex::vsDirectory::Subscription& subscriptions(int index) const;
  inline ::vplex::vsDirectory::Subscription* mutable_subscriptions(int index);
  inline ::vplex::vsDirectory::Subscription* add_subscriptions();
  inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::Subscription >&
      subscriptions() const;
  inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::Subscription >*
      mutable_subscriptions();
  
  // repeated .vplex.vsDirectory.UserStorage storageAssignments = 5;
  inline int storageassignments_size() const;
  inline void clear_storageassignments();
  static const int kStorageAssignmentsFieldNumber = 5;
  inline const ::vplex::vsDirectory::UserStorage& storageassignments(int index) const;
  inline ::vplex::vsDirectory::UserStorage* mutable_storageassignments(int index);
  inline ::vplex::vsDirectory::UserStorage* add_storageassignments();
  inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::UserStorage >&
      storageassignments() const;
  inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::UserStorage >*
      mutable_storageassignments();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetCloudInfoOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::DeviceInfo > devices_;
  ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::DatasetDetail > datasets_;
  ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::Subscription > subscriptions_;
  ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::UserStorage > storageassignments_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetCloudInfoOutput* default_instance_;
};
// -------------------------------------------------------------------

class GetSubscribedDatasetsInput : public ::google::protobuf::Message {
 public:
  GetSubscribedDatasetsInput();
  virtual ~GetSubscribedDatasetsInput();
  
  GetSubscribedDatasetsInput(const GetSubscribedDatasetsInput& from);
  
  inline GetSubscribedDatasetsInput& operator=(const GetSubscribedDatasetsInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSubscribedDatasetsInput& default_instance();
  
  void Swap(GetSubscribedDatasetsInput* other);
  
  // implements Message ----------------------------------------------
  
  GetSubscribedDatasetsInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetSubscribedDatasetsInput& from);
  void MergeFrom(const GetSubscribedDatasetsInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 deviceId = 2;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIdFieldNumber = 2;
  inline ::google::protobuf::uint64 deviceid() const;
  inline void set_deviceid(::google::protobuf::uint64 value);
  
  // required .vplex.vsDirectory.Localization l10n = 3;
  inline bool has_l10n() const;
  inline void clear_l10n();
  static const int kL10NFieldNumber = 3;
  inline const ::vplex::vsDirectory::Localization& l10n() const;
  inline ::vplex::vsDirectory::Localization* mutable_l10n();
  inline ::vplex::vsDirectory::Localization* release_l10n();
  
  // optional string version = 4;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 4;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetSubscribedDatasetsInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_l10n();
  inline void clear_has_l10n();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 deviceid_;
  ::vplex::vsDirectory::Localization* l10n_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetSubscribedDatasetsInput* default_instance_;
};
// -------------------------------------------------------------------

class GetSubscribedDatasetsOutput : public ::google::protobuf::Message {
 public:
  GetSubscribedDatasetsOutput();
  virtual ~GetSubscribedDatasetsOutput();
  
  GetSubscribedDatasetsOutput(const GetSubscribedDatasetsOutput& from);
  
  inline GetSubscribedDatasetsOutput& operator=(const GetSubscribedDatasetsOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSubscribedDatasetsOutput& default_instance();
  
  void Swap(GetSubscribedDatasetsOutput* other);
  
  // implements Message ----------------------------------------------
  
  GetSubscribedDatasetsOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetSubscribedDatasetsOutput& from);
  void MergeFrom(const GetSubscribedDatasetsOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // repeated .vplex.vsDirectory.TitleData titleData = 2;
  inline int titledata_size() const;
  inline void clear_titledata();
  static const int kTitleDataFieldNumber = 2;
  inline const ::vplex::vsDirectory::TitleData& titledata(int index) const;
  inline ::vplex::vsDirectory::TitleData* mutable_titledata(int index);
  inline ::vplex::vsDirectory::TitleData* add_titledata();
  inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::TitleData >&
      titledata() const;
  inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::TitleData >*
      mutable_titledata();
  
  // repeated .vplex.vsDirectory.DatasetData datasetData = 3;
  inline int datasetdata_size() const;
  inline void clear_datasetdata();
  static const int kDatasetDataFieldNumber = 3;
  inline const ::vplex::vsDirectory::DatasetData& datasetdata(int index) const;
  inline ::vplex::vsDirectory::DatasetData* mutable_datasetdata(int index);
  inline ::vplex::vsDirectory::DatasetData* add_datasetdata();
  inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::DatasetData >&
      datasetdata() const;
  inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::DatasetData >*
      mutable_datasetdata();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetSubscribedDatasetsOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::TitleData > titledata_;
  ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::DatasetData > datasetdata_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetSubscribedDatasetsOutput* default_instance_;
};
// -------------------------------------------------------------------

class GetSubscriptionDetailsInput : public ::google::protobuf::Message {
 public:
  GetSubscriptionDetailsInput();
  virtual ~GetSubscriptionDetailsInput();
  
  GetSubscriptionDetailsInput(const GetSubscriptionDetailsInput& from);
  
  inline GetSubscriptionDetailsInput& operator=(const GetSubscriptionDetailsInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSubscriptionDetailsInput& default_instance();
  
  void Swap(GetSubscriptionDetailsInput* other);
  
  // implements Message ----------------------------------------------
  
  GetSubscriptionDetailsInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetSubscriptionDetailsInput& from);
  void MergeFrom(const GetSubscriptionDetailsInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required fixed64 deviceId = 3;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIdFieldNumber = 3;
  inline ::google::protobuf::uint64 deviceid() const;
  inline void set_deviceid(::google::protobuf::uint64 value);
  
  // repeated fixed64 datasetIds = 4;
  inline int datasetids_size() const;
  inline void clear_datasetids();
  static const int kDatasetIdsFieldNumber = 4;
  inline ::google::protobuf::uint64 datasetids(int index) const;
  inline void set_datasetids(int index, ::google::protobuf::uint64 value);
  inline void add_datasetids(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      datasetids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_datasetids();
  
  // optional string version = 5;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 5;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetSubscriptionDetailsInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 deviceid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > datasetids_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetSubscriptionDetailsInput* default_instance_;
};
// -------------------------------------------------------------------

class GetSubscriptionDetailsOutput : public ::google::protobuf::Message {
 public:
  GetSubscriptionDetailsOutput();
  virtual ~GetSubscriptionDetailsOutput();
  
  GetSubscriptionDetailsOutput(const GetSubscriptionDetailsOutput& from);
  
  inline GetSubscriptionDetailsOutput& operator=(const GetSubscriptionDetailsOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSubscriptionDetailsOutput& default_instance();
  
  void Swap(GetSubscriptionDetailsOutput* other);
  
  // implements Message ----------------------------------------------
  
  GetSubscriptionDetailsOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetSubscriptionDetailsOutput& from);
  void MergeFrom(const GetSubscriptionDetailsOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // repeated .vplex.vsDirectory.Subscription subscriptions = 2;
  inline int subscriptions_size() const;
  inline void clear_subscriptions();
  static const int kSubscriptionsFieldNumber = 2;
  inline const ::vplex::vsDirectory::Subscription& subscriptions(int index) const;
  inline ::vplex::vsDirectory::Subscription* mutable_subscriptions(int index);
  inline ::vplex::vsDirectory::Subscription* add_subscriptions();
  inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::Subscription >&
      subscriptions() const;
  inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::Subscription >*
      mutable_subscriptions();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetSubscriptionDetailsOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::Subscription > subscriptions_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetSubscriptionDetailsOutput* default_instance_;
};
// -------------------------------------------------------------------

class LinkDeviceInput : public ::google::protobuf::Message {
 public:
  LinkDeviceInput();
  virtual ~LinkDeviceInput();
  
  LinkDeviceInput(const LinkDeviceInput& from);
  
  inline LinkDeviceInput& operator=(const LinkDeviceInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LinkDeviceInput& default_instance();
  
  void Swap(LinkDeviceInput* other);
  
  // implements Message ----------------------------------------------
  
  LinkDeviceInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LinkDeviceInput& from);
  void MergeFrom(const LinkDeviceInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required fixed64 deviceId = 3;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIdFieldNumber = 3;
  inline ::google::protobuf::uint64 deviceid() const;
  inline void set_deviceid(::google::protobuf::uint64 value);
  
  // required string deviceClass = 4;
  inline bool has_deviceclass() const;
  inline void clear_deviceclass();
  static const int kDeviceClassFieldNumber = 4;
  inline const ::std::string& deviceclass() const;
  inline void set_deviceclass(const ::std::string& value);
  inline void set_deviceclass(const char* value);
  inline void set_deviceclass(const char* value, size_t size);
  inline ::std::string* mutable_deviceclass();
  inline ::std::string* release_deviceclass();
  
  // optional string deviceName = 5;
  inline bool has_devicename() const;
  inline void clear_devicename();
  static const int kDeviceNameFieldNumber = 5;
  inline const ::std::string& devicename() const;
  inline void set_devicename(const ::std::string& value);
  inline void set_devicename(const char* value);
  inline void set_devicename(const char* value, size_t size);
  inline ::std::string* mutable_devicename();
  inline ::std::string* release_devicename();
  
  // optional bool isAcer = 6;
  inline bool has_isacer() const;
  inline void clear_isacer();
  static const int kIsAcerFieldNumber = 6;
  inline bool isacer() const;
  inline void set_isacer(bool value);
  
  // optional bool hasCamera = 7;
  inline bool has_hascamera() const;
  inline void clear_hascamera();
  static const int kHasCameraFieldNumber = 7;
  inline bool hascamera() const;
  inline void set_hascamera(bool value);
  
  // optional string osVersion = 8;
  inline bool has_osversion() const;
  inline void clear_osversion();
  static const int kOsVersionFieldNumber = 8;
  inline const ::std::string& osversion() const;
  inline void set_osversion(const ::std::string& value);
  inline void set_osversion(const char* value);
  inline void set_osversion(const char* value, size_t size);
  inline ::std::string* mutable_osversion();
  inline ::std::string* release_osversion();
  
  // optional string protocolVersion = 9;
  inline bool has_protocolversion() const;
  inline void clear_protocolversion();
  static const int kProtocolVersionFieldNumber = 9;
  inline const ::std::string& protocolversion() const;
  inline void set_protocolversion(const ::std::string& value);
  inline void set_protocolversion(const char* value);
  inline void set_protocolversion(const char* value, size_t size);
  inline ::std::string* mutable_protocolversion();
  inline ::std::string* release_protocolversion();
  
  // optional string version = 10;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 10;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // optional string modelNumber = 11;
  inline bool has_modelnumber() const;
  inline void clear_modelnumber();
  static const int kModelNumberFieldNumber = 11;
  inline const ::std::string& modelnumber() const;
  inline void set_modelnumber(const ::std::string& value);
  inline void set_modelnumber(const char* value);
  inline void set_modelnumber(const char* value, size_t size);
  inline ::std::string* mutable_modelnumber();
  inline ::std::string* release_modelnumber();
  
  // optional string buildInfo = 12;
  inline bool has_buildinfo() const;
  inline void clear_buildinfo();
  static const int kBuildInfoFieldNumber = 12;
  inline const ::std::string& buildinfo() const;
  inline void set_buildinfo(const ::std::string& value);
  inline void set_buildinfo(const char* value);
  inline void set_buildinfo(const char* value, size_t size);
  inline ::std::string* mutable_buildinfo();
  inline ::std::string* release_buildinfo();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.LinkDeviceInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_deviceclass();
  inline void clear_has_deviceclass();
  inline void set_has_devicename();
  inline void clear_has_devicename();
  inline void set_has_isacer();
  inline void clear_has_isacer();
  inline void set_has_hascamera();
  inline void clear_has_hascamera();
  inline void set_has_osversion();
  inline void clear_has_osversion();
  inline void set_has_protocolversion();
  inline void clear_has_protocolversion();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_modelnumber();
  inline void clear_has_modelnumber();
  inline void set_has_buildinfo();
  inline void clear_has_buildinfo();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 deviceid_;
  ::std::string* deviceclass_;
  ::std::string* devicename_;
  ::std::string* osversion_;
  ::std::string* protocolversion_;
  ::std::string* version_;
  ::std::string* modelnumber_;
  ::std::string* buildinfo_;
  bool isacer_;
  bool hascamera_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static LinkDeviceInput* default_instance_;
};
// -------------------------------------------------------------------

class LinkDeviceOutput : public ::google::protobuf::Message {
 public:
  LinkDeviceOutput();
  virtual ~LinkDeviceOutput();
  
  LinkDeviceOutput(const LinkDeviceOutput& from);
  
  inline LinkDeviceOutput& operator=(const LinkDeviceOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LinkDeviceOutput& default_instance();
  
  void Swap(LinkDeviceOutput* other);
  
  // implements Message ----------------------------------------------
  
  LinkDeviceOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LinkDeviceOutput& from);
  void MergeFrom(const LinkDeviceOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.LinkDeviceOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static LinkDeviceOutput* default_instance_;
};
// -------------------------------------------------------------------

class UnlinkDeviceInput : public ::google::protobuf::Message {
 public:
  UnlinkDeviceInput();
  virtual ~UnlinkDeviceInput();
  
  UnlinkDeviceInput(const UnlinkDeviceInput& from);
  
  inline UnlinkDeviceInput& operator=(const UnlinkDeviceInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UnlinkDeviceInput& default_instance();
  
  void Swap(UnlinkDeviceInput* other);
  
  // implements Message ----------------------------------------------
  
  UnlinkDeviceInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UnlinkDeviceInput& from);
  void MergeFrom(const UnlinkDeviceInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required fixed64 deviceId = 3;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIdFieldNumber = 3;
  inline ::google::protobuf::uint64 deviceid() const;
  inline void set_deviceid(::google::protobuf::uint64 value);
  
  // optional string version = 4;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 4;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.UnlinkDeviceInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 deviceid_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static UnlinkDeviceInput* default_instance_;
};
// -------------------------------------------------------------------

class UnlinkDeviceOutput : public ::google::protobuf::Message {
 public:
  UnlinkDeviceOutput();
  virtual ~UnlinkDeviceOutput();
  
  UnlinkDeviceOutput(const UnlinkDeviceOutput& from);
  
  inline UnlinkDeviceOutput& operator=(const UnlinkDeviceOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UnlinkDeviceOutput& default_instance();
  
  void Swap(UnlinkDeviceOutput* other);
  
  // implements Message ----------------------------------------------
  
  UnlinkDeviceOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UnlinkDeviceOutput& from);
  void MergeFrom(const UnlinkDeviceOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.UnlinkDeviceOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static UnlinkDeviceOutput* default_instance_;
};
// -------------------------------------------------------------------

class SetDeviceNameInput : public ::google::protobuf::Message {
 public:
  SetDeviceNameInput();
  virtual ~SetDeviceNameInput();
  
  SetDeviceNameInput(const SetDeviceNameInput& from);
  
  inline SetDeviceNameInput& operator=(const SetDeviceNameInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SetDeviceNameInput& default_instance();
  
  void Swap(SetDeviceNameInput* other);
  
  // implements Message ----------------------------------------------
  
  SetDeviceNameInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetDeviceNameInput& from);
  void MergeFrom(const SetDeviceNameInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required fixed64 deviceId = 3;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIdFieldNumber = 3;
  inline ::google::protobuf::uint64 deviceid() const;
  inline void set_deviceid(::google::protobuf::uint64 value);
  
  // required string deviceName = 4;
  inline bool has_devicename() const;
  inline void clear_devicename();
  static const int kDeviceNameFieldNumber = 4;
  inline const ::std::string& devicename() const;
  inline void set_devicename(const ::std::string& value);
  inline void set_devicename(const char* value);
  inline void set_devicename(const char* value, size_t size);
  inline ::std::string* mutable_devicename();
  inline ::std::string* release_devicename();
  
  // optional string version = 5;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 5;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.SetDeviceNameInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_devicename();
  inline void clear_has_devicename();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 deviceid_;
  ::std::string* devicename_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static SetDeviceNameInput* default_instance_;
};
// -------------------------------------------------------------------

class SetDeviceNameOutput : public ::google::protobuf::Message {
 public:
  SetDeviceNameOutput();
  virtual ~SetDeviceNameOutput();
  
  SetDeviceNameOutput(const SetDeviceNameOutput& from);
  
  inline SetDeviceNameOutput& operator=(const SetDeviceNameOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SetDeviceNameOutput& default_instance();
  
  void Swap(SetDeviceNameOutput* other);
  
  // implements Message ----------------------------------------------
  
  SetDeviceNameOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetDeviceNameOutput& from);
  void MergeFrom(const SetDeviceNameOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.SetDeviceNameOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static SetDeviceNameOutput* default_instance_;
};
// -------------------------------------------------------------------

class UpdateDeviceInfoInput : public ::google::protobuf::Message {
 public:
  UpdateDeviceInfoInput();
  virtual ~UpdateDeviceInfoInput();
  
  UpdateDeviceInfoInput(const UpdateDeviceInfoInput& from);
  
  inline UpdateDeviceInfoInput& operator=(const UpdateDeviceInfoInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateDeviceInfoInput& default_instance();
  
  void Swap(UpdateDeviceInfoInput* other);
  
  // implements Message ----------------------------------------------
  
  UpdateDeviceInfoInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateDeviceInfoInput& from);
  void MergeFrom(const UpdateDeviceInfoInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required fixed64 deviceId = 3;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIdFieldNumber = 3;
  inline ::google::protobuf::uint64 deviceid() const;
  inline void set_deviceid(::google::protobuf::uint64 value);
  
  // optional string deviceName = 4;
  inline bool has_devicename() const;
  inline void clear_devicename();
  static const int kDeviceNameFieldNumber = 4;
  inline const ::std::string& devicename() const;
  inline void set_devicename(const ::std::string& value);
  inline void set_devicename(const char* value);
  inline void set_devicename(const char* value, size_t size);
  inline ::std::string* mutable_devicename();
  inline ::std::string* release_devicename();
  
  // optional string osVersion = 5;
  inline bool has_osversion() const;
  inline void clear_osversion();
  static const int kOsVersionFieldNumber = 5;
  inline const ::std::string& osversion() const;
  inline void set_osversion(const ::std::string& value);
  inline void set_osversion(const char* value);
  inline void set_osversion(const char* value, size_t size);
  inline ::std::string* mutable_osversion();
  inline ::std::string* release_osversion();
  
  // optional string protocolVersion = 6;
  inline bool has_protocolversion() const;
  inline void clear_protocolversion();
  static const int kProtocolVersionFieldNumber = 6;
  inline const ::std::string& protocolversion() const;
  inline void set_protocolversion(const ::std::string& value);
  inline void set_protocolversion(const char* value);
  inline void set_protocolversion(const char* value, size_t size);
  inline ::std::string* mutable_protocolversion();
  inline ::std::string* release_protocolversion();
  
  // optional string version = 7;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 7;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // optional string modelNumber = 8;
  inline bool has_modelnumber() const;
  inline void clear_modelnumber();
  static const int kModelNumberFieldNumber = 8;
  inline const ::std::string& modelnumber() const;
  inline void set_modelnumber(const ::std::string& value);
  inline void set_modelnumber(const char* value);
  inline void set_modelnumber(const char* value, size_t size);
  inline ::std::string* mutable_modelnumber();
  inline ::std::string* release_modelnumber();
  
  // optional string buildInfo = 9;
  inline bool has_buildinfo() const;
  inline void clear_buildinfo();
  static const int kBuildInfoFieldNumber = 9;
  inline const ::std::string& buildinfo() const;
  inline void set_buildinfo(const ::std::string& value);
  inline void set_buildinfo(const char* value);
  inline void set_buildinfo(const char* value, size_t size);
  inline ::std::string* mutable_buildinfo();
  inline ::std::string* release_buildinfo();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.UpdateDeviceInfoInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_devicename();
  inline void clear_has_devicename();
  inline void set_has_osversion();
  inline void clear_has_osversion();
  inline void set_has_protocolversion();
  inline void clear_has_protocolversion();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_modelnumber();
  inline void clear_has_modelnumber();
  inline void set_has_buildinfo();
  inline void clear_has_buildinfo();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 deviceid_;
  ::std::string* devicename_;
  ::std::string* osversion_;
  ::std::string* protocolversion_;
  ::std::string* version_;
  ::std::string* modelnumber_;
  ::std::string* buildinfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static UpdateDeviceInfoInput* default_instance_;
};
// -------------------------------------------------------------------

class UpdateDeviceInfoOutput : public ::google::protobuf::Message {
 public:
  UpdateDeviceInfoOutput();
  virtual ~UpdateDeviceInfoOutput();
  
  UpdateDeviceInfoOutput(const UpdateDeviceInfoOutput& from);
  
  inline UpdateDeviceInfoOutput& operator=(const UpdateDeviceInfoOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateDeviceInfoOutput& default_instance();
  
  void Swap(UpdateDeviceInfoOutput* other);
  
  // implements Message ----------------------------------------------
  
  UpdateDeviceInfoOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateDeviceInfoOutput& from);
  void MergeFrom(const UpdateDeviceInfoOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.UpdateDeviceInfoOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static UpdateDeviceInfoOutput* default_instance_;
};
// -------------------------------------------------------------------

class GetDeviceLinkStateInput : public ::google::protobuf::Message {
 public:
  GetDeviceLinkStateInput();
  virtual ~GetDeviceLinkStateInput();
  
  GetDeviceLinkStateInput(const GetDeviceLinkStateInput& from);
  
  inline GetDeviceLinkStateInput& operator=(const GetDeviceLinkStateInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetDeviceLinkStateInput& default_instance();
  
  void Swap(GetDeviceLinkStateInput* other);
  
  // implements Message ----------------------------------------------
  
  GetDeviceLinkStateInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetDeviceLinkStateInput& from);
  void MergeFrom(const GetDeviceLinkStateInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required fixed64 deviceId = 3;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIdFieldNumber = 3;
  inline ::google::protobuf::uint64 deviceid() const;
  inline void set_deviceid(::google::protobuf::uint64 value);
  
  // optional string version = 4;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 4;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetDeviceLinkStateInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 deviceid_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetDeviceLinkStateInput* default_instance_;
};
// -------------------------------------------------------------------

class GetDeviceLinkStateOutput : public ::google::protobuf::Message {
 public:
  GetDeviceLinkStateOutput();
  virtual ~GetDeviceLinkStateOutput();
  
  GetDeviceLinkStateOutput(const GetDeviceLinkStateOutput& from);
  
  inline GetDeviceLinkStateOutput& operator=(const GetDeviceLinkStateOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetDeviceLinkStateOutput& default_instance();
  
  void Swap(GetDeviceLinkStateOutput* other);
  
  // implements Message ----------------------------------------------
  
  GetDeviceLinkStateOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetDeviceLinkStateOutput& from);
  void MergeFrom(const GetDeviceLinkStateOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // required bool linked = 2;
  inline bool has_linked() const;
  inline void clear_linked();
  static const int kLinkedFieldNumber = 2;
  inline bool linked() const;
  inline void set_linked(bool value);
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetDeviceLinkStateOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_linked();
  inline void clear_has_linked();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  bool linked_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetDeviceLinkStateOutput* default_instance_;
};
// -------------------------------------------------------------------

class GetDeviceNameInput : public ::google::protobuf::Message {
 public:
  GetDeviceNameInput();
  virtual ~GetDeviceNameInput();
  
  GetDeviceNameInput(const GetDeviceNameInput& from);
  
  inline GetDeviceNameInput& operator=(const GetDeviceNameInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetDeviceNameInput& default_instance();
  
  void Swap(GetDeviceNameInput* other);
  
  // implements Message ----------------------------------------------
  
  GetDeviceNameInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetDeviceNameInput& from);
  void MergeFrom(const GetDeviceNameInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required fixed64 deviceId = 3;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIdFieldNumber = 3;
  inline ::google::protobuf::uint64 deviceid() const;
  inline void set_deviceid(::google::protobuf::uint64 value);
  
  // optional string version = 4;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 4;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetDeviceNameInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 deviceid_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetDeviceNameInput* default_instance_;
};
// -------------------------------------------------------------------

class GetDeviceNameOutput : public ::google::protobuf::Message {
 public:
  GetDeviceNameOutput();
  virtual ~GetDeviceNameOutput();
  
  GetDeviceNameOutput(const GetDeviceNameOutput& from);
  
  inline GetDeviceNameOutput& operator=(const GetDeviceNameOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetDeviceNameOutput& default_instance();
  
  void Swap(GetDeviceNameOutput* other);
  
  // implements Message ----------------------------------------------
  
  GetDeviceNameOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetDeviceNameOutput& from);
  void MergeFrom(const GetDeviceNameOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // optional string deviceName = 2;
  inline bool has_devicename() const;
  inline void clear_devicename();
  static const int kDeviceNameFieldNumber = 2;
  inline const ::std::string& devicename() const;
  inline void set_devicename(const ::std::string& value);
  inline void set_devicename(const char* value);
  inline void set_devicename(const char* value, size_t size);
  inline ::std::string* mutable_devicename();
  inline ::std::string* release_devicename();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetDeviceNameOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_devicename();
  inline void clear_has_devicename();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  ::std::string* devicename_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetDeviceNameOutput* default_instance_;
};
// -------------------------------------------------------------------

class GetLinkedDevicesInput : public ::google::protobuf::Message {
 public:
  GetLinkedDevicesInput();
  virtual ~GetLinkedDevicesInput();
  
  GetLinkedDevicesInput(const GetLinkedDevicesInput& from);
  
  inline GetLinkedDevicesInput& operator=(const GetLinkedDevicesInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetLinkedDevicesInput& default_instance();
  
  void Swap(GetLinkedDevicesInput* other);
  
  // implements Message ----------------------------------------------
  
  GetLinkedDevicesInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetLinkedDevicesInput& from);
  void MergeFrom(const GetLinkedDevicesInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // optional string version = 3;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 3;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetLinkedDevicesInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 userid_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetLinkedDevicesInput* default_instance_;
};
// -------------------------------------------------------------------

class GetLinkedDevicesOutput : public ::google::protobuf::Message {
 public:
  GetLinkedDevicesOutput();
  virtual ~GetLinkedDevicesOutput();
  
  GetLinkedDevicesOutput(const GetLinkedDevicesOutput& from);
  
  inline GetLinkedDevicesOutput& operator=(const GetLinkedDevicesOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetLinkedDevicesOutput& default_instance();
  
  void Swap(GetLinkedDevicesOutput* other);
  
  // implements Message ----------------------------------------------
  
  GetLinkedDevicesOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetLinkedDevicesOutput& from);
  void MergeFrom(const GetLinkedDevicesOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // repeated .vplex.vsDirectory.DeviceInfo devices = 2;
  inline int devices_size() const;
  inline void clear_devices();
  static const int kDevicesFieldNumber = 2;
  inline const ::vplex::vsDirectory::DeviceInfo& devices(int index) const;
  inline ::vplex::vsDirectory::DeviceInfo* mutable_devices(int index);
  inline ::vplex::vsDirectory::DeviceInfo* add_devices();
  inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::DeviceInfo >&
      devices() const;
  inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::DeviceInfo >*
      mutable_devices();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetLinkedDevicesOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::DeviceInfo > devices_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetLinkedDevicesOutput* default_instance_;
};
// -------------------------------------------------------------------

class GetLoginSessionInput : public ::google::protobuf::Message {
 public:
  GetLoginSessionInput();
  virtual ~GetLoginSessionInput();
  
  GetLoginSessionInput(const GetLoginSessionInput& from);
  
  inline GetLoginSessionInput& operator=(const GetLoginSessionInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetLoginSessionInput& default_instance();
  
  void Swap(GetLoginSessionInput* other);
  
  // implements Message ----------------------------------------------
  
  GetLoginSessionInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetLoginSessionInput& from);
  void MergeFrom(const GetLoginSessionInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // optional fixed64 deviceId = 3;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIdFieldNumber = 3;
  inline ::google::protobuf::uint64 deviceid() const;
  inline void set_deviceid(::google::protobuf::uint64 value);
  
  // required fixed64 sessionHandle = 4;
  inline bool has_sessionhandle() const;
  inline void clear_sessionhandle();
  static const int kSessionHandleFieldNumber = 4;
  inline ::google::protobuf::uint64 sessionhandle() const;
  inline void set_sessionhandle(::google::protobuf::uint64 value);
  
  // optional string version = 5;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 5;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetLoginSessionInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_sessionhandle();
  inline void clear_has_sessionhandle();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 deviceid_;
  ::google::protobuf::uint64 sessionhandle_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetLoginSessionInput* default_instance_;
};
// -------------------------------------------------------------------

class GetLoginSessionOutput : public ::google::protobuf::Message {
 public:
  GetLoginSessionOutput();
  virtual ~GetLoginSessionOutput();
  
  GetLoginSessionOutput(const GetLoginSessionOutput& from);
  
  inline GetLoginSessionOutput& operator=(const GetLoginSessionOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetLoginSessionOutput& default_instance();
  
  void Swap(GetLoginSessionOutput* other);
  
  // implements Message ----------------------------------------------
  
  GetLoginSessionOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetLoginSessionOutput& from);
  void MergeFrom(const GetLoginSessionOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // optional fixed64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // optional bytes serviceTicket = 3;
  inline bool has_serviceticket() const;
  inline void clear_serviceticket();
  static const int kServiceTicketFieldNumber = 3;
  inline const ::std::string& serviceticket() const;
  inline void set_serviceticket(const ::std::string& value);
  inline void set_serviceticket(const char* value);
  inline void set_serviceticket(const void* value, size_t size);
  inline ::std::string* mutable_serviceticket();
  inline ::std::string* release_serviceticket();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetLoginSessionOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_serviceticket();
  inline void clear_has_serviceticket();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  ::google::protobuf::uint64 userid_;
  ::std::string* serviceticket_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetLoginSessionOutput* default_instance_;
};
// -------------------------------------------------------------------

class CreatePersonalStorageNodeInput : public ::google::protobuf::Message {
 public:
  CreatePersonalStorageNodeInput();
  virtual ~CreatePersonalStorageNodeInput();
  
  CreatePersonalStorageNodeInput(const CreatePersonalStorageNodeInput& from);
  
  inline CreatePersonalStorageNodeInput& operator=(const CreatePersonalStorageNodeInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreatePersonalStorageNodeInput& default_instance();
  
  void Swap(CreatePersonalStorageNodeInput* other);
  
  // implements Message ----------------------------------------------
  
  CreatePersonalStorageNodeInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreatePersonalStorageNodeInput& from);
  void MergeFrom(const CreatePersonalStorageNodeInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required fixed64 clusterId = 3;
  inline bool has_clusterid() const;
  inline void clear_clusterid();
  static const int kClusterIdFieldNumber = 3;
  inline ::google::protobuf::uint64 clusterid() const;
  inline void set_clusterid(::google::protobuf::uint64 value);
  
  // required string clusterName = 4;
  inline bool has_clustername() const;
  inline void clear_clustername();
  static const int kClusterNameFieldNumber = 4;
  inline const ::std::string& clustername() const;
  inline void set_clustername(const ::std::string& value);
  inline void set_clustername(const char* value);
  inline void set_clustername(const char* value, size_t size);
  inline ::std::string* mutable_clustername();
  inline ::std::string* release_clustername();
  
  // optional bool virtDriveCapable = 5;
  inline bool has_virtdrivecapable() const;
  inline void clear_virtdrivecapable();
  static const int kVirtDriveCapableFieldNumber = 5;
  inline bool virtdrivecapable() const;
  inline void set_virtdrivecapable(bool value);
  
  // optional bool mediaServerCapable = 6;
  inline bool has_mediaservercapable() const;
  inline void clear_mediaservercapable();
  static const int kMediaServerCapableFieldNumber = 6;
  inline bool mediaservercapable() const;
  inline void set_mediaservercapable(bool value);
  
  // optional bool featureMediaServerCapable = 7;
  inline bool has_featuremediaservercapable() const;
  inline void clear_featuremediaservercapable();
  static const int kFeatureMediaServerCapableFieldNumber = 7;
  inline bool featuremediaservercapable() const;
  inline void set_featuremediaservercapable(bool value);
  
  // optional bool featureVirtDriveCapable = 8;
  inline bool has_featurevirtdrivecapable() const;
  inline void clear_featurevirtdrivecapable();
  static const int kFeatureVirtDriveCapableFieldNumber = 8;
  inline bool featurevirtdrivecapable() const;
  inline void set_featurevirtdrivecapable(bool value);
  
  // optional bool featureRemoteFileAccessCapable = 9;
  inline bool has_featureremotefileaccesscapable() const;
  inline void clear_featureremotefileaccesscapable();
  static const int kFeatureRemoteFileAccessCapableFieldNumber = 9;
  inline bool featureremotefileaccesscapable() const;
  inline void set_featureremotefileaccesscapable(bool value);
  
  // optional bool featureFSDatasetTypeCapable = 10;
  inline bool has_featurefsdatasettypecapable() const;
  inline void clear_featurefsdatasettypecapable();
  static const int kFeatureFSDatasetTypeCapableFieldNumber = 10;
  inline bool featurefsdatasettypecapable() const;
  inline void set_featurefsdatasettypecapable(bool value);
  
  // optional string version = 11;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 11;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // optional bool featureVirtSyncCapable = 12;
  inline bool has_featurevirtsynccapable() const;
  inline void clear_featurevirtsynccapable();
  static const int kFeatureVirtSyncCapableFieldNumber = 12;
  inline bool featurevirtsynccapable() const;
  inline void set_featurevirtsynccapable(bool value);
  
  // optional bool featureMyStorageServerCapable = 13;
  inline bool has_featuremystorageservercapable() const;
  inline void clear_featuremystorageservercapable();
  static const int kFeatureMyStorageServerCapableFieldNumber = 13;
  inline bool featuremystorageservercapable() const;
  inline void set_featuremystorageservercapable(bool value);
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.CreatePersonalStorageNodeInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_clusterid();
  inline void clear_has_clusterid();
  inline void set_has_clustername();
  inline void clear_has_clustername();
  inline void set_has_virtdrivecapable();
  inline void clear_has_virtdrivecapable();
  inline void set_has_mediaservercapable();
  inline void clear_has_mediaservercapable();
  inline void set_has_featuremediaservercapable();
  inline void clear_has_featuremediaservercapable();
  inline void set_has_featurevirtdrivecapable();
  inline void clear_has_featurevirtdrivecapable();
  inline void set_has_featureremotefileaccesscapable();
  inline void clear_has_featureremotefileaccesscapable();
  inline void set_has_featurefsdatasettypecapable();
  inline void clear_has_featurefsdatasettypecapable();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_featurevirtsynccapable();
  inline void clear_has_featurevirtsynccapable();
  inline void set_has_featuremystorageservercapable();
  inline void clear_has_featuremystorageservercapable();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 clusterid_;
  ::std::string* clustername_;
  bool virtdrivecapable_;
  bool mediaservercapable_;
  bool featuremediaservercapable_;
  bool featurevirtdrivecapable_;
  bool featureremotefileaccesscapable_;
  bool featurefsdatasettypecapable_;
  bool featurevirtsynccapable_;
  bool featuremystorageservercapable_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static CreatePersonalStorageNodeInput* default_instance_;
};
// -------------------------------------------------------------------

class CreatePersonalStorageNodeOutput : public ::google::protobuf::Message {
 public:
  CreatePersonalStorageNodeOutput();
  virtual ~CreatePersonalStorageNodeOutput();
  
  CreatePersonalStorageNodeOutput(const CreatePersonalStorageNodeOutput& from);
  
  inline CreatePersonalStorageNodeOutput& operator=(const CreatePersonalStorageNodeOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreatePersonalStorageNodeOutput& default_instance();
  
  void Swap(CreatePersonalStorageNodeOutput* other);
  
  // implements Message ----------------------------------------------
  
  CreatePersonalStorageNodeOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreatePersonalStorageNodeOutput& from);
  void MergeFrom(const CreatePersonalStorageNodeOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.CreatePersonalStorageNodeOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static CreatePersonalStorageNodeOutput* default_instance_;
};
// -------------------------------------------------------------------

class GetAsyncNoticeServerInput : public ::google::protobuf::Message {
 public:
  GetAsyncNoticeServerInput();
  virtual ~GetAsyncNoticeServerInput();
  
  GetAsyncNoticeServerInput(const GetAsyncNoticeServerInput& from);
  
  inline GetAsyncNoticeServerInput& operator=(const GetAsyncNoticeServerInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAsyncNoticeServerInput& default_instance();
  
  void Swap(GetAsyncNoticeServerInput* other);
  
  // implements Message ----------------------------------------------
  
  GetAsyncNoticeServerInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetAsyncNoticeServerInput& from);
  void MergeFrom(const GetAsyncNoticeServerInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required fixed64 clusterId = 3;
  inline bool has_clusterid() const;
  inline void clear_clusterid();
  static const int kClusterIdFieldNumber = 3;
  inline ::google::protobuf::uint64 clusterid() const;
  inline void set_clusterid(::google::protobuf::uint64 value);
  
  // optional string version = 4;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 4;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetAsyncNoticeServerInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_clusterid();
  inline void clear_has_clusterid();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 clusterid_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetAsyncNoticeServerInput* default_instance_;
};
// -------------------------------------------------------------------

class GetAsyncNoticeServerOutput : public ::google::protobuf::Message {
 public:
  GetAsyncNoticeServerOutput();
  virtual ~GetAsyncNoticeServerOutput();
  
  GetAsyncNoticeServerOutput(const GetAsyncNoticeServerOutput& from);
  
  inline GetAsyncNoticeServerOutput& operator=(const GetAsyncNoticeServerOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAsyncNoticeServerOutput& default_instance();
  
  void Swap(GetAsyncNoticeServerOutput* other);
  
  // implements Message ----------------------------------------------
  
  GetAsyncNoticeServerOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetAsyncNoticeServerOutput& from);
  void MergeFrom(const GetAsyncNoticeServerOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // optional string address = 2;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 2;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  
  // optional int32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);
  
  // optional fixed64 clusterId = 4;
  inline bool has_clusterid() const;
  inline void clear_clusterid();
  static const int kClusterIdFieldNumber = 4;
  inline ::google::protobuf::uint64 clusterid() const;
  inline void set_clusterid(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetAsyncNoticeServerOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_clusterid();
  inline void clear_has_clusterid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  ::std::string* address_;
  ::google::protobuf::uint64 clusterid_;
  ::google::protobuf::int32 port_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetAsyncNoticeServerOutput* default_instance_;
};
// -------------------------------------------------------------------

class UpdateStorageNodeConnectionInput : public ::google::protobuf::Message {
 public:
  UpdateStorageNodeConnectionInput();
  virtual ~UpdateStorageNodeConnectionInput();
  
  UpdateStorageNodeConnectionInput(const UpdateStorageNodeConnectionInput& from);
  
  inline UpdateStorageNodeConnectionInput& operator=(const UpdateStorageNodeConnectionInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateStorageNodeConnectionInput& default_instance();
  
  void Swap(UpdateStorageNodeConnectionInput* other);
  
  // implements Message ----------------------------------------------
  
  UpdateStorageNodeConnectionInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateStorageNodeConnectionInput& from);
  void MergeFrom(const UpdateStorageNodeConnectionInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required fixed64 clusterId = 3;
  inline bool has_clusterid() const;
  inline void clear_clusterid();
  static const int kClusterIdFieldNumber = 3;
  inline ::google::protobuf::uint64 clusterid() const;
  inline void set_clusterid(::google::protobuf::uint64 value);
  
  // required string reportedName = 4;
  inline bool has_reportedname() const;
  inline void clear_reportedname();
  static const int kReportedNameFieldNumber = 4;
  inline const ::std::string& reportedname() const;
  inline void set_reportedname(const ::std::string& value);
  inline void set_reportedname(const char* value);
  inline void set_reportedname(const char* value, size_t size);
  inline ::std::string* mutable_reportedname();
  inline ::std::string* release_reportedname();
  
  // required int32 reportedPort = 5;
  inline bool has_reportedport() const;
  inline void clear_reportedport();
  static const int kReportedPortFieldNumber = 5;
  inline ::google::protobuf::int32 reportedport() const;
  inline void set_reportedport(::google::protobuf::int32 value);
  
  // required int32 reportedHTTPPort = 6;
  inline bool has_reportedhttpport() const;
  inline void clear_reportedhttpport();
  static const int kReportedHTTPPortFieldNumber = 6;
  inline ::google::protobuf::int32 reportedhttpport() const;
  inline void set_reportedhttpport(::google::protobuf::int32 value);
  
  // optional fixed64 proxyClusterId = 7;
  inline bool has_proxyclusterid() const;
  inline void clear_proxyclusterid();
  static const int kProxyClusterIdFieldNumber = 7;
  inline ::google::protobuf::uint64 proxyclusterid() const;
  inline void set_proxyclusterid(::google::protobuf::uint64 value);
  
  // optional int32 proxyConnectionCookie = 8;
  inline bool has_proxyconnectioncookie() const;
  inline void clear_proxyconnectioncookie();
  static const int kProxyConnectionCookieFieldNumber = 8;
  inline ::google::protobuf::int32 proxyconnectioncookie() const;
  inline void set_proxyconnectioncookie(::google::protobuf::int32 value);
  
  // optional int32 reportedClearFiPort = 9;
  inline bool has_reportedclearfiport() const;
  inline void clear_reportedclearfiport();
  static const int kReportedClearFiPortFieldNumber = 9;
  inline ::google::protobuf::int32 reportedclearfiport() const;
  inline void set_reportedclearfiport(::google::protobuf::int32 value);
  
  // optional int32 reportedClearFiSecurePort = 10;
  inline bool has_reportedclearfisecureport() const;
  inline void clear_reportedclearfisecureport();
  static const int kReportedClearFiSecurePortFieldNumber = 10;
  inline ::google::protobuf::int32 reportedclearfisecureport() const;
  inline void set_reportedclearfisecureport(::google::protobuf::int32 value);
  
  // optional fixed64 accessHandle = 11;
  inline bool has_accesshandle() const;
  inline void clear_accesshandle();
  static const int kAccessHandleFieldNumber = 11;
  inline ::google::protobuf::uint64 accesshandle() const;
  inline void set_accesshandle(::google::protobuf::uint64 value);
  
  // optional bytes accessTicket = 12;
  inline bool has_accessticket() const;
  inline void clear_accessticket();
  static const int kAccessTicketFieldNumber = 12;
  inline const ::std::string& accessticket() const;
  inline void set_accessticket(const ::std::string& value);
  inline void set_accessticket(const char* value);
  inline void set_accessticket(const void* value, size_t size);
  inline ::std::string* mutable_accessticket();
  inline ::std::string* release_accessticket();
  
  // repeated .vplex.vsDirectory.DeviceAccessTicket accessTickets = 13;
  inline int accesstickets_size() const;
  inline void clear_accesstickets();
  static const int kAccessTicketsFieldNumber = 13;
  inline const ::vplex::vsDirectory::DeviceAccessTicket& accesstickets(int index) const;
  inline ::vplex::vsDirectory::DeviceAccessTicket* mutable_accesstickets(int index);
  inline ::vplex::vsDirectory::DeviceAccessTicket* add_accesstickets();
  inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::DeviceAccessTicket >&
      accesstickets() const;
  inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::DeviceAccessTicket >*
      mutable_accesstickets();
  
  // optional string version = 14;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 14;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.UpdateStorageNodeConnectionInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_clusterid();
  inline void clear_has_clusterid();
  inline void set_has_reportedname();
  inline void clear_has_reportedname();
  inline void set_has_reportedport();
  inline void clear_has_reportedport();
  inline void set_has_reportedhttpport();
  inline void clear_has_reportedhttpport();
  inline void set_has_proxyclusterid();
  inline void clear_has_proxyclusterid();
  inline void set_has_proxyconnectioncookie();
  inline void clear_has_proxyconnectioncookie();
  inline void set_has_reportedclearfiport();
  inline void clear_has_reportedclearfiport();
  inline void set_has_reportedclearfisecureport();
  inline void clear_has_reportedclearfisecureport();
  inline void set_has_accesshandle();
  inline void clear_has_accesshandle();
  inline void set_has_accessticket();
  inline void clear_has_accessticket();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 clusterid_;
  ::std::string* reportedname_;
  ::google::protobuf::int32 reportedport_;
  ::google::protobuf::int32 reportedhttpport_;
  ::google::protobuf::uint64 proxyclusterid_;
  ::google::protobuf::int32 proxyconnectioncookie_;
  ::google::protobuf::int32 reportedclearfiport_;
  ::google::protobuf::uint64 accesshandle_;
  ::std::string* accessticket_;
  ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::DeviceAccessTicket > accesstickets_;
  ::std::string* version_;
  ::google::protobuf::int32 reportedclearfisecureport_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static UpdateStorageNodeConnectionInput* default_instance_;
};
// -------------------------------------------------------------------

class UpdateStorageNodeConnectionOutput : public ::google::protobuf::Message {
 public:
  UpdateStorageNodeConnectionOutput();
  virtual ~UpdateStorageNodeConnectionOutput();
  
  UpdateStorageNodeConnectionOutput(const UpdateStorageNodeConnectionOutput& from);
  
  inline UpdateStorageNodeConnectionOutput& operator=(const UpdateStorageNodeConnectionOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateStorageNodeConnectionOutput& default_instance();
  
  void Swap(UpdateStorageNodeConnectionOutput* other);
  
  // implements Message ----------------------------------------------
  
  UpdateStorageNodeConnectionOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateStorageNodeConnectionOutput& from);
  void MergeFrom(const UpdateStorageNodeConnectionOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.UpdateStorageNodeConnectionOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static UpdateStorageNodeConnectionOutput* default_instance_;
};
// -------------------------------------------------------------------

class UpdateStorageNodeFeaturesInput : public ::google::protobuf::Message {
 public:
  UpdateStorageNodeFeaturesInput();
  virtual ~UpdateStorageNodeFeaturesInput();
  
  UpdateStorageNodeFeaturesInput(const UpdateStorageNodeFeaturesInput& from);
  
  inline UpdateStorageNodeFeaturesInput& operator=(const UpdateStorageNodeFeaturesInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateStorageNodeFeaturesInput& default_instance();
  
  void Swap(UpdateStorageNodeFeaturesInput* other);
  
  // implements Message ----------------------------------------------
  
  UpdateStorageNodeFeaturesInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateStorageNodeFeaturesInput& from);
  void MergeFrom(const UpdateStorageNodeFeaturesInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required fixed64 clusterId = 3;
  inline bool has_clusterid() const;
  inline void clear_clusterid();
  static const int kClusterIdFieldNumber = 3;
  inline ::google::protobuf::uint64 clusterid() const;
  inline void set_clusterid(::google::protobuf::uint64 value);
  
  // optional bool isVirtDrive = 4;
  inline bool has_isvirtdrive() const;
  inline void clear_isvirtdrive();
  static const int kIsVirtDriveFieldNumber = 4;
  inline bool isvirtdrive() const;
  inline void set_isvirtdrive(bool value);
  
  // optional bool isMediaServer = 5;
  inline bool has_ismediaserver() const;
  inline void clear_ismediaserver();
  static const int kIsMediaServerFieldNumber = 5;
  inline bool ismediaserver() const;
  inline void set_ismediaserver(bool value);
  
  // optional bool featureMediaServerEnabled = 6;
  inline bool has_featuremediaserverenabled() const;
  inline void clear_featuremediaserverenabled();
  static const int kFeatureMediaServerEnabledFieldNumber = 6;
  inline bool featuremediaserverenabled() const;
  inline void set_featuremediaserverenabled(bool value);
  
  // optional bool featureVirtDriveEnabled = 7;
  inline bool has_featurevirtdriveenabled() const;
  inline void clear_featurevirtdriveenabled();
  static const int kFeatureVirtDriveEnabledFieldNumber = 7;
  inline bool featurevirtdriveenabled() const;
  inline void set_featurevirtdriveenabled(bool value);
  
  // optional bool featureRemoteFileAccessEnabled = 8;
  inline bool has_featureremotefileaccessenabled() const;
  inline void clear_featureremotefileaccessenabled();
  static const int kFeatureRemoteFileAccessEnabledFieldNumber = 8;
  inline bool featureremotefileaccessenabled() const;
  inline void set_featureremotefileaccessenabled(bool value);
  
  // optional bool featureFSDatasetTypeEnabled = 9;
  inline bool has_featurefsdatasettypeenabled() const;
  inline void clear_featurefsdatasettypeenabled();
  static const int kFeatureFSDatasetTypeEnabledFieldNumber = 9;
  inline bool featurefsdatasettypeenabled() const;
  inline void set_featurefsdatasettypeenabled(bool value);
  
  // optional string version = 10;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 10;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // optional bool featureVirtSyncEnabled = 11;
  inline bool has_featurevirtsyncenabled() const;
  inline void clear_featurevirtsyncenabled();
  static const int kFeatureVirtSyncEnabledFieldNumber = 11;
  inline bool featurevirtsyncenabled() const;
  inline void set_featurevirtsyncenabled(bool value);
  
  // optional bool featureMyStorageServerEnabled = 12;
  inline bool has_featuremystorageserverenabled() const;
  inline void clear_featuremystorageserverenabled();
  static const int kFeatureMyStorageServerEnabledFieldNumber = 12;
  inline bool featuremystorageserverenabled() const;
  inline void set_featuremystorageserverenabled(bool value);
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.UpdateStorageNodeFeaturesInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_clusterid();
  inline void clear_has_clusterid();
  inline void set_has_isvirtdrive();
  inline void clear_has_isvirtdrive();
  inline void set_has_ismediaserver();
  inline void clear_has_ismediaserver();
  inline void set_has_featuremediaserverenabled();
  inline void clear_has_featuremediaserverenabled();
  inline void set_has_featurevirtdriveenabled();
  inline void clear_has_featurevirtdriveenabled();
  inline void set_has_featureremotefileaccessenabled();
  inline void clear_has_featureremotefileaccessenabled();
  inline void set_has_featurefsdatasettypeenabled();
  inline void clear_has_featurefsdatasettypeenabled();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_featurevirtsyncenabled();
  inline void clear_has_featurevirtsyncenabled();
  inline void set_has_featuremystorageserverenabled();
  inline void clear_has_featuremystorageserverenabled();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 clusterid_;
  bool isvirtdrive_;
  bool ismediaserver_;
  bool featuremediaserverenabled_;
  bool featurevirtdriveenabled_;
  bool featureremotefileaccessenabled_;
  bool featurefsdatasettypeenabled_;
  bool featurevirtsyncenabled_;
  bool featuremystorageserverenabled_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static UpdateStorageNodeFeaturesInput* default_instance_;
};
// -------------------------------------------------------------------

class UpdateStorageNodeFeaturesOutput : public ::google::protobuf::Message {
 public:
  UpdateStorageNodeFeaturesOutput();
  virtual ~UpdateStorageNodeFeaturesOutput();
  
  UpdateStorageNodeFeaturesOutput(const UpdateStorageNodeFeaturesOutput& from);
  
  inline UpdateStorageNodeFeaturesOutput& operator=(const UpdateStorageNodeFeaturesOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateStorageNodeFeaturesOutput& default_instance();
  
  void Swap(UpdateStorageNodeFeaturesOutput* other);
  
  // implements Message ----------------------------------------------
  
  UpdateStorageNodeFeaturesOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateStorageNodeFeaturesOutput& from);
  void MergeFrom(const UpdateStorageNodeFeaturesOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.UpdateStorageNodeFeaturesOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static UpdateStorageNodeFeaturesOutput* default_instance_;
};
// -------------------------------------------------------------------

class GetPSNDatasetLocationInput : public ::google::protobuf::Message {
 public:
  GetPSNDatasetLocationInput();
  virtual ~GetPSNDatasetLocationInput();
  
  GetPSNDatasetLocationInput(const GetPSNDatasetLocationInput& from);
  
  inline GetPSNDatasetLocationInput& operator=(const GetPSNDatasetLocationInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetPSNDatasetLocationInput& default_instance();
  
  void Swap(GetPSNDatasetLocationInput* other);
  
  // implements Message ----------------------------------------------
  
  GetPSNDatasetLocationInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetPSNDatasetLocationInput& from);
  void MergeFrom(const GetPSNDatasetLocationInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required fixed64 datasetUserId = 3;
  inline bool has_datasetuserid() const;
  inline void clear_datasetuserid();
  static const int kDatasetUserIdFieldNumber = 3;
  inline ::google::protobuf::uint64 datasetuserid() const;
  inline void set_datasetuserid(::google::protobuf::uint64 value);
  
  // required fixed64 datasetId = 4;
  inline bool has_datasetid() const;
  inline void clear_datasetid();
  static const int kDatasetIdFieldNumber = 4;
  inline ::google::protobuf::uint64 datasetid() const;
  inline void set_datasetid(::google::protobuf::uint64 value);
  
  // optional string version = 5;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 5;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetPSNDatasetLocationInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_datasetuserid();
  inline void clear_has_datasetuserid();
  inline void set_has_datasetid();
  inline void clear_has_datasetid();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 datasetuserid_;
  ::google::protobuf::uint64 datasetid_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetPSNDatasetLocationInput* default_instance_;
};
// -------------------------------------------------------------------

class GetPSNDatasetLocationOutput : public ::google::protobuf::Message {
 public:
  GetPSNDatasetLocationOutput();
  virtual ~GetPSNDatasetLocationOutput();
  
  GetPSNDatasetLocationOutput(const GetPSNDatasetLocationOutput& from);
  
  inline GetPSNDatasetLocationOutput& operator=(const GetPSNDatasetLocationOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetPSNDatasetLocationOutput& default_instance();
  
  void Swap(GetPSNDatasetLocationOutput* other);
  
  // implements Message ----------------------------------------------
  
  GetPSNDatasetLocationOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetPSNDatasetLocationOutput& from);
  void MergeFrom(const GetPSNDatasetLocationOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // optional fixed64 storageClusterId = 2;
  inline bool has_storageclusterid() const;
  inline void clear_storageclusterid();
  static const int kStorageClusterIdFieldNumber = 2;
  inline ::google::protobuf::uint64 storageclusterid() const;
  inline void set_storageclusterid(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetPSNDatasetLocationOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_storageclusterid();
  inline void clear_has_storageclusterid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  ::google::protobuf::uint64 storageclusterid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetPSNDatasetLocationOutput* default_instance_;
};
// -------------------------------------------------------------------

class UpdatePSNDatasetStatusInput : public ::google::protobuf::Message {
 public:
  UpdatePSNDatasetStatusInput();
  virtual ~UpdatePSNDatasetStatusInput();
  
  UpdatePSNDatasetStatusInput(const UpdatePSNDatasetStatusInput& from);
  
  inline UpdatePSNDatasetStatusInput& operator=(const UpdatePSNDatasetStatusInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdatePSNDatasetStatusInput& default_instance();
  
  void Swap(UpdatePSNDatasetStatusInput* other);
  
  // implements Message ----------------------------------------------
  
  UpdatePSNDatasetStatusInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdatePSNDatasetStatusInput& from);
  void MergeFrom(const UpdatePSNDatasetStatusInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required fixed64 datasetUserId = 3;
  inline bool has_datasetuserid() const;
  inline void clear_datasetuserid();
  static const int kDatasetUserIdFieldNumber = 3;
  inline ::google::protobuf::uint64 datasetuserid() const;
  inline void set_datasetuserid(::google::protobuf::uint64 value);
  
  // required fixed64 datasetId = 4;
  inline bool has_datasetid() const;
  inline void clear_datasetid();
  static const int kDatasetIdFieldNumber = 4;
  inline ::google::protobuf::uint64 datasetid() const;
  inline void set_datasetid(::google::protobuf::uint64 value);
  
  // required fixed64 clusterId = 5;
  inline bool has_clusterid() const;
  inline void clear_clusterid();
  static const int kClusterIdFieldNumber = 5;
  inline ::google::protobuf::uint64 clusterid() const;
  inline void set_clusterid(::google::protobuf::uint64 value);
  
  // required fixed64 datasetSize = 6;
  inline bool has_datasetsize() const;
  inline void clear_datasetsize();
  static const int kDatasetSizeFieldNumber = 6;
  inline ::google::protobuf::uint64 datasetsize() const;
  inline void set_datasetsize(::google::protobuf::uint64 value);
  
  // required fixed64 datasetVersion = 7;
  inline bool has_datasetversion() const;
  inline void clear_datasetversion();
  static const int kDatasetVersionFieldNumber = 7;
  inline ::google::protobuf::uint64 datasetversion() const;
  inline void set_datasetversion(::google::protobuf::uint64 value);
  
  // optional string version = 8;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 8;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.UpdatePSNDatasetStatusInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_datasetuserid();
  inline void clear_has_datasetuserid();
  inline void set_has_datasetid();
  inline void clear_has_datasetid();
  inline void set_has_clusterid();
  inline void clear_has_clusterid();
  inline void set_has_datasetsize();
  inline void clear_has_datasetsize();
  inline void set_has_datasetversion();
  inline void clear_has_datasetversion();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 datasetuserid_;
  ::google::protobuf::uint64 datasetid_;
  ::google::protobuf::uint64 clusterid_;
  ::google::protobuf::uint64 datasetsize_;
  ::google::protobuf::uint64 datasetversion_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static UpdatePSNDatasetStatusInput* default_instance_;
};
// -------------------------------------------------------------------

class UpdatePSNDatasetStatusOutput : public ::google::protobuf::Message {
 public:
  UpdatePSNDatasetStatusOutput();
  virtual ~UpdatePSNDatasetStatusOutput();
  
  UpdatePSNDatasetStatusOutput(const UpdatePSNDatasetStatusOutput& from);
  
  inline UpdatePSNDatasetStatusOutput& operator=(const UpdatePSNDatasetStatusOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdatePSNDatasetStatusOutput& default_instance();
  
  void Swap(UpdatePSNDatasetStatusOutput* other);
  
  // implements Message ----------------------------------------------
  
  UpdatePSNDatasetStatusOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdatePSNDatasetStatusOutput& from);
  void MergeFrom(const UpdatePSNDatasetStatusOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.UpdatePSNDatasetStatusOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static UpdatePSNDatasetStatusOutput* default_instance_;
};
// -------------------------------------------------------------------

class AddUserStorageInput : public ::google::protobuf::Message {
 public:
  AddUserStorageInput();
  virtual ~AddUserStorageInput();
  
  AddUserStorageInput(const AddUserStorageInput& from);
  
  inline AddUserStorageInput& operator=(const AddUserStorageInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddUserStorageInput& default_instance();
  
  void Swap(AddUserStorageInput* other);
  
  // implements Message ----------------------------------------------
  
  AddUserStorageInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddUserStorageInput& from);
  void MergeFrom(const AddUserStorageInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required fixed64 storageClusterId = 3;
  inline bool has_storageclusterid() const;
  inline void clear_storageclusterid();
  static const int kStorageClusterIdFieldNumber = 3;
  inline ::google::protobuf::uint64 storageclusterid() const;
  inline void set_storageclusterid(::google::protobuf::uint64 value);
  
  // required string storageName = 4;
  inline bool has_storagename() const;
  inline void clear_storagename();
  static const int kStorageNameFieldNumber = 4;
  inline const ::std::string& storagename() const;
  inline void set_storagename(const ::std::string& value);
  inline void set_storagename(const char* value);
  inline void set_storagename(const char* value, size_t size);
  inline ::std::string* mutable_storagename();
  inline ::std::string* release_storagename();
  
  // required fixed64 usageLimit = 5;
  inline bool has_usagelimit() const;
  inline void clear_usagelimit();
  static const int kUsageLimitFieldNumber = 5;
  inline ::google::protobuf::uint64 usagelimit() const;
  inline void set_usagelimit(::google::protobuf::uint64 value);
  
  // optional string version = 6;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 6;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.AddUserStorageInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_storageclusterid();
  inline void clear_has_storageclusterid();
  inline void set_has_storagename();
  inline void clear_has_storagename();
  inline void set_has_usagelimit();
  inline void clear_has_usagelimit();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 storageclusterid_;
  ::std::string* storagename_;
  ::google::protobuf::uint64 usagelimit_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static AddUserStorageInput* default_instance_;
};
// -------------------------------------------------------------------

class AddUserStorageOutput : public ::google::protobuf::Message {
 public:
  AddUserStorageOutput();
  virtual ~AddUserStorageOutput();
  
  AddUserStorageOutput(const AddUserStorageOutput& from);
  
  inline AddUserStorageOutput& operator=(const AddUserStorageOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddUserStorageOutput& default_instance();
  
  void Swap(AddUserStorageOutput* other);
  
  // implements Message ----------------------------------------------
  
  AddUserStorageOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddUserStorageOutput& from);
  void MergeFrom(const AddUserStorageOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.AddUserStorageOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static AddUserStorageOutput* default_instance_;
};
// -------------------------------------------------------------------

class DeleteUserStorageInput : public ::google::protobuf::Message {
 public:
  DeleteUserStorageInput();
  virtual ~DeleteUserStorageInput();
  
  DeleteUserStorageInput(const DeleteUserStorageInput& from);
  
  inline DeleteUserStorageInput& operator=(const DeleteUserStorageInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteUserStorageInput& default_instance();
  
  void Swap(DeleteUserStorageInput* other);
  
  // implements Message ----------------------------------------------
  
  DeleteUserStorageInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteUserStorageInput& from);
  void MergeFrom(const DeleteUserStorageInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required fixed64 storageClusterId = 3;
  inline bool has_storageclusterid() const;
  inline void clear_storageclusterid();
  static const int kStorageClusterIdFieldNumber = 3;
  inline ::google::protobuf::uint64 storageclusterid() const;
  inline void set_storageclusterid(::google::protobuf::uint64 value);
  
  // optional string version = 4;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 4;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.DeleteUserStorageInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_storageclusterid();
  inline void clear_has_storageclusterid();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 storageclusterid_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static DeleteUserStorageInput* default_instance_;
};
// -------------------------------------------------------------------

class DeleteUserStorageOutput : public ::google::protobuf::Message {
 public:
  DeleteUserStorageOutput();
  virtual ~DeleteUserStorageOutput();
  
  DeleteUserStorageOutput(const DeleteUserStorageOutput& from);
  
  inline DeleteUserStorageOutput& operator=(const DeleteUserStorageOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteUserStorageOutput& default_instance();
  
  void Swap(DeleteUserStorageOutput* other);
  
  // implements Message ----------------------------------------------
  
  DeleteUserStorageOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteUserStorageOutput& from);
  void MergeFrom(const DeleteUserStorageOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.DeleteUserStorageOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static DeleteUserStorageOutput* default_instance_;
};
// -------------------------------------------------------------------

class ChangeUserStorageNameInput : public ::google::protobuf::Message {
 public:
  ChangeUserStorageNameInput();
  virtual ~ChangeUserStorageNameInput();
  
  ChangeUserStorageNameInput(const ChangeUserStorageNameInput& from);
  
  inline ChangeUserStorageNameInput& operator=(const ChangeUserStorageNameInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeUserStorageNameInput& default_instance();
  
  void Swap(ChangeUserStorageNameInput* other);
  
  // implements Message ----------------------------------------------
  
  ChangeUserStorageNameInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangeUserStorageNameInput& from);
  void MergeFrom(const ChangeUserStorageNameInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required fixed64 storageClusterId = 3;
  inline bool has_storageclusterid() const;
  inline void clear_storageclusterid();
  static const int kStorageClusterIdFieldNumber = 3;
  inline ::google::protobuf::uint64 storageclusterid() const;
  inline void set_storageclusterid(::google::protobuf::uint64 value);
  
  // required string newStorageName = 4;
  inline bool has_newstoragename() const;
  inline void clear_newstoragename();
  static const int kNewStorageNameFieldNumber = 4;
  inline const ::std::string& newstoragename() const;
  inline void set_newstoragename(const ::std::string& value);
  inline void set_newstoragename(const char* value);
  inline void set_newstoragename(const char* value, size_t size);
  inline ::std::string* mutable_newstoragename();
  inline ::std::string* release_newstoragename();
  
  // optional string version = 5;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 5;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.ChangeUserStorageNameInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_storageclusterid();
  inline void clear_has_storageclusterid();
  inline void set_has_newstoragename();
  inline void clear_has_newstoragename();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 storageclusterid_;
  ::std::string* newstoragename_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static ChangeUserStorageNameInput* default_instance_;
};
// -------------------------------------------------------------------

class ChangeUserStorageNameOutput : public ::google::protobuf::Message {
 public:
  ChangeUserStorageNameOutput();
  virtual ~ChangeUserStorageNameOutput();
  
  ChangeUserStorageNameOutput(const ChangeUserStorageNameOutput& from);
  
  inline ChangeUserStorageNameOutput& operator=(const ChangeUserStorageNameOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeUserStorageNameOutput& default_instance();
  
  void Swap(ChangeUserStorageNameOutput* other);
  
  // implements Message ----------------------------------------------
  
  ChangeUserStorageNameOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangeUserStorageNameOutput& from);
  void MergeFrom(const ChangeUserStorageNameOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.ChangeUserStorageNameOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static ChangeUserStorageNameOutput* default_instance_;
};
// -------------------------------------------------------------------

class ChangeUserStorageQuotaInput : public ::google::protobuf::Message {
 public:
  ChangeUserStorageQuotaInput();
  virtual ~ChangeUserStorageQuotaInput();
  
  ChangeUserStorageQuotaInput(const ChangeUserStorageQuotaInput& from);
  
  inline ChangeUserStorageQuotaInput& operator=(const ChangeUserStorageQuotaInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeUserStorageQuotaInput& default_instance();
  
  void Swap(ChangeUserStorageQuotaInput* other);
  
  // implements Message ----------------------------------------------
  
  ChangeUserStorageQuotaInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangeUserStorageQuotaInput& from);
  void MergeFrom(const ChangeUserStorageQuotaInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required fixed64 storageClusterId = 3;
  inline bool has_storageclusterid() const;
  inline void clear_storageclusterid();
  static const int kStorageClusterIdFieldNumber = 3;
  inline ::google::protobuf::uint64 storageclusterid() const;
  inline void set_storageclusterid(::google::protobuf::uint64 value);
  
  // required fixed64 newLimit = 4;
  inline bool has_newlimit() const;
  inline void clear_newlimit();
  static const int kNewLimitFieldNumber = 4;
  inline ::google::protobuf::uint64 newlimit() const;
  inline void set_newlimit(::google::protobuf::uint64 value);
  
  // optional string version = 5;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 5;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.ChangeUserStorageQuotaInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_storageclusterid();
  inline void clear_has_storageclusterid();
  inline void set_has_newlimit();
  inline void clear_has_newlimit();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 storageclusterid_;
  ::google::protobuf::uint64 newlimit_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static ChangeUserStorageQuotaInput* default_instance_;
};
// -------------------------------------------------------------------

class ChangeUserStorageQuotaOutput : public ::google::protobuf::Message {
 public:
  ChangeUserStorageQuotaOutput();
  virtual ~ChangeUserStorageQuotaOutput();
  
  ChangeUserStorageQuotaOutput(const ChangeUserStorageQuotaOutput& from);
  
  inline ChangeUserStorageQuotaOutput& operator=(const ChangeUserStorageQuotaOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeUserStorageQuotaOutput& default_instance();
  
  void Swap(ChangeUserStorageQuotaOutput* other);
  
  // implements Message ----------------------------------------------
  
  ChangeUserStorageQuotaOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangeUserStorageQuotaOutput& from);
  void MergeFrom(const ChangeUserStorageQuotaOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.ChangeUserStorageQuotaOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static ChangeUserStorageQuotaOutput* default_instance_;
};
// -------------------------------------------------------------------

class ListUserStorageInput : public ::google::protobuf::Message {
 public:
  ListUserStorageInput();
  virtual ~ListUserStorageInput();
  
  ListUserStorageInput(const ListUserStorageInput& from);
  
  inline ListUserStorageInput& operator=(const ListUserStorageInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListUserStorageInput& default_instance();
  
  void Swap(ListUserStorageInput* other);
  
  // implements Message ----------------------------------------------
  
  ListUserStorageInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListUserStorageInput& from);
  void MergeFrom(const ListUserStorageInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // optional fixed64 deviceId = 3;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIdFieldNumber = 3;
  inline ::google::protobuf::uint64 deviceid() const;
  inline void set_deviceid(::google::protobuf::uint64 value);
  
  // optional string version = 4;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 4;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.ListUserStorageInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 deviceid_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static ListUserStorageInput* default_instance_;
};
// -------------------------------------------------------------------

class ListUserStorageOutput : public ::google::protobuf::Message {
 public:
  ListUserStorageOutput();
  virtual ~ListUserStorageOutput();
  
  ListUserStorageOutput(const ListUserStorageOutput& from);
  
  inline ListUserStorageOutput& operator=(const ListUserStorageOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListUserStorageOutput& default_instance();
  
  void Swap(ListUserStorageOutput* other);
  
  // implements Message ----------------------------------------------
  
  ListUserStorageOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListUserStorageOutput& from);
  void MergeFrom(const ListUserStorageOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // repeated .vplex.vsDirectory.UserStorage storageAssignments = 2;
  inline int storageassignments_size() const;
  inline void clear_storageassignments();
  static const int kStorageAssignmentsFieldNumber = 2;
  inline const ::vplex::vsDirectory::UserStorage& storageassignments(int index) const;
  inline ::vplex::vsDirectory::UserStorage* mutable_storageassignments(int index);
  inline ::vplex::vsDirectory::UserStorage* add_storageassignments();
  inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::UserStorage >&
      storageassignments() const;
  inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::UserStorage >*
      mutable_storageassignments();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.ListUserStorageOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::UserStorage > storageassignments_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static ListUserStorageOutput* default_instance_;
};
// -------------------------------------------------------------------

class GetUserStorageAddressInput : public ::google::protobuf::Message {
 public:
  GetUserStorageAddressInput();
  virtual ~GetUserStorageAddressInput();
  
  GetUserStorageAddressInput(const GetUserStorageAddressInput& from);
  
  inline GetUserStorageAddressInput& operator=(const GetUserStorageAddressInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetUserStorageAddressInput& default_instance();
  
  void Swap(GetUserStorageAddressInput* other);
  
  // implements Message ----------------------------------------------
  
  GetUserStorageAddressInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetUserStorageAddressInput& from);
  void MergeFrom(const GetUserStorageAddressInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required fixed64 storageClusterId = 3;
  inline bool has_storageclusterid() const;
  inline void clear_storageclusterid();
  static const int kStorageClusterIdFieldNumber = 3;
  inline ::google::protobuf::uint64 storageclusterid() const;
  inline void set_storageclusterid(::google::protobuf::uint64 value);
  
  // optional string version = 4;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 4;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetUserStorageAddressInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_storageclusterid();
  inline void clear_has_storageclusterid();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 storageclusterid_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetUserStorageAddressInput* default_instance_;
};
// -------------------------------------------------------------------

class UserStorageAddress : public ::google::protobuf::Message {
 public:
  UserStorageAddress();
  virtual ~UserStorageAddress();
  
  UserStorageAddress(const UserStorageAddress& from);
  
  inline UserStorageAddress& operator=(const UserStorageAddress& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserStorageAddress& default_instance();
  
  void Swap(UserStorageAddress* other);
  
  // implements Message ----------------------------------------------
  
  UserStorageAddress* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserStorageAddress& from);
  void MergeFrom(const UserStorageAddress& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string direct_address = 1;
  inline bool has_direct_address() const;
  inline void clear_direct_address();
  static const int kDirectAddressFieldNumber = 1;
  inline const ::std::string& direct_address() const;
  inline void set_direct_address(const ::std::string& value);
  inline void set_direct_address(const char* value);
  inline void set_direct_address(const char* value, size_t size);
  inline ::std::string* mutable_direct_address();
  inline ::std::string* release_direct_address();
  
  // optional int32 direct_port = 2;
  inline bool has_direct_port() const;
  inline void clear_direct_port();
  static const int kDirectPortFieldNumber = 2;
  inline ::google::protobuf::int32 direct_port() const;
  inline void set_direct_port(::google::protobuf::int32 value);
  
  // optional string proxy_address = 3;
  inline bool has_proxy_address() const;
  inline void clear_proxy_address();
  static const int kProxyAddressFieldNumber = 3;
  inline const ::std::string& proxy_address() const;
  inline void set_proxy_address(const ::std::string& value);
  inline void set_proxy_address(const char* value);
  inline void set_proxy_address(const char* value, size_t size);
  inline ::std::string* mutable_proxy_address();
  inline ::std::string* release_proxy_address();
  
  // optional int32 proxy_port = 4;
  inline bool has_proxy_port() const;
  inline void clear_proxy_port();
  static const int kProxyPortFieldNumber = 4;
  inline ::google::protobuf::int32 proxy_port() const;
  inline void set_proxy_port(::google::protobuf::int32 value);
  
  // optional string internal_direct_address = 5;
  inline bool has_internal_direct_address() const;
  inline void clear_internal_direct_address();
  static const int kInternalDirectAddressFieldNumber = 5;
  inline const ::std::string& internal_direct_address() const;
  inline void set_internal_direct_address(const ::std::string& value);
  inline void set_internal_direct_address(const char* value);
  inline void set_internal_direct_address(const char* value, size_t size);
  inline ::std::string* mutable_internal_direct_address();
  inline ::std::string* release_internal_direct_address();
  
  // optional int32 direct_secure_port = 6;
  inline bool has_direct_secure_port() const;
  inline void clear_direct_secure_port();
  static const int kDirectSecurePortFieldNumber = 6;
  inline ::google::protobuf::int32 direct_secure_port() const;
  inline void set_direct_secure_port(::google::protobuf::int32 value);
  
  // optional fixed64 access_handle = 7;
  inline bool has_access_handle() const;
  inline void clear_access_handle();
  static const int kAccessHandleFieldNumber = 7;
  inline ::google::protobuf::uint64 access_handle() const;
  inline void set_access_handle(::google::protobuf::uint64 value);
  
  // optional bytes access_ticket = 8;
  inline bool has_access_ticket() const;
  inline void clear_access_ticket();
  static const int kAccessTicketFieldNumber = 8;
  inline const ::std::string& access_ticket() const;
  inline void set_access_ticket(const ::std::string& value);
  inline void set_access_ticket(const char* value);
  inline void set_access_ticket(const void* value, size_t size);
  inline ::std::string* mutable_access_ticket();
  inline ::std::string* release_access_ticket();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.UserStorageAddress)
 private:
  inline void set_has_direct_address();
  inline void clear_has_direct_address();
  inline void set_has_direct_port();
  inline void clear_has_direct_port();
  inline void set_has_proxy_address();
  inline void clear_has_proxy_address();
  inline void set_has_proxy_port();
  inline void clear_has_proxy_port();
  inline void set_has_internal_direct_address();
  inline void clear_has_internal_direct_address();
  inline void set_has_direct_secure_port();
  inline void clear_has_direct_secure_port();
  inline void set_has_access_handle();
  inline void clear_has_access_handle();
  inline void set_has_access_ticket();
  inline void clear_has_access_ticket();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* direct_address_;
  ::std::string* proxy_address_;
  ::google::protobuf::int32 direct_port_;
  ::google::protobuf::int32 proxy_port_;
  ::std::string* internal_direct_address_;
  ::google::protobuf::uint64 access_handle_;
  ::std::string* access_ticket_;
  ::google::protobuf::int32 direct_secure_port_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static UserStorageAddress* default_instance_;
};
// -------------------------------------------------------------------

class GetUserStorageAddressOutput : public ::google::protobuf::Message {
 public:
  GetUserStorageAddressOutput();
  virtual ~GetUserStorageAddressOutput();
  
  GetUserStorageAddressOutput(const GetUserStorageAddressOutput& from);
  
  inline GetUserStorageAddressOutput& operator=(const GetUserStorageAddressOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetUserStorageAddressOutput& default_instance();
  
  void Swap(GetUserStorageAddressOutput* other);
  
  // implements Message ----------------------------------------------
  
  GetUserStorageAddressOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetUserStorageAddressOutput& from);
  void MergeFrom(const GetUserStorageAddressOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // optional string directAddress = 2;
  inline bool has_directaddress() const;
  inline void clear_directaddress();
  static const int kDirectAddressFieldNumber = 2;
  inline const ::std::string& directaddress() const;
  inline void set_directaddress(const ::std::string& value);
  inline void set_directaddress(const char* value);
  inline void set_directaddress(const char* value, size_t size);
  inline ::std::string* mutable_directaddress();
  inline ::std::string* release_directaddress();
  
  // optional int32 directPort = 3;
  inline bool has_directport() const;
  inline void clear_directport();
  static const int kDirectPortFieldNumber = 3;
  inline ::google::protobuf::int32 directport() const;
  inline void set_directport(::google::protobuf::int32 value);
  
  // optional string proxyAddress = 4;
  inline bool has_proxyaddress() const;
  inline void clear_proxyaddress();
  static const int kProxyAddressFieldNumber = 4;
  inline const ::std::string& proxyaddress() const;
  inline void set_proxyaddress(const ::std::string& value);
  inline void set_proxyaddress(const char* value);
  inline void set_proxyaddress(const char* value, size_t size);
  inline ::std::string* mutable_proxyaddress();
  inline ::std::string* release_proxyaddress();
  
  // optional int32 proxyPort = 5;
  inline bool has_proxyport() const;
  inline void clear_proxyport();
  static const int kProxyPortFieldNumber = 5;
  inline ::google::protobuf::int32 proxyport() const;
  inline void set_proxyport(::google::protobuf::int32 value);
  
  // optional string internalDirectAddress = 6;
  inline bool has_internaldirectaddress() const;
  inline void clear_internaldirectaddress();
  static const int kInternalDirectAddressFieldNumber = 6;
  inline const ::std::string& internaldirectaddress() const;
  inline void set_internaldirectaddress(const ::std::string& value);
  inline void set_internaldirectaddress(const char* value);
  inline void set_internaldirectaddress(const char* value, size_t size);
  inline ::std::string* mutable_internaldirectaddress();
  inline ::std::string* release_internaldirectaddress();
  
  // optional int32 directSecurePort = 7;
  inline bool has_directsecureport() const;
  inline void clear_directsecureport();
  static const int kDirectSecurePortFieldNumber = 7;
  inline ::google::protobuf::int32 directsecureport() const;
  inline void set_directsecureport(::google::protobuf::int32 value);
  
  // optional fixed64 accessHandle = 8;
  inline bool has_accesshandle() const;
  inline void clear_accesshandle();
  static const int kAccessHandleFieldNumber = 8;
  inline ::google::protobuf::uint64 accesshandle() const;
  inline void set_accesshandle(::google::protobuf::uint64 value);
  
  // optional bytes accessTicket = 9;
  inline bool has_accessticket() const;
  inline void clear_accessticket();
  static const int kAccessTicketFieldNumber = 9;
  inline const ::std::string& accessticket() const;
  inline void set_accessticket(const ::std::string& value);
  inline void set_accessticket(const char* value);
  inline void set_accessticket(const void* value, size_t size);
  inline ::std::string* mutable_accessticket();
  inline ::std::string* release_accessticket();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetUserStorageAddressOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_directaddress();
  inline void clear_has_directaddress();
  inline void set_has_directport();
  inline void clear_has_directport();
  inline void set_has_proxyaddress();
  inline void clear_has_proxyaddress();
  inline void set_has_proxyport();
  inline void clear_has_proxyport();
  inline void set_has_internaldirectaddress();
  inline void clear_has_internaldirectaddress();
  inline void set_has_directsecureport();
  inline void clear_has_directsecureport();
  inline void set_has_accesshandle();
  inline void clear_has_accesshandle();
  inline void set_has_accessticket();
  inline void clear_has_accessticket();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  ::std::string* directaddress_;
  ::std::string* proxyaddress_;
  ::google::protobuf::int32 directport_;
  ::google::protobuf::int32 proxyport_;
  ::std::string* internaldirectaddress_;
  ::google::protobuf::uint64 accesshandle_;
  ::std::string* accessticket_;
  ::google::protobuf::int32 directsecureport_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetUserStorageAddressOutput* default_instance_;
};
// -------------------------------------------------------------------

class AssignUserDatacenterStorageInput : public ::google::protobuf::Message {
 public:
  AssignUserDatacenterStorageInput();
  virtual ~AssignUserDatacenterStorageInput();
  
  AssignUserDatacenterStorageInput(const AssignUserDatacenterStorageInput& from);
  
  inline AssignUserDatacenterStorageInput& operator=(const AssignUserDatacenterStorageInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AssignUserDatacenterStorageInput& default_instance();
  
  void Swap(AssignUserDatacenterStorageInput* other);
  
  // implements Message ----------------------------------------------
  
  AssignUserDatacenterStorageInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AssignUserDatacenterStorageInput& from);
  void MergeFrom(const AssignUserDatacenterStorageInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed64 userId = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required string region = 2;
  inline bool has_region() const;
  inline void clear_region();
  static const int kRegionFieldNumber = 2;
  inline const ::std::string& region() const;
  inline void set_region(const ::std::string& value);
  inline void set_region(const char* value);
  inline void set_region(const char* value, size_t size);
  inline ::std::string* mutable_region();
  inline ::std::string* release_region();
  
  // required fixed64 usageLimit = 3;
  inline bool has_usagelimit() const;
  inline void clear_usagelimit();
  static const int kUsageLimitFieldNumber = 3;
  inline ::google::protobuf::uint64 usagelimit() const;
  inline void set_usagelimit(::google::protobuf::uint64 value);
  
  // optional fixed64 storageClusterId = 4;
  inline bool has_storageclusterid() const;
  inline void clear_storageclusterid();
  static const int kStorageClusterIdFieldNumber = 4;
  inline ::google::protobuf::uint64 storageclusterid() const;
  inline void set_storageclusterid(::google::protobuf::uint64 value);
  
  // optional fixed64 primaryStorageId = 5;
  inline bool has_primarystorageid() const;
  inline void clear_primarystorageid();
  static const int kPrimaryStorageIdFieldNumber = 5;
  inline ::google::protobuf::uint64 primarystorageid() const;
  inline void set_primarystorageid(::google::protobuf::uint64 value);
  
  // optional fixed64 secondaryStorageId = 6;
  inline bool has_secondarystorageid() const;
  inline void clear_secondarystorageid();
  static const int kSecondaryStorageIdFieldNumber = 6;
  inline ::google::protobuf::uint64 secondarystorageid() const;
  inline void set_secondarystorageid(::google::protobuf::uint64 value);
  
  // optional string version = 7;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 7;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.AssignUserDatacenterStorageInput)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_region();
  inline void clear_has_region();
  inline void set_has_usagelimit();
  inline void clear_has_usagelimit();
  inline void set_has_storageclusterid();
  inline void clear_has_storageclusterid();
  inline void set_has_primarystorageid();
  inline void clear_has_primarystorageid();
  inline void set_has_secondarystorageid();
  inline void clear_has_secondarystorageid();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 userid_;
  ::std::string* region_;
  ::google::protobuf::uint64 usagelimit_;
  ::google::protobuf::uint64 storageclusterid_;
  ::google::protobuf::uint64 primarystorageid_;
  ::google::protobuf::uint64 secondarystorageid_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static AssignUserDatacenterStorageInput* default_instance_;
};
// -------------------------------------------------------------------

class AssignUserDatacenterStorageOutput : public ::google::protobuf::Message {
 public:
  AssignUserDatacenterStorageOutput();
  virtual ~AssignUserDatacenterStorageOutput();
  
  AssignUserDatacenterStorageOutput(const AssignUserDatacenterStorageOutput& from);
  
  inline AssignUserDatacenterStorageOutput& operator=(const AssignUserDatacenterStorageOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AssignUserDatacenterStorageOutput& default_instance();
  
  void Swap(AssignUserDatacenterStorageOutput* other);
  
  // implements Message ----------------------------------------------
  
  AssignUserDatacenterStorageOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AssignUserDatacenterStorageOutput& from);
  void MergeFrom(const AssignUserDatacenterStorageOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // optional .vplex.vsDirectory.UserStorage storageAssignment = 2;
  inline bool has_storageassignment() const;
  inline void clear_storageassignment();
  static const int kStorageAssignmentFieldNumber = 2;
  inline const ::vplex::vsDirectory::UserStorage& storageassignment() const;
  inline ::vplex::vsDirectory::UserStorage* mutable_storageassignment();
  inline ::vplex::vsDirectory::UserStorage* release_storageassignment();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.AssignUserDatacenterStorageOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_storageassignment();
  inline void clear_has_storageassignment();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  ::vplex::vsDirectory::UserStorage* storageassignment_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static AssignUserDatacenterStorageOutput* default_instance_;
};
// -------------------------------------------------------------------

class GetStorageUnitForDatasetInput : public ::google::protobuf::Message {
 public:
  GetStorageUnitForDatasetInput();
  virtual ~GetStorageUnitForDatasetInput();
  
  GetStorageUnitForDatasetInput(const GetStorageUnitForDatasetInput& from);
  
  inline GetStorageUnitForDatasetInput& operator=(const GetStorageUnitForDatasetInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetStorageUnitForDatasetInput& default_instance();
  
  void Swap(GetStorageUnitForDatasetInput* other);
  
  // implements Message ----------------------------------------------
  
  GetStorageUnitForDatasetInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetStorageUnitForDatasetInput& from);
  void MergeFrom(const GetStorageUnitForDatasetInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed64 userId = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required fixed64 datasetId = 2;
  inline bool has_datasetid() const;
  inline void clear_datasetid();
  static const int kDatasetIdFieldNumber = 2;
  inline ::google::protobuf::uint64 datasetid() const;
  inline void set_datasetid(::google::protobuf::uint64 value);
  
  // optional string version = 3;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 3;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetStorageUnitForDatasetInput)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_datasetid();
  inline void clear_has_datasetid();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 datasetid_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetStorageUnitForDatasetInput* default_instance_;
};
// -------------------------------------------------------------------

class GetStorageUnitForDatasetOutput : public ::google::protobuf::Message {
 public:
  GetStorageUnitForDatasetOutput();
  virtual ~GetStorageUnitForDatasetOutput();
  
  GetStorageUnitForDatasetOutput(const GetStorageUnitForDatasetOutput& from);
  
  inline GetStorageUnitForDatasetOutput& operator=(const GetStorageUnitForDatasetOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetStorageUnitForDatasetOutput& default_instance();
  
  void Swap(GetStorageUnitForDatasetOutput* other);
  
  // implements Message ----------------------------------------------
  
  GetStorageUnitForDatasetOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetStorageUnitForDatasetOutput& from);
  void MergeFrom(const GetStorageUnitForDatasetOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // optional fixed64 storageClusterId = 2;
  inline bool has_storageclusterid() const;
  inline void clear_storageclusterid();
  static const int kStorageClusterIdFieldNumber = 2;
  inline ::google::protobuf::uint64 storageclusterid() const;
  inline void set_storageclusterid(::google::protobuf::uint64 value);
  
  // optional fixed64 primaryStorageId = 3;
  inline bool has_primarystorageid() const;
  inline void clear_primarystorageid();
  static const int kPrimaryStorageIdFieldNumber = 3;
  inline ::google::protobuf::uint64 primarystorageid() const;
  inline void set_primarystorageid(::google::protobuf::uint64 value);
  
  // optional fixed64 secondaryStorageId = 4;
  inline bool has_secondarystorageid() const;
  inline void clear_secondarystorageid();
  static const int kSecondaryStorageIdFieldNumber = 4;
  inline ::google::protobuf::uint64 secondarystorageid() const;
  inline void set_secondarystorageid(::google::protobuf::uint64 value);
  
  // optional fixed64 backupStorageId = 5;
  inline bool has_backupstorageid() const;
  inline void clear_backupstorageid();
  static const int kBackupStorageIdFieldNumber = 5;
  inline ::google::protobuf::uint64 backupstorageid() const;
  inline void set_backupstorageid(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetStorageUnitForDatasetOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_storageclusterid();
  inline void clear_has_storageclusterid();
  inline void set_has_primarystorageid();
  inline void clear_has_primarystorageid();
  inline void set_has_secondarystorageid();
  inline void clear_has_secondarystorageid();
  inline void set_has_backupstorageid();
  inline void clear_has_backupstorageid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  ::google::protobuf::uint64 storageclusterid_;
  ::google::protobuf::uint64 primarystorageid_;
  ::google::protobuf::uint64 secondarystorageid_;
  ::google::protobuf::uint64 backupstorageid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetStorageUnitForDatasetOutput* default_instance_;
};
// -------------------------------------------------------------------

class GetStoredDatasetsInput : public ::google::protobuf::Message {
 public:
  GetStoredDatasetsInput();
  virtual ~GetStoredDatasetsInput();
  
  GetStoredDatasetsInput(const GetStoredDatasetsInput& from);
  
  inline GetStoredDatasetsInput& operator=(const GetStoredDatasetsInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetStoredDatasetsInput& default_instance();
  
  void Swap(GetStoredDatasetsInput* other);
  
  // implements Message ----------------------------------------------
  
  GetStoredDatasetsInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetStoredDatasetsInput& from);
  void MergeFrom(const GetStoredDatasetsInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed64 clusterId = 1;
  inline bool has_clusterid() const;
  inline void clear_clusterid();
  static const int kClusterIdFieldNumber = 1;
  inline ::google::protobuf::uint64 clusterid() const;
  inline void set_clusterid(::google::protobuf::uint64 value);
  
  // required fixed64 storageId = 2;
  inline bool has_storageid() const;
  inline void clear_storageid();
  static const int kStorageIdFieldNumber = 2;
  inline ::google::protobuf::uint64 storageid() const;
  inline void set_storageid(::google::protobuf::uint64 value);
  
  // optional string version = 3;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 3;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetStoredDatasetsInput)
 private:
  inline void set_has_clusterid();
  inline void clear_has_clusterid();
  inline void set_has_storageid();
  inline void clear_has_storageid();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 clusterid_;
  ::google::protobuf::uint64 storageid_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetStoredDatasetsInput* default_instance_;
};
// -------------------------------------------------------------------

class GetStoredDatasetsOutput : public ::google::protobuf::Message {
 public:
  GetStoredDatasetsOutput();
  virtual ~GetStoredDatasetsOutput();
  
  GetStoredDatasetsOutput(const GetStoredDatasetsOutput& from);
  
  inline GetStoredDatasetsOutput& operator=(const GetStoredDatasetsOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetStoredDatasetsOutput& default_instance();
  
  void Swap(GetStoredDatasetsOutput* other);
  
  // implements Message ----------------------------------------------
  
  GetStoredDatasetsOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetStoredDatasetsOutput& from);
  void MergeFrom(const GetStoredDatasetsOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // repeated .vplex.vsDirectory.StoredDataset datasets = 2;
  inline int datasets_size() const;
  inline void clear_datasets();
  static const int kDatasetsFieldNumber = 2;
  inline const ::vplex::vsDirectory::StoredDataset& datasets(int index) const;
  inline ::vplex::vsDirectory::StoredDataset* mutable_datasets(int index);
  inline ::vplex::vsDirectory::StoredDataset* add_datasets();
  inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::StoredDataset >&
      datasets() const;
  inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::StoredDataset >*
      mutable_datasets();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetStoredDatasetsOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::StoredDataset > datasets_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetStoredDatasetsOutput* default_instance_;
};
// -------------------------------------------------------------------

class GetProxyConnectionForClusterInput : public ::google::protobuf::Message {
 public:
  GetProxyConnectionForClusterInput();
  virtual ~GetProxyConnectionForClusterInput();
  
  GetProxyConnectionForClusterInput(const GetProxyConnectionForClusterInput& from);
  
  inline GetProxyConnectionForClusterInput& operator=(const GetProxyConnectionForClusterInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetProxyConnectionForClusterInput& default_instance();
  
  void Swap(GetProxyConnectionForClusterInput* other);
  
  // implements Message ----------------------------------------------
  
  GetProxyConnectionForClusterInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetProxyConnectionForClusterInput& from);
  void MergeFrom(const GetProxyConnectionForClusterInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed64 clusterId = 1;
  inline bool has_clusterid() const;
  inline void clear_clusterid();
  static const int kClusterIdFieldNumber = 1;
  inline ::google::protobuf::uint64 clusterid() const;
  inline void set_clusterid(::google::protobuf::uint64 value);
  
  // optional string version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetProxyConnectionForClusterInput)
 private:
  inline void set_has_clusterid();
  inline void clear_has_clusterid();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 clusterid_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetProxyConnectionForClusterInput* default_instance_;
};
// -------------------------------------------------------------------

class GetProxyConnectionForClusterOutput : public ::google::protobuf::Message {
 public:
  GetProxyConnectionForClusterOutput();
  virtual ~GetProxyConnectionForClusterOutput();
  
  GetProxyConnectionForClusterOutput(const GetProxyConnectionForClusterOutput& from);
  
  inline GetProxyConnectionForClusterOutput& operator=(const GetProxyConnectionForClusterOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetProxyConnectionForClusterOutput& default_instance();
  
  void Swap(GetProxyConnectionForClusterOutput* other);
  
  // implements Message ----------------------------------------------
  
  GetProxyConnectionForClusterOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetProxyConnectionForClusterOutput& from);
  void MergeFrom(const GetProxyConnectionForClusterOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // optional fixed32 cookie = 2;
  inline bool has_cookie() const;
  inline void clear_cookie();
  static const int kCookieFieldNumber = 2;
  inline ::google::protobuf::uint32 cookie() const;
  inline void set_cookie(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetProxyConnectionForClusterOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_cookie();
  inline void clear_has_cookie();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  ::google::protobuf::uint32 cookie_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetProxyConnectionForClusterOutput* default_instance_;
};
// -------------------------------------------------------------------

class SendMessageToPSNInput : public ::google::protobuf::Message {
 public:
  SendMessageToPSNInput();
  virtual ~SendMessageToPSNInput();
  
  SendMessageToPSNInput(const SendMessageToPSNInput& from);
  
  inline SendMessageToPSNInput& operator=(const SendMessageToPSNInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SendMessageToPSNInput& default_instance();
  
  void Swap(SendMessageToPSNInput* other);
  
  // implements Message ----------------------------------------------
  
  SendMessageToPSNInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SendMessageToPSNInput& from);
  void MergeFrom(const SendMessageToPSNInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed64 clusterId = 1;
  inline bool has_clusterid() const;
  inline void clear_clusterid();
  static const int kClusterIdFieldNumber = 1;
  inline ::google::protobuf::uint64 clusterid() const;
  inline void set_clusterid(::google::protobuf::uint64 value);
  
  // required bytes message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const void* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  
  // optional string version = 3;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 3;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.SendMessageToPSNInput)
 private:
  inline void set_has_clusterid();
  inline void clear_has_clusterid();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 clusterid_;
  ::std::string* message_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static SendMessageToPSNInput* default_instance_;
};
// -------------------------------------------------------------------

class SendMessageToPSNOutput : public ::google::protobuf::Message {
 public:
  SendMessageToPSNOutput();
  virtual ~SendMessageToPSNOutput();
  
  SendMessageToPSNOutput(const SendMessageToPSNOutput& from);
  
  inline SendMessageToPSNOutput& operator=(const SendMessageToPSNOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SendMessageToPSNOutput& default_instance();
  
  void Swap(SendMessageToPSNOutput* other);
  
  // implements Message ----------------------------------------------
  
  SendMessageToPSNOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SendMessageToPSNOutput& from);
  void MergeFrom(const SendMessageToPSNOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.SendMessageToPSNOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static SendMessageToPSNOutput* default_instance_;
};
// -------------------------------------------------------------------

class ChangeStorageUnitForDatasetInput : public ::google::protobuf::Message {
 public:
  ChangeStorageUnitForDatasetInput();
  virtual ~ChangeStorageUnitForDatasetInput();
  
  ChangeStorageUnitForDatasetInput(const ChangeStorageUnitForDatasetInput& from);
  
  inline ChangeStorageUnitForDatasetInput& operator=(const ChangeStorageUnitForDatasetInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeStorageUnitForDatasetInput& default_instance();
  
  void Swap(ChangeStorageUnitForDatasetInput* other);
  
  // implements Message ----------------------------------------------
  
  ChangeStorageUnitForDatasetInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangeStorageUnitForDatasetInput& from);
  void MergeFrom(const ChangeStorageUnitForDatasetInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed64 userId = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required fixed64 datasetId = 2;
  inline bool has_datasetid() const;
  inline void clear_datasetid();
  static const int kDatasetIdFieldNumber = 2;
  inline ::google::protobuf::uint64 datasetid() const;
  inline void set_datasetid(::google::protobuf::uint64 value);
  
  // required fixed64 currentStorageId = 3;
  inline bool has_currentstorageid() const;
  inline void clear_currentstorageid();
  static const int kCurrentStorageIdFieldNumber = 3;
  inline ::google::protobuf::uint64 currentstorageid() const;
  inline void set_currentstorageid(::google::protobuf::uint64 value);
  
  // required fixed64 newStorageId = 4;
  inline bool has_newstorageid() const;
  inline void clear_newstorageid();
  static const int kNewStorageIdFieldNumber = 4;
  inline ::google::protobuf::uint64 newstorageid() const;
  inline void set_newstorageid(::google::protobuf::uint64 value);
  
  // optional string version = 5;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 5;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.ChangeStorageUnitForDatasetInput)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_datasetid();
  inline void clear_has_datasetid();
  inline void set_has_currentstorageid();
  inline void clear_has_currentstorageid();
  inline void set_has_newstorageid();
  inline void clear_has_newstorageid();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 datasetid_;
  ::google::protobuf::uint64 currentstorageid_;
  ::google::protobuf::uint64 newstorageid_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static ChangeStorageUnitForDatasetInput* default_instance_;
};
// -------------------------------------------------------------------

class ChangeStorageUnitForDatasetOutput : public ::google::protobuf::Message {
 public:
  ChangeStorageUnitForDatasetOutput();
  virtual ~ChangeStorageUnitForDatasetOutput();
  
  ChangeStorageUnitForDatasetOutput(const ChangeStorageUnitForDatasetOutput& from);
  
  inline ChangeStorageUnitForDatasetOutput& operator=(const ChangeStorageUnitForDatasetOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeStorageUnitForDatasetOutput& default_instance();
  
  void Swap(ChangeStorageUnitForDatasetOutput* other);
  
  // implements Message ----------------------------------------------
  
  ChangeStorageUnitForDatasetOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangeStorageUnitForDatasetOutput& from);
  void MergeFrom(const ChangeStorageUnitForDatasetOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // optional fixed64 storageId = 2;
  inline bool has_storageid() const;
  inline void clear_storageid();
  static const int kStorageIdFieldNumber = 2;
  inline ::google::protobuf::uint64 storageid() const;
  inline void set_storageid(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.ChangeStorageUnitForDatasetOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_storageid();
  inline void clear_has_storageid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  ::google::protobuf::uint64 storageid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static ChangeStorageUnitForDatasetOutput* default_instance_;
};
// -------------------------------------------------------------------

class CreateStorageClusterInput : public ::google::protobuf::Message {
 public:
  CreateStorageClusterInput();
  virtual ~CreateStorageClusterInput();
  
  CreateStorageClusterInput(const CreateStorageClusterInput& from);
  
  inline CreateStorageClusterInput& operator=(const CreateStorageClusterInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateStorageClusterInput& default_instance();
  
  void Swap(CreateStorageClusterInput* other);
  
  // implements Message ----------------------------------------------
  
  CreateStorageClusterInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateStorageClusterInput& from);
  void MergeFrom(const CreateStorageClusterInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed64 clusterId = 1;
  inline bool has_clusterid() const;
  inline void clear_clusterid();
  static const int kClusterIdFieldNumber = 1;
  inline ::google::protobuf::uint64 clusterid() const;
  inline void set_clusterid(::google::protobuf::uint64 value);
  
  // required string clusterName = 2;
  inline bool has_clustername() const;
  inline void clear_clustername();
  static const int kClusterNameFieldNumber = 2;
  inline const ::std::string& clustername() const;
  inline void set_clustername(const ::std::string& value);
  inline void set_clustername(const char* value);
  inline void set_clustername(const char* value, size_t size);
  inline ::std::string* mutable_clustername();
  inline ::std::string* release_clustername();
  
  // optional int32 clusterType = 3;
  inline bool has_clustertype() const;
  inline void clear_clustertype();
  static const int kClusterTypeFieldNumber = 3;
  inline ::google::protobuf::int32 clustertype() const;
  inline void set_clustertype(::google::protobuf::int32 value);
  
  // optional string region = 4;
  inline bool has_region() const;
  inline void clear_region();
  static const int kRegionFieldNumber = 4;
  inline const ::std::string& region() const;
  inline void set_region(const ::std::string& value);
  inline void set_region(const char* value);
  inline void set_region(const char* value, size_t size);
  inline ::std::string* mutable_region();
  inline ::std::string* release_region();
  
  // optional string version = 5;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 5;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.CreateStorageClusterInput)
 private:
  inline void set_has_clusterid();
  inline void clear_has_clusterid();
  inline void set_has_clustername();
  inline void clear_has_clustername();
  inline void set_has_clustertype();
  inline void clear_has_clustertype();
  inline void set_has_region();
  inline void clear_has_region();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 clusterid_;
  ::std::string* clustername_;
  ::std::string* region_;
  ::std::string* version_;
  ::google::protobuf::int32 clustertype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static CreateStorageClusterInput* default_instance_;
};
// -------------------------------------------------------------------

class CreateStorageClusterOutput : public ::google::protobuf::Message {
 public:
  CreateStorageClusterOutput();
  virtual ~CreateStorageClusterOutput();
  
  CreateStorageClusterOutput(const CreateStorageClusterOutput& from);
  
  inline CreateStorageClusterOutput& operator=(const CreateStorageClusterOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateStorageClusterOutput& default_instance();
  
  void Swap(CreateStorageClusterOutput* other);
  
  // implements Message ----------------------------------------------
  
  CreateStorageClusterOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateStorageClusterOutput& from);
  void MergeFrom(const CreateStorageClusterOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.CreateStorageClusterOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static CreateStorageClusterOutput* default_instance_;
};
// -------------------------------------------------------------------

class GetMssInstancesForClusterInput : public ::google::protobuf::Message {
 public:
  GetMssInstancesForClusterInput();
  virtual ~GetMssInstancesForClusterInput();
  
  GetMssInstancesForClusterInput(const GetMssInstancesForClusterInput& from);
  
  inline GetMssInstancesForClusterInput& operator=(const GetMssInstancesForClusterInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetMssInstancesForClusterInput& default_instance();
  
  void Swap(GetMssInstancesForClusterInput* other);
  
  // implements Message ----------------------------------------------
  
  GetMssInstancesForClusterInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetMssInstancesForClusterInput& from);
  void MergeFrom(const GetMssInstancesForClusterInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed64 clusterId = 1;
  inline bool has_clusterid() const;
  inline void clear_clusterid();
  static const int kClusterIdFieldNumber = 1;
  inline ::google::protobuf::uint64 clusterid() const;
  inline void set_clusterid(::google::protobuf::uint64 value);
  
  // optional string version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetMssInstancesForClusterInput)
 private:
  inline void set_has_clusterid();
  inline void clear_has_clusterid();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 clusterid_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetMssInstancesForClusterInput* default_instance_;
};
// -------------------------------------------------------------------

class GetMssInstancesForClusterOutput : public ::google::protobuf::Message {
 public:
  GetMssInstancesForClusterOutput();
  virtual ~GetMssInstancesForClusterOutput();
  
  GetMssInstancesForClusterOutput(const GetMssInstancesForClusterOutput& from);
  
  inline GetMssInstancesForClusterOutput& operator=(const GetMssInstancesForClusterOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetMssInstancesForClusterOutput& default_instance();
  
  void Swap(GetMssInstancesForClusterOutput* other);
  
  // implements Message ----------------------------------------------
  
  GetMssInstancesForClusterOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetMssInstancesForClusterOutput& from);
  void MergeFrom(const GetMssInstancesForClusterOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // repeated .vplex.vsDirectory.MssDetail mssInstances = 2;
  inline int mssinstances_size() const;
  inline void clear_mssinstances();
  static const int kMssInstancesFieldNumber = 2;
  inline const ::vplex::vsDirectory::MssDetail& mssinstances(int index) const;
  inline ::vplex::vsDirectory::MssDetail* mutable_mssinstances(int index);
  inline ::vplex::vsDirectory::MssDetail* add_mssinstances();
  inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::MssDetail >&
      mssinstances() const;
  inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::MssDetail >*
      mutable_mssinstances();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetMssInstancesForClusterOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::MssDetail > mssinstances_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetMssInstancesForClusterOutput* default_instance_;
};
// -------------------------------------------------------------------

class GetStorageUnitsForClusterInput : public ::google::protobuf::Message {
 public:
  GetStorageUnitsForClusterInput();
  virtual ~GetStorageUnitsForClusterInput();
  
  GetStorageUnitsForClusterInput(const GetStorageUnitsForClusterInput& from);
  
  inline GetStorageUnitsForClusterInput& operator=(const GetStorageUnitsForClusterInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetStorageUnitsForClusterInput& default_instance();
  
  void Swap(GetStorageUnitsForClusterInput* other);
  
  // implements Message ----------------------------------------------
  
  GetStorageUnitsForClusterInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetStorageUnitsForClusterInput& from);
  void MergeFrom(const GetStorageUnitsForClusterInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed64 clusterId = 1;
  inline bool has_clusterid() const;
  inline void clear_clusterid();
  static const int kClusterIdFieldNumber = 1;
  inline ::google::protobuf::uint64 clusterid() const;
  inline void set_clusterid(::google::protobuf::uint64 value);
  
  // optional string version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetStorageUnitsForClusterInput)
 private:
  inline void set_has_clusterid();
  inline void clear_has_clusterid();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 clusterid_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetStorageUnitsForClusterInput* default_instance_;
};
// -------------------------------------------------------------------

class GetStorageUnitsForClusterOutput : public ::google::protobuf::Message {
 public:
  GetStorageUnitsForClusterOutput();
  virtual ~GetStorageUnitsForClusterOutput();
  
  GetStorageUnitsForClusterOutput(const GetStorageUnitsForClusterOutput& from);
  
  inline GetStorageUnitsForClusterOutput& operator=(const GetStorageUnitsForClusterOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetStorageUnitsForClusterOutput& default_instance();
  
  void Swap(GetStorageUnitsForClusterOutput* other);
  
  // implements Message ----------------------------------------------
  
  GetStorageUnitsForClusterOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetStorageUnitsForClusterOutput& from);
  void MergeFrom(const GetStorageUnitsForClusterOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // repeated .vplex.vsDirectory.StorageUnitDetail storageUnits = 2;
  inline int storageunits_size() const;
  inline void clear_storageunits();
  static const int kStorageUnitsFieldNumber = 2;
  inline const ::vplex::vsDirectory::StorageUnitDetail& storageunits(int index) const;
  inline ::vplex::vsDirectory::StorageUnitDetail* mutable_storageunits(int index);
  inline ::vplex::vsDirectory::StorageUnitDetail* add_storageunits();
  inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::StorageUnitDetail >&
      storageunits() const;
  inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::StorageUnitDetail >*
      mutable_storageunits();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetStorageUnitsForClusterOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::StorageUnitDetail > storageunits_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetStorageUnitsForClusterOutput* default_instance_;
};
// -------------------------------------------------------------------

class GetBrsInstancesForClusterInput : public ::google::protobuf::Message {
 public:
  GetBrsInstancesForClusterInput();
  virtual ~GetBrsInstancesForClusterInput();
  
  GetBrsInstancesForClusterInput(const GetBrsInstancesForClusterInput& from);
  
  inline GetBrsInstancesForClusterInput& operator=(const GetBrsInstancesForClusterInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetBrsInstancesForClusterInput& default_instance();
  
  void Swap(GetBrsInstancesForClusterInput* other);
  
  // implements Message ----------------------------------------------
  
  GetBrsInstancesForClusterInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetBrsInstancesForClusterInput& from);
  void MergeFrom(const GetBrsInstancesForClusterInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed64 clusterId = 1;
  inline bool has_clusterid() const;
  inline void clear_clusterid();
  static const int kClusterIdFieldNumber = 1;
  inline ::google::protobuf::uint64 clusterid() const;
  inline void set_clusterid(::google::protobuf::uint64 value);
  
  // optional string version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetBrsInstancesForClusterInput)
 private:
  inline void set_has_clusterid();
  inline void clear_has_clusterid();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 clusterid_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetBrsInstancesForClusterInput* default_instance_;
};
// -------------------------------------------------------------------

class GetBrsInstancesForClusterOutput : public ::google::protobuf::Message {
 public:
  GetBrsInstancesForClusterOutput();
  virtual ~GetBrsInstancesForClusterOutput();
  
  GetBrsInstancesForClusterOutput(const GetBrsInstancesForClusterOutput& from);
  
  inline GetBrsInstancesForClusterOutput& operator=(const GetBrsInstancesForClusterOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetBrsInstancesForClusterOutput& default_instance();
  
  void Swap(GetBrsInstancesForClusterOutput* other);
  
  // implements Message ----------------------------------------------
  
  GetBrsInstancesForClusterOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetBrsInstancesForClusterOutput& from);
  void MergeFrom(const GetBrsInstancesForClusterOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // repeated .vplex.vsDirectory.BrsDetail brsInstances = 2;
  inline int brsinstances_size() const;
  inline void clear_brsinstances();
  static const int kBrsInstancesFieldNumber = 2;
  inline const ::vplex::vsDirectory::BrsDetail& brsinstances(int index) const;
  inline ::vplex::vsDirectory::BrsDetail* mutable_brsinstances(int index);
  inline ::vplex::vsDirectory::BrsDetail* add_brsinstances();
  inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::BrsDetail >&
      brsinstances() const;
  inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::BrsDetail >*
      mutable_brsinstances();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetBrsInstancesForClusterOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::BrsDetail > brsinstances_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetBrsInstancesForClusterOutput* default_instance_;
};
// -------------------------------------------------------------------

class GetBrsStorageUnitsForClusterInput : public ::google::protobuf::Message {
 public:
  GetBrsStorageUnitsForClusterInput();
  virtual ~GetBrsStorageUnitsForClusterInput();
  
  GetBrsStorageUnitsForClusterInput(const GetBrsStorageUnitsForClusterInput& from);
  
  inline GetBrsStorageUnitsForClusterInput& operator=(const GetBrsStorageUnitsForClusterInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetBrsStorageUnitsForClusterInput& default_instance();
  
  void Swap(GetBrsStorageUnitsForClusterInput* other);
  
  // implements Message ----------------------------------------------
  
  GetBrsStorageUnitsForClusterInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetBrsStorageUnitsForClusterInput& from);
  void MergeFrom(const GetBrsStorageUnitsForClusterInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed64 clusterId = 1;
  inline bool has_clusterid() const;
  inline void clear_clusterid();
  static const int kClusterIdFieldNumber = 1;
  inline ::google::protobuf::uint64 clusterid() const;
  inline void set_clusterid(::google::protobuf::uint64 value);
  
  // optional string version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetBrsStorageUnitsForClusterInput)
 private:
  inline void set_has_clusterid();
  inline void clear_has_clusterid();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 clusterid_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetBrsStorageUnitsForClusterInput* default_instance_;
};
// -------------------------------------------------------------------

class GetBrsStorageUnitsForClusterOutput : public ::google::protobuf::Message {
 public:
  GetBrsStorageUnitsForClusterOutput();
  virtual ~GetBrsStorageUnitsForClusterOutput();
  
  GetBrsStorageUnitsForClusterOutput(const GetBrsStorageUnitsForClusterOutput& from);
  
  inline GetBrsStorageUnitsForClusterOutput& operator=(const GetBrsStorageUnitsForClusterOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetBrsStorageUnitsForClusterOutput& default_instance();
  
  void Swap(GetBrsStorageUnitsForClusterOutput* other);
  
  // implements Message ----------------------------------------------
  
  GetBrsStorageUnitsForClusterOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetBrsStorageUnitsForClusterOutput& from);
  void MergeFrom(const GetBrsStorageUnitsForClusterOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // repeated .vplex.vsDirectory.BrsStorageUnitDetail brsStorageUnits = 2;
  inline int brsstorageunits_size() const;
  inline void clear_brsstorageunits();
  static const int kBrsStorageUnitsFieldNumber = 2;
  inline const ::vplex::vsDirectory::BrsStorageUnitDetail& brsstorageunits(int index) const;
  inline ::vplex::vsDirectory::BrsStorageUnitDetail* mutable_brsstorageunits(int index);
  inline ::vplex::vsDirectory::BrsStorageUnitDetail* add_brsstorageunits();
  inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::BrsStorageUnitDetail >&
      brsstorageunits() const;
  inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::BrsStorageUnitDetail >*
      mutable_brsstorageunits();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetBrsStorageUnitsForClusterOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::BrsStorageUnitDetail > brsstorageunits_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetBrsStorageUnitsForClusterOutput* default_instance_;
};
// -------------------------------------------------------------------

class ChangeStorageAssignmentsForDatasetInput : public ::google::protobuf::Message {
 public:
  ChangeStorageAssignmentsForDatasetInput();
  virtual ~ChangeStorageAssignmentsForDatasetInput();
  
  ChangeStorageAssignmentsForDatasetInput(const ChangeStorageAssignmentsForDatasetInput& from);
  
  inline ChangeStorageAssignmentsForDatasetInput& operator=(const ChangeStorageAssignmentsForDatasetInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeStorageAssignmentsForDatasetInput& default_instance();
  
  void Swap(ChangeStorageAssignmentsForDatasetInput* other);
  
  // implements Message ----------------------------------------------
  
  ChangeStorageAssignmentsForDatasetInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangeStorageAssignmentsForDatasetInput& from);
  void MergeFrom(const ChangeStorageAssignmentsForDatasetInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed64 userId = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required fixed64 datasetId = 2;
  inline bool has_datasetid() const;
  inline void clear_datasetid();
  static const int kDatasetIdFieldNumber = 2;
  inline ::google::protobuf::uint64 datasetid() const;
  inline void set_datasetid(::google::protobuf::uint64 value);
  
  // required fixed64 clusterId = 3;
  inline bool has_clusterid() const;
  inline void clear_clusterid();
  static const int kClusterIdFieldNumber = 3;
  inline ::google::protobuf::uint64 clusterid() const;
  inline void set_clusterid(::google::protobuf::uint64 value);
  
  // required fixed64 primaryStorageId = 4;
  inline bool has_primarystorageid() const;
  inline void clear_primarystorageid();
  static const int kPrimaryStorageIdFieldNumber = 4;
  inline ::google::protobuf::uint64 primarystorageid() const;
  inline void set_primarystorageid(::google::protobuf::uint64 value);
  
  // required fixed64 secondaryStorageId = 5;
  inline bool has_secondarystorageid() const;
  inline void clear_secondarystorageid();
  static const int kSecondaryStorageIdFieldNumber = 5;
  inline ::google::protobuf::uint64 secondarystorageid() const;
  inline void set_secondarystorageid(::google::protobuf::uint64 value);
  
  // required fixed64 backupStorageId = 6;
  inline bool has_backupstorageid() const;
  inline void clear_backupstorageid();
  static const int kBackupStorageIdFieldNumber = 6;
  inline ::google::protobuf::uint64 backupstorageid() const;
  inline void set_backupstorageid(::google::protobuf::uint64 value);
  
  // optional string version = 7;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 7;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.ChangeStorageAssignmentsForDatasetInput)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_datasetid();
  inline void clear_has_datasetid();
  inline void set_has_clusterid();
  inline void clear_has_clusterid();
  inline void set_has_primarystorageid();
  inline void clear_has_primarystorageid();
  inline void set_has_secondarystorageid();
  inline void clear_has_secondarystorageid();
  inline void set_has_backupstorageid();
  inline void clear_has_backupstorageid();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 datasetid_;
  ::google::protobuf::uint64 clusterid_;
  ::google::protobuf::uint64 primarystorageid_;
  ::google::protobuf::uint64 secondarystorageid_;
  ::google::protobuf::uint64 backupstorageid_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static ChangeStorageAssignmentsForDatasetInput* default_instance_;
};
// -------------------------------------------------------------------

class ChangeStorageAssignmentsForDatasetOutput : public ::google::protobuf::Message {
 public:
  ChangeStorageAssignmentsForDatasetOutput();
  virtual ~ChangeStorageAssignmentsForDatasetOutput();
  
  ChangeStorageAssignmentsForDatasetOutput(const ChangeStorageAssignmentsForDatasetOutput& from);
  
  inline ChangeStorageAssignmentsForDatasetOutput& operator=(const ChangeStorageAssignmentsForDatasetOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeStorageAssignmentsForDatasetOutput& default_instance();
  
  void Swap(ChangeStorageAssignmentsForDatasetOutput* other);
  
  // implements Message ----------------------------------------------
  
  ChangeStorageAssignmentsForDatasetOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangeStorageAssignmentsForDatasetOutput& from);
  void MergeFrom(const ChangeStorageAssignmentsForDatasetOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.ChangeStorageAssignmentsForDatasetOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static ChangeStorageAssignmentsForDatasetOutput* default_instance_;
};
// -------------------------------------------------------------------

class UpdateDatasetStatusInput : public ::google::protobuf::Message {
 public:
  UpdateDatasetStatusInput();
  virtual ~UpdateDatasetStatusInput();
  
  UpdateDatasetStatusInput(const UpdateDatasetStatusInput& from);
  
  inline UpdateDatasetStatusInput& operator=(const UpdateDatasetStatusInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateDatasetStatusInput& default_instance();
  
  void Swap(UpdateDatasetStatusInput* other);
  
  // implements Message ----------------------------------------------
  
  UpdateDatasetStatusInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateDatasetStatusInput& from);
  void MergeFrom(const UpdateDatasetStatusInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed64 userId = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required fixed64 datasetId = 2;
  inline bool has_datasetid() const;
  inline void clear_datasetid();
  static const int kDatasetIdFieldNumber = 2;
  inline ::google::protobuf::uint64 datasetid() const;
  inline void set_datasetid(::google::protobuf::uint64 value);
  
  // required fixed64 clusterId = 3;
  inline bool has_clusterid() const;
  inline void clear_clusterid();
  static const int kClusterIdFieldNumber = 3;
  inline ::google::protobuf::uint64 clusterid() const;
  inline void set_clusterid(::google::protobuf::uint64 value);
  
  // required fixed64 storageId = 4;
  inline bool has_storageid() const;
  inline void clear_storageid();
  static const int kStorageIdFieldNumber = 4;
  inline ::google::protobuf::uint64 storageid() const;
  inline void set_storageid(::google::protobuf::uint64 value);
  
  // required fixed64 datasetSize = 5;
  inline bool has_datasetsize() const;
  inline void clear_datasetsize();
  static const int kDatasetSizeFieldNumber = 5;
  inline ::google::protobuf::uint64 datasetsize() const;
  inline void set_datasetsize(::google::protobuf::uint64 value);
  
  // required fixed64 datasetVersion = 6;
  inline bool has_datasetversion() const;
  inline void clear_datasetversion();
  static const int kDatasetVersionFieldNumber = 6;
  inline ::google::protobuf::uint64 datasetversion() const;
  inline void set_datasetversion(::google::protobuf::uint64 value);
  
  // optional string version = 7;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 7;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // optional bool ansNotificationOff = 8;
  inline bool has_ansnotificationoff() const;
  inline void clear_ansnotificationoff();
  static const int kAnsNotificationOffFieldNumber = 8;
  inline bool ansnotificationoff() const;
  inline void set_ansnotificationoff(bool value);
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.UpdateDatasetStatusInput)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_datasetid();
  inline void clear_has_datasetid();
  inline void set_has_clusterid();
  inline void clear_has_clusterid();
  inline void set_has_storageid();
  inline void clear_has_storageid();
  inline void set_has_datasetsize();
  inline void clear_has_datasetsize();
  inline void set_has_datasetversion();
  inline void clear_has_datasetversion();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_ansnotificationoff();
  inline void clear_has_ansnotificationoff();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 datasetid_;
  ::google::protobuf::uint64 clusterid_;
  ::google::protobuf::uint64 storageid_;
  ::google::protobuf::uint64 datasetsize_;
  ::google::protobuf::uint64 datasetversion_;
  ::std::string* version_;
  bool ansnotificationoff_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static UpdateDatasetStatusInput* default_instance_;
};
// -------------------------------------------------------------------

class UpdateDatasetStatusOutput : public ::google::protobuf::Message {
 public:
  UpdateDatasetStatusOutput();
  virtual ~UpdateDatasetStatusOutput();
  
  UpdateDatasetStatusOutput(const UpdateDatasetStatusOutput& from);
  
  inline UpdateDatasetStatusOutput& operator=(const UpdateDatasetStatusOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateDatasetStatusOutput& default_instance();
  
  void Swap(UpdateDatasetStatusOutput* other);
  
  // implements Message ----------------------------------------------
  
  UpdateDatasetStatusOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateDatasetStatusOutput& from);
  void MergeFrom(const UpdateDatasetStatusOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.UpdateDatasetStatusOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static UpdateDatasetStatusOutput* default_instance_;
};
// -------------------------------------------------------------------

class UpdateDatasetBackupStatusInput : public ::google::protobuf::Message {
 public:
  UpdateDatasetBackupStatusInput();
  virtual ~UpdateDatasetBackupStatusInput();
  
  UpdateDatasetBackupStatusInput(const UpdateDatasetBackupStatusInput& from);
  
  inline UpdateDatasetBackupStatusInput& operator=(const UpdateDatasetBackupStatusInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateDatasetBackupStatusInput& default_instance();
  
  void Swap(UpdateDatasetBackupStatusInput* other);
  
  // implements Message ----------------------------------------------
  
  UpdateDatasetBackupStatusInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateDatasetBackupStatusInput& from);
  void MergeFrom(const UpdateDatasetBackupStatusInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed64 userId = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required fixed64 datasetId = 2;
  inline bool has_datasetid() const;
  inline void clear_datasetid();
  static const int kDatasetIdFieldNumber = 2;
  inline ::google::protobuf::uint64 datasetid() const;
  inline void set_datasetid(::google::protobuf::uint64 value);
  
  // required fixed64 clusterId = 3;
  inline bool has_clusterid() const;
  inline void clear_clusterid();
  static const int kClusterIdFieldNumber = 3;
  inline ::google::protobuf::uint64 clusterid() const;
  inline void set_clusterid(::google::protobuf::uint64 value);
  
  // required fixed64 backupStorageId = 4;
  inline bool has_backupstorageid() const;
  inline void clear_backupstorageid();
  static const int kBackupStorageIdFieldNumber = 4;
  inline ::google::protobuf::uint64 backupstorageid() const;
  inline void set_backupstorageid(::google::protobuf::uint64 value);
  
  // required fixed64 datasetVersion = 5;
  inline bool has_datasetversion() const;
  inline void clear_datasetversion();
  static const int kDatasetVersionFieldNumber = 5;
  inline ::google::protobuf::uint64 datasetversion() const;
  inline void set_datasetversion(::google::protobuf::uint64 value);
  
  // optional string version = 6;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 6;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.UpdateDatasetBackupStatusInput)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_datasetid();
  inline void clear_has_datasetid();
  inline void set_has_clusterid();
  inline void clear_has_clusterid();
  inline void set_has_backupstorageid();
  inline void clear_has_backupstorageid();
  inline void set_has_datasetversion();
  inline void clear_has_datasetversion();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 datasetid_;
  ::google::protobuf::uint64 clusterid_;
  ::google::protobuf::uint64 backupstorageid_;
  ::google::protobuf::uint64 datasetversion_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static UpdateDatasetBackupStatusInput* default_instance_;
};
// -------------------------------------------------------------------

class UpdateDatasetBackupStatusOutput : public ::google::protobuf::Message {
 public:
  UpdateDatasetBackupStatusOutput();
  virtual ~UpdateDatasetBackupStatusOutput();
  
  UpdateDatasetBackupStatusOutput(const UpdateDatasetBackupStatusOutput& from);
  
  inline UpdateDatasetBackupStatusOutput& operator=(const UpdateDatasetBackupStatusOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateDatasetBackupStatusOutput& default_instance();
  
  void Swap(UpdateDatasetBackupStatusOutput* other);
  
  // implements Message ----------------------------------------------
  
  UpdateDatasetBackupStatusOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateDatasetBackupStatusOutput& from);
  void MergeFrom(const UpdateDatasetBackupStatusOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.UpdateDatasetBackupStatusOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static UpdateDatasetBackupStatusOutput* default_instance_;
};
// -------------------------------------------------------------------

class UpdateDatasetArchiveStatusInput : public ::google::protobuf::Message {
 public:
  UpdateDatasetArchiveStatusInput();
  virtual ~UpdateDatasetArchiveStatusInput();
  
  UpdateDatasetArchiveStatusInput(const UpdateDatasetArchiveStatusInput& from);
  
  inline UpdateDatasetArchiveStatusInput& operator=(const UpdateDatasetArchiveStatusInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateDatasetArchiveStatusInput& default_instance();
  
  void Swap(UpdateDatasetArchiveStatusInput* other);
  
  // implements Message ----------------------------------------------
  
  UpdateDatasetArchiveStatusInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateDatasetArchiveStatusInput& from);
  void MergeFrom(const UpdateDatasetArchiveStatusInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed64 userId = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required fixed64 datasetId = 2;
  inline bool has_datasetid() const;
  inline void clear_datasetid();
  static const int kDatasetIdFieldNumber = 2;
  inline ::google::protobuf::uint64 datasetid() const;
  inline void set_datasetid(::google::protobuf::uint64 value);
  
  // required fixed64 clusterId = 3;
  inline bool has_clusterid() const;
  inline void clear_clusterid();
  static const int kClusterIdFieldNumber = 3;
  inline ::google::protobuf::uint64 clusterid() const;
  inline void set_clusterid(::google::protobuf::uint64 value);
  
  // required fixed64 backupStorageId = 4;
  inline bool has_backupstorageid() const;
  inline void clear_backupstorageid();
  static const int kBackupStorageIdFieldNumber = 4;
  inline ::google::protobuf::uint64 backupstorageid() const;
  inline void set_backupstorageid(::google::protobuf::uint64 value);
  
  // required fixed64 datasetVersion = 5;
  inline bool has_datasetversion() const;
  inline void clear_datasetversion();
  static const int kDatasetVersionFieldNumber = 5;
  inline ::google::protobuf::uint64 datasetversion() const;
  inline void set_datasetversion(::google::protobuf::uint64 value);
  
  // optional string version = 6;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 6;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.UpdateDatasetArchiveStatusInput)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_datasetid();
  inline void clear_has_datasetid();
  inline void set_has_clusterid();
  inline void clear_has_clusterid();
  inline void set_has_backupstorageid();
  inline void clear_has_backupstorageid();
  inline void set_has_datasetversion();
  inline void clear_has_datasetversion();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 datasetid_;
  ::google::protobuf::uint64 clusterid_;
  ::google::protobuf::uint64 backupstorageid_;
  ::google::protobuf::uint64 datasetversion_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static UpdateDatasetArchiveStatusInput* default_instance_;
};
// -------------------------------------------------------------------

class UpdateDatasetArchiveStatusOutput : public ::google::protobuf::Message {
 public:
  UpdateDatasetArchiveStatusOutput();
  virtual ~UpdateDatasetArchiveStatusOutput();
  
  UpdateDatasetArchiveStatusOutput(const UpdateDatasetArchiveStatusOutput& from);
  
  inline UpdateDatasetArchiveStatusOutput& operator=(const UpdateDatasetArchiveStatusOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateDatasetArchiveStatusOutput& default_instance();
  
  void Swap(UpdateDatasetArchiveStatusOutput* other);
  
  // implements Message ----------------------------------------------
  
  UpdateDatasetArchiveStatusOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateDatasetArchiveStatusOutput& from);
  void MergeFrom(const UpdateDatasetArchiveStatusOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.UpdateDatasetArchiveStatusOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static UpdateDatasetArchiveStatusOutput* default_instance_;
};
// -------------------------------------------------------------------

class GetDatasetStatusInput : public ::google::protobuf::Message {
 public:
  GetDatasetStatusInput();
  virtual ~GetDatasetStatusInput();
  
  GetDatasetStatusInput(const GetDatasetStatusInput& from);
  
  inline GetDatasetStatusInput& operator=(const GetDatasetStatusInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetDatasetStatusInput& default_instance();
  
  void Swap(GetDatasetStatusInput* other);
  
  // implements Message ----------------------------------------------
  
  GetDatasetStatusInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetDatasetStatusInput& from);
  void MergeFrom(const GetDatasetStatusInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed64 userId = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required fixed64 datasetId = 2;
  inline bool has_datasetid() const;
  inline void clear_datasetid();
  static const int kDatasetIdFieldNumber = 2;
  inline ::google::protobuf::uint64 datasetid() const;
  inline void set_datasetid(::google::protobuf::uint64 value);
  
  // optional string version = 3;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 3;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetDatasetStatusInput)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_datasetid();
  inline void clear_has_datasetid();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 datasetid_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetDatasetStatusInput* default_instance_;
};
// -------------------------------------------------------------------

class GetDatasetStatusOutput : public ::google::protobuf::Message {
 public:
  GetDatasetStatusOutput();
  virtual ~GetDatasetStatusOutput();
  
  GetDatasetStatusOutput(const GetDatasetStatusOutput& from);
  
  inline GetDatasetStatusOutput& operator=(const GetDatasetStatusOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetDatasetStatusOutput& default_instance();
  
  void Swap(GetDatasetStatusOutput* other);
  
  // implements Message ----------------------------------------------
  
  GetDatasetStatusOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetDatasetStatusOutput& from);
  void MergeFrom(const GetDatasetStatusOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // optional fixed64 clusterId = 2;
  inline bool has_clusterid() const;
  inline void clear_clusterid();
  static const int kClusterIdFieldNumber = 2;
  inline ::google::protobuf::uint64 clusterid() const;
  inline void set_clusterid(::google::protobuf::uint64 value);
  
  // optional fixed64 primaryStorageId = 3;
  inline bool has_primarystorageid() const;
  inline void clear_primarystorageid();
  static const int kPrimaryStorageIdFieldNumber = 3;
  inline ::google::protobuf::uint64 primarystorageid() const;
  inline void set_primarystorageid(::google::protobuf::uint64 value);
  
  // optional fixed64 primaryDatasetSize = 4;
  inline bool has_primarydatasetsize() const;
  inline void clear_primarydatasetsize();
  static const int kPrimaryDatasetSizeFieldNumber = 4;
  inline ::google::protobuf::uint64 primarydatasetsize() const;
  inline void set_primarydatasetsize(::google::protobuf::uint64 value);
  
  // optional fixed64 primaryDatasetVersion = 5;
  inline bool has_primarydatasetversion() const;
  inline void clear_primarydatasetversion();
  static const int kPrimaryDatasetVersionFieldNumber = 5;
  inline ::google::protobuf::uint64 primarydatasetversion() const;
  inline void set_primarydatasetversion(::google::protobuf::uint64 value);
  
  // optional fixed64 secondaryStorageId = 6;
  inline bool has_secondarystorageid() const;
  inline void clear_secondarystorageid();
  static const int kSecondaryStorageIdFieldNumber = 6;
  inline ::google::protobuf::uint64 secondarystorageid() const;
  inline void set_secondarystorageid(::google::protobuf::uint64 value);
  
  // optional fixed64 secondaryDatasetSize = 7;
  inline bool has_secondarydatasetsize() const;
  inline void clear_secondarydatasetsize();
  static const int kSecondaryDatasetSizeFieldNumber = 7;
  inline ::google::protobuf::uint64 secondarydatasetsize() const;
  inline void set_secondarydatasetsize(::google::protobuf::uint64 value);
  
  // optional fixed64 secondaryDatasetVersion = 8;
  inline bool has_secondarydatasetversion() const;
  inline void clear_secondarydatasetversion();
  static const int kSecondaryDatasetVersionFieldNumber = 8;
  inline ::google::protobuf::uint64 secondarydatasetversion() const;
  inline void set_secondarydatasetversion(::google::protobuf::uint64 value);
  
  // optional fixed64 backupStorageId = 9;
  inline bool has_backupstorageid() const;
  inline void clear_backupstorageid();
  static const int kBackupStorageIdFieldNumber = 9;
  inline ::google::protobuf::uint64 backupstorageid() const;
  inline void set_backupstorageid(::google::protobuf::uint64 value);
  
  // optional .vplex.vsDirectory.DatasetType datasetType = 10;
  inline bool has_datasettype() const;
  inline void clear_datasettype();
  static const int kDatasetTypeFieldNumber = 10;
  inline vplex::vsDirectory::DatasetType datasettype() const;
  inline void set_datasettype(vplex::vsDirectory::DatasetType value);
  
  // optional fixed64 deleteDataAfter = 11;
  inline bool has_deletedataafter() const;
  inline void clear_deletedataafter();
  static const int kDeleteDataAfterFieldNumber = 11;
  inline ::google::protobuf::uint64 deletedataafter() const;
  inline void set_deletedataafter(::google::protobuf::uint64 value);
  
  // optional fixed64 backupDatasetVersion = 12;
  inline bool has_backupdatasetversion() const;
  inline void clear_backupdatasetversion();
  static const int kBackupDatasetVersionFieldNumber = 12;
  inline ::google::protobuf::uint64 backupdatasetversion() const;
  inline void set_backupdatasetversion(::google::protobuf::uint64 value);
  
  // optional fixed64 archiveDatasetVersion = 13;
  inline bool has_archivedatasetversion() const;
  inline void clear_archivedatasetversion();
  static const int kArchiveDatasetVersionFieldNumber = 13;
  inline ::google::protobuf::uint64 archivedatasetversion() const;
  inline void set_archivedatasetversion(::google::protobuf::uint64 value);
  
  // optional bool suspendedFlag = 14;
  inline bool has_suspendedflag() const;
  inline void clear_suspendedflag();
  static const int kSuspendedFlagFieldNumber = 14;
  inline bool suspendedflag() const;
  inline void set_suspendedflag(bool value);
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetDatasetStatusOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_clusterid();
  inline void clear_has_clusterid();
  inline void set_has_primarystorageid();
  inline void clear_has_primarystorageid();
  inline void set_has_primarydatasetsize();
  inline void clear_has_primarydatasetsize();
  inline void set_has_primarydatasetversion();
  inline void clear_has_primarydatasetversion();
  inline void set_has_secondarystorageid();
  inline void clear_has_secondarystorageid();
  inline void set_has_secondarydatasetsize();
  inline void clear_has_secondarydatasetsize();
  inline void set_has_secondarydatasetversion();
  inline void clear_has_secondarydatasetversion();
  inline void set_has_backupstorageid();
  inline void clear_has_backupstorageid();
  inline void set_has_datasettype();
  inline void clear_has_datasettype();
  inline void set_has_deletedataafter();
  inline void clear_has_deletedataafter();
  inline void set_has_backupdatasetversion();
  inline void clear_has_backupdatasetversion();
  inline void set_has_archivedatasetversion();
  inline void clear_has_archivedatasetversion();
  inline void set_has_suspendedflag();
  inline void clear_has_suspendedflag();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  ::google::protobuf::uint64 clusterid_;
  ::google::protobuf::uint64 primarystorageid_;
  ::google::protobuf::uint64 primarydatasetsize_;
  ::google::protobuf::uint64 primarydatasetversion_;
  ::google::protobuf::uint64 secondarystorageid_;
  ::google::protobuf::uint64 secondarydatasetsize_;
  ::google::protobuf::uint64 secondarydatasetversion_;
  ::google::protobuf::uint64 backupstorageid_;
  ::google::protobuf::uint64 deletedataafter_;
  ::google::protobuf::uint64 backupdatasetversion_;
  int datasettype_;
  bool suspendedflag_;
  ::google::protobuf::uint64 archivedatasetversion_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetDatasetStatusOutput* default_instance_;
};
// -------------------------------------------------------------------

class StoreDeviceEventInput : public ::google::protobuf::Message {
 public:
  StoreDeviceEventInput();
  virtual ~StoreDeviceEventInput();
  
  StoreDeviceEventInput(const StoreDeviceEventInput& from);
  
  inline StoreDeviceEventInput& operator=(const StoreDeviceEventInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StoreDeviceEventInput& default_instance();
  
  void Swap(StoreDeviceEventInput* other);
  
  // implements Message ----------------------------------------------
  
  StoreDeviceEventInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StoreDeviceEventInput& from);
  void MergeFrom(const StoreDeviceEventInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.SessionInfo session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required fixed64 deviceId = 3;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIdFieldNumber = 3;
  inline ::google::protobuf::uint64 deviceid() const;
  inline void set_deviceid(::google::protobuf::uint64 value);
  
  // repeated .vplex.vsDirectory.EventInfo eventInfos = 4;
  inline int eventinfos_size() const;
  inline void clear_eventinfos();
  static const int kEventInfosFieldNumber = 4;
  inline const ::vplex::vsDirectory::EventInfo& eventinfos(int index) const;
  inline ::vplex::vsDirectory::EventInfo* mutable_eventinfos(int index);
  inline ::vplex::vsDirectory::EventInfo* add_eventinfos();
  inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::EventInfo >&
      eventinfos() const;
  inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::EventInfo >*
      mutable_eventinfos();
  
  // optional string version = 5;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 5;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.StoreDeviceEventInput)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 deviceid_;
  ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::EventInfo > eventinfos_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static StoreDeviceEventInput* default_instance_;
};
// -------------------------------------------------------------------

class StoreDeviceEventOutput : public ::google::protobuf::Message {
 public:
  StoreDeviceEventOutput();
  virtual ~StoreDeviceEventOutput();
  
  StoreDeviceEventOutput(const StoreDeviceEventOutput& from);
  
  inline StoreDeviceEventOutput& operator=(const StoreDeviceEventOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StoreDeviceEventOutput& default_instance();
  
  void Swap(StoreDeviceEventOutput* other);
  
  // implements Message ----------------------------------------------
  
  StoreDeviceEventOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StoreDeviceEventOutput& from);
  void MergeFrom(const StoreDeviceEventOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // optional fixed32 successCount = 2;
  inline bool has_successcount() const;
  inline void clear_successcount();
  static const int kSuccessCountFieldNumber = 2;
  inline ::google::protobuf::uint32 successcount() const;
  inline void set_successcount(::google::protobuf::uint32 value);
  
  // optional fixed32 errorCount = 3;
  inline bool has_errorcount() const;
  inline void clear_errorcount();
  static const int kErrorCountFieldNumber = 3;
  inline ::google::protobuf::uint32 errorcount() const;
  inline void set_errorcount(::google::protobuf::uint32 value);
  
  // optional fixed32 nextReportTime = 4;
  inline bool has_nextreporttime() const;
  inline void clear_nextreporttime();
  static const int kNextReportTimeFieldNumber = 4;
  inline ::google::protobuf::uint32 nextreporttime() const;
  inline void set_nextreporttime(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.StoreDeviceEventOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_successcount();
  inline void clear_has_successcount();
  inline void set_has_errorcount();
  inline void clear_has_errorcount();
  inline void set_has_nextreporttime();
  inline void clear_has_nextreporttime();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  ::google::protobuf::uint32 successcount_;
  ::google::protobuf::uint32 errorcount_;
  ::google::protobuf::uint32 nextreporttime_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static StoreDeviceEventOutput* default_instance_;
};
// -------------------------------------------------------------------

class EventInfo : public ::google::protobuf::Message {
 public:
  EventInfo();
  virtual ~EventInfo();
  
  EventInfo(const EventInfo& from);
  
  inline EventInfo& operator=(const EventInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const EventInfo& default_instance();
  
  void Swap(EventInfo* other);
  
  // implements Message ----------------------------------------------
  
  EventInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EventInfo& from);
  void MergeFrom(const EventInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string appId = 1;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIdFieldNumber = 1;
  inline const ::std::string& appid() const;
  inline void set_appid(const ::std::string& value);
  inline void set_appid(const char* value);
  inline void set_appid(const char* value, size_t size);
  inline ::std::string* mutable_appid();
  inline ::std::string* release_appid();
  
  // required string eventId = 2;
  inline bool has_eventid() const;
  inline void clear_eventid();
  static const int kEventIdFieldNumber = 2;
  inline const ::std::string& eventid() const;
  inline void set_eventid(const ::std::string& value);
  inline void set_eventid(const char* value);
  inline void set_eventid(const char* value, size_t size);
  inline ::std::string* mutable_eventid();
  inline ::std::string* release_eventid();
  
  // required fixed64 startTime = 3;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 3;
  inline ::google::protobuf::uint64 starttime() const;
  inline void set_starttime(::google::protobuf::uint64 value);
  
  // optional fixed64 endTime = 4;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 4;
  inline ::google::protobuf::uint64 endtime() const;
  inline void set_endtime(::google::protobuf::uint64 value);
  
  // optional fixed32 eventCount = 5;
  inline bool has_eventcount() const;
  inline void clear_eventcount();
  static const int kEventCountFieldNumber = 5;
  inline ::google::protobuf::uint32 eventcount() const;
  inline void set_eventcount(::google::protobuf::uint32 value);
  
  // optional bool limitReached = 6;
  inline bool has_limitreached() const;
  inline void clear_limitreached();
  static const int kLimitReachedFieldNumber = 6;
  inline bool limitreached() const;
  inline void set_limitreached(bool value);
  
  // optional string eventInfo = 7;
  inline bool has_eventinfo() const;
  inline void clear_eventinfo();
  static const int kEventInfoFieldNumber = 7;
  inline const ::std::string& eventinfo() const;
  inline void set_eventinfo(const ::std::string& value);
  inline void set_eventinfo(const char* value);
  inline void set_eventinfo(const char* value, size_t size);
  inline ::std::string* mutable_eventinfo();
  inline ::std::string* release_eventinfo();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.EventInfo)
 private:
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_eventid();
  inline void clear_has_eventid();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_eventcount();
  inline void clear_has_eventcount();
  inline void set_has_limitreached();
  inline void clear_has_limitreached();
  inline void set_has_eventinfo();
  inline void clear_has_eventinfo();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* appid_;
  ::std::string* eventid_;
  ::google::protobuf::uint64 starttime_;
  ::google::protobuf::uint64 endtime_;
  ::google::protobuf::uint32 eventcount_;
  bool limitreached_;
  ::std::string* eventinfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static EventInfo* default_instance_;
};
// -------------------------------------------------------------------

class GetLinkedDatasetStatusInput : public ::google::protobuf::Message {
 public:
  GetLinkedDatasetStatusInput();
  virtual ~GetLinkedDatasetStatusInput();
  
  GetLinkedDatasetStatusInput(const GetLinkedDatasetStatusInput& from);
  
  inline GetLinkedDatasetStatusInput& operator=(const GetLinkedDatasetStatusInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetLinkedDatasetStatusInput& default_instance();
  
  void Swap(GetLinkedDatasetStatusInput* other);
  
  // implements Message ----------------------------------------------
  
  GetLinkedDatasetStatusInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetLinkedDatasetStatusInput& from);
  void MergeFrom(const GetLinkedDatasetStatusInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed64 userId = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required fixed64 datasetId = 2;
  inline bool has_datasetid() const;
  inline void clear_datasetid();
  static const int kDatasetIdFieldNumber = 2;
  inline ::google::protobuf::uint64 datasetid() const;
  inline void set_datasetid(::google::protobuf::uint64 value);
  
  // optional string version = 3;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 3;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetLinkedDatasetStatusInput)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_datasetid();
  inline void clear_has_datasetid();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 datasetid_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetLinkedDatasetStatusInput* default_instance_;
};
// -------------------------------------------------------------------

class GetLinkedDatasetStatusOutput : public ::google::protobuf::Message {
 public:
  GetLinkedDatasetStatusOutput();
  virtual ~GetLinkedDatasetStatusOutput();
  
  GetLinkedDatasetStatusOutput(const GetLinkedDatasetStatusOutput& from);
  
  inline GetLinkedDatasetStatusOutput& operator=(const GetLinkedDatasetStatusOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetLinkedDatasetStatusOutput& default_instance();
  
  void Swap(GetLinkedDatasetStatusOutput* other);
  
  // implements Message ----------------------------------------------
  
  GetLinkedDatasetStatusOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetLinkedDatasetStatusOutput& from);
  void MergeFrom(const GetLinkedDatasetStatusOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // optional fixed64 linkedDatasetId = 2;
  inline bool has_linkeddatasetid() const;
  inline void clear_linkeddatasetid();
  static const int kLinkedDatasetIdFieldNumber = 2;
  inline ::google::protobuf::uint64 linkeddatasetid() const;
  inline void set_linkeddatasetid(::google::protobuf::uint64 value);
  
  // optional fixed64 clusterId = 3;
  inline bool has_clusterid() const;
  inline void clear_clusterid();
  static const int kClusterIdFieldNumber = 3;
  inline ::google::protobuf::uint64 clusterid() const;
  inline void set_clusterid(::google::protobuf::uint64 value);
  
  // optional fixed64 primaryStorageId = 4;
  inline bool has_primarystorageid() const;
  inline void clear_primarystorageid();
  static const int kPrimaryStorageIdFieldNumber = 4;
  inline ::google::protobuf::uint64 primarystorageid() const;
  inline void set_primarystorageid(::google::protobuf::uint64 value);
  
  // optional fixed64 primaryDatasetSize = 5;
  inline bool has_primarydatasetsize() const;
  inline void clear_primarydatasetsize();
  static const int kPrimaryDatasetSizeFieldNumber = 5;
  inline ::google::protobuf::uint64 primarydatasetsize() const;
  inline void set_primarydatasetsize(::google::protobuf::uint64 value);
  
  // optional fixed64 primaryDatasetVersion = 6;
  inline bool has_primarydatasetversion() const;
  inline void clear_primarydatasetversion();
  static const int kPrimaryDatasetVersionFieldNumber = 6;
  inline ::google::protobuf::uint64 primarydatasetversion() const;
  inline void set_primarydatasetversion(::google::protobuf::uint64 value);
  
  // optional fixed64 secondaryStorageId = 7;
  inline bool has_secondarystorageid() const;
  inline void clear_secondarystorageid();
  static const int kSecondaryStorageIdFieldNumber = 7;
  inline ::google::protobuf::uint64 secondarystorageid() const;
  inline void set_secondarystorageid(::google::protobuf::uint64 value);
  
  // optional fixed64 secondaryDatasetSize = 8;
  inline bool has_secondarydatasetsize() const;
  inline void clear_secondarydatasetsize();
  static const int kSecondaryDatasetSizeFieldNumber = 8;
  inline ::google::protobuf::uint64 secondarydatasetsize() const;
  inline void set_secondarydatasetsize(::google::protobuf::uint64 value);
  
  // optional fixed64 secondaryDatasetVersion = 9;
  inline bool has_secondarydatasetversion() const;
  inline void clear_secondarydatasetversion();
  static const int kSecondaryDatasetVersionFieldNumber = 9;
  inline ::google::protobuf::uint64 secondarydatasetversion() const;
  inline void set_secondarydatasetversion(::google::protobuf::uint64 value);
  
  // optional fixed64 backupStorageId = 10;
  inline bool has_backupstorageid() const;
  inline void clear_backupstorageid();
  static const int kBackupStorageIdFieldNumber = 10;
  inline ::google::protobuf::uint64 backupstorageid() const;
  inline void set_backupstorageid(::google::protobuf::uint64 value);
  
  // optional .vplex.vsDirectory.DatasetType datasetType = 11;
  inline bool has_datasettype() const;
  inline void clear_datasettype();
  static const int kDatasetTypeFieldNumber = 11;
  inline vplex::vsDirectory::DatasetType datasettype() const;
  inline void set_datasettype(vplex::vsDirectory::DatasetType value);
  
  // optional bool suspendedFlag = 12;
  inline bool has_suspendedflag() const;
  inline void clear_suspendedflag();
  static const int kSuspendedFlagFieldNumber = 12;
  inline bool suspendedflag() const;
  inline void set_suspendedflag(bool value);
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetLinkedDatasetStatusOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_linkeddatasetid();
  inline void clear_has_linkeddatasetid();
  inline void set_has_clusterid();
  inline void clear_has_clusterid();
  inline void set_has_primarystorageid();
  inline void clear_has_primarystorageid();
  inline void set_has_primarydatasetsize();
  inline void clear_has_primarydatasetsize();
  inline void set_has_primarydatasetversion();
  inline void clear_has_primarydatasetversion();
  inline void set_has_secondarystorageid();
  inline void clear_has_secondarystorageid();
  inline void set_has_secondarydatasetsize();
  inline void clear_has_secondarydatasetsize();
  inline void set_has_secondarydatasetversion();
  inline void clear_has_secondarydatasetversion();
  inline void set_has_backupstorageid();
  inline void clear_has_backupstorageid();
  inline void set_has_datasettype();
  inline void clear_has_datasettype();
  inline void set_has_suspendedflag();
  inline void clear_has_suspendedflag();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  ::google::protobuf::uint64 linkeddatasetid_;
  ::google::protobuf::uint64 clusterid_;
  ::google::protobuf::uint64 primarystorageid_;
  ::google::protobuf::uint64 primarydatasetsize_;
  ::google::protobuf::uint64 primarydatasetversion_;
  ::google::protobuf::uint64 secondarystorageid_;
  ::google::protobuf::uint64 secondarydatasetsize_;
  ::google::protobuf::uint64 secondarydatasetversion_;
  ::google::protobuf::uint64 backupstorageid_;
  int datasettype_;
  bool suspendedflag_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetLinkedDatasetStatusOutput* default_instance_;
};
// -------------------------------------------------------------------

class GetUserQuotaStatusInput : public ::google::protobuf::Message {
 public:
  GetUserQuotaStatusInput();
  virtual ~GetUserQuotaStatusInput();
  
  GetUserQuotaStatusInput(const GetUserQuotaStatusInput& from);
  
  inline GetUserQuotaStatusInput& operator=(const GetUserQuotaStatusInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetUserQuotaStatusInput& default_instance();
  
  void Swap(GetUserQuotaStatusInput* other);
  
  // implements Message ----------------------------------------------
  
  GetUserQuotaStatusInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetUserQuotaStatusInput& from);
  void MergeFrom(const GetUserQuotaStatusInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed64 userId = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required fixed64 clusterId = 2;
  inline bool has_clusterid() const;
  inline void clear_clusterid();
  static const int kClusterIdFieldNumber = 2;
  inline ::google::protobuf::uint64 clusterid() const;
  inline void set_clusterid(::google::protobuf::uint64 value);
  
  // optional string version = 3;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 3;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetUserQuotaStatusInput)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_clusterid();
  inline void clear_has_clusterid();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 clusterid_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetUserQuotaStatusInput* default_instance_;
};
// -------------------------------------------------------------------

class GetUserQuotaStatusOutput : public ::google::protobuf::Message {
 public:
  GetUserQuotaStatusOutput();
  virtual ~GetUserQuotaStatusOutput();
  
  GetUserQuotaStatusOutput(const GetUserQuotaStatusOutput& from);
  
  inline GetUserQuotaStatusOutput& operator=(const GetUserQuotaStatusOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetUserQuotaStatusOutput& default_instance();
  
  void Swap(GetUserQuotaStatusOutput* other);
  
  // implements Message ----------------------------------------------
  
  GetUserQuotaStatusOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetUserQuotaStatusOutput& from);
  void MergeFrom(const GetUserQuotaStatusOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // optional fixed64 quotaLimit = 2;
  inline bool has_quotalimit() const;
  inline void clear_quotalimit();
  static const int kQuotaLimitFieldNumber = 2;
  inline ::google::protobuf::uint64 quotalimit() const;
  inline void set_quotalimit(::google::protobuf::uint64 value);
  
  // optional fixed64 currentUsage = 3;
  inline bool has_currentusage() const;
  inline void clear_currentusage();
  static const int kCurrentUsageFieldNumber = 3;
  inline ::google::protobuf::uint64 currentusage() const;
  inline void set_currentusage(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetUserQuotaStatusOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_quotalimit();
  inline void clear_has_quotalimit();
  inline void set_has_currentusage();
  inline void clear_has_currentusage();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  ::google::protobuf::uint64 quotalimit_;
  ::google::protobuf::uint64 currentusage_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetUserQuotaStatusOutput* default_instance_;
};
// -------------------------------------------------------------------

class GetDatasetsToBackupInput : public ::google::protobuf::Message {
 public:
  GetDatasetsToBackupInput();
  virtual ~GetDatasetsToBackupInput();
  
  GetDatasetsToBackupInput(const GetDatasetsToBackupInput& from);
  
  inline GetDatasetsToBackupInput& operator=(const GetDatasetsToBackupInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetDatasetsToBackupInput& default_instance();
  
  void Swap(GetDatasetsToBackupInput* other);
  
  // implements Message ----------------------------------------------
  
  GetDatasetsToBackupInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetDatasetsToBackupInput& from);
  void MergeFrom(const GetDatasetsToBackupInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed64 backupStorageId = 1;
  inline bool has_backupstorageid() const;
  inline void clear_backupstorageid();
  static const int kBackupStorageIdFieldNumber = 1;
  inline ::google::protobuf::uint64 backupstorageid() const;
  inline void set_backupstorageid(::google::protobuf::uint64 value);
  
  // required fixed64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required fixed64 datasetId = 3;
  inline bool has_datasetid() const;
  inline void clear_datasetid();
  static const int kDatasetIdFieldNumber = 3;
  inline ::google::protobuf::uint64 datasetid() const;
  inline void set_datasetid(::google::protobuf::uint64 value);
  
  // required fixed32 count = 4;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 4;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);
  
  // optional fixed64 clusterId = 5;
  inline bool has_clusterid() const;
  inline void clear_clusterid();
  static const int kClusterIdFieldNumber = 5;
  inline ::google::protobuf::uint64 clusterid() const;
  inline void set_clusterid(::google::protobuf::uint64 value);
  
  // optional string version = 6;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 6;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetDatasetsToBackupInput)
 private:
  inline void set_has_backupstorageid();
  inline void clear_has_backupstorageid();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_datasetid();
  inline void clear_has_datasetid();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_clusterid();
  inline void clear_has_clusterid();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 backupstorageid_;
  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint64 datasetid_;
  ::google::protobuf::uint64 clusterid_;
  ::std::string* version_;
  ::google::protobuf::uint32 count_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetDatasetsToBackupInput* default_instance_;
};
// -------------------------------------------------------------------

class GetDatasetsToBackupOutput : public ::google::protobuf::Message {
 public:
  GetDatasetsToBackupOutput();
  virtual ~GetDatasetsToBackupOutput();
  
  GetDatasetsToBackupOutput(const GetDatasetsToBackupOutput& from);
  
  inline GetDatasetsToBackupOutput& operator=(const GetDatasetsToBackupOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetDatasetsToBackupOutput& default_instance();
  
  void Swap(GetDatasetsToBackupOutput* other);
  
  // implements Message ----------------------------------------------
  
  GetDatasetsToBackupOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetDatasetsToBackupOutput& from);
  void MergeFrom(const GetDatasetsToBackupOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // repeated .vplex.vsDirectory.BackupStatus datasetsToBackup = 2;
  inline int datasetstobackup_size() const;
  inline void clear_datasetstobackup();
  static const int kDatasetsToBackupFieldNumber = 2;
  inline const ::vplex::vsDirectory::BackupStatus& datasetstobackup(int index) const;
  inline ::vplex::vsDirectory::BackupStatus* mutable_datasetstobackup(int index);
  inline ::vplex::vsDirectory::BackupStatus* add_datasetstobackup();
  inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::BackupStatus >&
      datasetstobackup() const;
  inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::BackupStatus >*
      mutable_datasetstobackup();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetDatasetsToBackupOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::BackupStatus > datasetstobackup_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetDatasetsToBackupOutput* default_instance_;
};
// -------------------------------------------------------------------

class GetBRSHostNameInput : public ::google::protobuf::Message {
 public:
  GetBRSHostNameInput();
  virtual ~GetBRSHostNameInput();
  
  GetBRSHostNameInput(const GetBRSHostNameInput& from);
  
  inline GetBRSHostNameInput& operator=(const GetBRSHostNameInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetBRSHostNameInput& default_instance();
  
  void Swap(GetBRSHostNameInput* other);
  
  // implements Message ----------------------------------------------
  
  GetBRSHostNameInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetBRSHostNameInput& from);
  void MergeFrom(const GetBRSHostNameInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed64 clusterId = 1;
  inline bool has_clusterid() const;
  inline void clear_clusterid();
  static const int kClusterIdFieldNumber = 1;
  inline ::google::protobuf::uint64 clusterid() const;
  inline void set_clusterid(::google::protobuf::uint64 value);
  
  // required fixed64 backupStorageId = 2;
  inline bool has_backupstorageid() const;
  inline void clear_backupstorageid();
  static const int kBackupStorageIdFieldNumber = 2;
  inline ::google::protobuf::uint64 backupstorageid() const;
  inline void set_backupstorageid(::google::protobuf::uint64 value);
  
  // optional string version = 3;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 3;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetBRSHostNameInput)
 private:
  inline void set_has_clusterid();
  inline void clear_has_clusterid();
  inline void set_has_backupstorageid();
  inline void clear_has_backupstorageid();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 clusterid_;
  ::google::protobuf::uint64 backupstorageid_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetBRSHostNameInput* default_instance_;
};
// -------------------------------------------------------------------

class GetBRSHostNameOutput : public ::google::protobuf::Message {
 public:
  GetBRSHostNameOutput();
  virtual ~GetBRSHostNameOutput();
  
  GetBRSHostNameOutput(const GetBRSHostNameOutput& from);
  
  inline GetBRSHostNameOutput& operator=(const GetBRSHostNameOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetBRSHostNameOutput& default_instance();
  
  void Swap(GetBRSHostNameOutput* other);
  
  // implements Message ----------------------------------------------
  
  GetBRSHostNameOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetBRSHostNameOutput& from);
  void MergeFrom(const GetBRSHostNameOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // optional string hostName = 2;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostNameFieldNumber = 2;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetBRSHostNameOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_hostname();
  inline void clear_has_hostname();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  ::std::string* hostname_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetBRSHostNameOutput* default_instance_;
};
// -------------------------------------------------------------------

class GetBackupStorageUnitsForBrsInput : public ::google::protobuf::Message {
 public:
  GetBackupStorageUnitsForBrsInput();
  virtual ~GetBackupStorageUnitsForBrsInput();
  
  GetBackupStorageUnitsForBrsInput(const GetBackupStorageUnitsForBrsInput& from);
  
  inline GetBackupStorageUnitsForBrsInput& operator=(const GetBackupStorageUnitsForBrsInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetBackupStorageUnitsForBrsInput& default_instance();
  
  void Swap(GetBackupStorageUnitsForBrsInput* other);
  
  // implements Message ----------------------------------------------
  
  GetBackupStorageUnitsForBrsInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetBackupStorageUnitsForBrsInput& from);
  void MergeFrom(const GetBackupStorageUnitsForBrsInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed64 clusterId = 1;
  inline bool has_clusterid() const;
  inline void clear_clusterid();
  static const int kClusterIdFieldNumber = 1;
  inline ::google::protobuf::uint64 clusterid() const;
  inline void set_clusterid(::google::protobuf::uint64 value);
  
  // required fixed64 brsId = 2;
  inline bool has_brsid() const;
  inline void clear_brsid();
  static const int kBrsIdFieldNumber = 2;
  inline ::google::protobuf::uint64 brsid() const;
  inline void set_brsid(::google::protobuf::uint64 value);
  
  // optional string version = 3;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 3;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetBackupStorageUnitsForBrsInput)
 private:
  inline void set_has_clusterid();
  inline void clear_has_clusterid();
  inline void set_has_brsid();
  inline void clear_has_brsid();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 clusterid_;
  ::google::protobuf::uint64 brsid_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetBackupStorageUnitsForBrsInput* default_instance_;
};
// -------------------------------------------------------------------

class GetBackupStorageUnitsForBrsOutput : public ::google::protobuf::Message {
 public:
  GetBackupStorageUnitsForBrsOutput();
  virtual ~GetBackupStorageUnitsForBrsOutput();
  
  GetBackupStorageUnitsForBrsOutput(const GetBackupStorageUnitsForBrsOutput& from);
  
  inline GetBackupStorageUnitsForBrsOutput& operator=(const GetBackupStorageUnitsForBrsOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetBackupStorageUnitsForBrsOutput& default_instance();
  
  void Swap(GetBackupStorageUnitsForBrsOutput* other);
  
  // implements Message ----------------------------------------------
  
  GetBackupStorageUnitsForBrsOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetBackupStorageUnitsForBrsOutput& from);
  void MergeFrom(const GetBackupStorageUnitsForBrsOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // repeated fixed64 backupStorageIds = 2;
  inline int backupstorageids_size() const;
  inline void clear_backupstorageids();
  static const int kBackupStorageIdsFieldNumber = 2;
  inline ::google::protobuf::uint64 backupstorageids(int index) const;
  inline void set_backupstorageids(int index, ::google::protobuf::uint64 value);
  inline void add_backupstorageids(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      backupstorageids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_backupstorageids();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetBackupStorageUnitsForBrsOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > backupstorageids_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetBackupStorageUnitsForBrsOutput* default_instance_;
};
// -------------------------------------------------------------------

class GetUpdatedDatasetsInput : public ::google::protobuf::Message {
 public:
  GetUpdatedDatasetsInput();
  virtual ~GetUpdatedDatasetsInput();
  
  GetUpdatedDatasetsInput(const GetUpdatedDatasetsInput& from);
  
  inline GetUpdatedDatasetsInput& operator=(const GetUpdatedDatasetsInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetUpdatedDatasetsInput& default_instance();
  
  void Swap(GetUpdatedDatasetsInput* other);
  
  // implements Message ----------------------------------------------
  
  GetUpdatedDatasetsInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetUpdatedDatasetsInput& from);
  void MergeFrom(const GetUpdatedDatasetsInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // required fixed64 clusterId = 2;
  inline bool has_clusterid() const;
  inline void clear_clusterid();
  static const int kClusterIdFieldNumber = 2;
  inline ::google::protobuf::uint64 clusterid() const;
  inline void set_clusterid(::google::protobuf::uint64 value);
  
  // required fixed64 startTime = 3;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 3;
  inline ::google::protobuf::uint64 starttime() const;
  inline void set_starttime(::google::protobuf::uint64 value);
  
  // required fixed64 endTime = 4;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 4;
  inline ::google::protobuf::uint64 endtime() const;
  inline void set_endtime(::google::protobuf::uint64 value);
  
  // required fixed32 count = 5;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 5;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);
  
  // repeated .vplex.vsDirectory.DatasetFilter filters = 6;
  inline int filters_size() const;
  inline void clear_filters();
  static const int kFiltersFieldNumber = 6;
  inline const ::vplex::vsDirectory::DatasetFilter& filters(int index) const;
  inline ::vplex::vsDirectory::DatasetFilter* mutable_filters(int index);
  inline ::vplex::vsDirectory::DatasetFilter* add_filters();
  inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::DatasetFilter >&
      filters() const;
  inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::DatasetFilter >*
      mutable_filters();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetUpdatedDatasetsInput)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_clusterid();
  inline void clear_has_clusterid();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_count();
  inline void clear_has_count();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* version_;
  ::google::protobuf::uint64 clusterid_;
  ::google::protobuf::uint64 starttime_;
  ::google::protobuf::uint64 endtime_;
  ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::DatasetFilter > filters_;
  ::google::protobuf::uint32 count_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetUpdatedDatasetsInput* default_instance_;
};
// -------------------------------------------------------------------

class GetUpdatedDatasetsOutput : public ::google::protobuf::Message {
 public:
  GetUpdatedDatasetsOutput();
  virtual ~GetUpdatedDatasetsOutput();
  
  GetUpdatedDatasetsOutput(const GetUpdatedDatasetsOutput& from);
  
  inline GetUpdatedDatasetsOutput& operator=(const GetUpdatedDatasetsOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetUpdatedDatasetsOutput& default_instance();
  
  void Swap(GetUpdatedDatasetsOutput* other);
  
  // implements Message ----------------------------------------------
  
  GetUpdatedDatasetsOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetUpdatedDatasetsOutput& from);
  void MergeFrom(const GetUpdatedDatasetsOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // repeated .vplex.vsDirectory.UpdatedDataset datasets = 2;
  inline int datasets_size() const;
  inline void clear_datasets();
  static const int kDatasetsFieldNumber = 2;
  inline const ::vplex::vsDirectory::UpdatedDataset& datasets(int index) const;
  inline ::vplex::vsDirectory::UpdatedDataset* mutable_datasets(int index);
  inline ::vplex::vsDirectory::UpdatedDataset* add_datasets();
  inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::UpdatedDataset >&
      datasets() const;
  inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::UpdatedDataset >*
      mutable_datasets();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.GetUpdatedDatasetsOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::UpdatedDataset > datasets_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetUpdatedDatasetsOutput* default_instance_;
};
// -------------------------------------------------------------------

class AddDatasetArchiveStorageDeviceInput : public ::google::protobuf::Message {
 public:
  AddDatasetArchiveStorageDeviceInput();
  virtual ~AddDatasetArchiveStorageDeviceInput();
  
  AddDatasetArchiveStorageDeviceInput(const AddDatasetArchiveStorageDeviceInput& from);
  
  inline AddDatasetArchiveStorageDeviceInput& operator=(const AddDatasetArchiveStorageDeviceInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddDatasetArchiveStorageDeviceInput& default_instance();
  
  void Swap(AddDatasetArchiveStorageDeviceInput* other);
  
  // implements Message ----------------------------------------------
  
  AddDatasetArchiveStorageDeviceInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddDatasetArchiveStorageDeviceInput& from);
  void MergeFrom(const AddDatasetArchiveStorageDeviceInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed64 datasetId = 1;
  inline bool has_datasetid() const;
  inline void clear_datasetid();
  static const int kDatasetIdFieldNumber = 1;
  inline ::google::protobuf::uint64 datasetid() const;
  inline void set_datasetid(::google::protobuf::uint64 value);
  
  // repeated fixed64 archiveStorageDeviceId = 2;
  inline int archivestoragedeviceid_size() const;
  inline void clear_archivestoragedeviceid();
  static const int kArchiveStorageDeviceIdFieldNumber = 2;
  inline ::google::protobuf::uint64 archivestoragedeviceid(int index) const;
  inline void set_archivestoragedeviceid(int index, ::google::protobuf::uint64 value);
  inline void add_archivestoragedeviceid(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      archivestoragedeviceid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_archivestoragedeviceid();
  
  // required .vplex.vsDirectory.SessionInfo session = 3;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 3;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 userId = 4;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 4;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // optional string version = 5;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 5;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.AddDatasetArchiveStorageDeviceInput)
 private:
  inline void set_has_datasetid();
  inline void clear_has_datasetid();
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 datasetid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > archivestoragedeviceid_;
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 userid_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static AddDatasetArchiveStorageDeviceInput* default_instance_;
};
// -------------------------------------------------------------------

class AddDatasetArchiveStorageDeviceOutput : public ::google::protobuf::Message {
 public:
  AddDatasetArchiveStorageDeviceOutput();
  virtual ~AddDatasetArchiveStorageDeviceOutput();
  
  AddDatasetArchiveStorageDeviceOutput(const AddDatasetArchiveStorageDeviceOutput& from);
  
  inline AddDatasetArchiveStorageDeviceOutput& operator=(const AddDatasetArchiveStorageDeviceOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddDatasetArchiveStorageDeviceOutput& default_instance();
  
  void Swap(AddDatasetArchiveStorageDeviceOutput* other);
  
  // implements Message ----------------------------------------------
  
  AddDatasetArchiveStorageDeviceOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddDatasetArchiveStorageDeviceOutput& from);
  void MergeFrom(const AddDatasetArchiveStorageDeviceOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.AddDatasetArchiveStorageDeviceOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static AddDatasetArchiveStorageDeviceOutput* default_instance_;
};
// -------------------------------------------------------------------

class RemoveDatasetArchiveStorageDeviceInput : public ::google::protobuf::Message {
 public:
  RemoveDatasetArchiveStorageDeviceInput();
  virtual ~RemoveDatasetArchiveStorageDeviceInput();
  
  RemoveDatasetArchiveStorageDeviceInput(const RemoveDatasetArchiveStorageDeviceInput& from);
  
  inline RemoveDatasetArchiveStorageDeviceInput& operator=(const RemoveDatasetArchiveStorageDeviceInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoveDatasetArchiveStorageDeviceInput& default_instance();
  
  void Swap(RemoveDatasetArchiveStorageDeviceInput* other);
  
  // implements Message ----------------------------------------------
  
  RemoveDatasetArchiveStorageDeviceInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemoveDatasetArchiveStorageDeviceInput& from);
  void MergeFrom(const RemoveDatasetArchiveStorageDeviceInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed64 datasetId = 1;
  inline bool has_datasetid() const;
  inline void clear_datasetid();
  static const int kDatasetIdFieldNumber = 1;
  inline ::google::protobuf::uint64 datasetid() const;
  inline void set_datasetid(::google::protobuf::uint64 value);
  
  // repeated fixed64 archiveStorageDeviceId = 2;
  inline int archivestoragedeviceid_size() const;
  inline void clear_archivestoragedeviceid();
  static const int kArchiveStorageDeviceIdFieldNumber = 2;
  inline ::google::protobuf::uint64 archivestoragedeviceid(int index) const;
  inline void set_archivestoragedeviceid(int index, ::google::protobuf::uint64 value);
  inline void add_archivestoragedeviceid(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      archivestoragedeviceid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_archivestoragedeviceid();
  
  // required .vplex.vsDirectory.SessionInfo session = 3;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 3;
  inline const ::vplex::vsDirectory::SessionInfo& session() const;
  inline ::vplex::vsDirectory::SessionInfo* mutable_session();
  inline ::vplex::vsDirectory::SessionInfo* release_session();
  
  // required fixed64 userId = 4;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 4;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // optional string version = 5;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 5;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.RemoveDatasetArchiveStorageDeviceInput)
 private:
  inline void set_has_datasetid();
  inline void clear_has_datasetid();
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 datasetid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > archivestoragedeviceid_;
  ::vplex::vsDirectory::SessionInfo* session_;
  ::google::protobuf::uint64 userid_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static RemoveDatasetArchiveStorageDeviceInput* default_instance_;
};
// -------------------------------------------------------------------

class RemoveDatasetArchiveStorageDeviceOutput : public ::google::protobuf::Message {
 public:
  RemoveDatasetArchiveStorageDeviceOutput();
  virtual ~RemoveDatasetArchiveStorageDeviceOutput();
  
  RemoveDatasetArchiveStorageDeviceOutput(const RemoveDatasetArchiveStorageDeviceOutput& from);
  
  inline RemoveDatasetArchiveStorageDeviceOutput& operator=(const RemoveDatasetArchiveStorageDeviceOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoveDatasetArchiveStorageDeviceOutput& default_instance();
  
  void Swap(RemoveDatasetArchiveStorageDeviceOutput* other);
  
  // implements Message ----------------------------------------------
  
  RemoveDatasetArchiveStorageDeviceOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemoveDatasetArchiveStorageDeviceOutput& from);
  void MergeFrom(const RemoveDatasetArchiveStorageDeviceOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::vplex::vsDirectory::Error& error() const;
  inline ::vplex::vsDirectory::Error* mutable_error();
  inline ::vplex::vsDirectory::Error* release_error();
  
  // @@protoc_insertion_point(class_scope:vplex.vsDirectory.RemoveDatasetArchiveStorageDeviceOutput)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Error* error_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static RemoveDatasetArchiveStorageDeviceOutput* default_instance_;
};
// ===================================================================


// ===================================================================

// APIVersion

// optional string version = 1 [default = "1.0"];
inline bool APIVersion::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void APIVersion::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void APIVersion::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void APIVersion::clear_version() {
  if (version_ != &_default_version_) {
    version_->assign(_default_version_);
  }
  clear_has_version();
}
inline const ::std::string& APIVersion::version() const {
  return *version_;
}
inline void APIVersion::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &_default_version_) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void APIVersion::set_version(const char* value) {
  set_has_version();
  if (version_ == &_default_version_) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void APIVersion::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &_default_version_) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* APIVersion::mutable_version() {
  set_has_version();
  if (version_ == &_default_version_) {
    version_ = new ::std::string(_default_version_);
  }
  return version_;
}
inline ::std::string* APIVersion::release_version() {
  clear_has_version();
  if (version_ == &_default_version_) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&_default_version_);
    return temp;
  }
}

// -------------------------------------------------------------------

// Error

// required sint32 errorCode = 1;
inline bool Error::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Error::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Error::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Error::clear_errorcode() {
  errorcode_ = 0;
  clear_has_errorcode();
}
inline ::google::protobuf::int32 Error::errorcode() const {
  return errorcode_;
}
inline void Error::set_errorcode(::google::protobuf::int32 value) {
  set_has_errorcode();
  errorcode_ = value;
}

// optional string errorDetail = 2;
inline bool Error::has_errordetail() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Error::set_has_errordetail() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Error::clear_has_errordetail() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Error::clear_errordetail() {
  if (errordetail_ != &::google::protobuf::internal::kEmptyString) {
    errordetail_->clear();
  }
  clear_has_errordetail();
}
inline const ::std::string& Error::errordetail() const {
  return *errordetail_;
}
inline void Error::set_errordetail(const ::std::string& value) {
  set_has_errordetail();
  if (errordetail_ == &::google::protobuf::internal::kEmptyString) {
    errordetail_ = new ::std::string;
  }
  errordetail_->assign(value);
}
inline void Error::set_errordetail(const char* value) {
  set_has_errordetail();
  if (errordetail_ == &::google::protobuf::internal::kEmptyString) {
    errordetail_ = new ::std::string;
  }
  errordetail_->assign(value);
}
inline void Error::set_errordetail(const char* value, size_t size) {
  set_has_errordetail();
  if (errordetail_ == &::google::protobuf::internal::kEmptyString) {
    errordetail_ = new ::std::string;
  }
  errordetail_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Error::mutable_errordetail() {
  set_has_errordetail();
  if (errordetail_ == &::google::protobuf::internal::kEmptyString) {
    errordetail_ = new ::std::string;
  }
  return errordetail_;
}
inline ::std::string* Error::release_errordetail() {
  clear_has_errordetail();
  if (errordetail_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = errordetail_;
    errordetail_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// SessionInfo

// required fixed64 sessionHandle = 1;
inline bool SessionInfo::has_sessionhandle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SessionInfo::set_has_sessionhandle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SessionInfo::clear_has_sessionhandle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SessionInfo::clear_sessionhandle() {
  sessionhandle_ = GOOGLE_ULONGLONG(0);
  clear_has_sessionhandle();
}
inline ::google::protobuf::uint64 SessionInfo::sessionhandle() const {
  return sessionhandle_;
}
inline void SessionInfo::set_sessionhandle(::google::protobuf::uint64 value) {
  set_has_sessionhandle();
  sessionhandle_ = value;
}

// required bytes serviceTicket = 2;
inline bool SessionInfo::has_serviceticket() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SessionInfo::set_has_serviceticket() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SessionInfo::clear_has_serviceticket() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SessionInfo::clear_serviceticket() {
  if (serviceticket_ != &::google::protobuf::internal::kEmptyString) {
    serviceticket_->clear();
  }
  clear_has_serviceticket();
}
inline const ::std::string& SessionInfo::serviceticket() const {
  return *serviceticket_;
}
inline void SessionInfo::set_serviceticket(const ::std::string& value) {
  set_has_serviceticket();
  if (serviceticket_ == &::google::protobuf::internal::kEmptyString) {
    serviceticket_ = new ::std::string;
  }
  serviceticket_->assign(value);
}
inline void SessionInfo::set_serviceticket(const char* value) {
  set_has_serviceticket();
  if (serviceticket_ == &::google::protobuf::internal::kEmptyString) {
    serviceticket_ = new ::std::string;
  }
  serviceticket_->assign(value);
}
inline void SessionInfo::set_serviceticket(const void* value, size_t size) {
  set_has_serviceticket();
  if (serviceticket_ == &::google::protobuf::internal::kEmptyString) {
    serviceticket_ = new ::std::string;
  }
  serviceticket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SessionInfo::mutable_serviceticket() {
  set_has_serviceticket();
  if (serviceticket_ == &::google::protobuf::internal::kEmptyString) {
    serviceticket_ = new ::std::string;
  }
  return serviceticket_;
}
inline ::std::string* SessionInfo::release_serviceticket() {
  clear_has_serviceticket();
  if (serviceticket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serviceticket_;
    serviceticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ETicketData

// required bytes eTicket = 1;
inline bool ETicketData::has_eticket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ETicketData::set_has_eticket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ETicketData::clear_has_eticket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ETicketData::clear_eticket() {
  if (eticket_ != &::google::protobuf::internal::kEmptyString) {
    eticket_->clear();
  }
  clear_has_eticket();
}
inline const ::std::string& ETicketData::eticket() const {
  return *eticket_;
}
inline void ETicketData::set_eticket(const ::std::string& value) {
  set_has_eticket();
  if (eticket_ == &::google::protobuf::internal::kEmptyString) {
    eticket_ = new ::std::string;
  }
  eticket_->assign(value);
}
inline void ETicketData::set_eticket(const char* value) {
  set_has_eticket();
  if (eticket_ == &::google::protobuf::internal::kEmptyString) {
    eticket_ = new ::std::string;
  }
  eticket_->assign(value);
}
inline void ETicketData::set_eticket(const void* value, size_t size) {
  set_has_eticket();
  if (eticket_ == &::google::protobuf::internal::kEmptyString) {
    eticket_ = new ::std::string;
  }
  eticket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ETicketData::mutable_eticket() {
  set_has_eticket();
  if (eticket_ == &::google::protobuf::internal::kEmptyString) {
    eticket_ = new ::std::string;
  }
  return eticket_;
}
inline ::std::string* ETicketData::release_eticket() {
  clear_has_eticket();
  if (eticket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = eticket_;
    eticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated bytes certificate = 2;
inline int ETicketData::certificate_size() const {
  return certificate_.size();
}
inline void ETicketData::clear_certificate() {
  certificate_.Clear();
}
inline const ::std::string& ETicketData::certificate(int index) const {
  return certificate_.Get(index);
}
inline ::std::string* ETicketData::mutable_certificate(int index) {
  return certificate_.Mutable(index);
}
inline void ETicketData::set_certificate(int index, const ::std::string& value) {
  certificate_.Mutable(index)->assign(value);
}
inline void ETicketData::set_certificate(int index, const char* value) {
  certificate_.Mutable(index)->assign(value);
}
inline void ETicketData::set_certificate(int index, const void* value, size_t size) {
  certificate_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ETicketData::add_certificate() {
  return certificate_.Add();
}
inline void ETicketData::add_certificate(const ::std::string& value) {
  certificate_.Add()->assign(value);
}
inline void ETicketData::add_certificate(const char* value) {
  certificate_.Add()->assign(value);
}
inline void ETicketData::add_certificate(const void* value, size_t size) {
  certificate_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ETicketData::certificate() const {
  return certificate_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ETicketData::mutable_certificate() {
  return &certificate_;
}

// -------------------------------------------------------------------

// Localization

// required string language = 1;
inline bool Localization::has_language() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Localization::set_has_language() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Localization::clear_has_language() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Localization::clear_language() {
  if (language_ != &::google::protobuf::internal::kEmptyString) {
    language_->clear();
  }
  clear_has_language();
}
inline const ::std::string& Localization::language() const {
  return *language_;
}
inline void Localization::set_language(const ::std::string& value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(value);
}
inline void Localization::set_language(const char* value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(value);
}
inline void Localization::set_language(const char* value, size_t size) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Localization::mutable_language() {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  return language_;
}
inline ::std::string* Localization::release_language() {
  clear_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = language_;
    language_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string country = 2;
inline bool Localization::has_country() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Localization::set_has_country() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Localization::clear_has_country() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Localization::clear_country() {
  if (country_ != &::google::protobuf::internal::kEmptyString) {
    country_->clear();
  }
  clear_has_country();
}
inline const ::std::string& Localization::country() const {
  return *country_;
}
inline void Localization::set_country(const ::std::string& value) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    country_ = new ::std::string;
  }
  country_->assign(value);
}
inline void Localization::set_country(const char* value) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    country_ = new ::std::string;
  }
  country_->assign(value);
}
inline void Localization::set_country(const char* value, size_t size) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    country_ = new ::std::string;
  }
  country_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Localization::mutable_country() {
  set_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    country_ = new ::std::string;
  }
  return country_;
}
inline ::std::string* Localization::release_country() {
  clear_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = country_;
    country_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string region = 3;
inline bool Localization::has_region() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Localization::set_has_region() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Localization::clear_has_region() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Localization::clear_region() {
  if (region_ != &::google::protobuf::internal::kEmptyString) {
    region_->clear();
  }
  clear_has_region();
}
inline const ::std::string& Localization::region() const {
  return *region_;
}
inline void Localization::set_region(const ::std::string& value) {
  set_has_region();
  if (region_ == &::google::protobuf::internal::kEmptyString) {
    region_ = new ::std::string;
  }
  region_->assign(value);
}
inline void Localization::set_region(const char* value) {
  set_has_region();
  if (region_ == &::google::protobuf::internal::kEmptyString) {
    region_ = new ::std::string;
  }
  region_->assign(value);
}
inline void Localization::set_region(const char* value, size_t size) {
  set_has_region();
  if (region_ == &::google::protobuf::internal::kEmptyString) {
    region_ = new ::std::string;
  }
  region_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Localization::mutable_region() {
  set_has_region();
  if (region_ == &::google::protobuf::internal::kEmptyString) {
    region_ = new ::std::string;
  }
  return region_;
}
inline ::std::string* Localization::release_region() {
  clear_has_region();
  if (region_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = region_;
    region_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// TitleData

// required string titleId = 1;
inline bool TitleData::has_titleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TitleData::set_has_titleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TitleData::clear_has_titleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TitleData::clear_titleid() {
  if (titleid_ != &::google::protobuf::internal::kEmptyString) {
    titleid_->clear();
  }
  clear_has_titleid();
}
inline const ::std::string& TitleData::titleid() const {
  return *titleid_;
}
inline void TitleData::set_titleid(const ::std::string& value) {
  set_has_titleid();
  if (titleid_ == &::google::protobuf::internal::kEmptyString) {
    titleid_ = new ::std::string;
  }
  titleid_->assign(value);
}
inline void TitleData::set_titleid(const char* value) {
  set_has_titleid();
  if (titleid_ == &::google::protobuf::internal::kEmptyString) {
    titleid_ = new ::std::string;
  }
  titleid_->assign(value);
}
inline void TitleData::set_titleid(const char* value, size_t size) {
  set_has_titleid();
  if (titleid_ == &::google::protobuf::internal::kEmptyString) {
    titleid_ = new ::std::string;
  }
  titleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TitleData::mutable_titleid() {
  set_has_titleid();
  if (titleid_ == &::google::protobuf::internal::kEmptyString) {
    titleid_ = new ::std::string;
  }
  return titleid_;
}
inline ::std::string* TitleData::release_titleid() {
  clear_has_titleid();
  if (titleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = titleid_;
    titleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 detailHash = 2;
inline bool TitleData::has_detailhash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TitleData::set_has_detailhash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TitleData::clear_has_detailhash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TitleData::clear_detailhash() {
  detailhash_ = 0;
  clear_has_detailhash();
}
inline ::google::protobuf::int32 TitleData::detailhash() const {
  return detailhash_;
}
inline void TitleData::set_detailhash(::google::protobuf::int32 value) {
  set_has_detailhash();
  detailhash_ = value;
}

// required int32 ticketVersion = 3;
inline bool TitleData::has_ticketversion() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TitleData::set_has_ticketversion() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TitleData::clear_has_ticketversion() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TitleData::clear_ticketversion() {
  ticketversion_ = 0;
  clear_has_ticketversion();
}
inline ::google::protobuf::int32 TitleData::ticketversion() const {
  return ticketversion_;
}
inline void TitleData::set_ticketversion(::google::protobuf::int32 value) {
  set_has_ticketversion();
  ticketversion_ = value;
}

// required bool useOnlineETicket = 4;
inline bool TitleData::has_useonlineeticket() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TitleData::set_has_useonlineeticket() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TitleData::clear_has_useonlineeticket() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TitleData::clear_useonlineeticket() {
  useonlineeticket_ = false;
  clear_has_useonlineeticket();
}
inline bool TitleData::useonlineeticket() const {
  return useonlineeticket_;
}
inline void TitleData::set_useonlineeticket(bool value) {
  set_has_useonlineeticket();
  useonlineeticket_ = value;
}

// required bool useOfflineETicket = 5;
inline bool TitleData::has_useofflineeticket() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TitleData::set_has_useofflineeticket() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TitleData::clear_has_useofflineeticket() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TitleData::clear_useofflineeticket() {
  useofflineeticket_ = false;
  clear_has_useofflineeticket();
}
inline bool TitleData::useofflineeticket() const {
  return useofflineeticket_;
}
inline void TitleData::set_useofflineeticket(bool value) {
  set_has_useofflineeticket();
  useofflineeticket_ = value;
}

// -------------------------------------------------------------------

// TitleDetail

// required string titleId = 1;
inline bool TitleDetail::has_titleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TitleDetail::set_has_titleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TitleDetail::clear_has_titleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TitleDetail::clear_titleid() {
  if (titleid_ != &::google::protobuf::internal::kEmptyString) {
    titleid_->clear();
  }
  clear_has_titleid();
}
inline const ::std::string& TitleDetail::titleid() const {
  return *titleid_;
}
inline void TitleDetail::set_titleid(const ::std::string& value) {
  set_has_titleid();
  if (titleid_ == &::google::protobuf::internal::kEmptyString) {
    titleid_ = new ::std::string;
  }
  titleid_->assign(value);
}
inline void TitleDetail::set_titleid(const char* value) {
  set_has_titleid();
  if (titleid_ == &::google::protobuf::internal::kEmptyString) {
    titleid_ = new ::std::string;
  }
  titleid_->assign(value);
}
inline void TitleDetail::set_titleid(const char* value, size_t size) {
  set_has_titleid();
  if (titleid_ == &::google::protobuf::internal::kEmptyString) {
    titleid_ = new ::std::string;
  }
  titleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TitleDetail::mutable_titleid() {
  set_has_titleid();
  if (titleid_ == &::google::protobuf::internal::kEmptyString) {
    titleid_ = new ::std::string;
  }
  return titleid_;
}
inline ::std::string* TitleDetail::release_titleid() {
  clear_has_titleid();
  if (titleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = titleid_;
    titleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string titleVersion = 2;
inline bool TitleDetail::has_titleversion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TitleDetail::set_has_titleversion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TitleDetail::clear_has_titleversion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TitleDetail::clear_titleversion() {
  if (titleversion_ != &::google::protobuf::internal::kEmptyString) {
    titleversion_->clear();
  }
  clear_has_titleversion();
}
inline const ::std::string& TitleDetail::titleversion() const {
  return *titleversion_;
}
inline void TitleDetail::set_titleversion(const ::std::string& value) {
  set_has_titleversion();
  if (titleversion_ == &::google::protobuf::internal::kEmptyString) {
    titleversion_ = new ::std::string;
  }
  titleversion_->assign(value);
}
inline void TitleDetail::set_titleversion(const char* value) {
  set_has_titleversion();
  if (titleversion_ == &::google::protobuf::internal::kEmptyString) {
    titleversion_ = new ::std::string;
  }
  titleversion_->assign(value);
}
inline void TitleDetail::set_titleversion(const char* value, size_t size) {
  set_has_titleversion();
  if (titleversion_ == &::google::protobuf::internal::kEmptyString) {
    titleversion_ = new ::std::string;
  }
  titleversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TitleDetail::mutable_titleversion() {
  set_has_titleversion();
  if (titleversion_ == &::google::protobuf::internal::kEmptyString) {
    titleversion_ = new ::std::string;
  }
  return titleversion_;
}
inline ::std::string* TitleDetail::release_titleversion() {
  clear_has_titleversion();
  if (titleversion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = titleversion_;
    titleversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string tmdUrl = 3;
inline bool TitleDetail::has_tmdurl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TitleDetail::set_has_tmdurl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TitleDetail::clear_has_tmdurl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TitleDetail::clear_tmdurl() {
  if (tmdurl_ != &::google::protobuf::internal::kEmptyString) {
    tmdurl_->clear();
  }
  clear_has_tmdurl();
}
inline const ::std::string& TitleDetail::tmdurl() const {
  return *tmdurl_;
}
inline void TitleDetail::set_tmdurl(const ::std::string& value) {
  set_has_tmdurl();
  if (tmdurl_ == &::google::protobuf::internal::kEmptyString) {
    tmdurl_ = new ::std::string;
  }
  tmdurl_->assign(value);
}
inline void TitleDetail::set_tmdurl(const char* value) {
  set_has_tmdurl();
  if (tmdurl_ == &::google::protobuf::internal::kEmptyString) {
    tmdurl_ = new ::std::string;
  }
  tmdurl_->assign(value);
}
inline void TitleDetail::set_tmdurl(const char* value, size_t size) {
  set_has_tmdurl();
  if (tmdurl_ == &::google::protobuf::internal::kEmptyString) {
    tmdurl_ = new ::std::string;
  }
  tmdurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TitleDetail::mutable_tmdurl() {
  set_has_tmdurl();
  if (tmdurl_ == &::google::protobuf::internal::kEmptyString) {
    tmdurl_ = new ::std::string;
  }
  return tmdurl_;
}
inline ::std::string* TitleDetail::release_tmdurl() {
  clear_has_tmdurl();
  if (tmdurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tmdurl_;
    tmdurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .vplex.vsDirectory.ContentDetail contents = 4;
inline int TitleDetail::contents_size() const {
  return contents_.size();
}
inline void TitleDetail::clear_contents() {
  contents_.Clear();
}
inline const ::vplex::vsDirectory::ContentDetail& TitleDetail::contents(int index) const {
  return contents_.Get(index);
}
inline ::vplex::vsDirectory::ContentDetail* TitleDetail::mutable_contents(int index) {
  return contents_.Mutable(index);
}
inline ::vplex::vsDirectory::ContentDetail* TitleDetail::add_contents() {
  return contents_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::ContentDetail >&
TitleDetail::contents() const {
  return contents_;
}
inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::ContentDetail >*
TitleDetail::mutable_contents() {
  return &contents_;
}

// optional string name = 5;
inline bool TitleDetail::has_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TitleDetail::set_has_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TitleDetail::clear_has_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TitleDetail::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TitleDetail::name() const {
  return *name_;
}
inline void TitleDetail::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TitleDetail::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TitleDetail::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TitleDetail::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TitleDetail::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string iconUrl = 6;
inline bool TitleDetail::has_iconurl() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TitleDetail::set_has_iconurl() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TitleDetail::clear_has_iconurl() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TitleDetail::clear_iconurl() {
  if (iconurl_ != &::google::protobuf::internal::kEmptyString) {
    iconurl_->clear();
  }
  clear_has_iconurl();
}
inline const ::std::string& TitleDetail::iconurl() const {
  return *iconurl_;
}
inline void TitleDetail::set_iconurl(const ::std::string& value) {
  set_has_iconurl();
  if (iconurl_ == &::google::protobuf::internal::kEmptyString) {
    iconurl_ = new ::std::string;
  }
  iconurl_->assign(value);
}
inline void TitleDetail::set_iconurl(const char* value) {
  set_has_iconurl();
  if (iconurl_ == &::google::protobuf::internal::kEmptyString) {
    iconurl_ = new ::std::string;
  }
  iconurl_->assign(value);
}
inline void TitleDetail::set_iconurl(const char* value, size_t size) {
  set_has_iconurl();
  if (iconurl_ == &::google::protobuf::internal::kEmptyString) {
    iconurl_ = new ::std::string;
  }
  iconurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TitleDetail::mutable_iconurl() {
  set_has_iconurl();
  if (iconurl_ == &::google::protobuf::internal::kEmptyString) {
    iconurl_ = new ::std::string;
  }
  return iconurl_;
}
inline ::std::string* TitleDetail::release_iconurl() {
  clear_has_iconurl();
  if (iconurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = iconurl_;
    iconurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string imageUrl = 7;
inline bool TitleDetail::has_imageurl() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TitleDetail::set_has_imageurl() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TitleDetail::clear_has_imageurl() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TitleDetail::clear_imageurl() {
  if (imageurl_ != &::google::protobuf::internal::kEmptyString) {
    imageurl_->clear();
  }
  clear_has_imageurl();
}
inline const ::std::string& TitleDetail::imageurl() const {
  return *imageurl_;
}
inline void TitleDetail::set_imageurl(const ::std::string& value) {
  set_has_imageurl();
  if (imageurl_ == &::google::protobuf::internal::kEmptyString) {
    imageurl_ = new ::std::string;
  }
  imageurl_->assign(value);
}
inline void TitleDetail::set_imageurl(const char* value) {
  set_has_imageurl();
  if (imageurl_ == &::google::protobuf::internal::kEmptyString) {
    imageurl_ = new ::std::string;
  }
  imageurl_->assign(value);
}
inline void TitleDetail::set_imageurl(const char* value, size_t size) {
  set_has_imageurl();
  if (imageurl_ == &::google::protobuf::internal::kEmptyString) {
    imageurl_ = new ::std::string;
  }
  imageurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TitleDetail::mutable_imageurl() {
  set_has_imageurl();
  if (imageurl_ == &::google::protobuf::internal::kEmptyString) {
    imageurl_ = new ::std::string;
  }
  return imageurl_;
}
inline ::std::string* TitleDetail::release_imageurl() {
  clear_has_imageurl();
  if (imageurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = imageurl_;
    imageurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string publisher = 8;
inline bool TitleDetail::has_publisher() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TitleDetail::set_has_publisher() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TitleDetail::clear_has_publisher() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TitleDetail::clear_publisher() {
  if (publisher_ != &::google::protobuf::internal::kEmptyString) {
    publisher_->clear();
  }
  clear_has_publisher();
}
inline const ::std::string& TitleDetail::publisher() const {
  return *publisher_;
}
inline void TitleDetail::set_publisher(const ::std::string& value) {
  set_has_publisher();
  if (publisher_ == &::google::protobuf::internal::kEmptyString) {
    publisher_ = new ::std::string;
  }
  publisher_->assign(value);
}
inline void TitleDetail::set_publisher(const char* value) {
  set_has_publisher();
  if (publisher_ == &::google::protobuf::internal::kEmptyString) {
    publisher_ = new ::std::string;
  }
  publisher_->assign(value);
}
inline void TitleDetail::set_publisher(const char* value, size_t size) {
  set_has_publisher();
  if (publisher_ == &::google::protobuf::internal::kEmptyString) {
    publisher_ = new ::std::string;
  }
  publisher_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TitleDetail::mutable_publisher() {
  set_has_publisher();
  if (publisher_ == &::google::protobuf::internal::kEmptyString) {
    publisher_ = new ::std::string;
  }
  return publisher_;
}
inline ::std::string* TitleDetail::release_publisher() {
  clear_has_publisher();
  if (publisher_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = publisher_;
    publisher_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string genre = 9;
inline bool TitleDetail::has_genre() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TitleDetail::set_has_genre() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TitleDetail::clear_has_genre() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TitleDetail::clear_genre() {
  if (genre_ != &::google::protobuf::internal::kEmptyString) {
    genre_->clear();
  }
  clear_has_genre();
}
inline const ::std::string& TitleDetail::genre() const {
  return *genre_;
}
inline void TitleDetail::set_genre(const ::std::string& value) {
  set_has_genre();
  if (genre_ == &::google::protobuf::internal::kEmptyString) {
    genre_ = new ::std::string;
  }
  genre_->assign(value);
}
inline void TitleDetail::set_genre(const char* value) {
  set_has_genre();
  if (genre_ == &::google::protobuf::internal::kEmptyString) {
    genre_ = new ::std::string;
  }
  genre_->assign(value);
}
inline void TitleDetail::set_genre(const char* value, size_t size) {
  set_has_genre();
  if (genre_ == &::google::protobuf::internal::kEmptyString) {
    genre_ = new ::std::string;
  }
  genre_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TitleDetail::mutable_genre() {
  set_has_genre();
  if (genre_ == &::google::protobuf::internal::kEmptyString) {
    genre_ = new ::std::string;
  }
  return genre_;
}
inline ::std::string* TitleDetail::release_genre() {
  clear_has_genre();
  if (genre_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = genre_;
    genre_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .vplex.common.ContentRating contentRating = 10;
inline bool TitleDetail::has_contentrating() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TitleDetail::set_has_contentrating() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TitleDetail::clear_has_contentrating() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TitleDetail::clear_contentrating() {
  if (contentrating_ != NULL) contentrating_->::vplex::common::ContentRating::Clear();
  clear_has_contentrating();
}
inline const ::vplex::common::ContentRating& TitleDetail::contentrating() const {
  return contentrating_ != NULL ? *contentrating_ : *default_instance_->contentrating_;
}
inline ::vplex::common::ContentRating* TitleDetail::mutable_contentrating() {
  set_has_contentrating();
  if (contentrating_ == NULL) contentrating_ = new ::vplex::common::ContentRating;
  return contentrating_;
}
inline ::vplex::common::ContentRating* TitleDetail::release_contentrating() {
  clear_has_contentrating();
  ::vplex::common::ContentRating* temp = contentrating_;
  contentrating_ = NULL;
  return temp;
}

// optional .vplex.common.ContentRating altContentRating = 11;
inline bool TitleDetail::has_altcontentrating() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TitleDetail::set_has_altcontentrating() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TitleDetail::clear_has_altcontentrating() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TitleDetail::clear_altcontentrating() {
  if (altcontentrating_ != NULL) altcontentrating_->::vplex::common::ContentRating::Clear();
  clear_has_altcontentrating();
}
inline const ::vplex::common::ContentRating& TitleDetail::altcontentrating() const {
  return altcontentrating_ != NULL ? *altcontentrating_ : *default_instance_->altcontentrating_;
}
inline ::vplex::common::ContentRating* TitleDetail::mutable_altcontentrating() {
  set_has_altcontentrating();
  if (altcontentrating_ == NULL) altcontentrating_ = new ::vplex::common::ContentRating;
  return altcontentrating_;
}
inline ::vplex::common::ContentRating* TitleDetail::release_altcontentrating() {
  clear_has_altcontentrating();
  ::vplex::common::ContentRating* temp = altcontentrating_;
  altcontentrating_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ContentDetail

// required string contentId = 1;
inline bool ContentDetail::has_contentid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContentDetail::set_has_contentid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContentDetail::clear_has_contentid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContentDetail::clear_contentid() {
  if (contentid_ != &::google::protobuf::internal::kEmptyString) {
    contentid_->clear();
  }
  clear_has_contentid();
}
inline const ::std::string& ContentDetail::contentid() const {
  return *contentid_;
}
inline void ContentDetail::set_contentid(const ::std::string& value) {
  set_has_contentid();
  if (contentid_ == &::google::protobuf::internal::kEmptyString) {
    contentid_ = new ::std::string;
  }
  contentid_->assign(value);
}
inline void ContentDetail::set_contentid(const char* value) {
  set_has_contentid();
  if (contentid_ == &::google::protobuf::internal::kEmptyString) {
    contentid_ = new ::std::string;
  }
  contentid_->assign(value);
}
inline void ContentDetail::set_contentid(const char* value, size_t size) {
  set_has_contentid();
  if (contentid_ == &::google::protobuf::internal::kEmptyString) {
    contentid_ = new ::std::string;
  }
  contentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContentDetail::mutable_contentid() {
  set_has_contentid();
  if (contentid_ == &::google::protobuf::internal::kEmptyString) {
    contentid_ = new ::std::string;
  }
  return contentid_;
}
inline ::std::string* ContentDetail::release_contentid() {
  clear_has_contentid();
  if (contentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contentid_;
    contentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string contentLocation = 2;
inline bool ContentDetail::has_contentlocation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContentDetail::set_has_contentlocation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContentDetail::clear_has_contentlocation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContentDetail::clear_contentlocation() {
  if (contentlocation_ != &::google::protobuf::internal::kEmptyString) {
    contentlocation_->clear();
  }
  clear_has_contentlocation();
}
inline const ::std::string& ContentDetail::contentlocation() const {
  return *contentlocation_;
}
inline void ContentDetail::set_contentlocation(const ::std::string& value) {
  set_has_contentlocation();
  if (contentlocation_ == &::google::protobuf::internal::kEmptyString) {
    contentlocation_ = new ::std::string;
  }
  contentlocation_->assign(value);
}
inline void ContentDetail::set_contentlocation(const char* value) {
  set_has_contentlocation();
  if (contentlocation_ == &::google::protobuf::internal::kEmptyString) {
    contentlocation_ = new ::std::string;
  }
  contentlocation_->assign(value);
}
inline void ContentDetail::set_contentlocation(const char* value, size_t size) {
  set_has_contentlocation();
  if (contentlocation_ == &::google::protobuf::internal::kEmptyString) {
    contentlocation_ = new ::std::string;
  }
  contentlocation_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContentDetail::mutable_contentlocation() {
  set_has_contentlocation();
  if (contentlocation_ == &::google::protobuf::internal::kEmptyString) {
    contentlocation_ = new ::std::string;
  }
  return contentlocation_;
}
inline ::std::string* ContentDetail::release_contentlocation() {
  clear_has_contentlocation();
  if (contentlocation_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contentlocation_;
    contentlocation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// SaveData

// required string titleId = 1;
inline bool SaveData::has_titleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SaveData::set_has_titleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SaveData::clear_has_titleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SaveData::clear_titleid() {
  if (titleid_ != &::google::protobuf::internal::kEmptyString) {
    titleid_->clear();
  }
  clear_has_titleid();
}
inline const ::std::string& SaveData::titleid() const {
  return *titleid_;
}
inline void SaveData::set_titleid(const ::std::string& value) {
  set_has_titleid();
  if (titleid_ == &::google::protobuf::internal::kEmptyString) {
    titleid_ = new ::std::string;
  }
  titleid_->assign(value);
}
inline void SaveData::set_titleid(const char* value) {
  set_has_titleid();
  if (titleid_ == &::google::protobuf::internal::kEmptyString) {
    titleid_ = new ::std::string;
  }
  titleid_->assign(value);
}
inline void SaveData::set_titleid(const char* value, size_t size) {
  set_has_titleid();
  if (titleid_ == &::google::protobuf::internal::kEmptyString) {
    titleid_ = new ::std::string;
  }
  titleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SaveData::mutable_titleid() {
  set_has_titleid();
  if (titleid_ == &::google::protobuf::internal::kEmptyString) {
    titleid_ = new ::std::string;
  }
  return titleid_;
}
inline ::std::string* SaveData::release_titleid() {
  clear_has_titleid();
  if (titleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = titleid_;
    titleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string saveLocation = 2;
inline bool SaveData::has_savelocation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SaveData::set_has_savelocation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SaveData::clear_has_savelocation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SaveData::clear_savelocation() {
  if (savelocation_ != &::google::protobuf::internal::kEmptyString) {
    savelocation_->clear();
  }
  clear_has_savelocation();
}
inline const ::std::string& SaveData::savelocation() const {
  return *savelocation_;
}
inline void SaveData::set_savelocation(const ::std::string& value) {
  set_has_savelocation();
  if (savelocation_ == &::google::protobuf::internal::kEmptyString) {
    savelocation_ = new ::std::string;
  }
  savelocation_->assign(value);
}
inline void SaveData::set_savelocation(const char* value) {
  set_has_savelocation();
  if (savelocation_ == &::google::protobuf::internal::kEmptyString) {
    savelocation_ = new ::std::string;
  }
  savelocation_->assign(value);
}
inline void SaveData::set_savelocation(const char* value, size_t size) {
  set_has_savelocation();
  if (savelocation_ == &::google::protobuf::internal::kEmptyString) {
    savelocation_ = new ::std::string;
  }
  savelocation_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SaveData::mutable_savelocation() {
  set_has_savelocation();
  if (savelocation_ == &::google::protobuf::internal::kEmptyString) {
    savelocation_ = new ::std::string;
  }
  return savelocation_;
}
inline ::std::string* SaveData::release_savelocation() {
  clear_has_savelocation();
  if (savelocation_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = savelocation_;
    savelocation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// TitleTicket

// required string titleId = 1;
inline bool TitleTicket::has_titleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TitleTicket::set_has_titleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TitleTicket::clear_has_titleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TitleTicket::clear_titleid() {
  if (titleid_ != &::google::protobuf::internal::kEmptyString) {
    titleid_->clear();
  }
  clear_has_titleid();
}
inline const ::std::string& TitleTicket::titleid() const {
  return *titleid_;
}
inline void TitleTicket::set_titleid(const ::std::string& value) {
  set_has_titleid();
  if (titleid_ == &::google::protobuf::internal::kEmptyString) {
    titleid_ = new ::std::string;
  }
  titleid_->assign(value);
}
inline void TitleTicket::set_titleid(const char* value) {
  set_has_titleid();
  if (titleid_ == &::google::protobuf::internal::kEmptyString) {
    titleid_ = new ::std::string;
  }
  titleid_->assign(value);
}
inline void TitleTicket::set_titleid(const char* value, size_t size) {
  set_has_titleid();
  if (titleid_ == &::google::protobuf::internal::kEmptyString) {
    titleid_ = new ::std::string;
  }
  titleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TitleTicket::mutable_titleid() {
  set_has_titleid();
  if (titleid_ == &::google::protobuf::internal::kEmptyString) {
    titleid_ = new ::std::string;
  }
  return titleid_;
}
inline ::std::string* TitleTicket::release_titleid() {
  clear_has_titleid();
  if (titleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = titleid_;
    titleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .vplex.vsDirectory.ETicketData eTicket = 2;
inline bool TitleTicket::has_eticket() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TitleTicket::set_has_eticket() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TitleTicket::clear_has_eticket() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TitleTicket::clear_eticket() {
  if (eticket_ != NULL) eticket_->::vplex::vsDirectory::ETicketData::Clear();
  clear_has_eticket();
}
inline const ::vplex::vsDirectory::ETicketData& TitleTicket::eticket() const {
  return eticket_ != NULL ? *eticket_ : *default_instance_->eticket_;
}
inline ::vplex::vsDirectory::ETicketData* TitleTicket::mutable_eticket() {
  set_has_eticket();
  if (eticket_ == NULL) eticket_ = new ::vplex::vsDirectory::ETicketData;
  return eticket_;
}
inline ::vplex::vsDirectory::ETicketData* TitleTicket::release_eticket() {
  clear_has_eticket();
  ::vplex::vsDirectory::ETicketData* temp = eticket_;
  eticket_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Subscription

// optional fixed64 datasetId = 1;
inline bool Subscription::has_datasetid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Subscription::set_has_datasetid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Subscription::clear_has_datasetid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Subscription::clear_datasetid() {
  datasetid_ = GOOGLE_ULONGLONG(0);
  clear_has_datasetid();
}
inline ::google::protobuf::uint64 Subscription::datasetid() const {
  return datasetid_;
}
inline void Subscription::set_datasetid(::google::protobuf::uint64 value) {
  set_has_datasetid();
  datasetid_ = value;
}

// optional string datasetName = 2;
inline bool Subscription::has_datasetname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Subscription::set_has_datasetname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Subscription::clear_has_datasetname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Subscription::clear_datasetname() {
  if (datasetname_ != &::google::protobuf::internal::kEmptyString) {
    datasetname_->clear();
  }
  clear_has_datasetname();
}
inline const ::std::string& Subscription::datasetname() const {
  return *datasetname_;
}
inline void Subscription::set_datasetname(const ::std::string& value) {
  set_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    datasetname_ = new ::std::string;
  }
  datasetname_->assign(value);
}
inline void Subscription::set_datasetname(const char* value) {
  set_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    datasetname_ = new ::std::string;
  }
  datasetname_->assign(value);
}
inline void Subscription::set_datasetname(const char* value, size_t size) {
  set_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    datasetname_ = new ::std::string;
  }
  datasetname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Subscription::mutable_datasetname() {
  set_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    datasetname_ = new ::std::string;
  }
  return datasetname_;
}
inline ::std::string* Subscription::release_datasetname() {
  clear_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = datasetname_;
    datasetname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string filter = 3;
inline bool Subscription::has_filter() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Subscription::set_has_filter() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Subscription::clear_has_filter() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Subscription::clear_filter() {
  if (filter_ != &::google::protobuf::internal::kEmptyString) {
    filter_->clear();
  }
  clear_has_filter();
}
inline const ::std::string& Subscription::filter() const {
  return *filter_;
}
inline void Subscription::set_filter(const ::std::string& value) {
  set_has_filter();
  if (filter_ == &::google::protobuf::internal::kEmptyString) {
    filter_ = new ::std::string;
  }
  filter_->assign(value);
}
inline void Subscription::set_filter(const char* value) {
  set_has_filter();
  if (filter_ == &::google::protobuf::internal::kEmptyString) {
    filter_ = new ::std::string;
  }
  filter_->assign(value);
}
inline void Subscription::set_filter(const char* value, size_t size) {
  set_has_filter();
  if (filter_ == &::google::protobuf::internal::kEmptyString) {
    filter_ = new ::std::string;
  }
  filter_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Subscription::mutable_filter() {
  set_has_filter();
  if (filter_ == &::google::protobuf::internal::kEmptyString) {
    filter_ = new ::std::string;
  }
  return filter_;
}
inline ::std::string* Subscription::release_filter() {
  clear_has_filter();
  if (filter_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filter_;
    filter_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string deviceRoot = 4;
inline bool Subscription::has_deviceroot() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Subscription::set_has_deviceroot() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Subscription::clear_has_deviceroot() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Subscription::clear_deviceroot() {
  if (deviceroot_ != &::google::protobuf::internal::kEmptyString) {
    deviceroot_->clear();
  }
  clear_has_deviceroot();
}
inline const ::std::string& Subscription::deviceroot() const {
  return *deviceroot_;
}
inline void Subscription::set_deviceroot(const ::std::string& value) {
  set_has_deviceroot();
  if (deviceroot_ == &::google::protobuf::internal::kEmptyString) {
    deviceroot_ = new ::std::string;
  }
  deviceroot_->assign(value);
}
inline void Subscription::set_deviceroot(const char* value) {
  set_has_deviceroot();
  if (deviceroot_ == &::google::protobuf::internal::kEmptyString) {
    deviceroot_ = new ::std::string;
  }
  deviceroot_->assign(value);
}
inline void Subscription::set_deviceroot(const char* value, size_t size) {
  set_has_deviceroot();
  if (deviceroot_ == &::google::protobuf::internal::kEmptyString) {
    deviceroot_ = new ::std::string;
  }
  deviceroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Subscription::mutable_deviceroot() {
  set_has_deviceroot();
  if (deviceroot_ == &::google::protobuf::internal::kEmptyString) {
    deviceroot_ = new ::std::string;
  }
  return deviceroot_;
}
inline ::std::string* Subscription::release_deviceroot() {
  clear_has_deviceroot();
  if (deviceroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deviceroot_;
    deviceroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string datasetRoot = 5;
inline bool Subscription::has_datasetroot() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Subscription::set_has_datasetroot() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Subscription::clear_has_datasetroot() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Subscription::clear_datasetroot() {
  if (datasetroot_ != &::google::protobuf::internal::kEmptyString) {
    datasetroot_->clear();
  }
  clear_has_datasetroot();
}
inline const ::std::string& Subscription::datasetroot() const {
  return *datasetroot_;
}
inline void Subscription::set_datasetroot(const ::std::string& value) {
  set_has_datasetroot();
  if (datasetroot_ == &::google::protobuf::internal::kEmptyString) {
    datasetroot_ = new ::std::string;
  }
  datasetroot_->assign(value);
}
inline void Subscription::set_datasetroot(const char* value) {
  set_has_datasetroot();
  if (datasetroot_ == &::google::protobuf::internal::kEmptyString) {
    datasetroot_ = new ::std::string;
  }
  datasetroot_->assign(value);
}
inline void Subscription::set_datasetroot(const char* value, size_t size) {
  set_has_datasetroot();
  if (datasetroot_ == &::google::protobuf::internal::kEmptyString) {
    datasetroot_ = new ::std::string;
  }
  datasetroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Subscription::mutable_datasetroot() {
  set_has_datasetroot();
  if (datasetroot_ == &::google::protobuf::internal::kEmptyString) {
    datasetroot_ = new ::std::string;
  }
  return datasetroot_;
}
inline ::std::string* Subscription::release_datasetroot() {
  clear_has_datasetroot();
  if (datasetroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = datasetroot_;
    datasetroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool uploadOk = 6;
inline bool Subscription::has_uploadok() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Subscription::set_has_uploadok() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Subscription::clear_has_uploadok() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Subscription::clear_uploadok() {
  uploadok_ = false;
  clear_has_uploadok();
}
inline bool Subscription::uploadok() const {
  return uploadok_;
}
inline void Subscription::set_uploadok(bool value) {
  set_has_uploadok();
  uploadok_ = value;
}

// optional bool downloadOk = 7;
inline bool Subscription::has_downloadok() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Subscription::set_has_downloadok() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Subscription::clear_has_downloadok() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Subscription::clear_downloadok() {
  downloadok_ = false;
  clear_has_downloadok();
}
inline bool Subscription::downloadok() const {
  return downloadok_;
}
inline void Subscription::set_downloadok(bool value) {
  set_has_downloadok();
  downloadok_ = value;
}

// optional bool uploadDeleteOk = 8;
inline bool Subscription::has_uploaddeleteok() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Subscription::set_has_uploaddeleteok() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Subscription::clear_has_uploaddeleteok() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Subscription::clear_uploaddeleteok() {
  uploaddeleteok_ = false;
  clear_has_uploaddeleteok();
}
inline bool Subscription::uploaddeleteok() const {
  return uploaddeleteok_;
}
inline void Subscription::set_uploaddeleteok(bool value) {
  set_has_uploaddeleteok();
  uploaddeleteok_ = value;
}

// optional bool downloadDeleteOk = 9;
inline bool Subscription::has_downloaddeleteok() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Subscription::set_has_downloaddeleteok() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Subscription::clear_has_downloaddeleteok() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Subscription::clear_downloaddeleteok() {
  downloaddeleteok_ = false;
  clear_has_downloaddeleteok();
}
inline bool Subscription::downloaddeleteok() const {
  return downloaddeleteok_;
}
inline void Subscription::set_downloaddeleteok(bool value) {
  set_has_downloaddeleteok();
  downloaddeleteok_ = value;
}

// optional string datasetLocation = 10;
inline bool Subscription::has_datasetlocation() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Subscription::set_has_datasetlocation() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Subscription::clear_has_datasetlocation() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Subscription::clear_datasetlocation() {
  if (datasetlocation_ != &::google::protobuf::internal::kEmptyString) {
    datasetlocation_->clear();
  }
  clear_has_datasetlocation();
}
inline const ::std::string& Subscription::datasetlocation() const {
  return *datasetlocation_;
}
inline void Subscription::set_datasetlocation(const ::std::string& value) {
  set_has_datasetlocation();
  if (datasetlocation_ == &::google::protobuf::internal::kEmptyString) {
    datasetlocation_ = new ::std::string;
  }
  datasetlocation_->assign(value);
}
inline void Subscription::set_datasetlocation(const char* value) {
  set_has_datasetlocation();
  if (datasetlocation_ == &::google::protobuf::internal::kEmptyString) {
    datasetlocation_ = new ::std::string;
  }
  datasetlocation_->assign(value);
}
inline void Subscription::set_datasetlocation(const char* value, size_t size) {
  set_has_datasetlocation();
  if (datasetlocation_ == &::google::protobuf::internal::kEmptyString) {
    datasetlocation_ = new ::std::string;
  }
  datasetlocation_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Subscription::mutable_datasetlocation() {
  set_has_datasetlocation();
  if (datasetlocation_ == &::google::protobuf::internal::kEmptyString) {
    datasetlocation_ = new ::std::string;
  }
  return datasetlocation_;
}
inline ::std::string* Subscription::release_datasetlocation() {
  clear_has_datasetlocation();
  if (datasetlocation_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = datasetlocation_;
    datasetlocation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string contentType = 11;
inline bool Subscription::has_contenttype() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Subscription::set_has_contenttype() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Subscription::clear_has_contenttype() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Subscription::clear_contenttype() {
  if (contenttype_ != &::google::protobuf::internal::kEmptyString) {
    contenttype_->clear();
  }
  clear_has_contenttype();
}
inline const ::std::string& Subscription::contenttype() const {
  return *contenttype_;
}
inline void Subscription::set_contenttype(const ::std::string& value) {
  set_has_contenttype();
  if (contenttype_ == &::google::protobuf::internal::kEmptyString) {
    contenttype_ = new ::std::string;
  }
  contenttype_->assign(value);
}
inline void Subscription::set_contenttype(const char* value) {
  set_has_contenttype();
  if (contenttype_ == &::google::protobuf::internal::kEmptyString) {
    contenttype_ = new ::std::string;
  }
  contenttype_->assign(value);
}
inline void Subscription::set_contenttype(const char* value, size_t size) {
  set_has_contenttype();
  if (contenttype_ == &::google::protobuf::internal::kEmptyString) {
    contenttype_ = new ::std::string;
  }
  contenttype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Subscription::mutable_contenttype() {
  set_has_contenttype();
  if (contenttype_ == &::google::protobuf::internal::kEmptyString) {
    contenttype_ = new ::std::string;
  }
  return contenttype_;
}
inline ::std::string* Subscription::release_contenttype() {
  clear_has_contenttype();
  if (contenttype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contenttype_;
    contenttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string createdFor = 12;
inline bool Subscription::has_createdfor() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Subscription::set_has_createdfor() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Subscription::clear_has_createdfor() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Subscription::clear_createdfor() {
  if (createdfor_ != &::google::protobuf::internal::kEmptyString) {
    createdfor_->clear();
  }
  clear_has_createdfor();
}
inline const ::std::string& Subscription::createdfor() const {
  return *createdfor_;
}
inline void Subscription::set_createdfor(const ::std::string& value) {
  set_has_createdfor();
  if (createdfor_ == &::google::protobuf::internal::kEmptyString) {
    createdfor_ = new ::std::string;
  }
  createdfor_->assign(value);
}
inline void Subscription::set_createdfor(const char* value) {
  set_has_createdfor();
  if (createdfor_ == &::google::protobuf::internal::kEmptyString) {
    createdfor_ = new ::std::string;
  }
  createdfor_->assign(value);
}
inline void Subscription::set_createdfor(const char* value, size_t size) {
  set_has_createdfor();
  if (createdfor_ == &::google::protobuf::internal::kEmptyString) {
    createdfor_ = new ::std::string;
  }
  createdfor_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Subscription::mutable_createdfor() {
  set_has_createdfor();
  if (createdfor_ == &::google::protobuf::internal::kEmptyString) {
    createdfor_ = new ::std::string;
  }
  return createdfor_;
}
inline ::std::string* Subscription::release_createdfor() {
  clear_has_createdfor();
  if (createdfor_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = createdfor_;
    createdfor_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional fixed64 maxSize = 13;
inline bool Subscription::has_maxsize() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Subscription::set_has_maxsize() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Subscription::clear_has_maxsize() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Subscription::clear_maxsize() {
  maxsize_ = GOOGLE_ULONGLONG(0);
  clear_has_maxsize();
}
inline ::google::protobuf::uint64 Subscription::maxsize() const {
  return maxsize_;
}
inline void Subscription::set_maxsize(::google::protobuf::uint64 value) {
  set_has_maxsize();
  maxsize_ = value;
}

// optional fixed64 maxFiles = 14;
inline bool Subscription::has_maxfiles() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Subscription::set_has_maxfiles() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Subscription::clear_has_maxfiles() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Subscription::clear_maxfiles() {
  maxfiles_ = GOOGLE_ULONGLONG(0);
  clear_has_maxfiles();
}
inline ::google::protobuf::uint64 Subscription::maxfiles() const {
  return maxfiles_;
}
inline void Subscription::set_maxfiles(::google::protobuf::uint64 value) {
  set_has_maxfiles();
  maxfiles_ = value;
}

// optional fixed64 creationTime = 15;
inline bool Subscription::has_creationtime() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Subscription::set_has_creationtime() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Subscription::clear_has_creationtime() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Subscription::clear_creationtime() {
  creationtime_ = GOOGLE_ULONGLONG(0);
  clear_has_creationtime();
}
inline ::google::protobuf::uint64 Subscription::creationtime() const {
  return creationtime_;
}
inline void Subscription::set_creationtime(::google::protobuf::uint64 value) {
  set_has_creationtime();
  creationtime_ = value;
}

// -------------------------------------------------------------------

// SyncDirectory

// required string localPath = 1;
inline bool SyncDirectory::has_localpath() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SyncDirectory::set_has_localpath() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SyncDirectory::clear_has_localpath() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SyncDirectory::clear_localpath() {
  if (localpath_ != &::google::protobuf::internal::kEmptyString) {
    localpath_->clear();
  }
  clear_has_localpath();
}
inline const ::std::string& SyncDirectory::localpath() const {
  return *localpath_;
}
inline void SyncDirectory::set_localpath(const ::std::string& value) {
  set_has_localpath();
  if (localpath_ == &::google::protobuf::internal::kEmptyString) {
    localpath_ = new ::std::string;
  }
  localpath_->assign(value);
}
inline void SyncDirectory::set_localpath(const char* value) {
  set_has_localpath();
  if (localpath_ == &::google::protobuf::internal::kEmptyString) {
    localpath_ = new ::std::string;
  }
  localpath_->assign(value);
}
inline void SyncDirectory::set_localpath(const char* value, size_t size) {
  set_has_localpath();
  if (localpath_ == &::google::protobuf::internal::kEmptyString) {
    localpath_ = new ::std::string;
  }
  localpath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SyncDirectory::mutable_localpath() {
  set_has_localpath();
  if (localpath_ == &::google::protobuf::internal::kEmptyString) {
    localpath_ = new ::std::string;
  }
  return localpath_;
}
inline ::std::string* SyncDirectory::release_localpath() {
  clear_has_localpath();
  if (localpath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = localpath_;
    localpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string serverPath = 2;
inline bool SyncDirectory::has_serverpath() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SyncDirectory::set_has_serverpath() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SyncDirectory::clear_has_serverpath() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SyncDirectory::clear_serverpath() {
  if (serverpath_ != &::google::protobuf::internal::kEmptyString) {
    serverpath_->clear();
  }
  clear_has_serverpath();
}
inline const ::std::string& SyncDirectory::serverpath() const {
  return *serverpath_;
}
inline void SyncDirectory::set_serverpath(const ::std::string& value) {
  set_has_serverpath();
  if (serverpath_ == &::google::protobuf::internal::kEmptyString) {
    serverpath_ = new ::std::string;
  }
  serverpath_->assign(value);
}
inline void SyncDirectory::set_serverpath(const char* value) {
  set_has_serverpath();
  if (serverpath_ == &::google::protobuf::internal::kEmptyString) {
    serverpath_ = new ::std::string;
  }
  serverpath_->assign(value);
}
inline void SyncDirectory::set_serverpath(const char* value, size_t size) {
  set_has_serverpath();
  if (serverpath_ == &::google::protobuf::internal::kEmptyString) {
    serverpath_ = new ::std::string;
  }
  serverpath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SyncDirectory::mutable_serverpath() {
  set_has_serverpath();
  if (serverpath_ == &::google::protobuf::internal::kEmptyString) {
    serverpath_ = new ::std::string;
  }
  return serverpath_;
}
inline ::std::string* SyncDirectory::release_serverpath() {
  clear_has_serverpath();
  if (serverpath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serverpath_;
    serverpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bool privateFlag = 3;
inline bool SyncDirectory::has_privateflag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SyncDirectory::set_has_privateflag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SyncDirectory::clear_has_privateflag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SyncDirectory::clear_privateflag() {
  privateflag_ = false;
  clear_has_privateflag();
}
inline bool SyncDirectory::privateflag() const {
  return privateflag_;
}
inline void SyncDirectory::set_privateflag(bool value) {
  set_has_privateflag();
  privateflag_ = value;
}

// -------------------------------------------------------------------

// DatasetData

// required fixed64 datasetId = 1;
inline bool DatasetData::has_datasetid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DatasetData::set_has_datasetid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DatasetData::clear_has_datasetid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DatasetData::clear_datasetid() {
  datasetid_ = GOOGLE_ULONGLONG(0);
  clear_has_datasetid();
}
inline ::google::protobuf::uint64 DatasetData::datasetid() const {
  return datasetid_;
}
inline void DatasetData::set_datasetid(::google::protobuf::uint64 value) {
  set_has_datasetid();
  datasetid_ = value;
}

// required int32 detailHash = 2;
inline bool DatasetData::has_detailhash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DatasetData::set_has_detailhash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DatasetData::clear_has_detailhash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DatasetData::clear_detailhash() {
  detailhash_ = 0;
  clear_has_detailhash();
}
inline ::google::protobuf::int32 DatasetData::detailhash() const {
  return detailhash_;
}
inline void DatasetData::set_detailhash(::google::protobuf::int32 value) {
  set_has_detailhash();
  detailhash_ = value;
}

// -------------------------------------------------------------------

// DatasetDetail

// required fixed64 datasetId = 1;
inline bool DatasetDetail::has_datasetid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DatasetDetail::set_has_datasetid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DatasetDetail::clear_has_datasetid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DatasetDetail::clear_datasetid() {
  datasetid_ = GOOGLE_ULONGLONG(0);
  clear_has_datasetid();
}
inline ::google::protobuf::uint64 DatasetDetail::datasetid() const {
  return datasetid_;
}
inline void DatasetDetail::set_datasetid(::google::protobuf::uint64 value) {
  set_has_datasetid();
  datasetid_ = value;
}

// required string datasetName = 2;
inline bool DatasetDetail::has_datasetname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DatasetDetail::set_has_datasetname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DatasetDetail::clear_has_datasetname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DatasetDetail::clear_datasetname() {
  if (datasetname_ != &::google::protobuf::internal::kEmptyString) {
    datasetname_->clear();
  }
  clear_has_datasetname();
}
inline const ::std::string& DatasetDetail::datasetname() const {
  return *datasetname_;
}
inline void DatasetDetail::set_datasetname(const ::std::string& value) {
  set_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    datasetname_ = new ::std::string;
  }
  datasetname_->assign(value);
}
inline void DatasetDetail::set_datasetname(const char* value) {
  set_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    datasetname_ = new ::std::string;
  }
  datasetname_->assign(value);
}
inline void DatasetDetail::set_datasetname(const char* value, size_t size) {
  set_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    datasetname_ = new ::std::string;
  }
  datasetname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DatasetDetail::mutable_datasetname() {
  set_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    datasetname_ = new ::std::string;
  }
  return datasetname_;
}
inline ::std::string* DatasetDetail::release_datasetname() {
  clear_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = datasetname_;
    datasetname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string contentType = 3;
inline bool DatasetDetail::has_contenttype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DatasetDetail::set_has_contenttype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DatasetDetail::clear_has_contenttype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DatasetDetail::clear_contenttype() {
  if (contenttype_ != &::google::protobuf::internal::kEmptyString) {
    contenttype_->clear();
  }
  clear_has_contenttype();
}
inline const ::std::string& DatasetDetail::contenttype() const {
  return *contenttype_;
}
inline void DatasetDetail::set_contenttype(const ::std::string& value) {
  set_has_contenttype();
  if (contenttype_ == &::google::protobuf::internal::kEmptyString) {
    contenttype_ = new ::std::string;
  }
  contenttype_->assign(value);
}
inline void DatasetDetail::set_contenttype(const char* value) {
  set_has_contenttype();
  if (contenttype_ == &::google::protobuf::internal::kEmptyString) {
    contenttype_ = new ::std::string;
  }
  contenttype_->assign(value);
}
inline void DatasetDetail::set_contenttype(const char* value, size_t size) {
  set_has_contenttype();
  if (contenttype_ == &::google::protobuf::internal::kEmptyString) {
    contenttype_ = new ::std::string;
  }
  contenttype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DatasetDetail::mutable_contenttype() {
  set_has_contenttype();
  if (contenttype_ == &::google::protobuf::internal::kEmptyString) {
    contenttype_ = new ::std::string;
  }
  return contenttype_;
}
inline ::std::string* DatasetDetail::release_contenttype() {
  clear_has_contenttype();
  if (contenttype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contenttype_;
    contenttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string createdFor = 4;
inline bool DatasetDetail::has_createdfor() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DatasetDetail::set_has_createdfor() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DatasetDetail::clear_has_createdfor() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DatasetDetail::clear_createdfor() {
  if (createdfor_ != &::google::protobuf::internal::kEmptyString) {
    createdfor_->clear();
  }
  clear_has_createdfor();
}
inline const ::std::string& DatasetDetail::createdfor() const {
  return *createdfor_;
}
inline void DatasetDetail::set_createdfor(const ::std::string& value) {
  set_has_createdfor();
  if (createdfor_ == &::google::protobuf::internal::kEmptyString) {
    createdfor_ = new ::std::string;
  }
  createdfor_->assign(value);
}
inline void DatasetDetail::set_createdfor(const char* value) {
  set_has_createdfor();
  if (createdfor_ == &::google::protobuf::internal::kEmptyString) {
    createdfor_ = new ::std::string;
  }
  createdfor_->assign(value);
}
inline void DatasetDetail::set_createdfor(const char* value, size_t size) {
  set_has_createdfor();
  if (createdfor_ == &::google::protobuf::internal::kEmptyString) {
    createdfor_ = new ::std::string;
  }
  createdfor_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DatasetDetail::mutable_createdfor() {
  set_has_createdfor();
  if (createdfor_ == &::google::protobuf::internal::kEmptyString) {
    createdfor_ = new ::std::string;
  }
  return createdfor_;
}
inline ::std::string* DatasetDetail::release_createdfor() {
  clear_has_createdfor();
  if (createdfor_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = createdfor_;
    createdfor_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string externalId = 5;
inline bool DatasetDetail::has_externalid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DatasetDetail::set_has_externalid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DatasetDetail::clear_has_externalid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DatasetDetail::clear_externalid() {
  if (externalid_ != &::google::protobuf::internal::kEmptyString) {
    externalid_->clear();
  }
  clear_has_externalid();
}
inline const ::std::string& DatasetDetail::externalid() const {
  return *externalid_;
}
inline void DatasetDetail::set_externalid(const ::std::string& value) {
  set_has_externalid();
  if (externalid_ == &::google::protobuf::internal::kEmptyString) {
    externalid_ = new ::std::string;
  }
  externalid_->assign(value);
}
inline void DatasetDetail::set_externalid(const char* value) {
  set_has_externalid();
  if (externalid_ == &::google::protobuf::internal::kEmptyString) {
    externalid_ = new ::std::string;
  }
  externalid_->assign(value);
}
inline void DatasetDetail::set_externalid(const char* value, size_t size) {
  set_has_externalid();
  if (externalid_ == &::google::protobuf::internal::kEmptyString) {
    externalid_ = new ::std::string;
  }
  externalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DatasetDetail::mutable_externalid() {
  set_has_externalid();
  if (externalid_ == &::google::protobuf::internal::kEmptyString) {
    externalid_ = new ::std::string;
  }
  return externalid_;
}
inline ::std::string* DatasetDetail::release_externalid() {
  clear_has_externalid();
  if (externalid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = externalid_;
    externalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required fixed64 lastUpdated = 6;
inline bool DatasetDetail::has_lastupdated() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DatasetDetail::set_has_lastupdated() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DatasetDetail::clear_has_lastupdated() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DatasetDetail::clear_lastupdated() {
  lastupdated_ = GOOGLE_ULONGLONG(0);
  clear_has_lastupdated();
}
inline ::google::protobuf::uint64 DatasetDetail::lastupdated() const {
  return lastupdated_;
}
inline void DatasetDetail::set_lastupdated(::google::protobuf::uint64 value) {
  set_has_lastupdated();
  lastupdated_ = value;
}

// optional string storageClusterName = 7;
inline bool DatasetDetail::has_storageclustername() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DatasetDetail::set_has_storageclustername() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DatasetDetail::clear_has_storageclustername() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DatasetDetail::clear_storageclustername() {
  if (storageclustername_ != &::google::protobuf::internal::kEmptyString) {
    storageclustername_->clear();
  }
  clear_has_storageclustername();
}
inline const ::std::string& DatasetDetail::storageclustername() const {
  return *storageclustername_;
}
inline void DatasetDetail::set_storageclustername(const ::std::string& value) {
  set_has_storageclustername();
  if (storageclustername_ == &::google::protobuf::internal::kEmptyString) {
    storageclustername_ = new ::std::string;
  }
  storageclustername_->assign(value);
}
inline void DatasetDetail::set_storageclustername(const char* value) {
  set_has_storageclustername();
  if (storageclustername_ == &::google::protobuf::internal::kEmptyString) {
    storageclustername_ = new ::std::string;
  }
  storageclustername_->assign(value);
}
inline void DatasetDetail::set_storageclustername(const char* value, size_t size) {
  set_has_storageclustername();
  if (storageclustername_ == &::google::protobuf::internal::kEmptyString) {
    storageclustername_ = new ::std::string;
  }
  storageclustername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DatasetDetail::mutable_storageclustername() {
  set_has_storageclustername();
  if (storageclustername_ == &::google::protobuf::internal::kEmptyString) {
    storageclustername_ = new ::std::string;
  }
  return storageclustername_;
}
inline ::std::string* DatasetDetail::release_storageclustername() {
  clear_has_storageclustername();
  if (storageclustername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = storageclustername_;
    storageclustername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string storageClusterHostName = 8;
inline bool DatasetDetail::has_storageclusterhostname() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DatasetDetail::set_has_storageclusterhostname() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DatasetDetail::clear_has_storageclusterhostname() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DatasetDetail::clear_storageclusterhostname() {
  if (storageclusterhostname_ != &::google::protobuf::internal::kEmptyString) {
    storageclusterhostname_->clear();
  }
  clear_has_storageclusterhostname();
}
inline const ::std::string& DatasetDetail::storageclusterhostname() const {
  return *storageclusterhostname_;
}
inline void DatasetDetail::set_storageclusterhostname(const ::std::string& value) {
  set_has_storageclusterhostname();
  if (storageclusterhostname_ == &::google::protobuf::internal::kEmptyString) {
    storageclusterhostname_ = new ::std::string;
  }
  storageclusterhostname_->assign(value);
}
inline void DatasetDetail::set_storageclusterhostname(const char* value) {
  set_has_storageclusterhostname();
  if (storageclusterhostname_ == &::google::protobuf::internal::kEmptyString) {
    storageclusterhostname_ = new ::std::string;
  }
  storageclusterhostname_->assign(value);
}
inline void DatasetDetail::set_storageclusterhostname(const char* value, size_t size) {
  set_has_storageclusterhostname();
  if (storageclusterhostname_ == &::google::protobuf::internal::kEmptyString) {
    storageclusterhostname_ = new ::std::string;
  }
  storageclusterhostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DatasetDetail::mutable_storageclusterhostname() {
  set_has_storageclusterhostname();
  if (storageclusterhostname_ == &::google::protobuf::internal::kEmptyString) {
    storageclusterhostname_ = new ::std::string;
  }
  return storageclusterhostname_;
}
inline ::std::string* DatasetDetail::release_storageclusterhostname() {
  clear_has_storageclusterhostname();
  if (storageclusterhostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = storageclusterhostname_;
    storageclusterhostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 storageClusterPort = 9;
inline bool DatasetDetail::has_storageclusterport() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DatasetDetail::set_has_storageclusterport() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DatasetDetail::clear_has_storageclusterport() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DatasetDetail::clear_storageclusterport() {
  storageclusterport_ = 0;
  clear_has_storageclusterport();
}
inline ::google::protobuf::int32 DatasetDetail::storageclusterport() const {
  return storageclusterport_;
}
inline void DatasetDetail::set_storageclusterport(::google::protobuf::int32 value) {
  set_has_storageclusterport();
  storageclusterport_ = value;
}

// optional string datasetLocation = 10;
inline bool DatasetDetail::has_datasetlocation() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DatasetDetail::set_has_datasetlocation() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DatasetDetail::clear_has_datasetlocation() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DatasetDetail::clear_datasetlocation() {
  if (datasetlocation_ != &::google::protobuf::internal::kEmptyString) {
    datasetlocation_->clear();
  }
  clear_has_datasetlocation();
}
inline const ::std::string& DatasetDetail::datasetlocation() const {
  return *datasetlocation_;
}
inline void DatasetDetail::set_datasetlocation(const ::std::string& value) {
  set_has_datasetlocation();
  if (datasetlocation_ == &::google::protobuf::internal::kEmptyString) {
    datasetlocation_ = new ::std::string;
  }
  datasetlocation_->assign(value);
}
inline void DatasetDetail::set_datasetlocation(const char* value) {
  set_has_datasetlocation();
  if (datasetlocation_ == &::google::protobuf::internal::kEmptyString) {
    datasetlocation_ = new ::std::string;
  }
  datasetlocation_->assign(value);
}
inline void DatasetDetail::set_datasetlocation(const char* value, size_t size) {
  set_has_datasetlocation();
  if (datasetlocation_ == &::google::protobuf::internal::kEmptyString) {
    datasetlocation_ = new ::std::string;
  }
  datasetlocation_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DatasetDetail::mutable_datasetlocation() {
  set_has_datasetlocation();
  if (datasetlocation_ == &::google::protobuf::internal::kEmptyString) {
    datasetlocation_ = new ::std::string;
  }
  return datasetlocation_;
}
inline ::std::string* DatasetDetail::release_datasetlocation() {
  clear_has_datasetlocation();
  if (datasetlocation_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = datasetlocation_;
    datasetlocation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional fixed64 sizeOnDisk = 11;
inline bool DatasetDetail::has_sizeondisk() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DatasetDetail::set_has_sizeondisk() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DatasetDetail::clear_has_sizeondisk() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DatasetDetail::clear_sizeondisk() {
  sizeondisk_ = GOOGLE_ULONGLONG(0);
  clear_has_sizeondisk();
}
inline ::google::protobuf::uint64 DatasetDetail::sizeondisk() const {
  return sizeondisk_;
}
inline void DatasetDetail::set_sizeondisk(::google::protobuf::uint64 value) {
  set_has_sizeondisk();
  sizeondisk_ = value;
}

// optional .vplex.vsDirectory.DatasetType datasetType = 12;
inline bool DatasetDetail::has_datasettype() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DatasetDetail::set_has_datasettype() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DatasetDetail::clear_has_datasettype() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DatasetDetail::clear_datasettype() {
  datasettype_ = 1;
  clear_has_datasettype();
}
inline vplex::vsDirectory::DatasetType DatasetDetail::datasettype() const {
  return static_cast< vplex::vsDirectory::DatasetType >(datasettype_);
}
inline void DatasetDetail::set_datasettype(vplex::vsDirectory::DatasetType value) {
  GOOGLE_DCHECK(vplex::vsDirectory::DatasetType_IsValid(value));
  set_has_datasettype();
  datasettype_ = value;
}

// optional fixed64 linkedTo = 13;
inline bool DatasetDetail::has_linkedto() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DatasetDetail::set_has_linkedto() {
  _has_bits_[0] |= 0x00001000u;
}
inline void DatasetDetail::clear_has_linkedto() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void DatasetDetail::clear_linkedto() {
  linkedto_ = GOOGLE_ULONGLONG(0);
  clear_has_linkedto();
}
inline ::google::protobuf::uint64 DatasetDetail::linkedto() const {
  return linkedto_;
}
inline void DatasetDetail::set_linkedto(::google::protobuf::uint64 value) {
  set_has_linkedto();
  linkedto_ = value;
}

// optional fixed64 clusterId = 14;
inline bool DatasetDetail::has_clusterid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void DatasetDetail::set_has_clusterid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void DatasetDetail::clear_has_clusterid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void DatasetDetail::clear_clusterid() {
  clusterid_ = GOOGLE_ULONGLONG(0);
  clear_has_clusterid();
}
inline ::google::protobuf::uint64 DatasetDetail::clusterid() const {
  return clusterid_;
}
inline void DatasetDetail::set_clusterid(::google::protobuf::uint64 value) {
  set_has_clusterid();
  clusterid_ = value;
}

// optional fixed64 userId = 15;
inline bool DatasetDetail::has_userid() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void DatasetDetail::set_has_userid() {
  _has_bits_[0] |= 0x00004000u;
}
inline void DatasetDetail::clear_has_userid() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void DatasetDetail::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 DatasetDetail::userid() const {
  return userid_;
}
inline void DatasetDetail::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// optional bool suspendedFlag = 16;
inline bool DatasetDetail::has_suspendedflag() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void DatasetDetail::set_has_suspendedflag() {
  _has_bits_[0] |= 0x00008000u;
}
inline void DatasetDetail::clear_has_suspendedflag() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void DatasetDetail::clear_suspendedflag() {
  suspendedflag_ = false;
  clear_has_suspendedflag();
}
inline bool DatasetDetail::suspendedflag() const {
  return suspendedflag_;
}
inline void DatasetDetail::set_suspendedflag(bool value) {
  set_has_suspendedflag();
  suspendedflag_ = value;
}

// optional fixed64 primaryStorageId = 17;
inline bool DatasetDetail::has_primarystorageid() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void DatasetDetail::set_has_primarystorageid() {
  _has_bits_[0] |= 0x00010000u;
}
inline void DatasetDetail::clear_has_primarystorageid() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void DatasetDetail::clear_primarystorageid() {
  primarystorageid_ = GOOGLE_ULONGLONG(0);
  clear_has_primarystorageid();
}
inline ::google::protobuf::uint64 DatasetDetail::primarystorageid() const {
  return primarystorageid_;
}
inline void DatasetDetail::set_primarystorageid(::google::protobuf::uint64 value) {
  set_has_primarystorageid();
  primarystorageid_ = value;
}

// optional fixed64 deleteDataAfter = 18;
inline bool DatasetDetail::has_deletedataafter() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void DatasetDetail::set_has_deletedataafter() {
  _has_bits_[0] |= 0x00020000u;
}
inline void DatasetDetail::clear_has_deletedataafter() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void DatasetDetail::clear_deletedataafter() {
  deletedataafter_ = GOOGLE_ULONGLONG(0);
  clear_has_deletedataafter();
}
inline ::google::protobuf::uint64 DatasetDetail::deletedataafter() const {
  return deletedataafter_;
}
inline void DatasetDetail::set_deletedataafter(::google::protobuf::uint64 value) {
  set_has_deletedataafter();
  deletedataafter_ = value;
}

// repeated fixed64 archiveStorageDeviceId = 19;
inline int DatasetDetail::archivestoragedeviceid_size() const {
  return archivestoragedeviceid_.size();
}
inline void DatasetDetail::clear_archivestoragedeviceid() {
  archivestoragedeviceid_.Clear();
}
inline ::google::protobuf::uint64 DatasetDetail::archivestoragedeviceid(int index) const {
  return archivestoragedeviceid_.Get(index);
}
inline void DatasetDetail::set_archivestoragedeviceid(int index, ::google::protobuf::uint64 value) {
  archivestoragedeviceid_.Set(index, value);
}
inline void DatasetDetail::add_archivestoragedeviceid(::google::protobuf::uint64 value) {
  archivestoragedeviceid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
DatasetDetail::archivestoragedeviceid() const {
  return archivestoragedeviceid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
DatasetDetail::mutable_archivestoragedeviceid() {
  return &archivestoragedeviceid_;
}

// optional string displayName = 20;
inline bool DatasetDetail::has_displayname() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void DatasetDetail::set_has_displayname() {
  _has_bits_[0] |= 0x00080000u;
}
inline void DatasetDetail::clear_has_displayname() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void DatasetDetail::clear_displayname() {
  if (displayname_ != &::google::protobuf::internal::kEmptyString) {
    displayname_->clear();
  }
  clear_has_displayname();
}
inline const ::std::string& DatasetDetail::displayname() const {
  return *displayname_;
}
inline void DatasetDetail::set_displayname(const ::std::string& value) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(value);
}
inline void DatasetDetail::set_displayname(const char* value) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(value);
}
inline void DatasetDetail::set_displayname(const char* value, size_t size) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DatasetDetail::mutable_displayname() {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  return displayname_;
}
inline ::std::string* DatasetDetail::release_displayname() {
  clear_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = displayname_;
    displayname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// StoredDataset

// required fixed64 userId = 1;
inline bool StoredDataset::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StoredDataset::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StoredDataset::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StoredDataset::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 StoredDataset::userid() const {
  return userid_;
}
inline void StoredDataset::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required fixed64 datasetId = 2;
inline bool StoredDataset::has_datasetid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StoredDataset::set_has_datasetid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StoredDataset::clear_has_datasetid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StoredDataset::clear_datasetid() {
  datasetid_ = GOOGLE_ULONGLONG(0);
  clear_has_datasetid();
}
inline ::google::protobuf::uint64 StoredDataset::datasetid() const {
  return datasetid_;
}
inline void StoredDataset::set_datasetid(::google::protobuf::uint64 value) {
  set_has_datasetid();
  datasetid_ = value;
}

// required .vplex.vsDirectory.DatasetType datasetType = 3;
inline bool StoredDataset::has_datasettype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StoredDataset::set_has_datasettype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StoredDataset::clear_has_datasettype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StoredDataset::clear_datasettype() {
  datasettype_ = 1;
  clear_has_datasettype();
}
inline vplex::vsDirectory::DatasetType StoredDataset::datasettype() const {
  return static_cast< vplex::vsDirectory::DatasetType >(datasettype_);
}
inline void StoredDataset::set_datasettype(vplex::vsDirectory::DatasetType value) {
  GOOGLE_DCHECK(vplex::vsDirectory::DatasetType_IsValid(value));
  set_has_datasettype();
  datasettype_ = value;
}

// required fixed64 dataRetentionTime = 4;
inline bool StoredDataset::has_dataretentiontime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StoredDataset::set_has_dataretentiontime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StoredDataset::clear_has_dataretentiontime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StoredDataset::clear_dataretentiontime() {
  dataretentiontime_ = GOOGLE_ULONGLONG(0);
  clear_has_dataretentiontime();
}
inline ::google::protobuf::uint64 StoredDataset::dataretentiontime() const {
  return dataretentiontime_;
}
inline void StoredDataset::set_dataretentiontime(::google::protobuf::uint64 value) {
  set_has_dataretentiontime();
  dataretentiontime_ = value;
}

// optional fixed64 storageClusterId = 5;
inline bool StoredDataset::has_storageclusterid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StoredDataset::set_has_storageclusterid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StoredDataset::clear_has_storageclusterid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StoredDataset::clear_storageclusterid() {
  storageclusterid_ = GOOGLE_ULONGLONG(0);
  clear_has_storageclusterid();
}
inline ::google::protobuf::uint64 StoredDataset::storageclusterid() const {
  return storageclusterid_;
}
inline void StoredDataset::set_storageclusterid(::google::protobuf::uint64 value) {
  set_has_storageclusterid();
  storageclusterid_ = value;
}

// optional fixed64 primaryStorageId = 6;
inline bool StoredDataset::has_primarystorageid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StoredDataset::set_has_primarystorageid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StoredDataset::clear_has_primarystorageid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StoredDataset::clear_primarystorageid() {
  primarystorageid_ = GOOGLE_ULONGLONG(0);
  clear_has_primarystorageid();
}
inline ::google::protobuf::uint64 StoredDataset::primarystorageid() const {
  return primarystorageid_;
}
inline void StoredDataset::set_primarystorageid(::google::protobuf::uint64 value) {
  set_has_primarystorageid();
  primarystorageid_ = value;
}

// optional fixed64 secondaryStorageId = 7;
inline bool StoredDataset::has_secondarystorageid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void StoredDataset::set_has_secondarystorageid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void StoredDataset::clear_has_secondarystorageid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void StoredDataset::clear_secondarystorageid() {
  secondarystorageid_ = GOOGLE_ULONGLONG(0);
  clear_has_secondarystorageid();
}
inline ::google::protobuf::uint64 StoredDataset::secondarystorageid() const {
  return secondarystorageid_;
}
inline void StoredDataset::set_secondarystorageid(::google::protobuf::uint64 value) {
  set_has_secondarystorageid();
  secondarystorageid_ = value;
}

// optional fixed64 backupStorageId = 8;
inline bool StoredDataset::has_backupstorageid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void StoredDataset::set_has_backupstorageid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void StoredDataset::clear_has_backupstorageid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void StoredDataset::clear_backupstorageid() {
  backupstorageid_ = GOOGLE_ULONGLONG(0);
  clear_has_backupstorageid();
}
inline ::google::protobuf::uint64 StoredDataset::backupstorageid() const {
  return backupstorageid_;
}
inline void StoredDataset::set_backupstorageid(::google::protobuf::uint64 value) {
  set_has_backupstorageid();
  backupstorageid_ = value;
}

// -------------------------------------------------------------------

// DeviceInfo

// required fixed64 deviceId = 1;
inline bool DeviceInfo::has_deviceid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceInfo::set_has_deviceid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceInfo::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceInfo::clear_deviceid() {
  deviceid_ = GOOGLE_ULONGLONG(0);
  clear_has_deviceid();
}
inline ::google::protobuf::uint64 DeviceInfo::deviceid() const {
  return deviceid_;
}
inline void DeviceInfo::set_deviceid(::google::protobuf::uint64 value) {
  set_has_deviceid();
  deviceid_ = value;
}

// required string deviceClass = 2;
inline bool DeviceInfo::has_deviceclass() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceInfo::set_has_deviceclass() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeviceInfo::clear_has_deviceclass() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceInfo::clear_deviceclass() {
  if (deviceclass_ != &::google::protobuf::internal::kEmptyString) {
    deviceclass_->clear();
  }
  clear_has_deviceclass();
}
inline const ::std::string& DeviceInfo::deviceclass() const {
  return *deviceclass_;
}
inline void DeviceInfo::set_deviceclass(const ::std::string& value) {
  set_has_deviceclass();
  if (deviceclass_ == &::google::protobuf::internal::kEmptyString) {
    deviceclass_ = new ::std::string;
  }
  deviceclass_->assign(value);
}
inline void DeviceInfo::set_deviceclass(const char* value) {
  set_has_deviceclass();
  if (deviceclass_ == &::google::protobuf::internal::kEmptyString) {
    deviceclass_ = new ::std::string;
  }
  deviceclass_->assign(value);
}
inline void DeviceInfo::set_deviceclass(const char* value, size_t size) {
  set_has_deviceclass();
  if (deviceclass_ == &::google::protobuf::internal::kEmptyString) {
    deviceclass_ = new ::std::string;
  }
  deviceclass_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceInfo::mutable_deviceclass() {
  set_has_deviceclass();
  if (deviceclass_ == &::google::protobuf::internal::kEmptyString) {
    deviceclass_ = new ::std::string;
  }
  return deviceclass_;
}
inline ::std::string* DeviceInfo::release_deviceclass() {
  clear_has_deviceclass();
  if (deviceclass_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deviceclass_;
    deviceclass_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string deviceName = 3;
inline bool DeviceInfo::has_devicename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceInfo::set_has_devicename() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeviceInfo::clear_has_devicename() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeviceInfo::clear_devicename() {
  if (devicename_ != &::google::protobuf::internal::kEmptyString) {
    devicename_->clear();
  }
  clear_has_devicename();
}
inline const ::std::string& DeviceInfo::devicename() const {
  return *devicename_;
}
inline void DeviceInfo::set_devicename(const ::std::string& value) {
  set_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    devicename_ = new ::std::string;
  }
  devicename_->assign(value);
}
inline void DeviceInfo::set_devicename(const char* value) {
  set_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    devicename_ = new ::std::string;
  }
  devicename_->assign(value);
}
inline void DeviceInfo::set_devicename(const char* value, size_t size) {
  set_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    devicename_ = new ::std::string;
  }
  devicename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceInfo::mutable_devicename() {
  set_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    devicename_ = new ::std::string;
  }
  return devicename_;
}
inline ::std::string* DeviceInfo::release_devicename() {
  clear_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devicename_;
    devicename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool isAcer = 4;
inline bool DeviceInfo::has_isacer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeviceInfo::set_has_isacer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DeviceInfo::clear_has_isacer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DeviceInfo::clear_isacer() {
  isacer_ = false;
  clear_has_isacer();
}
inline bool DeviceInfo::isacer() const {
  return isacer_;
}
inline void DeviceInfo::set_isacer(bool value) {
  set_has_isacer();
  isacer_ = value;
}

// optional bool hasCamera = 5;
inline bool DeviceInfo::has_hascamera() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DeviceInfo::set_has_hascamera() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DeviceInfo::clear_has_hascamera() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DeviceInfo::clear_hascamera() {
  hascamera_ = false;
  clear_has_hascamera();
}
inline bool DeviceInfo::hascamera() const {
  return hascamera_;
}
inline void DeviceInfo::set_hascamera(bool value) {
  set_has_hascamera();
  hascamera_ = value;
}

// optional string osVersion = 6;
inline bool DeviceInfo::has_osversion() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DeviceInfo::set_has_osversion() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DeviceInfo::clear_has_osversion() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DeviceInfo::clear_osversion() {
  if (osversion_ != &::google::protobuf::internal::kEmptyString) {
    osversion_->clear();
  }
  clear_has_osversion();
}
inline const ::std::string& DeviceInfo::osversion() const {
  return *osversion_;
}
inline void DeviceInfo::set_osversion(const ::std::string& value) {
  set_has_osversion();
  if (osversion_ == &::google::protobuf::internal::kEmptyString) {
    osversion_ = new ::std::string;
  }
  osversion_->assign(value);
}
inline void DeviceInfo::set_osversion(const char* value) {
  set_has_osversion();
  if (osversion_ == &::google::protobuf::internal::kEmptyString) {
    osversion_ = new ::std::string;
  }
  osversion_->assign(value);
}
inline void DeviceInfo::set_osversion(const char* value, size_t size) {
  set_has_osversion();
  if (osversion_ == &::google::protobuf::internal::kEmptyString) {
    osversion_ = new ::std::string;
  }
  osversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceInfo::mutable_osversion() {
  set_has_osversion();
  if (osversion_ == &::google::protobuf::internal::kEmptyString) {
    osversion_ = new ::std::string;
  }
  return osversion_;
}
inline ::std::string* DeviceInfo::release_osversion() {
  clear_has_osversion();
  if (osversion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = osversion_;
    osversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string protocolVersion = 7;
inline bool DeviceInfo::has_protocolversion() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DeviceInfo::set_has_protocolversion() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DeviceInfo::clear_has_protocolversion() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DeviceInfo::clear_protocolversion() {
  if (protocolversion_ != &::google::protobuf::internal::kEmptyString) {
    protocolversion_->clear();
  }
  clear_has_protocolversion();
}
inline const ::std::string& DeviceInfo::protocolversion() const {
  return *protocolversion_;
}
inline void DeviceInfo::set_protocolversion(const ::std::string& value) {
  set_has_protocolversion();
  if (protocolversion_ == &::google::protobuf::internal::kEmptyString) {
    protocolversion_ = new ::std::string;
  }
  protocolversion_->assign(value);
}
inline void DeviceInfo::set_protocolversion(const char* value) {
  set_has_protocolversion();
  if (protocolversion_ == &::google::protobuf::internal::kEmptyString) {
    protocolversion_ = new ::std::string;
  }
  protocolversion_->assign(value);
}
inline void DeviceInfo::set_protocolversion(const char* value, size_t size) {
  set_has_protocolversion();
  if (protocolversion_ == &::google::protobuf::internal::kEmptyString) {
    protocolversion_ = new ::std::string;
  }
  protocolversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceInfo::mutable_protocolversion() {
  set_has_protocolversion();
  if (protocolversion_ == &::google::protobuf::internal::kEmptyString) {
    protocolversion_ = new ::std::string;
  }
  return protocolversion_;
}
inline ::std::string* DeviceInfo::release_protocolversion() {
  clear_has_protocolversion();
  if (protocolversion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = protocolversion_;
    protocolversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool isVirtDrive = 8;
inline bool DeviceInfo::has_isvirtdrive() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DeviceInfo::set_has_isvirtdrive() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DeviceInfo::clear_has_isvirtdrive() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DeviceInfo::clear_isvirtdrive() {
  isvirtdrive_ = false;
  clear_has_isvirtdrive();
}
inline bool DeviceInfo::isvirtdrive() const {
  return isvirtdrive_;
}
inline void DeviceInfo::set_isvirtdrive(bool value) {
  set_has_isvirtdrive();
  isvirtdrive_ = value;
}

// optional bool isMediaServer = 9;
inline bool DeviceInfo::has_ismediaserver() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DeviceInfo::set_has_ismediaserver() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DeviceInfo::clear_has_ismediaserver() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DeviceInfo::clear_ismediaserver() {
  ismediaserver_ = false;
  clear_has_ismediaserver();
}
inline bool DeviceInfo::ismediaserver() const {
  return ismediaserver_;
}
inline void DeviceInfo::set_ismediaserver(bool value) {
  set_has_ismediaserver();
  ismediaserver_ = value;
}

// optional bool featureMediaServerCapable = 10;
inline bool DeviceInfo::has_featuremediaservercapable() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DeviceInfo::set_has_featuremediaservercapable() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DeviceInfo::clear_has_featuremediaservercapable() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DeviceInfo::clear_featuremediaservercapable() {
  featuremediaservercapable_ = false;
  clear_has_featuremediaservercapable();
}
inline bool DeviceInfo::featuremediaservercapable() const {
  return featuremediaservercapable_;
}
inline void DeviceInfo::set_featuremediaservercapable(bool value) {
  set_has_featuremediaservercapable();
  featuremediaservercapable_ = value;
}

// optional bool featureVirtDriveCapable = 11;
inline bool DeviceInfo::has_featurevirtdrivecapable() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DeviceInfo::set_has_featurevirtdrivecapable() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DeviceInfo::clear_has_featurevirtdrivecapable() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DeviceInfo::clear_featurevirtdrivecapable() {
  featurevirtdrivecapable_ = false;
  clear_has_featurevirtdrivecapable();
}
inline bool DeviceInfo::featurevirtdrivecapable() const {
  return featurevirtdrivecapable_;
}
inline void DeviceInfo::set_featurevirtdrivecapable(bool value) {
  set_has_featurevirtdrivecapable();
  featurevirtdrivecapable_ = value;
}

// optional bool featureRemoteFileAccessCapable = 12;
inline bool DeviceInfo::has_featureremotefileaccesscapable() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DeviceInfo::set_has_featureremotefileaccesscapable() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DeviceInfo::clear_has_featureremotefileaccesscapable() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DeviceInfo::clear_featureremotefileaccesscapable() {
  featureremotefileaccesscapable_ = false;
  clear_has_featureremotefileaccesscapable();
}
inline bool DeviceInfo::featureremotefileaccesscapable() const {
  return featureremotefileaccesscapable_;
}
inline void DeviceInfo::set_featureremotefileaccesscapable(bool value) {
  set_has_featureremotefileaccesscapable();
  featureremotefileaccesscapable_ = value;
}

// optional bool featureFSDatasetTypeCapable = 13;
inline bool DeviceInfo::has_featurefsdatasettypecapable() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DeviceInfo::set_has_featurefsdatasettypecapable() {
  _has_bits_[0] |= 0x00001000u;
}
inline void DeviceInfo::clear_has_featurefsdatasettypecapable() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void DeviceInfo::clear_featurefsdatasettypecapable() {
  featurefsdatasettypecapable_ = false;
  clear_has_featurefsdatasettypecapable();
}
inline bool DeviceInfo::featurefsdatasettypecapable() const {
  return featurefsdatasettypecapable_;
}
inline void DeviceInfo::set_featurefsdatasettypecapable(bool value) {
  set_has_featurefsdatasettypecapable();
  featurefsdatasettypecapable_ = value;
}

// optional string modelNumber = 14;
inline bool DeviceInfo::has_modelnumber() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void DeviceInfo::set_has_modelnumber() {
  _has_bits_[0] |= 0x00002000u;
}
inline void DeviceInfo::clear_has_modelnumber() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void DeviceInfo::clear_modelnumber() {
  if (modelnumber_ != &::google::protobuf::internal::kEmptyString) {
    modelnumber_->clear();
  }
  clear_has_modelnumber();
}
inline const ::std::string& DeviceInfo::modelnumber() const {
  return *modelnumber_;
}
inline void DeviceInfo::set_modelnumber(const ::std::string& value) {
  set_has_modelnumber();
  if (modelnumber_ == &::google::protobuf::internal::kEmptyString) {
    modelnumber_ = new ::std::string;
  }
  modelnumber_->assign(value);
}
inline void DeviceInfo::set_modelnumber(const char* value) {
  set_has_modelnumber();
  if (modelnumber_ == &::google::protobuf::internal::kEmptyString) {
    modelnumber_ = new ::std::string;
  }
  modelnumber_->assign(value);
}
inline void DeviceInfo::set_modelnumber(const char* value, size_t size) {
  set_has_modelnumber();
  if (modelnumber_ == &::google::protobuf::internal::kEmptyString) {
    modelnumber_ = new ::std::string;
  }
  modelnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceInfo::mutable_modelnumber() {
  set_has_modelnumber();
  if (modelnumber_ == &::google::protobuf::internal::kEmptyString) {
    modelnumber_ = new ::std::string;
  }
  return modelnumber_;
}
inline ::std::string* DeviceInfo::release_modelnumber() {
  clear_has_modelnumber();
  if (modelnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = modelnumber_;
    modelnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string buildInfo = 15;
inline bool DeviceInfo::has_buildinfo() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void DeviceInfo::set_has_buildinfo() {
  _has_bits_[0] |= 0x00004000u;
}
inline void DeviceInfo::clear_has_buildinfo() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void DeviceInfo::clear_buildinfo() {
  if (buildinfo_ != &::google::protobuf::internal::kEmptyString) {
    buildinfo_->clear();
  }
  clear_has_buildinfo();
}
inline const ::std::string& DeviceInfo::buildinfo() const {
  return *buildinfo_;
}
inline void DeviceInfo::set_buildinfo(const ::std::string& value) {
  set_has_buildinfo();
  if (buildinfo_ == &::google::protobuf::internal::kEmptyString) {
    buildinfo_ = new ::std::string;
  }
  buildinfo_->assign(value);
}
inline void DeviceInfo::set_buildinfo(const char* value) {
  set_has_buildinfo();
  if (buildinfo_ == &::google::protobuf::internal::kEmptyString) {
    buildinfo_ = new ::std::string;
  }
  buildinfo_->assign(value);
}
inline void DeviceInfo::set_buildinfo(const char* value, size_t size) {
  set_has_buildinfo();
  if (buildinfo_ == &::google::protobuf::internal::kEmptyString) {
    buildinfo_ = new ::std::string;
  }
  buildinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceInfo::mutable_buildinfo() {
  set_has_buildinfo();
  if (buildinfo_ == &::google::protobuf::internal::kEmptyString) {
    buildinfo_ = new ::std::string;
  }
  return buildinfo_;
}
inline ::std::string* DeviceInfo::release_buildinfo() {
  clear_has_buildinfo();
  if (buildinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buildinfo_;
    buildinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool featureVirtSyncCapable = 16;
inline bool DeviceInfo::has_featurevirtsynccapable() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void DeviceInfo::set_has_featurevirtsynccapable() {
  _has_bits_[0] |= 0x00008000u;
}
inline void DeviceInfo::clear_has_featurevirtsynccapable() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void DeviceInfo::clear_featurevirtsynccapable() {
  featurevirtsynccapable_ = false;
  clear_has_featurevirtsynccapable();
}
inline bool DeviceInfo::featurevirtsynccapable() const {
  return featurevirtsynccapable_;
}
inline void DeviceInfo::set_featurevirtsynccapable(bool value) {
  set_has_featurevirtsynccapable();
  featurevirtsynccapable_ = value;
}

// optional bool featureMyStorageServerCapable = 17;
inline bool DeviceInfo::has_featuremystorageservercapable() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void DeviceInfo::set_has_featuremystorageservercapable() {
  _has_bits_[0] |= 0x00010000u;
}
inline void DeviceInfo::clear_has_featuremystorageservercapable() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void DeviceInfo::clear_featuremystorageservercapable() {
  featuremystorageservercapable_ = false;
  clear_has_featuremystorageservercapable();
}
inline bool DeviceInfo::featuremystorageservercapable() const {
  return featuremystorageservercapable_;
}
inline void DeviceInfo::set_featuremystorageservercapable(bool value) {
  set_has_featuremystorageservercapable();
  featuremystorageservercapable_ = value;
}

// -------------------------------------------------------------------

// StorageAccessPort

// required .vplex.vsDirectory.PortType portType = 1;
inline bool StorageAccessPort::has_porttype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StorageAccessPort::set_has_porttype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StorageAccessPort::clear_has_porttype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StorageAccessPort::clear_porttype() {
  porttype_ = 0;
  clear_has_porttype();
}
inline vplex::vsDirectory::PortType StorageAccessPort::porttype() const {
  return static_cast< vplex::vsDirectory::PortType >(porttype_);
}
inline void StorageAccessPort::set_porttype(vplex::vsDirectory::PortType value) {
  GOOGLE_DCHECK(vplex::vsDirectory::PortType_IsValid(value));
  set_has_porttype();
  porttype_ = value;
}

// required int32 port = 2;
inline bool StorageAccessPort::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StorageAccessPort::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StorageAccessPort::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StorageAccessPort::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 StorageAccessPort::port() const {
  return port_;
}
inline void StorageAccessPort::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// StorageAccess

// required .vplex.vsDirectory.RouteType routeType = 1;
inline bool StorageAccess::has_routetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StorageAccess::set_has_routetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StorageAccess::clear_has_routetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StorageAccess::clear_routetype() {
  routetype_ = 0;
  clear_has_routetype();
}
inline vplex::vsDirectory::RouteType StorageAccess::routetype() const {
  return static_cast< vplex::vsDirectory::RouteType >(routetype_);
}
inline void StorageAccess::set_routetype(vplex::vsDirectory::RouteType value) {
  GOOGLE_DCHECK(vplex::vsDirectory::RouteType_IsValid(value));
  set_has_routetype();
  routetype_ = value;
}

// required .vplex.vsDirectory.ProtocolType protocol = 2;
inline bool StorageAccess::has_protocol() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StorageAccess::set_has_protocol() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StorageAccess::clear_has_protocol() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StorageAccess::clear_protocol() {
  protocol_ = 0;
  clear_has_protocol();
}
inline vplex::vsDirectory::ProtocolType StorageAccess::protocol() const {
  return static_cast< vplex::vsDirectory::ProtocolType >(protocol_);
}
inline void StorageAccess::set_protocol(vplex::vsDirectory::ProtocolType value) {
  GOOGLE_DCHECK(vplex::vsDirectory::ProtocolType_IsValid(value));
  set_has_protocol();
  protocol_ = value;
}

// required string server = 3;
inline bool StorageAccess::has_server() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StorageAccess::set_has_server() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StorageAccess::clear_has_server() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StorageAccess::clear_server() {
  if (server_ != &::google::protobuf::internal::kEmptyString) {
    server_->clear();
  }
  clear_has_server();
}
inline const ::std::string& StorageAccess::server() const {
  return *server_;
}
inline void StorageAccess::set_server(const ::std::string& value) {
  set_has_server();
  if (server_ == &::google::protobuf::internal::kEmptyString) {
    server_ = new ::std::string;
  }
  server_->assign(value);
}
inline void StorageAccess::set_server(const char* value) {
  set_has_server();
  if (server_ == &::google::protobuf::internal::kEmptyString) {
    server_ = new ::std::string;
  }
  server_->assign(value);
}
inline void StorageAccess::set_server(const char* value, size_t size) {
  set_has_server();
  if (server_ == &::google::protobuf::internal::kEmptyString) {
    server_ = new ::std::string;
  }
  server_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StorageAccess::mutable_server() {
  set_has_server();
  if (server_ == &::google::protobuf::internal::kEmptyString) {
    server_ = new ::std::string;
  }
  return server_;
}
inline ::std::string* StorageAccess::release_server() {
  clear_has_server();
  if (server_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = server_;
    server_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .vplex.vsDirectory.StorageAccessPort ports = 4;
inline int StorageAccess::ports_size() const {
  return ports_.size();
}
inline void StorageAccess::clear_ports() {
  ports_.Clear();
}
inline const ::vplex::vsDirectory::StorageAccessPort& StorageAccess::ports(int index) const {
  return ports_.Get(index);
}
inline ::vplex::vsDirectory::StorageAccessPort* StorageAccess::mutable_ports(int index) {
  return ports_.Mutable(index);
}
inline ::vplex::vsDirectory::StorageAccessPort* StorageAccess::add_ports() {
  return ports_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::StorageAccessPort >&
StorageAccess::ports() const {
  return ports_;
}
inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::StorageAccessPort >*
StorageAccess::mutable_ports() {
  return &ports_;
}

// -------------------------------------------------------------------

// DeviceAccessTicket

// required fixed64 deviceId = 1;
inline bool DeviceAccessTicket::has_deviceid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceAccessTicket::set_has_deviceid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceAccessTicket::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceAccessTicket::clear_deviceid() {
  deviceid_ = GOOGLE_ULONGLONG(0);
  clear_has_deviceid();
}
inline ::google::protobuf::uint64 DeviceAccessTicket::deviceid() const {
  return deviceid_;
}
inline void DeviceAccessTicket::set_deviceid(::google::protobuf::uint64 value) {
  set_has_deviceid();
  deviceid_ = value;
}

// required bytes accessTicket = 2;
inline bool DeviceAccessTicket::has_accessticket() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceAccessTicket::set_has_accessticket() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeviceAccessTicket::clear_has_accessticket() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceAccessTicket::clear_accessticket() {
  if (accessticket_ != &::google::protobuf::internal::kEmptyString) {
    accessticket_->clear();
  }
  clear_has_accessticket();
}
inline const ::std::string& DeviceAccessTicket::accessticket() const {
  return *accessticket_;
}
inline void DeviceAccessTicket::set_accessticket(const ::std::string& value) {
  set_has_accessticket();
  if (accessticket_ == &::google::protobuf::internal::kEmptyString) {
    accessticket_ = new ::std::string;
  }
  accessticket_->assign(value);
}
inline void DeviceAccessTicket::set_accessticket(const char* value) {
  set_has_accessticket();
  if (accessticket_ == &::google::protobuf::internal::kEmptyString) {
    accessticket_ = new ::std::string;
  }
  accessticket_->assign(value);
}
inline void DeviceAccessTicket::set_accessticket(const void* value, size_t size) {
  set_has_accessticket();
  if (accessticket_ == &::google::protobuf::internal::kEmptyString) {
    accessticket_ = new ::std::string;
  }
  accessticket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceAccessTicket::mutable_accessticket() {
  set_has_accessticket();
  if (accessticket_ == &::google::protobuf::internal::kEmptyString) {
    accessticket_ = new ::std::string;
  }
  return accessticket_;
}
inline ::std::string* DeviceAccessTicket::release_accessticket() {
  clear_has_accessticket();
  if (accessticket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = accessticket_;
    accessticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// UserStorage

// required fixed64 storageClusterId = 1;
inline bool UserStorage::has_storageclusterid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserStorage::set_has_storageclusterid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserStorage::clear_has_storageclusterid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserStorage::clear_storageclusterid() {
  storageclusterid_ = GOOGLE_ULONGLONG(0);
  clear_has_storageclusterid();
}
inline ::google::protobuf::uint64 UserStorage::storageclusterid() const {
  return storageclusterid_;
}
inline void UserStorage::set_storageclusterid(::google::protobuf::uint64 value) {
  set_has_storageclusterid();
  storageclusterid_ = value;
}

// optional string storageName = 2;
inline bool UserStorage::has_storagename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserStorage::set_has_storagename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserStorage::clear_has_storagename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserStorage::clear_storagename() {
  if (storagename_ != &::google::protobuf::internal::kEmptyString) {
    storagename_->clear();
  }
  clear_has_storagename();
}
inline const ::std::string& UserStorage::storagename() const {
  return *storagename_;
}
inline void UserStorage::set_storagename(const ::std::string& value) {
  set_has_storagename();
  if (storagename_ == &::google::protobuf::internal::kEmptyString) {
    storagename_ = new ::std::string;
  }
  storagename_->assign(value);
}
inline void UserStorage::set_storagename(const char* value) {
  set_has_storagename();
  if (storagename_ == &::google::protobuf::internal::kEmptyString) {
    storagename_ = new ::std::string;
  }
  storagename_->assign(value);
}
inline void UserStorage::set_storagename(const char* value, size_t size) {
  set_has_storagename();
  if (storagename_ == &::google::protobuf::internal::kEmptyString) {
    storagename_ = new ::std::string;
  }
  storagename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserStorage::mutable_storagename() {
  set_has_storagename();
  if (storagename_ == &::google::protobuf::internal::kEmptyString) {
    storagename_ = new ::std::string;
  }
  return storagename_;
}
inline ::std::string* UserStorage::release_storagename() {
  clear_has_storagename();
  if (storagename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = storagename_;
    storagename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 storageType = 3;
inline bool UserStorage::has_storagetype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserStorage::set_has_storagetype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserStorage::clear_has_storagetype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserStorage::clear_storagetype() {
  storagetype_ = 0;
  clear_has_storagetype();
}
inline ::google::protobuf::int32 UserStorage::storagetype() const {
  return storagetype_;
}
inline void UserStorage::set_storagetype(::google::protobuf::int32 value) {
  set_has_storagetype();
  storagetype_ = value;
}

// required fixed64 usageLimit = 4;
inline bool UserStorage::has_usagelimit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserStorage::set_has_usagelimit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserStorage::clear_has_usagelimit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserStorage::clear_usagelimit() {
  usagelimit_ = GOOGLE_ULONGLONG(0);
  clear_has_usagelimit();
}
inline ::google::protobuf::uint64 UserStorage::usagelimit() const {
  return usagelimit_;
}
inline void UserStorage::set_usagelimit(::google::protobuf::uint64 value) {
  set_has_usagelimit();
  usagelimit_ = value;
}

// optional bool isVirtDrive = 5;
inline bool UserStorage::has_isvirtdrive() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserStorage::set_has_isvirtdrive() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserStorage::clear_has_isvirtdrive() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserStorage::clear_isvirtdrive() {
  isvirtdrive_ = false;
  clear_has_isvirtdrive();
}
inline bool UserStorage::isvirtdrive() const {
  return isvirtdrive_;
}
inline void UserStorage::set_isvirtdrive(bool value) {
  set_has_isvirtdrive();
  isvirtdrive_ = value;
}

// optional bool isMediaServer = 6;
inline bool UserStorage::has_ismediaserver() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserStorage::set_has_ismediaserver() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserStorage::clear_has_ismediaserver() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserStorage::clear_ismediaserver() {
  ismediaserver_ = false;
  clear_has_ismediaserver();
}
inline bool UserStorage::ismediaserver() const {
  return ismediaserver_;
}
inline void UserStorage::set_ismediaserver(bool value) {
  set_has_ismediaserver();
  ismediaserver_ = value;
}

// optional fixed64 accessHandle = 7;
inline bool UserStorage::has_accesshandle() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserStorage::set_has_accesshandle() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserStorage::clear_has_accesshandle() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserStorage::clear_accesshandle() {
  accesshandle_ = GOOGLE_ULONGLONG(0);
  clear_has_accesshandle();
}
inline ::google::protobuf::uint64 UserStorage::accesshandle() const {
  return accesshandle_;
}
inline void UserStorage::set_accesshandle(::google::protobuf::uint64 value) {
  set_has_accesshandle();
  accesshandle_ = value;
}

// optional bytes accessTicket = 8;
inline bool UserStorage::has_accessticket() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserStorage::set_has_accessticket() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserStorage::clear_has_accessticket() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserStorage::clear_accessticket() {
  if (accessticket_ != &::google::protobuf::internal::kEmptyString) {
    accessticket_->clear();
  }
  clear_has_accessticket();
}
inline const ::std::string& UserStorage::accessticket() const {
  return *accessticket_;
}
inline void UserStorage::set_accessticket(const ::std::string& value) {
  set_has_accessticket();
  if (accessticket_ == &::google::protobuf::internal::kEmptyString) {
    accessticket_ = new ::std::string;
  }
  accessticket_->assign(value);
}
inline void UserStorage::set_accessticket(const char* value) {
  set_has_accessticket();
  if (accessticket_ == &::google::protobuf::internal::kEmptyString) {
    accessticket_ = new ::std::string;
  }
  accessticket_->assign(value);
}
inline void UserStorage::set_accessticket(const void* value, size_t size) {
  set_has_accessticket();
  if (accessticket_ == &::google::protobuf::internal::kEmptyString) {
    accessticket_ = new ::std::string;
  }
  accessticket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserStorage::mutable_accessticket() {
  set_has_accessticket();
  if (accessticket_ == &::google::protobuf::internal::kEmptyString) {
    accessticket_ = new ::std::string;
  }
  return accessticket_;
}
inline ::std::string* UserStorage::release_accessticket() {
  clear_has_accessticket();
  if (accessticket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = accessticket_;
    accessticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .vplex.vsDirectory.StorageAccess storageAccess = 9;
inline int UserStorage::storageaccess_size() const {
  return storageaccess_.size();
}
inline void UserStorage::clear_storageaccess() {
  storageaccess_.Clear();
}
inline const ::vplex::vsDirectory::StorageAccess& UserStorage::storageaccess(int index) const {
  return storageaccess_.Get(index);
}
inline ::vplex::vsDirectory::StorageAccess* UserStorage::mutable_storageaccess(int index) {
  return storageaccess_.Mutable(index);
}
inline ::vplex::vsDirectory::StorageAccess* UserStorage::add_storageaccess() {
  return storageaccess_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::StorageAccess >&
UserStorage::storageaccess() const {
  return storageaccess_;
}
inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::StorageAccess >*
UserStorage::mutable_storageaccess() {
  return &storageaccess_;
}

// optional bool featureMediaServerEnabled = 10;
inline bool UserStorage::has_featuremediaserverenabled() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UserStorage::set_has_featuremediaserverenabled() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UserStorage::clear_has_featuremediaserverenabled() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UserStorage::clear_featuremediaserverenabled() {
  featuremediaserverenabled_ = false;
  clear_has_featuremediaserverenabled();
}
inline bool UserStorage::featuremediaserverenabled() const {
  return featuremediaserverenabled_;
}
inline void UserStorage::set_featuremediaserverenabled(bool value) {
  set_has_featuremediaserverenabled();
  featuremediaserverenabled_ = value;
}

// optional bool featureVirtDriveEnabled = 11;
inline bool UserStorage::has_featurevirtdriveenabled() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UserStorage::set_has_featurevirtdriveenabled() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UserStorage::clear_has_featurevirtdriveenabled() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UserStorage::clear_featurevirtdriveenabled() {
  featurevirtdriveenabled_ = false;
  clear_has_featurevirtdriveenabled();
}
inline bool UserStorage::featurevirtdriveenabled() const {
  return featurevirtdriveenabled_;
}
inline void UserStorage::set_featurevirtdriveenabled(bool value) {
  set_has_featurevirtdriveenabled();
  featurevirtdriveenabled_ = value;
}

// optional bool featureRemoteFileAccessEnabled = 12;
inline bool UserStorage::has_featureremotefileaccessenabled() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UserStorage::set_has_featureremotefileaccessenabled() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UserStorage::clear_has_featureremotefileaccessenabled() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UserStorage::clear_featureremotefileaccessenabled() {
  featureremotefileaccessenabled_ = false;
  clear_has_featureremotefileaccessenabled();
}
inline bool UserStorage::featureremotefileaccessenabled() const {
  return featureremotefileaccessenabled_;
}
inline void UserStorage::set_featureremotefileaccessenabled(bool value) {
  set_has_featureremotefileaccessenabled();
  featureremotefileaccessenabled_ = value;
}

// optional bool featureFSDatasetTypeEnabled = 13;
inline bool UserStorage::has_featurefsdatasettypeenabled() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void UserStorage::set_has_featurefsdatasettypeenabled() {
  _has_bits_[0] |= 0x00001000u;
}
inline void UserStorage::clear_has_featurefsdatasettypeenabled() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void UserStorage::clear_featurefsdatasettypeenabled() {
  featurefsdatasettypeenabled_ = false;
  clear_has_featurefsdatasettypeenabled();
}
inline bool UserStorage::featurefsdatasettypeenabled() const {
  return featurefsdatasettypeenabled_;
}
inline void UserStorage::set_featurefsdatasettypeenabled(bool value) {
  set_has_featurefsdatasettypeenabled();
  featurefsdatasettypeenabled_ = value;
}

// optional bytes devSpecAccessTicket = 14;
inline bool UserStorage::has_devspecaccessticket() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void UserStorage::set_has_devspecaccessticket() {
  _has_bits_[0] |= 0x00002000u;
}
inline void UserStorage::clear_has_devspecaccessticket() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void UserStorage::clear_devspecaccessticket() {
  if (devspecaccessticket_ != &::google::protobuf::internal::kEmptyString) {
    devspecaccessticket_->clear();
  }
  clear_has_devspecaccessticket();
}
inline const ::std::string& UserStorage::devspecaccessticket() const {
  return *devspecaccessticket_;
}
inline void UserStorage::set_devspecaccessticket(const ::std::string& value) {
  set_has_devspecaccessticket();
  if (devspecaccessticket_ == &::google::protobuf::internal::kEmptyString) {
    devspecaccessticket_ = new ::std::string;
  }
  devspecaccessticket_->assign(value);
}
inline void UserStorage::set_devspecaccessticket(const char* value) {
  set_has_devspecaccessticket();
  if (devspecaccessticket_ == &::google::protobuf::internal::kEmptyString) {
    devspecaccessticket_ = new ::std::string;
  }
  devspecaccessticket_->assign(value);
}
inline void UserStorage::set_devspecaccessticket(const void* value, size_t size) {
  set_has_devspecaccessticket();
  if (devspecaccessticket_ == &::google::protobuf::internal::kEmptyString) {
    devspecaccessticket_ = new ::std::string;
  }
  devspecaccessticket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserStorage::mutable_devspecaccessticket() {
  set_has_devspecaccessticket();
  if (devspecaccessticket_ == &::google::protobuf::internal::kEmptyString) {
    devspecaccessticket_ = new ::std::string;
  }
  return devspecaccessticket_;
}
inline ::std::string* UserStorage::release_devspecaccessticket() {
  clear_has_devspecaccessticket();
  if (devspecaccessticket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devspecaccessticket_;
    devspecaccessticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool featureCloudDocEnabled = 15;
inline bool UserStorage::has_featureclouddocenabled() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void UserStorage::set_has_featureclouddocenabled() {
  _has_bits_[0] |= 0x00004000u;
}
inline void UserStorage::clear_has_featureclouddocenabled() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void UserStorage::clear_featureclouddocenabled() {
  featureclouddocenabled_ = false;
  clear_has_featureclouddocenabled();
}
inline bool UserStorage::featureclouddocenabled() const {
  return featureclouddocenabled_;
}
inline void UserStorage::set_featureclouddocenabled(bool value) {
  set_has_featureclouddocenabled();
  featureclouddocenabled_ = value;
}

// optional bool featureVirtSyncEnabled = 16;
inline bool UserStorage::has_featurevirtsyncenabled() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void UserStorage::set_has_featurevirtsyncenabled() {
  _has_bits_[0] |= 0x00008000u;
}
inline void UserStorage::clear_has_featurevirtsyncenabled() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void UserStorage::clear_featurevirtsyncenabled() {
  featurevirtsyncenabled_ = false;
  clear_has_featurevirtsyncenabled();
}
inline bool UserStorage::featurevirtsyncenabled() const {
  return featurevirtsyncenabled_;
}
inline void UserStorage::set_featurevirtsyncenabled(bool value) {
  set_has_featurevirtsyncenabled();
  featurevirtsyncenabled_ = value;
}

// optional bool featureMyStorageServerEnabled = 17;
inline bool UserStorage::has_featuremystorageserverenabled() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void UserStorage::set_has_featuremystorageserverenabled() {
  _has_bits_[0] |= 0x00010000u;
}
inline void UserStorage::clear_has_featuremystorageserverenabled() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void UserStorage::clear_featuremystorageserverenabled() {
  featuremystorageserverenabled_ = false;
  clear_has_featuremystorageserverenabled();
}
inline bool UserStorage::featuremystorageserverenabled() const {
  return featuremystorageserverenabled_;
}
inline void UserStorage::set_featuremystorageserverenabled(bool value) {
  set_has_featuremystorageserverenabled();
  featuremystorageserverenabled_ = value;
}

// -------------------------------------------------------------------

// UpdatedDataset

// required fixed64 datasetId = 1;
inline bool UpdatedDataset::has_datasetid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdatedDataset::set_has_datasetid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdatedDataset::clear_has_datasetid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdatedDataset::clear_datasetid() {
  datasetid_ = GOOGLE_ULONGLONG(0);
  clear_has_datasetid();
}
inline ::google::protobuf::uint64 UpdatedDataset::datasetid() const {
  return datasetid_;
}
inline void UpdatedDataset::set_datasetid(::google::protobuf::uint64 value) {
  set_has_datasetid();
  datasetid_ = value;
}

// required fixed64 clusterId = 2;
inline bool UpdatedDataset::has_clusterid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdatedDataset::set_has_clusterid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdatedDataset::clear_has_clusterid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdatedDataset::clear_clusterid() {
  clusterid_ = GOOGLE_ULONGLONG(0);
  clear_has_clusterid();
}
inline ::google::protobuf::uint64 UpdatedDataset::clusterid() const {
  return clusterid_;
}
inline void UpdatedDataset::set_clusterid(::google::protobuf::uint64 value) {
  set_has_clusterid();
  clusterid_ = value;
}

// required fixed64 userId = 3;
inline bool UpdatedDataset::has_userid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdatedDataset::set_has_userid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdatedDataset::clear_has_userid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdatedDataset::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 UpdatedDataset::userid() const {
  return userid_;
}
inline void UpdatedDataset::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required .vplex.vsDirectory.DatasetType datasetType = 4;
inline bool UpdatedDataset::has_datasettype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UpdatedDataset::set_has_datasettype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UpdatedDataset::clear_has_datasettype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UpdatedDataset::clear_datasettype() {
  datasettype_ = 1;
  clear_has_datasettype();
}
inline vplex::vsDirectory::DatasetType UpdatedDataset::datasettype() const {
  return static_cast< vplex::vsDirectory::DatasetType >(datasettype_);
}
inline void UpdatedDataset::set_datasettype(vplex::vsDirectory::DatasetType value) {
  GOOGLE_DCHECK(vplex::vsDirectory::DatasetType_IsValid(value));
  set_has_datasettype();
  datasettype_ = value;
}

// required string datasetName = 5;
inline bool UpdatedDataset::has_datasetname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UpdatedDataset::set_has_datasetname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UpdatedDataset::clear_has_datasetname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UpdatedDataset::clear_datasetname() {
  if (datasetname_ != &::google::protobuf::internal::kEmptyString) {
    datasetname_->clear();
  }
  clear_has_datasetname();
}
inline const ::std::string& UpdatedDataset::datasetname() const {
  return *datasetname_;
}
inline void UpdatedDataset::set_datasetname(const ::std::string& value) {
  set_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    datasetname_ = new ::std::string;
  }
  datasetname_->assign(value);
}
inline void UpdatedDataset::set_datasetname(const char* value) {
  set_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    datasetname_ = new ::std::string;
  }
  datasetname_->assign(value);
}
inline void UpdatedDataset::set_datasetname(const char* value, size_t size) {
  set_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    datasetname_ = new ::std::string;
  }
  datasetname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdatedDataset::mutable_datasetname() {
  set_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    datasetname_ = new ::std::string;
  }
  return datasetname_;
}
inline ::std::string* UpdatedDataset::release_datasetname() {
  clear_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = datasetname_;
    datasetname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required fixed64 lastUpdated = 6;
inline bool UpdatedDataset::has_lastupdated() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UpdatedDataset::set_has_lastupdated() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UpdatedDataset::clear_has_lastupdated() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UpdatedDataset::clear_lastupdated() {
  lastupdated_ = GOOGLE_ULONGLONG(0);
  clear_has_lastupdated();
}
inline ::google::protobuf::uint64 UpdatedDataset::lastupdated() const {
  return lastupdated_;
}
inline void UpdatedDataset::set_lastupdated(::google::protobuf::uint64 value) {
  set_has_lastupdated();
  lastupdated_ = value;
}

// optional fixed64 destDatasetId = 7;
inline bool UpdatedDataset::has_destdatasetid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UpdatedDataset::set_has_destdatasetid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UpdatedDataset::clear_has_destdatasetid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UpdatedDataset::clear_destdatasetid() {
  destdatasetid_ = GOOGLE_ULONGLONG(0);
  clear_has_destdatasetid();
}
inline ::google::protobuf::uint64 UpdatedDataset::destdatasetid() const {
  return destdatasetid_;
}
inline void UpdatedDataset::set_destdatasetid(::google::protobuf::uint64 value) {
  set_has_destdatasetid();
  destdatasetid_ = value;
}

// optional fixed64 primaryVersion = 8;
inline bool UpdatedDataset::has_primaryversion() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UpdatedDataset::set_has_primaryversion() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UpdatedDataset::clear_has_primaryversion() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UpdatedDataset::clear_primaryversion() {
  primaryversion_ = GOOGLE_ULONGLONG(0);
  clear_has_primaryversion();
}
inline ::google::protobuf::uint64 UpdatedDataset::primaryversion() const {
  return primaryversion_;
}
inline void UpdatedDataset::set_primaryversion(::google::protobuf::uint64 value) {
  set_has_primaryversion();
  primaryversion_ = value;
}

// -------------------------------------------------------------------

// DatasetFilter

// required string name = 1;
inline bool DatasetFilter::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DatasetFilter::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DatasetFilter::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DatasetFilter::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& DatasetFilter::name() const {
  return *name_;
}
inline void DatasetFilter::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void DatasetFilter::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void DatasetFilter::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DatasetFilter::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* DatasetFilter::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string value = 2;
inline bool DatasetFilter::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DatasetFilter::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DatasetFilter::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DatasetFilter::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& DatasetFilter::value() const {
  return *value_;
}
inline void DatasetFilter::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void DatasetFilter::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void DatasetFilter::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DatasetFilter::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* DatasetFilter::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// MssDetail

// required fixed64 mssId = 1;
inline bool MssDetail::has_mssid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MssDetail::set_has_mssid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MssDetail::clear_has_mssid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MssDetail::clear_mssid() {
  mssid_ = GOOGLE_ULONGLONG(0);
  clear_has_mssid();
}
inline ::google::protobuf::uint64 MssDetail::mssid() const {
  return mssid_;
}
inline void MssDetail::set_mssid(::google::protobuf::uint64 value) {
  set_has_mssid();
  mssid_ = value;
}

// required string mssName = 2;
inline bool MssDetail::has_mssname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MssDetail::set_has_mssname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MssDetail::clear_has_mssname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MssDetail::clear_mssname() {
  if (mssname_ != &::google::protobuf::internal::kEmptyString) {
    mssname_->clear();
  }
  clear_has_mssname();
}
inline const ::std::string& MssDetail::mssname() const {
  return *mssname_;
}
inline void MssDetail::set_mssname(const ::std::string& value) {
  set_has_mssname();
  if (mssname_ == &::google::protobuf::internal::kEmptyString) {
    mssname_ = new ::std::string;
  }
  mssname_->assign(value);
}
inline void MssDetail::set_mssname(const char* value) {
  set_has_mssname();
  if (mssname_ == &::google::protobuf::internal::kEmptyString) {
    mssname_ = new ::std::string;
  }
  mssname_->assign(value);
}
inline void MssDetail::set_mssname(const char* value, size_t size) {
  set_has_mssname();
  if (mssname_ == &::google::protobuf::internal::kEmptyString) {
    mssname_ = new ::std::string;
  }
  mssname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MssDetail::mutable_mssname() {
  set_has_mssname();
  if (mssname_ == &::google::protobuf::internal::kEmptyString) {
    mssname_ = new ::std::string;
  }
  return mssname_;
}
inline ::std::string* MssDetail::release_mssname() {
  clear_has_mssname();
  if (mssname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mssname_;
    mssname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool inactiveFlag = 3;
inline bool MssDetail::has_inactiveflag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MssDetail::set_has_inactiveflag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MssDetail::clear_has_inactiveflag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MssDetail::clear_inactiveflag() {
  inactiveflag_ = false;
  clear_has_inactiveflag();
}
inline bool MssDetail::inactiveflag() const {
  return inactiveflag_;
}
inline void MssDetail::set_inactiveflag(bool value) {
  set_has_inactiveflag();
  inactiveflag_ = value;
}

// -------------------------------------------------------------------

// StorageUnitDetail

// required fixed64 storageId = 1;
inline bool StorageUnitDetail::has_storageid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StorageUnitDetail::set_has_storageid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StorageUnitDetail::clear_has_storageid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StorageUnitDetail::clear_storageid() {
  storageid_ = GOOGLE_ULONGLONG(0);
  clear_has_storageid();
}
inline ::google::protobuf::uint64 StorageUnitDetail::storageid() const {
  return storageid_;
}
inline void StorageUnitDetail::set_storageid(::google::protobuf::uint64 value) {
  set_has_storageid();
  storageid_ = value;
}

// repeated fixed64 mssIds = 2;
inline int StorageUnitDetail::mssids_size() const {
  return mssids_.size();
}
inline void StorageUnitDetail::clear_mssids() {
  mssids_.Clear();
}
inline ::google::protobuf::uint64 StorageUnitDetail::mssids(int index) const {
  return mssids_.Get(index);
}
inline void StorageUnitDetail::set_mssids(int index, ::google::protobuf::uint64 value) {
  mssids_.Set(index, value);
}
inline void StorageUnitDetail::add_mssids(::google::protobuf::uint64 value) {
  mssids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
StorageUnitDetail::mssids() const {
  return mssids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
StorageUnitDetail::mutable_mssids() {
  return &mssids_;
}

// optional bool inactiveFlag = 3;
inline bool StorageUnitDetail::has_inactiveflag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StorageUnitDetail::set_has_inactiveflag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StorageUnitDetail::clear_has_inactiveflag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StorageUnitDetail::clear_inactiveflag() {
  inactiveflag_ = false;
  clear_has_inactiveflag();
}
inline bool StorageUnitDetail::inactiveflag() const {
  return inactiveflag_;
}
inline void StorageUnitDetail::set_inactiveflag(bool value) {
  set_has_inactiveflag();
  inactiveflag_ = value;
}

// -------------------------------------------------------------------

// BrsDetail

// required fixed64 brsId = 1;
inline bool BrsDetail::has_brsid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BrsDetail::set_has_brsid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BrsDetail::clear_has_brsid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BrsDetail::clear_brsid() {
  brsid_ = GOOGLE_ULONGLONG(0);
  clear_has_brsid();
}
inline ::google::protobuf::uint64 BrsDetail::brsid() const {
  return brsid_;
}
inline void BrsDetail::set_brsid(::google::protobuf::uint64 value) {
  set_has_brsid();
  brsid_ = value;
}

// required string brsName = 2;
inline bool BrsDetail::has_brsname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BrsDetail::set_has_brsname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BrsDetail::clear_has_brsname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BrsDetail::clear_brsname() {
  if (brsname_ != &::google::protobuf::internal::kEmptyString) {
    brsname_->clear();
  }
  clear_has_brsname();
}
inline const ::std::string& BrsDetail::brsname() const {
  return *brsname_;
}
inline void BrsDetail::set_brsname(const ::std::string& value) {
  set_has_brsname();
  if (brsname_ == &::google::protobuf::internal::kEmptyString) {
    brsname_ = new ::std::string;
  }
  brsname_->assign(value);
}
inline void BrsDetail::set_brsname(const char* value) {
  set_has_brsname();
  if (brsname_ == &::google::protobuf::internal::kEmptyString) {
    brsname_ = new ::std::string;
  }
  brsname_->assign(value);
}
inline void BrsDetail::set_brsname(const char* value, size_t size) {
  set_has_brsname();
  if (brsname_ == &::google::protobuf::internal::kEmptyString) {
    brsname_ = new ::std::string;
  }
  brsname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BrsDetail::mutable_brsname() {
  set_has_brsname();
  if (brsname_ == &::google::protobuf::internal::kEmptyString) {
    brsname_ = new ::std::string;
  }
  return brsname_;
}
inline ::std::string* BrsDetail::release_brsname() {
  clear_has_brsname();
  if (brsname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = brsname_;
    brsname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool inactiveFlag = 3;
inline bool BrsDetail::has_inactiveflag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BrsDetail::set_has_inactiveflag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BrsDetail::clear_has_inactiveflag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BrsDetail::clear_inactiveflag() {
  inactiveflag_ = false;
  clear_has_inactiveflag();
}
inline bool BrsDetail::inactiveflag() const {
  return inactiveflag_;
}
inline void BrsDetail::set_inactiveflag(bool value) {
  set_has_inactiveflag();
  inactiveflag_ = value;
}

// -------------------------------------------------------------------

// BrsStorageUnitDetail

// required fixed64 brsStorageId = 1;
inline bool BrsStorageUnitDetail::has_brsstorageid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BrsStorageUnitDetail::set_has_brsstorageid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BrsStorageUnitDetail::clear_has_brsstorageid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BrsStorageUnitDetail::clear_brsstorageid() {
  brsstorageid_ = GOOGLE_ULONGLONG(0);
  clear_has_brsstorageid();
}
inline ::google::protobuf::uint64 BrsStorageUnitDetail::brsstorageid() const {
  return brsstorageid_;
}
inline void BrsStorageUnitDetail::set_brsstorageid(::google::protobuf::uint64 value) {
  set_has_brsstorageid();
  brsstorageid_ = value;
}

// required fixed64 brsId = 2;
inline bool BrsStorageUnitDetail::has_brsid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BrsStorageUnitDetail::set_has_brsid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BrsStorageUnitDetail::clear_has_brsid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BrsStorageUnitDetail::clear_brsid() {
  brsid_ = GOOGLE_ULONGLONG(0);
  clear_has_brsid();
}
inline ::google::protobuf::uint64 BrsStorageUnitDetail::brsid() const {
  return brsid_;
}
inline void BrsStorageUnitDetail::set_brsid(::google::protobuf::uint64 value) {
  set_has_brsid();
  brsid_ = value;
}

// optional bool inactiveFlag = 3;
inline bool BrsStorageUnitDetail::has_inactiveflag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BrsStorageUnitDetail::set_has_inactiveflag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BrsStorageUnitDetail::clear_has_inactiveflag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BrsStorageUnitDetail::clear_inactiveflag() {
  inactiveflag_ = false;
  clear_has_inactiveflag();
}
inline bool BrsStorageUnitDetail::inactiveflag() const {
  return inactiveflag_;
}
inline void BrsStorageUnitDetail::set_inactiveflag(bool value) {
  set_has_inactiveflag();
  inactiveflag_ = value;
}

// -------------------------------------------------------------------

// BackupStatus

// required fixed64 userId = 1;
inline bool BackupStatus::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BackupStatus::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BackupStatus::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BackupStatus::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 BackupStatus::userid() const {
  return userid_;
}
inline void BackupStatus::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required fixed64 datasetId = 2;
inline bool BackupStatus::has_datasetid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BackupStatus::set_has_datasetid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BackupStatus::clear_has_datasetid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BackupStatus::clear_datasetid() {
  datasetid_ = GOOGLE_ULONGLONG(0);
  clear_has_datasetid();
}
inline ::google::protobuf::uint64 BackupStatus::datasetid() const {
  return datasetid_;
}
inline void BackupStatus::set_datasetid(::google::protobuf::uint64 value) {
  set_has_datasetid();
  datasetid_ = value;
}

// required fixed64 lastBackupTime = 3;
inline bool BackupStatus::has_lastbackuptime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BackupStatus::set_has_lastbackuptime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BackupStatus::clear_has_lastbackuptime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BackupStatus::clear_lastbackuptime() {
  lastbackuptime_ = GOOGLE_ULONGLONG(0);
  clear_has_lastbackuptime();
}
inline ::google::protobuf::uint64 BackupStatus::lastbackuptime() const {
  return lastbackuptime_;
}
inline void BackupStatus::set_lastbackuptime(::google::protobuf::uint64 value) {
  set_has_lastbackuptime();
  lastbackuptime_ = value;
}

// required fixed64 lastBackupVersion = 4;
inline bool BackupStatus::has_lastbackupversion() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BackupStatus::set_has_lastbackupversion() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BackupStatus::clear_has_lastbackupversion() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BackupStatus::clear_lastbackupversion() {
  lastbackupversion_ = GOOGLE_ULONGLONG(0);
  clear_has_lastbackupversion();
}
inline ::google::protobuf::uint64 BackupStatus::lastbackupversion() const {
  return lastbackupversion_;
}
inline void BackupStatus::set_lastbackupversion(::google::protobuf::uint64 value) {
  set_has_lastbackupversion();
  lastbackupversion_ = value;
}

// optional fixed64 lastArchiveTime = 5;
inline bool BackupStatus::has_lastarchivetime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BackupStatus::set_has_lastarchivetime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BackupStatus::clear_has_lastarchivetime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BackupStatus::clear_lastarchivetime() {
  lastarchivetime_ = GOOGLE_ULONGLONG(0);
  clear_has_lastarchivetime();
}
inline ::google::protobuf::uint64 BackupStatus::lastarchivetime() const {
  return lastarchivetime_;
}
inline void BackupStatus::set_lastarchivetime(::google::protobuf::uint64 value) {
  set_has_lastarchivetime();
  lastarchivetime_ = value;
}

// optional fixed64 lastArchiveVersion = 6;
inline bool BackupStatus::has_lastarchiveversion() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BackupStatus::set_has_lastarchiveversion() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BackupStatus::clear_has_lastarchiveversion() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BackupStatus::clear_lastarchiveversion() {
  lastarchiveversion_ = GOOGLE_ULONGLONG(0);
  clear_has_lastarchiveversion();
}
inline ::google::protobuf::uint64 BackupStatus::lastarchiveversion() const {
  return lastarchiveversion_;
}
inline void BackupStatus::set_lastarchiveversion(::google::protobuf::uint64 value) {
  set_has_lastarchiveversion();
  lastarchiveversion_ = value;
}

// -------------------------------------------------------------------

// GetSaveTicketsInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool GetSaveTicketsInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetSaveTicketsInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetSaveTicketsInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetSaveTicketsInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& GetSaveTicketsInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* GetSaveTicketsInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* GetSaveTicketsInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 deviceId = 2;
inline bool GetSaveTicketsInput::has_deviceid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetSaveTicketsInput::set_has_deviceid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetSaveTicketsInput::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetSaveTicketsInput::clear_deviceid() {
  deviceid_ = GOOGLE_ULONGLONG(0);
  clear_has_deviceid();
}
inline ::google::protobuf::uint64 GetSaveTicketsInput::deviceid() const {
  return deviceid_;
}
inline void GetSaveTicketsInput::set_deviceid(::google::protobuf::uint64 value) {
  set_has_deviceid();
  deviceid_ = value;
}

// required bytes certificate = 3;
inline bool GetSaveTicketsInput::has_certificate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetSaveTicketsInput::set_has_certificate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetSaveTicketsInput::clear_has_certificate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetSaveTicketsInput::clear_certificate() {
  if (certificate_ != &::google::protobuf::internal::kEmptyString) {
    certificate_->clear();
  }
  clear_has_certificate();
}
inline const ::std::string& GetSaveTicketsInput::certificate() const {
  return *certificate_;
}
inline void GetSaveTicketsInput::set_certificate(const ::std::string& value) {
  set_has_certificate();
  if (certificate_ == &::google::protobuf::internal::kEmptyString) {
    certificate_ = new ::std::string;
  }
  certificate_->assign(value);
}
inline void GetSaveTicketsInput::set_certificate(const char* value) {
  set_has_certificate();
  if (certificate_ == &::google::protobuf::internal::kEmptyString) {
    certificate_ = new ::std::string;
  }
  certificate_->assign(value);
}
inline void GetSaveTicketsInput::set_certificate(const void* value, size_t size) {
  set_has_certificate();
  if (certificate_ == &::google::protobuf::internal::kEmptyString) {
    certificate_ = new ::std::string;
  }
  certificate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetSaveTicketsInput::mutable_certificate() {
  set_has_certificate();
  if (certificate_ == &::google::protobuf::internal::kEmptyString) {
    certificate_ = new ::std::string;
  }
  return certificate_;
}
inline ::std::string* GetSaveTicketsInput::release_certificate() {
  clear_has_certificate();
  if (certificate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = certificate_;
    certificate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetSaveTicketsOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool GetSaveTicketsOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetSaveTicketsOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetSaveTicketsOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetSaveTicketsOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& GetSaveTicketsOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* GetSaveTicketsOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* GetSaveTicketsOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// optional .vplex.vsDirectory.ETicketData encryptionTicket = 2;
inline bool GetSaveTicketsOutput::has_encryptionticket() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetSaveTicketsOutput::set_has_encryptionticket() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetSaveTicketsOutput::clear_has_encryptionticket() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetSaveTicketsOutput::clear_encryptionticket() {
  if (encryptionticket_ != NULL) encryptionticket_->::vplex::vsDirectory::ETicketData::Clear();
  clear_has_encryptionticket();
}
inline const ::vplex::vsDirectory::ETicketData& GetSaveTicketsOutput::encryptionticket() const {
  return encryptionticket_ != NULL ? *encryptionticket_ : *default_instance_->encryptionticket_;
}
inline ::vplex::vsDirectory::ETicketData* GetSaveTicketsOutput::mutable_encryptionticket() {
  set_has_encryptionticket();
  if (encryptionticket_ == NULL) encryptionticket_ = new ::vplex::vsDirectory::ETicketData;
  return encryptionticket_;
}
inline ::vplex::vsDirectory::ETicketData* GetSaveTicketsOutput::release_encryptionticket() {
  clear_has_encryptionticket();
  ::vplex::vsDirectory::ETicketData* temp = encryptionticket_;
  encryptionticket_ = NULL;
  return temp;
}

// optional .vplex.vsDirectory.ETicketData signingTicket = 3;
inline bool GetSaveTicketsOutput::has_signingticket() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetSaveTicketsOutput::set_has_signingticket() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetSaveTicketsOutput::clear_has_signingticket() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetSaveTicketsOutput::clear_signingticket() {
  if (signingticket_ != NULL) signingticket_->::vplex::vsDirectory::ETicketData::Clear();
  clear_has_signingticket();
}
inline const ::vplex::vsDirectory::ETicketData& GetSaveTicketsOutput::signingticket() const {
  return signingticket_ != NULL ? *signingticket_ : *default_instance_->signingticket_;
}
inline ::vplex::vsDirectory::ETicketData* GetSaveTicketsOutput::mutable_signingticket() {
  set_has_signingticket();
  if (signingticket_ == NULL) signingticket_ = new ::vplex::vsDirectory::ETicketData;
  return signingticket_;
}
inline ::vplex::vsDirectory::ETicketData* GetSaveTicketsOutput::release_signingticket() {
  clear_has_signingticket();
  ::vplex::vsDirectory::ETicketData* temp = signingticket_;
  signingticket_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// GetSaveDataInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool GetSaveDataInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetSaveDataInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetSaveDataInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetSaveDataInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& GetSaveDataInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* GetSaveDataInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* GetSaveDataInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// repeated string titleIds = 2;
inline int GetSaveDataInput::titleids_size() const {
  return titleids_.size();
}
inline void GetSaveDataInput::clear_titleids() {
  titleids_.Clear();
}
inline const ::std::string& GetSaveDataInput::titleids(int index) const {
  return titleids_.Get(index);
}
inline ::std::string* GetSaveDataInput::mutable_titleids(int index) {
  return titleids_.Mutable(index);
}
inline void GetSaveDataInput::set_titleids(int index, const ::std::string& value) {
  titleids_.Mutable(index)->assign(value);
}
inline void GetSaveDataInput::set_titleids(int index, const char* value) {
  titleids_.Mutable(index)->assign(value);
}
inline void GetSaveDataInput::set_titleids(int index, const char* value, size_t size) {
  titleids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetSaveDataInput::add_titleids() {
  return titleids_.Add();
}
inline void GetSaveDataInput::add_titleids(const ::std::string& value) {
  titleids_.Add()->assign(value);
}
inline void GetSaveDataInput::add_titleids(const char* value) {
  titleids_.Add()->assign(value);
}
inline void GetSaveDataInput::add_titleids(const char* value, size_t size) {
  titleids_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetSaveDataInput::titleids() const {
  return titleids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetSaveDataInput::mutable_titleids() {
  return &titleids_;
}

// -------------------------------------------------------------------

// GetSaveDataOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool GetSaveDataOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetSaveDataOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetSaveDataOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetSaveDataOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& GetSaveDataOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* GetSaveDataOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* GetSaveDataOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// repeated .vplex.vsDirectory.SaveData data = 2;
inline int GetSaveDataOutput::data_size() const {
  return data_.size();
}
inline void GetSaveDataOutput::clear_data() {
  data_.Clear();
}
inline const ::vplex::vsDirectory::SaveData& GetSaveDataOutput::data(int index) const {
  return data_.Get(index);
}
inline ::vplex::vsDirectory::SaveData* GetSaveDataOutput::mutable_data(int index) {
  return data_.Mutable(index);
}
inline ::vplex::vsDirectory::SaveData* GetSaveDataOutput::add_data() {
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::SaveData >&
GetSaveDataOutput::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::SaveData >*
GetSaveDataOutput::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// GetOwnedTitlesInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool GetOwnedTitlesInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetOwnedTitlesInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetOwnedTitlesInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetOwnedTitlesInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& GetOwnedTitlesInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* GetOwnedTitlesInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* GetOwnedTitlesInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required .vplex.vsDirectory.Localization l10n = 2;
inline bool GetOwnedTitlesInput::has_l10n() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetOwnedTitlesInput::set_has_l10n() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetOwnedTitlesInput::clear_has_l10n() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetOwnedTitlesInput::clear_l10n() {
  if (l10n_ != NULL) l10n_->::vplex::vsDirectory::Localization::Clear();
  clear_has_l10n();
}
inline const ::vplex::vsDirectory::Localization& GetOwnedTitlesInput::l10n() const {
  return l10n_ != NULL ? *l10n_ : *default_instance_->l10n_;
}
inline ::vplex::vsDirectory::Localization* GetOwnedTitlesInput::mutable_l10n() {
  set_has_l10n();
  if (l10n_ == NULL) l10n_ = new ::vplex::vsDirectory::Localization;
  return l10n_;
}
inline ::vplex::vsDirectory::Localization* GetOwnedTitlesInput::release_l10n() {
  clear_has_l10n();
  ::vplex::vsDirectory::Localization* temp = l10n_;
  l10n_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// GetOwnedTitlesOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool GetOwnedTitlesOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetOwnedTitlesOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetOwnedTitlesOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetOwnedTitlesOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& GetOwnedTitlesOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* GetOwnedTitlesOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* GetOwnedTitlesOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// repeated .vplex.vsDirectory.TitleData titleData = 2;
inline int GetOwnedTitlesOutput::titledata_size() const {
  return titledata_.size();
}
inline void GetOwnedTitlesOutput::clear_titledata() {
  titledata_.Clear();
}
inline const ::vplex::vsDirectory::TitleData& GetOwnedTitlesOutput::titledata(int index) const {
  return titledata_.Get(index);
}
inline ::vplex::vsDirectory::TitleData* GetOwnedTitlesOutput::mutable_titledata(int index) {
  return titledata_.Mutable(index);
}
inline ::vplex::vsDirectory::TitleData* GetOwnedTitlesOutput::add_titledata() {
  return titledata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::TitleData >&
GetOwnedTitlesOutput::titledata() const {
  return titledata_;
}
inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::TitleData >*
GetOwnedTitlesOutput::mutable_titledata() {
  return &titledata_;
}

// -------------------------------------------------------------------

// GetTitlesInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool GetTitlesInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTitlesInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTitlesInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetTitlesInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& GetTitlesInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* GetTitlesInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* GetTitlesInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required .vplex.vsDirectory.Localization l10n = 2;
inline bool GetTitlesInput::has_l10n() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetTitlesInput::set_has_l10n() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetTitlesInput::clear_has_l10n() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetTitlesInput::clear_l10n() {
  if (l10n_ != NULL) l10n_->::vplex::vsDirectory::Localization::Clear();
  clear_has_l10n();
}
inline const ::vplex::vsDirectory::Localization& GetTitlesInput::l10n() const {
  return l10n_ != NULL ? *l10n_ : *default_instance_->l10n_;
}
inline ::vplex::vsDirectory::Localization* GetTitlesInput::mutable_l10n() {
  set_has_l10n();
  if (l10n_ == NULL) l10n_ = new ::vplex::vsDirectory::Localization;
  return l10n_;
}
inline ::vplex::vsDirectory::Localization* GetTitlesInput::release_l10n() {
  clear_has_l10n();
  ::vplex::vsDirectory::Localization* temp = l10n_;
  l10n_ = NULL;
  return temp;
}

// repeated string titleIds = 3;
inline int GetTitlesInput::titleids_size() const {
  return titleids_.size();
}
inline void GetTitlesInput::clear_titleids() {
  titleids_.Clear();
}
inline const ::std::string& GetTitlesInput::titleids(int index) const {
  return titleids_.Get(index);
}
inline ::std::string* GetTitlesInput::mutable_titleids(int index) {
  return titleids_.Mutable(index);
}
inline void GetTitlesInput::set_titleids(int index, const ::std::string& value) {
  titleids_.Mutable(index)->assign(value);
}
inline void GetTitlesInput::set_titleids(int index, const char* value) {
  titleids_.Mutable(index)->assign(value);
}
inline void GetTitlesInput::set_titleids(int index, const char* value, size_t size) {
  titleids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetTitlesInput::add_titleids() {
  return titleids_.Add();
}
inline void GetTitlesInput::add_titleids(const ::std::string& value) {
  titleids_.Add()->assign(value);
}
inline void GetTitlesInput::add_titleids(const char* value) {
  titleids_.Add()->assign(value);
}
inline void GetTitlesInput::add_titleids(const char* value, size_t size) {
  titleids_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetTitlesInput::titleids() const {
  return titleids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetTitlesInput::mutable_titleids() {
  return &titleids_;
}

// -------------------------------------------------------------------

// GetTitlesOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool GetTitlesOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTitlesOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTitlesOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetTitlesOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& GetTitlesOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* GetTitlesOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* GetTitlesOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// repeated .vplex.vsDirectory.TitleData titleData = 2;
inline int GetTitlesOutput::titledata_size() const {
  return titledata_.size();
}
inline void GetTitlesOutput::clear_titledata() {
  titledata_.Clear();
}
inline const ::vplex::vsDirectory::TitleData& GetTitlesOutput::titledata(int index) const {
  return titledata_.Get(index);
}
inline ::vplex::vsDirectory::TitleData* GetTitlesOutput::mutable_titledata(int index) {
  return titledata_.Mutable(index);
}
inline ::vplex::vsDirectory::TitleData* GetTitlesOutput::add_titledata() {
  return titledata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::TitleData >&
GetTitlesOutput::titledata() const {
  return titledata_;
}
inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::TitleData >*
GetTitlesOutput::mutable_titledata() {
  return &titledata_;
}

// -------------------------------------------------------------------

// GetTitleDetailsInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool GetTitleDetailsInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTitleDetailsInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTitleDetailsInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetTitleDetailsInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& GetTitleDetailsInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* GetTitleDetailsInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* GetTitleDetailsInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required .vplex.vsDirectory.Localization l10n = 2;
inline bool GetTitleDetailsInput::has_l10n() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetTitleDetailsInput::set_has_l10n() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetTitleDetailsInput::clear_has_l10n() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetTitleDetailsInput::clear_l10n() {
  if (l10n_ != NULL) l10n_->::vplex::vsDirectory::Localization::Clear();
  clear_has_l10n();
}
inline const ::vplex::vsDirectory::Localization& GetTitleDetailsInput::l10n() const {
  return l10n_ != NULL ? *l10n_ : *default_instance_->l10n_;
}
inline ::vplex::vsDirectory::Localization* GetTitleDetailsInput::mutable_l10n() {
  set_has_l10n();
  if (l10n_ == NULL) l10n_ = new ::vplex::vsDirectory::Localization;
  return l10n_;
}
inline ::vplex::vsDirectory::Localization* GetTitleDetailsInput::release_l10n() {
  clear_has_l10n();
  ::vplex::vsDirectory::Localization* temp = l10n_;
  l10n_ = NULL;
  return temp;
}

// repeated string titleIds = 3;
inline int GetTitleDetailsInput::titleids_size() const {
  return titleids_.size();
}
inline void GetTitleDetailsInput::clear_titleids() {
  titleids_.Clear();
}
inline const ::std::string& GetTitleDetailsInput::titleids(int index) const {
  return titleids_.Get(index);
}
inline ::std::string* GetTitleDetailsInput::mutable_titleids(int index) {
  return titleids_.Mutable(index);
}
inline void GetTitleDetailsInput::set_titleids(int index, const ::std::string& value) {
  titleids_.Mutable(index)->assign(value);
}
inline void GetTitleDetailsInput::set_titleids(int index, const char* value) {
  titleids_.Mutable(index)->assign(value);
}
inline void GetTitleDetailsInput::set_titleids(int index, const char* value, size_t size) {
  titleids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetTitleDetailsInput::add_titleids() {
  return titleids_.Add();
}
inline void GetTitleDetailsInput::add_titleids(const ::std::string& value) {
  titleids_.Add()->assign(value);
}
inline void GetTitleDetailsInput::add_titleids(const char* value) {
  titleids_.Add()->assign(value);
}
inline void GetTitleDetailsInput::add_titleids(const char* value, size_t size) {
  titleids_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetTitleDetailsInput::titleids() const {
  return titleids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetTitleDetailsInput::mutable_titleids() {
  return &titleids_;
}

// -------------------------------------------------------------------

// GetTitleDetailsOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool GetTitleDetailsOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTitleDetailsOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTitleDetailsOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetTitleDetailsOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& GetTitleDetailsOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* GetTitleDetailsOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* GetTitleDetailsOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// repeated .vplex.vsDirectory.TitleDetail titleDetails = 2;
inline int GetTitleDetailsOutput::titledetails_size() const {
  return titledetails_.size();
}
inline void GetTitleDetailsOutput::clear_titledetails() {
  titledetails_.Clear();
}
inline const ::vplex::vsDirectory::TitleDetail& GetTitleDetailsOutput::titledetails(int index) const {
  return titledetails_.Get(index);
}
inline ::vplex::vsDirectory::TitleDetail* GetTitleDetailsOutput::mutable_titledetails(int index) {
  return titledetails_.Mutable(index);
}
inline ::vplex::vsDirectory::TitleDetail* GetTitleDetailsOutput::add_titledetails() {
  return titledetails_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::TitleDetail >&
GetTitleDetailsOutput::titledetails() const {
  return titledetails_;
}
inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::TitleDetail >*
GetTitleDetailsOutput::mutable_titledetails() {
  return &titledetails_;
}

// -------------------------------------------------------------------

// GetAttestationChallengeInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool GetAttestationChallengeInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetAttestationChallengeInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetAttestationChallengeInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetAttestationChallengeInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& GetAttestationChallengeInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* GetAttestationChallengeInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* GetAttestationChallengeInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 deviceId = 2;
inline bool GetAttestationChallengeInput::has_deviceid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetAttestationChallengeInput::set_has_deviceid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetAttestationChallengeInput::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetAttestationChallengeInput::clear_deviceid() {
  deviceid_ = GOOGLE_ULONGLONG(0);
  clear_has_deviceid();
}
inline ::google::protobuf::uint64 GetAttestationChallengeInput::deviceid() const {
  return deviceid_;
}
inline void GetAttestationChallengeInput::set_deviceid(::google::protobuf::uint64 value) {
  set_has_deviceid();
  deviceid_ = value;
}

// -------------------------------------------------------------------

// GetAttestationChallengeOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool GetAttestationChallengeOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetAttestationChallengeOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetAttestationChallengeOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetAttestationChallengeOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& GetAttestationChallengeOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* GetAttestationChallengeOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* GetAttestationChallengeOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// optional bytes challenge = 2;
inline bool GetAttestationChallengeOutput::has_challenge() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetAttestationChallengeOutput::set_has_challenge() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetAttestationChallengeOutput::clear_has_challenge() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetAttestationChallengeOutput::clear_challenge() {
  if (challenge_ != &::google::protobuf::internal::kEmptyString) {
    challenge_->clear();
  }
  clear_has_challenge();
}
inline const ::std::string& GetAttestationChallengeOutput::challenge() const {
  return *challenge_;
}
inline void GetAttestationChallengeOutput::set_challenge(const ::std::string& value) {
  set_has_challenge();
  if (challenge_ == &::google::protobuf::internal::kEmptyString) {
    challenge_ = new ::std::string;
  }
  challenge_->assign(value);
}
inline void GetAttestationChallengeOutput::set_challenge(const char* value) {
  set_has_challenge();
  if (challenge_ == &::google::protobuf::internal::kEmptyString) {
    challenge_ = new ::std::string;
  }
  challenge_->assign(value);
}
inline void GetAttestationChallengeOutput::set_challenge(const void* value, size_t size) {
  set_has_challenge();
  if (challenge_ == &::google::protobuf::internal::kEmptyString) {
    challenge_ = new ::std::string;
  }
  challenge_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetAttestationChallengeOutput::mutable_challenge() {
  set_has_challenge();
  if (challenge_ == &::google::protobuf::internal::kEmptyString) {
    challenge_ = new ::std::string;
  }
  return challenge_;
}
inline ::std::string* GetAttestationChallengeOutput::release_challenge() {
  clear_has_challenge();
  if (challenge_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = challenge_;
    challenge_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes challengeTmd = 3;
inline bool GetAttestationChallengeOutput::has_challengetmd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetAttestationChallengeOutput::set_has_challengetmd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetAttestationChallengeOutput::clear_has_challengetmd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetAttestationChallengeOutput::clear_challengetmd() {
  if (challengetmd_ != &::google::protobuf::internal::kEmptyString) {
    challengetmd_->clear();
  }
  clear_has_challengetmd();
}
inline const ::std::string& GetAttestationChallengeOutput::challengetmd() const {
  return *challengetmd_;
}
inline void GetAttestationChallengeOutput::set_challengetmd(const ::std::string& value) {
  set_has_challengetmd();
  if (challengetmd_ == &::google::protobuf::internal::kEmptyString) {
    challengetmd_ = new ::std::string;
  }
  challengetmd_->assign(value);
}
inline void GetAttestationChallengeOutput::set_challengetmd(const char* value) {
  set_has_challengetmd();
  if (challengetmd_ == &::google::protobuf::internal::kEmptyString) {
    challengetmd_ = new ::std::string;
  }
  challengetmd_->assign(value);
}
inline void GetAttestationChallengeOutput::set_challengetmd(const void* value, size_t size) {
  set_has_challengetmd();
  if (challengetmd_ == &::google::protobuf::internal::kEmptyString) {
    challengetmd_ = new ::std::string;
  }
  challengetmd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetAttestationChallengeOutput::mutable_challengetmd() {
  set_has_challengetmd();
  if (challengetmd_ == &::google::protobuf::internal::kEmptyString) {
    challengetmd_ = new ::std::string;
  }
  return challengetmd_;
}
inline ::std::string* GetAttestationChallengeOutput::release_challengetmd() {
  clear_has_challengetmd();
  if (challengetmd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = challengetmd_;
    challengetmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AuthenticateDeviceInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool AuthenticateDeviceInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthenticateDeviceInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthenticateDeviceInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthenticateDeviceInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& AuthenticateDeviceInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* AuthenticateDeviceInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* AuthenticateDeviceInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required bytes challengeResponse = 2;
inline bool AuthenticateDeviceInput::has_challengeresponse() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AuthenticateDeviceInput::set_has_challengeresponse() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AuthenticateDeviceInput::clear_has_challengeresponse() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AuthenticateDeviceInput::clear_challengeresponse() {
  if (challengeresponse_ != &::google::protobuf::internal::kEmptyString) {
    challengeresponse_->clear();
  }
  clear_has_challengeresponse();
}
inline const ::std::string& AuthenticateDeviceInput::challengeresponse() const {
  return *challengeresponse_;
}
inline void AuthenticateDeviceInput::set_challengeresponse(const ::std::string& value) {
  set_has_challengeresponse();
  if (challengeresponse_ == &::google::protobuf::internal::kEmptyString) {
    challengeresponse_ = new ::std::string;
  }
  challengeresponse_->assign(value);
}
inline void AuthenticateDeviceInput::set_challengeresponse(const char* value) {
  set_has_challengeresponse();
  if (challengeresponse_ == &::google::protobuf::internal::kEmptyString) {
    challengeresponse_ = new ::std::string;
  }
  challengeresponse_->assign(value);
}
inline void AuthenticateDeviceInput::set_challengeresponse(const void* value, size_t size) {
  set_has_challengeresponse();
  if (challengeresponse_ == &::google::protobuf::internal::kEmptyString) {
    challengeresponse_ = new ::std::string;
  }
  challengeresponse_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuthenticateDeviceInput::mutable_challengeresponse() {
  set_has_challengeresponse();
  if (challengeresponse_ == &::google::protobuf::internal::kEmptyString) {
    challengeresponse_ = new ::std::string;
  }
  return challengeresponse_;
}
inline ::std::string* AuthenticateDeviceInput::release_challengeresponse() {
  clear_has_challengeresponse();
  if (challengeresponse_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = challengeresponse_;
    challengeresponse_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes deviceCertificate = 3;
inline bool AuthenticateDeviceInput::has_devicecertificate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AuthenticateDeviceInput::set_has_devicecertificate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AuthenticateDeviceInput::clear_has_devicecertificate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AuthenticateDeviceInput::clear_devicecertificate() {
  if (devicecertificate_ != &::google::protobuf::internal::kEmptyString) {
    devicecertificate_->clear();
  }
  clear_has_devicecertificate();
}
inline const ::std::string& AuthenticateDeviceInput::devicecertificate() const {
  return *devicecertificate_;
}
inline void AuthenticateDeviceInput::set_devicecertificate(const ::std::string& value) {
  set_has_devicecertificate();
  if (devicecertificate_ == &::google::protobuf::internal::kEmptyString) {
    devicecertificate_ = new ::std::string;
  }
  devicecertificate_->assign(value);
}
inline void AuthenticateDeviceInput::set_devicecertificate(const char* value) {
  set_has_devicecertificate();
  if (devicecertificate_ == &::google::protobuf::internal::kEmptyString) {
    devicecertificate_ = new ::std::string;
  }
  devicecertificate_->assign(value);
}
inline void AuthenticateDeviceInput::set_devicecertificate(const void* value, size_t size) {
  set_has_devicecertificate();
  if (devicecertificate_ == &::google::protobuf::internal::kEmptyString) {
    devicecertificate_ = new ::std::string;
  }
  devicecertificate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuthenticateDeviceInput::mutable_devicecertificate() {
  set_has_devicecertificate();
  if (devicecertificate_ == &::google::protobuf::internal::kEmptyString) {
    devicecertificate_ = new ::std::string;
  }
  return devicecertificate_;
}
inline ::std::string* AuthenticateDeviceInput::release_devicecertificate() {
  clear_has_devicecertificate();
  if (devicecertificate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devicecertificate_;
    devicecertificate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AuthenticateDeviceOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool AuthenticateDeviceOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthenticateDeviceOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthenticateDeviceOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthenticateDeviceOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& AuthenticateDeviceOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* AuthenticateDeviceOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* AuthenticateDeviceOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// GetOnlineTitleTicketInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool GetOnlineTitleTicketInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetOnlineTitleTicketInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetOnlineTitleTicketInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetOnlineTitleTicketInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& GetOnlineTitleTicketInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* GetOnlineTitleTicketInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* GetOnlineTitleTicketInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 deviceId = 2;
inline bool GetOnlineTitleTicketInput::has_deviceid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetOnlineTitleTicketInput::set_has_deviceid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetOnlineTitleTicketInput::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetOnlineTitleTicketInput::clear_deviceid() {
  deviceid_ = GOOGLE_ULONGLONG(0);
  clear_has_deviceid();
}
inline ::google::protobuf::uint64 GetOnlineTitleTicketInput::deviceid() const {
  return deviceid_;
}
inline void GetOnlineTitleTicketInput::set_deviceid(::google::protobuf::uint64 value) {
  set_has_deviceid();
  deviceid_ = value;
}

// required bytes deviceCertificate = 3;
inline bool GetOnlineTitleTicketInput::has_devicecertificate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetOnlineTitleTicketInput::set_has_devicecertificate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetOnlineTitleTicketInput::clear_has_devicecertificate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetOnlineTitleTicketInput::clear_devicecertificate() {
  if (devicecertificate_ != &::google::protobuf::internal::kEmptyString) {
    devicecertificate_->clear();
  }
  clear_has_devicecertificate();
}
inline const ::std::string& GetOnlineTitleTicketInput::devicecertificate() const {
  return *devicecertificate_;
}
inline void GetOnlineTitleTicketInput::set_devicecertificate(const ::std::string& value) {
  set_has_devicecertificate();
  if (devicecertificate_ == &::google::protobuf::internal::kEmptyString) {
    devicecertificate_ = new ::std::string;
  }
  devicecertificate_->assign(value);
}
inline void GetOnlineTitleTicketInput::set_devicecertificate(const char* value) {
  set_has_devicecertificate();
  if (devicecertificate_ == &::google::protobuf::internal::kEmptyString) {
    devicecertificate_ = new ::std::string;
  }
  devicecertificate_->assign(value);
}
inline void GetOnlineTitleTicketInput::set_devicecertificate(const void* value, size_t size) {
  set_has_devicecertificate();
  if (devicecertificate_ == &::google::protobuf::internal::kEmptyString) {
    devicecertificate_ = new ::std::string;
  }
  devicecertificate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetOnlineTitleTicketInput::mutable_devicecertificate() {
  set_has_devicecertificate();
  if (devicecertificate_ == &::google::protobuf::internal::kEmptyString) {
    devicecertificate_ = new ::std::string;
  }
  return devicecertificate_;
}
inline ::std::string* GetOnlineTitleTicketInput::release_devicecertificate() {
  clear_has_devicecertificate();
  if (devicecertificate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devicecertificate_;
    devicecertificate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string titleId = 4;
inline bool GetOnlineTitleTicketInput::has_titleid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetOnlineTitleTicketInput::set_has_titleid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetOnlineTitleTicketInput::clear_has_titleid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetOnlineTitleTicketInput::clear_titleid() {
  if (titleid_ != &::google::protobuf::internal::kEmptyString) {
    titleid_->clear();
  }
  clear_has_titleid();
}
inline const ::std::string& GetOnlineTitleTicketInput::titleid() const {
  return *titleid_;
}
inline void GetOnlineTitleTicketInput::set_titleid(const ::std::string& value) {
  set_has_titleid();
  if (titleid_ == &::google::protobuf::internal::kEmptyString) {
    titleid_ = new ::std::string;
  }
  titleid_->assign(value);
}
inline void GetOnlineTitleTicketInput::set_titleid(const char* value) {
  set_has_titleid();
  if (titleid_ == &::google::protobuf::internal::kEmptyString) {
    titleid_ = new ::std::string;
  }
  titleid_->assign(value);
}
inline void GetOnlineTitleTicketInput::set_titleid(const char* value, size_t size) {
  set_has_titleid();
  if (titleid_ == &::google::protobuf::internal::kEmptyString) {
    titleid_ = new ::std::string;
  }
  titleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetOnlineTitleTicketInput::mutable_titleid() {
  set_has_titleid();
  if (titleid_ == &::google::protobuf::internal::kEmptyString) {
    titleid_ = new ::std::string;
  }
  return titleid_;
}
inline ::std::string* GetOnlineTitleTicketInput::release_titleid() {
  clear_has_titleid();
  if (titleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = titleid_;
    titleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetOnlineTitleTicketOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool GetOnlineTitleTicketOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetOnlineTitleTicketOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetOnlineTitleTicketOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetOnlineTitleTicketOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& GetOnlineTitleTicketOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* GetOnlineTitleTicketOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* GetOnlineTitleTicketOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// optional .vplex.vsDirectory.ETicketData eTicket = 2;
inline bool GetOnlineTitleTicketOutput::has_eticket() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetOnlineTitleTicketOutput::set_has_eticket() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetOnlineTitleTicketOutput::clear_has_eticket() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetOnlineTitleTicketOutput::clear_eticket() {
  if (eticket_ != NULL) eticket_->::vplex::vsDirectory::ETicketData::Clear();
  clear_has_eticket();
}
inline const ::vplex::vsDirectory::ETicketData& GetOnlineTitleTicketOutput::eticket() const {
  return eticket_ != NULL ? *eticket_ : *default_instance_->eticket_;
}
inline ::vplex::vsDirectory::ETicketData* GetOnlineTitleTicketOutput::mutable_eticket() {
  set_has_eticket();
  if (eticket_ == NULL) eticket_ = new ::vplex::vsDirectory::ETicketData;
  return eticket_;
}
inline ::vplex::vsDirectory::ETicketData* GetOnlineTitleTicketOutput::release_eticket() {
  clear_has_eticket();
  ::vplex::vsDirectory::ETicketData* temp = eticket_;
  eticket_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// GetOfflineTitleTicketsInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool GetOfflineTitleTicketsInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetOfflineTitleTicketsInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetOfflineTitleTicketsInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetOfflineTitleTicketsInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& GetOfflineTitleTicketsInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* GetOfflineTitleTicketsInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* GetOfflineTitleTicketsInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 deviceId = 2;
inline bool GetOfflineTitleTicketsInput::has_deviceid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetOfflineTitleTicketsInput::set_has_deviceid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetOfflineTitleTicketsInput::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetOfflineTitleTicketsInput::clear_deviceid() {
  deviceid_ = GOOGLE_ULONGLONG(0);
  clear_has_deviceid();
}
inline ::google::protobuf::uint64 GetOfflineTitleTicketsInput::deviceid() const {
  return deviceid_;
}
inline void GetOfflineTitleTicketsInput::set_deviceid(::google::protobuf::uint64 value) {
  set_has_deviceid();
  deviceid_ = value;
}

// required bytes deviceCertificate = 3;
inline bool GetOfflineTitleTicketsInput::has_devicecertificate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetOfflineTitleTicketsInput::set_has_devicecertificate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetOfflineTitleTicketsInput::clear_has_devicecertificate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetOfflineTitleTicketsInput::clear_devicecertificate() {
  if (devicecertificate_ != &::google::protobuf::internal::kEmptyString) {
    devicecertificate_->clear();
  }
  clear_has_devicecertificate();
}
inline const ::std::string& GetOfflineTitleTicketsInput::devicecertificate() const {
  return *devicecertificate_;
}
inline void GetOfflineTitleTicketsInput::set_devicecertificate(const ::std::string& value) {
  set_has_devicecertificate();
  if (devicecertificate_ == &::google::protobuf::internal::kEmptyString) {
    devicecertificate_ = new ::std::string;
  }
  devicecertificate_->assign(value);
}
inline void GetOfflineTitleTicketsInput::set_devicecertificate(const char* value) {
  set_has_devicecertificate();
  if (devicecertificate_ == &::google::protobuf::internal::kEmptyString) {
    devicecertificate_ = new ::std::string;
  }
  devicecertificate_->assign(value);
}
inline void GetOfflineTitleTicketsInput::set_devicecertificate(const void* value, size_t size) {
  set_has_devicecertificate();
  if (devicecertificate_ == &::google::protobuf::internal::kEmptyString) {
    devicecertificate_ = new ::std::string;
  }
  devicecertificate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetOfflineTitleTicketsInput::mutable_devicecertificate() {
  set_has_devicecertificate();
  if (devicecertificate_ == &::google::protobuf::internal::kEmptyString) {
    devicecertificate_ = new ::std::string;
  }
  return devicecertificate_;
}
inline ::std::string* GetOfflineTitleTicketsInput::release_devicecertificate() {
  clear_has_devicecertificate();
  if (devicecertificate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devicecertificate_;
    devicecertificate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated string titleIds = 4;
inline int GetOfflineTitleTicketsInput::titleids_size() const {
  return titleids_.size();
}
inline void GetOfflineTitleTicketsInput::clear_titleids() {
  titleids_.Clear();
}
inline const ::std::string& GetOfflineTitleTicketsInput::titleids(int index) const {
  return titleids_.Get(index);
}
inline ::std::string* GetOfflineTitleTicketsInput::mutable_titleids(int index) {
  return titleids_.Mutable(index);
}
inline void GetOfflineTitleTicketsInput::set_titleids(int index, const ::std::string& value) {
  titleids_.Mutable(index)->assign(value);
}
inline void GetOfflineTitleTicketsInput::set_titleids(int index, const char* value) {
  titleids_.Mutable(index)->assign(value);
}
inline void GetOfflineTitleTicketsInput::set_titleids(int index, const char* value, size_t size) {
  titleids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetOfflineTitleTicketsInput::add_titleids() {
  return titleids_.Add();
}
inline void GetOfflineTitleTicketsInput::add_titleids(const ::std::string& value) {
  titleids_.Add()->assign(value);
}
inline void GetOfflineTitleTicketsInput::add_titleids(const char* value) {
  titleids_.Add()->assign(value);
}
inline void GetOfflineTitleTicketsInput::add_titleids(const char* value, size_t size) {
  titleids_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetOfflineTitleTicketsInput::titleids() const {
  return titleids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetOfflineTitleTicketsInput::mutable_titleids() {
  return &titleids_;
}

// -------------------------------------------------------------------

// GetOfflineTitleTicketsOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool GetOfflineTitleTicketsOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetOfflineTitleTicketsOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetOfflineTitleTicketsOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetOfflineTitleTicketsOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& GetOfflineTitleTicketsOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* GetOfflineTitleTicketsOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* GetOfflineTitleTicketsOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// repeated .vplex.vsDirectory.TitleTicket titleTickets = 2;
inline int GetOfflineTitleTicketsOutput::titletickets_size() const {
  return titletickets_.size();
}
inline void GetOfflineTitleTicketsOutput::clear_titletickets() {
  titletickets_.Clear();
}
inline const ::vplex::vsDirectory::TitleTicket& GetOfflineTitleTicketsOutput::titletickets(int index) const {
  return titletickets_.Get(index);
}
inline ::vplex::vsDirectory::TitleTicket* GetOfflineTitleTicketsOutput::mutable_titletickets(int index) {
  return titletickets_.Mutable(index);
}
inline ::vplex::vsDirectory::TitleTicket* GetOfflineTitleTicketsOutput::add_titletickets() {
  return titletickets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::TitleTicket >&
GetOfflineTitleTicketsOutput::titletickets() const {
  return titletickets_;
}
inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::TitleTicket >*
GetOfflineTitleTicketsOutput::mutable_titletickets() {
  return &titletickets_;
}

// -------------------------------------------------------------------

// ListOwnedDataSetsInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool ListOwnedDataSetsInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ListOwnedDataSetsInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ListOwnedDataSetsInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ListOwnedDataSetsInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& ListOwnedDataSetsInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* ListOwnedDataSetsInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* ListOwnedDataSetsInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 userId = 2;
inline bool ListOwnedDataSetsInput::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ListOwnedDataSetsInput::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ListOwnedDataSetsInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ListOwnedDataSetsInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 ListOwnedDataSetsInput::userid() const {
  return userid_;
}
inline void ListOwnedDataSetsInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// optional fixed64 deviceId = 3;
inline bool ListOwnedDataSetsInput::has_deviceid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ListOwnedDataSetsInput::set_has_deviceid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ListOwnedDataSetsInput::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ListOwnedDataSetsInput::clear_deviceid() {
  deviceid_ = GOOGLE_ULONGLONG(0);
  clear_has_deviceid();
}
inline ::google::protobuf::uint64 ListOwnedDataSetsInput::deviceid() const {
  return deviceid_;
}
inline void ListOwnedDataSetsInput::set_deviceid(::google::protobuf::uint64 value) {
  set_has_deviceid();
  deviceid_ = value;
}

// optional string version = 4;
inline bool ListOwnedDataSetsInput::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ListOwnedDataSetsInput::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ListOwnedDataSetsInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ListOwnedDataSetsInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& ListOwnedDataSetsInput::version() const {
  return *version_;
}
inline void ListOwnedDataSetsInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void ListOwnedDataSetsInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void ListOwnedDataSetsInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListOwnedDataSetsInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* ListOwnedDataSetsInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ListOwnedDataSetsOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool ListOwnedDataSetsOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ListOwnedDataSetsOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ListOwnedDataSetsOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ListOwnedDataSetsOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& ListOwnedDataSetsOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* ListOwnedDataSetsOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* ListOwnedDataSetsOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// repeated .vplex.vsDirectory.DatasetDetail datasets = 2;
inline int ListOwnedDataSetsOutput::datasets_size() const {
  return datasets_.size();
}
inline void ListOwnedDataSetsOutput::clear_datasets() {
  datasets_.Clear();
}
inline const ::vplex::vsDirectory::DatasetDetail& ListOwnedDataSetsOutput::datasets(int index) const {
  return datasets_.Get(index);
}
inline ::vplex::vsDirectory::DatasetDetail* ListOwnedDataSetsOutput::mutable_datasets(int index) {
  return datasets_.Mutable(index);
}
inline ::vplex::vsDirectory::DatasetDetail* ListOwnedDataSetsOutput::add_datasets() {
  return datasets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::DatasetDetail >&
ListOwnedDataSetsOutput::datasets() const {
  return datasets_;
}
inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::DatasetDetail >*
ListOwnedDataSetsOutput::mutable_datasets() {
  return &datasets_;
}

// -------------------------------------------------------------------

// GetDatasetDetailsInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool GetDatasetDetailsInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetDatasetDetailsInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetDatasetDetailsInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetDatasetDetailsInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& GetDatasetDetailsInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* GetDatasetDetailsInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* GetDatasetDetailsInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 userId = 2;
inline bool GetDatasetDetailsInput::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetDatasetDetailsInput::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetDatasetDetailsInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetDatasetDetailsInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 GetDatasetDetailsInput::userid() const {
  return userid_;
}
inline void GetDatasetDetailsInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required fixed64 datasetId = 3;
inline bool GetDatasetDetailsInput::has_datasetid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetDatasetDetailsInput::set_has_datasetid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetDatasetDetailsInput::clear_has_datasetid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetDatasetDetailsInput::clear_datasetid() {
  datasetid_ = GOOGLE_ULONGLONG(0);
  clear_has_datasetid();
}
inline ::google::protobuf::uint64 GetDatasetDetailsInput::datasetid() const {
  return datasetid_;
}
inline void GetDatasetDetailsInput::set_datasetid(::google::protobuf::uint64 value) {
  set_has_datasetid();
  datasetid_ = value;
}

// optional string version = 4;
inline bool GetDatasetDetailsInput::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetDatasetDetailsInput::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetDatasetDetailsInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetDatasetDetailsInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& GetDatasetDetailsInput::version() const {
  return *version_;
}
inline void GetDatasetDetailsInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetDatasetDetailsInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetDatasetDetailsInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetDatasetDetailsInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* GetDatasetDetailsInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetDatasetDetailsOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool GetDatasetDetailsOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetDatasetDetailsOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetDatasetDetailsOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetDatasetDetailsOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& GetDatasetDetailsOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* GetDatasetDetailsOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* GetDatasetDetailsOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// optional .vplex.vsDirectory.DatasetDetail datasetDetail = 2;
inline bool GetDatasetDetailsOutput::has_datasetdetail() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetDatasetDetailsOutput::set_has_datasetdetail() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetDatasetDetailsOutput::clear_has_datasetdetail() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetDatasetDetailsOutput::clear_datasetdetail() {
  if (datasetdetail_ != NULL) datasetdetail_->::vplex::vsDirectory::DatasetDetail::Clear();
  clear_has_datasetdetail();
}
inline const ::vplex::vsDirectory::DatasetDetail& GetDatasetDetailsOutput::datasetdetail() const {
  return datasetdetail_ != NULL ? *datasetdetail_ : *default_instance_->datasetdetail_;
}
inline ::vplex::vsDirectory::DatasetDetail* GetDatasetDetailsOutput::mutable_datasetdetail() {
  set_has_datasetdetail();
  if (datasetdetail_ == NULL) datasetdetail_ = new ::vplex::vsDirectory::DatasetDetail;
  return datasetdetail_;
}
inline ::vplex::vsDirectory::DatasetDetail* GetDatasetDetailsOutput::release_datasetdetail() {
  clear_has_datasetdetail();
  ::vplex::vsDirectory::DatasetDetail* temp = datasetdetail_;
  datasetdetail_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// AddDataSetInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool AddDataSetInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddDataSetInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddDataSetInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddDataSetInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& AddDataSetInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* AddDataSetInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* AddDataSetInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 userId = 2;
inline bool AddDataSetInput::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddDataSetInput::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddDataSetInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddDataSetInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 AddDataSetInput::userid() const {
  return userid_;
}
inline void AddDataSetInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required string datasetName = 3;
inline bool AddDataSetInput::has_datasetname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AddDataSetInput::set_has_datasetname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AddDataSetInput::clear_has_datasetname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AddDataSetInput::clear_datasetname() {
  if (datasetname_ != &::google::protobuf::internal::kEmptyString) {
    datasetname_->clear();
  }
  clear_has_datasetname();
}
inline const ::std::string& AddDataSetInput::datasetname() const {
  return *datasetname_;
}
inline void AddDataSetInput::set_datasetname(const ::std::string& value) {
  set_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    datasetname_ = new ::std::string;
  }
  datasetname_->assign(value);
}
inline void AddDataSetInput::set_datasetname(const char* value) {
  set_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    datasetname_ = new ::std::string;
  }
  datasetname_->assign(value);
}
inline void AddDataSetInput::set_datasetname(const char* value, size_t size) {
  set_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    datasetname_ = new ::std::string;
  }
  datasetname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddDataSetInput::mutable_datasetname() {
  set_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    datasetname_ = new ::std::string;
  }
  return datasetname_;
}
inline ::std::string* AddDataSetInput::release_datasetname() {
  clear_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = datasetname_;
    datasetname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .vplex.vsDirectory.DatasetType datasetTypeId = 4;
inline bool AddDataSetInput::has_datasettypeid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AddDataSetInput::set_has_datasettypeid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AddDataSetInput::clear_has_datasettypeid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AddDataSetInput::clear_datasettypeid() {
  datasettypeid_ = 1;
  clear_has_datasettypeid();
}
inline vplex::vsDirectory::DatasetType AddDataSetInput::datasettypeid() const {
  return static_cast< vplex::vsDirectory::DatasetType >(datasettypeid_);
}
inline void AddDataSetInput::set_datasettypeid(vplex::vsDirectory::DatasetType value) {
  GOOGLE_DCHECK(vplex::vsDirectory::DatasetType_IsValid(value));
  set_has_datasettypeid();
  datasettypeid_ = value;
}

// optional fixed64 storageClusterId = 5;
inline bool AddDataSetInput::has_storageclusterid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AddDataSetInput::set_has_storageclusterid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AddDataSetInput::clear_has_storageclusterid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AddDataSetInput::clear_storageclusterid() {
  storageclusterid_ = GOOGLE_ULONGLONG(0);
  clear_has_storageclusterid();
}
inline ::google::protobuf::uint64 AddDataSetInput::storageclusterid() const {
  return storageclusterid_;
}
inline void AddDataSetInput::set_storageclusterid(::google::protobuf::uint64 value) {
  set_has_storageclusterid();
  storageclusterid_ = value;
}

// optional string version = 6;
inline bool AddDataSetInput::has_version() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AddDataSetInput::set_has_version() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AddDataSetInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AddDataSetInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& AddDataSetInput::version() const {
  return *version_;
}
inline void AddDataSetInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void AddDataSetInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void AddDataSetInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddDataSetInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* AddDataSetInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AddDataSetOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool AddDataSetOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddDataSetOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddDataSetOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddDataSetOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& AddDataSetOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* AddDataSetOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* AddDataSetOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// optional fixed64 datasetId = 2;
inline bool AddDataSetOutput::has_datasetid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddDataSetOutput::set_has_datasetid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddDataSetOutput::clear_has_datasetid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddDataSetOutput::clear_datasetid() {
  datasetid_ = GOOGLE_ULONGLONG(0);
  clear_has_datasetid();
}
inline ::google::protobuf::uint64 AddDataSetOutput::datasetid() const {
  return datasetid_;
}
inline void AddDataSetOutput::set_datasetid(::google::protobuf::uint64 value) {
  set_has_datasetid();
  datasetid_ = value;
}

// -------------------------------------------------------------------

// AddCameraDatasetInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool AddCameraDatasetInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddCameraDatasetInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddCameraDatasetInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddCameraDatasetInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& AddCameraDatasetInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* AddCameraDatasetInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* AddCameraDatasetInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 userId = 2;
inline bool AddCameraDatasetInput::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddCameraDatasetInput::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddCameraDatasetInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddCameraDatasetInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 AddCameraDatasetInput::userid() const {
  return userid_;
}
inline void AddCameraDatasetInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required string datasetName = 3;
inline bool AddCameraDatasetInput::has_datasetname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AddCameraDatasetInput::set_has_datasetname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AddCameraDatasetInput::clear_has_datasetname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AddCameraDatasetInput::clear_datasetname() {
  if (datasetname_ != &::google::protobuf::internal::kEmptyString) {
    datasetname_->clear();
  }
  clear_has_datasetname();
}
inline const ::std::string& AddCameraDatasetInput::datasetname() const {
  return *datasetname_;
}
inline void AddCameraDatasetInput::set_datasetname(const ::std::string& value) {
  set_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    datasetname_ = new ::std::string;
  }
  datasetname_->assign(value);
}
inline void AddCameraDatasetInput::set_datasetname(const char* value) {
  set_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    datasetname_ = new ::std::string;
  }
  datasetname_->assign(value);
}
inline void AddCameraDatasetInput::set_datasetname(const char* value, size_t size) {
  set_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    datasetname_ = new ::std::string;
  }
  datasetname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddCameraDatasetInput::mutable_datasetname() {
  set_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    datasetname_ = new ::std::string;
  }
  return datasetname_;
}
inline ::std::string* AddCameraDatasetInput::release_datasetname() {
  clear_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = datasetname_;
    datasetname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string createdFor = 4;
inline bool AddCameraDatasetInput::has_createdfor() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AddCameraDatasetInput::set_has_createdfor() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AddCameraDatasetInput::clear_has_createdfor() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AddCameraDatasetInput::clear_createdfor() {
  if (createdfor_ != &::google::protobuf::internal::kEmptyString) {
    createdfor_->clear();
  }
  clear_has_createdfor();
}
inline const ::std::string& AddCameraDatasetInput::createdfor() const {
  return *createdfor_;
}
inline void AddCameraDatasetInput::set_createdfor(const ::std::string& value) {
  set_has_createdfor();
  if (createdfor_ == &::google::protobuf::internal::kEmptyString) {
    createdfor_ = new ::std::string;
  }
  createdfor_->assign(value);
}
inline void AddCameraDatasetInput::set_createdfor(const char* value) {
  set_has_createdfor();
  if (createdfor_ == &::google::protobuf::internal::kEmptyString) {
    createdfor_ = new ::std::string;
  }
  createdfor_->assign(value);
}
inline void AddCameraDatasetInput::set_createdfor(const char* value, size_t size) {
  set_has_createdfor();
  if (createdfor_ == &::google::protobuf::internal::kEmptyString) {
    createdfor_ = new ::std::string;
  }
  createdfor_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddCameraDatasetInput::mutable_createdfor() {
  set_has_createdfor();
  if (createdfor_ == &::google::protobuf::internal::kEmptyString) {
    createdfor_ = new ::std::string;
  }
  return createdfor_;
}
inline ::std::string* AddCameraDatasetInput::release_createdfor() {
  clear_has_createdfor();
  if (createdfor_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = createdfor_;
    createdfor_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string version = 5;
inline bool AddCameraDatasetInput::has_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AddCameraDatasetInput::set_has_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AddCameraDatasetInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AddCameraDatasetInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& AddCameraDatasetInput::version() const {
  return *version_;
}
inline void AddCameraDatasetInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void AddCameraDatasetInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void AddCameraDatasetInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddCameraDatasetInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* AddCameraDatasetInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AddCameraDatasetOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool AddCameraDatasetOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddCameraDatasetOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddCameraDatasetOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddCameraDatasetOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& AddCameraDatasetOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* AddCameraDatasetOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* AddCameraDatasetOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// optional fixed64 datasetId = 2;
inline bool AddCameraDatasetOutput::has_datasetid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddCameraDatasetOutput::set_has_datasetid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddCameraDatasetOutput::clear_has_datasetid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddCameraDatasetOutput::clear_datasetid() {
  datasetid_ = GOOGLE_ULONGLONG(0);
  clear_has_datasetid();
}
inline ::google::protobuf::uint64 AddCameraDatasetOutput::datasetid() const {
  return datasetid_;
}
inline void AddCameraDatasetOutput::set_datasetid(::google::protobuf::uint64 value) {
  set_has_datasetid();
  datasetid_ = value;
}

// -------------------------------------------------------------------

// DeleteDataSetInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool DeleteDataSetInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteDataSetInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteDataSetInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteDataSetInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& DeleteDataSetInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* DeleteDataSetInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* DeleteDataSetInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 userId = 2;
inline bool DeleteDataSetInput::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeleteDataSetInput::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeleteDataSetInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeleteDataSetInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 DeleteDataSetInput::userid() const {
  return userid_;
}
inline void DeleteDataSetInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// optional fixed64 datasetId = 3;
inline bool DeleteDataSetInput::has_datasetid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeleteDataSetInput::set_has_datasetid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeleteDataSetInput::clear_has_datasetid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeleteDataSetInput::clear_datasetid() {
  datasetid_ = GOOGLE_ULONGLONG(0);
  clear_has_datasetid();
}
inline ::google::protobuf::uint64 DeleteDataSetInput::datasetid() const {
  return datasetid_;
}
inline void DeleteDataSetInput::set_datasetid(::google::protobuf::uint64 value) {
  set_has_datasetid();
  datasetid_ = value;
}

// optional string datasetName = 4;
inline bool DeleteDataSetInput::has_datasetname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeleteDataSetInput::set_has_datasetname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DeleteDataSetInput::clear_has_datasetname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DeleteDataSetInput::clear_datasetname() {
  if (datasetname_ != &::google::protobuf::internal::kEmptyString) {
    datasetname_->clear();
  }
  clear_has_datasetname();
}
inline const ::std::string& DeleteDataSetInput::datasetname() const {
  return *datasetname_;
}
inline void DeleteDataSetInput::set_datasetname(const ::std::string& value) {
  set_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    datasetname_ = new ::std::string;
  }
  datasetname_->assign(value);
}
inline void DeleteDataSetInput::set_datasetname(const char* value) {
  set_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    datasetname_ = new ::std::string;
  }
  datasetname_->assign(value);
}
inline void DeleteDataSetInput::set_datasetname(const char* value, size_t size) {
  set_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    datasetname_ = new ::std::string;
  }
  datasetname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeleteDataSetInput::mutable_datasetname() {
  set_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    datasetname_ = new ::std::string;
  }
  return datasetname_;
}
inline ::std::string* DeleteDataSetInput::release_datasetname() {
  clear_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = datasetname_;
    datasetname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string version = 5;
inline bool DeleteDataSetInput::has_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DeleteDataSetInput::set_has_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DeleteDataSetInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DeleteDataSetInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& DeleteDataSetInput::version() const {
  return *version_;
}
inline void DeleteDataSetInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void DeleteDataSetInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void DeleteDataSetInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeleteDataSetInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* DeleteDataSetInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// DeleteDataSetOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool DeleteDataSetOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteDataSetOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteDataSetOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteDataSetOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& DeleteDataSetOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* DeleteDataSetOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* DeleteDataSetOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// RenameDataSetInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool RenameDataSetInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RenameDataSetInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RenameDataSetInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RenameDataSetInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& RenameDataSetInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* RenameDataSetInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* RenameDataSetInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 userId = 2;
inline bool RenameDataSetInput::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RenameDataSetInput::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RenameDataSetInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RenameDataSetInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 RenameDataSetInput::userid() const {
  return userid_;
}
inline void RenameDataSetInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// optional fixed64 datasetId = 3;
inline bool RenameDataSetInput::has_datasetid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RenameDataSetInput::set_has_datasetid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RenameDataSetInput::clear_has_datasetid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RenameDataSetInput::clear_datasetid() {
  datasetid_ = GOOGLE_ULONGLONG(0);
  clear_has_datasetid();
}
inline ::google::protobuf::uint64 RenameDataSetInput::datasetid() const {
  return datasetid_;
}
inline void RenameDataSetInput::set_datasetid(::google::protobuf::uint64 value) {
  set_has_datasetid();
  datasetid_ = value;
}

// optional string datasetName = 4;
inline bool RenameDataSetInput::has_datasetname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RenameDataSetInput::set_has_datasetname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RenameDataSetInput::clear_has_datasetname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RenameDataSetInput::clear_datasetname() {
  if (datasetname_ != &::google::protobuf::internal::kEmptyString) {
    datasetname_->clear();
  }
  clear_has_datasetname();
}
inline const ::std::string& RenameDataSetInput::datasetname() const {
  return *datasetname_;
}
inline void RenameDataSetInput::set_datasetname(const ::std::string& value) {
  set_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    datasetname_ = new ::std::string;
  }
  datasetname_->assign(value);
}
inline void RenameDataSetInput::set_datasetname(const char* value) {
  set_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    datasetname_ = new ::std::string;
  }
  datasetname_->assign(value);
}
inline void RenameDataSetInput::set_datasetname(const char* value, size_t size) {
  set_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    datasetname_ = new ::std::string;
  }
  datasetname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RenameDataSetInput::mutable_datasetname() {
  set_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    datasetname_ = new ::std::string;
  }
  return datasetname_;
}
inline ::std::string* RenameDataSetInput::release_datasetname() {
  clear_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = datasetname_;
    datasetname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string datasetNameNew = 5;
inline bool RenameDataSetInput::has_datasetnamenew() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RenameDataSetInput::set_has_datasetnamenew() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RenameDataSetInput::clear_has_datasetnamenew() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RenameDataSetInput::clear_datasetnamenew() {
  if (datasetnamenew_ != &::google::protobuf::internal::kEmptyString) {
    datasetnamenew_->clear();
  }
  clear_has_datasetnamenew();
}
inline const ::std::string& RenameDataSetInput::datasetnamenew() const {
  return *datasetnamenew_;
}
inline void RenameDataSetInput::set_datasetnamenew(const ::std::string& value) {
  set_has_datasetnamenew();
  if (datasetnamenew_ == &::google::protobuf::internal::kEmptyString) {
    datasetnamenew_ = new ::std::string;
  }
  datasetnamenew_->assign(value);
}
inline void RenameDataSetInput::set_datasetnamenew(const char* value) {
  set_has_datasetnamenew();
  if (datasetnamenew_ == &::google::protobuf::internal::kEmptyString) {
    datasetnamenew_ = new ::std::string;
  }
  datasetnamenew_->assign(value);
}
inline void RenameDataSetInput::set_datasetnamenew(const char* value, size_t size) {
  set_has_datasetnamenew();
  if (datasetnamenew_ == &::google::protobuf::internal::kEmptyString) {
    datasetnamenew_ = new ::std::string;
  }
  datasetnamenew_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RenameDataSetInput::mutable_datasetnamenew() {
  set_has_datasetnamenew();
  if (datasetnamenew_ == &::google::protobuf::internal::kEmptyString) {
    datasetnamenew_ = new ::std::string;
  }
  return datasetnamenew_;
}
inline ::std::string* RenameDataSetInput::release_datasetnamenew() {
  clear_has_datasetnamenew();
  if (datasetnamenew_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = datasetnamenew_;
    datasetnamenew_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string version = 6;
inline bool RenameDataSetInput::has_version() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RenameDataSetInput::set_has_version() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RenameDataSetInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RenameDataSetInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& RenameDataSetInput::version() const {
  return *version_;
}
inline void RenameDataSetInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void RenameDataSetInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void RenameDataSetInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RenameDataSetInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* RenameDataSetInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RenameDataSetOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool RenameDataSetOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RenameDataSetOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RenameDataSetOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RenameDataSetOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& RenameDataSetOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* RenameDataSetOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* RenameDataSetOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// SetDataSetCacheInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool SetDataSetCacheInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetDataSetCacheInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetDataSetCacheInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetDataSetCacheInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& SetDataSetCacheInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* SetDataSetCacheInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* SetDataSetCacheInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 userId = 2;
inline bool SetDataSetCacheInput::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetDataSetCacheInput::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetDataSetCacheInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetDataSetCacheInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 SetDataSetCacheInput::userid() const {
  return userid_;
}
inline void SetDataSetCacheInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required fixed64 datasetId = 3;
inline bool SetDataSetCacheInput::has_datasetid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SetDataSetCacheInput::set_has_datasetid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SetDataSetCacheInput::clear_has_datasetid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SetDataSetCacheInput::clear_datasetid() {
  datasetid_ = GOOGLE_ULONGLONG(0);
  clear_has_datasetid();
}
inline ::google::protobuf::uint64 SetDataSetCacheInput::datasetid() const {
  return datasetid_;
}
inline void SetDataSetCacheInput::set_datasetid(::google::protobuf::uint64 value) {
  set_has_datasetid();
  datasetid_ = value;
}

// optional fixed64 cacheDatasetId = 4;
inline bool SetDataSetCacheInput::has_cachedatasetid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SetDataSetCacheInput::set_has_cachedatasetid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SetDataSetCacheInput::clear_has_cachedatasetid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SetDataSetCacheInput::clear_cachedatasetid() {
  cachedatasetid_ = GOOGLE_ULONGLONG(0);
  clear_has_cachedatasetid();
}
inline ::google::protobuf::uint64 SetDataSetCacheInput::cachedatasetid() const {
  return cachedatasetid_;
}
inline void SetDataSetCacheInput::set_cachedatasetid(::google::protobuf::uint64 value) {
  set_has_cachedatasetid();
  cachedatasetid_ = value;
}

// optional string version = 5;
inline bool SetDataSetCacheInput::has_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SetDataSetCacheInput::set_has_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SetDataSetCacheInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SetDataSetCacheInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& SetDataSetCacheInput::version() const {
  return *version_;
}
inline void SetDataSetCacheInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void SetDataSetCacheInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void SetDataSetCacheInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SetDataSetCacheInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* SetDataSetCacheInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// SetDataSetCacheOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool SetDataSetCacheOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetDataSetCacheOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetDataSetCacheOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetDataSetCacheOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& SetDataSetCacheOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* SetDataSetCacheOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* SetDataSetCacheOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// RemoveDeviceFromSubscriptionsInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool RemoveDeviceFromSubscriptionsInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoveDeviceFromSubscriptionsInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoveDeviceFromSubscriptionsInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoveDeviceFromSubscriptionsInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& RemoveDeviceFromSubscriptionsInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* RemoveDeviceFromSubscriptionsInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* RemoveDeviceFromSubscriptionsInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 userId = 2;
inline bool RemoveDeviceFromSubscriptionsInput::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RemoveDeviceFromSubscriptionsInput::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RemoveDeviceFromSubscriptionsInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RemoveDeviceFromSubscriptionsInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 RemoveDeviceFromSubscriptionsInput::userid() const {
  return userid_;
}
inline void RemoveDeviceFromSubscriptionsInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required fixed64 deviceId = 3;
inline bool RemoveDeviceFromSubscriptionsInput::has_deviceid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RemoveDeviceFromSubscriptionsInput::set_has_deviceid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RemoveDeviceFromSubscriptionsInput::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RemoveDeviceFromSubscriptionsInput::clear_deviceid() {
  deviceid_ = GOOGLE_ULONGLONG(0);
  clear_has_deviceid();
}
inline ::google::protobuf::uint64 RemoveDeviceFromSubscriptionsInput::deviceid() const {
  return deviceid_;
}
inline void RemoveDeviceFromSubscriptionsInput::set_deviceid(::google::protobuf::uint64 value) {
  set_has_deviceid();
  deviceid_ = value;
}

// optional string version = 4;
inline bool RemoveDeviceFromSubscriptionsInput::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RemoveDeviceFromSubscriptionsInput::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RemoveDeviceFromSubscriptionsInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RemoveDeviceFromSubscriptionsInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& RemoveDeviceFromSubscriptionsInput::version() const {
  return *version_;
}
inline void RemoveDeviceFromSubscriptionsInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void RemoveDeviceFromSubscriptionsInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void RemoveDeviceFromSubscriptionsInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoveDeviceFromSubscriptionsInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* RemoveDeviceFromSubscriptionsInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RemoveDeviceFromSubscriptionsOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool RemoveDeviceFromSubscriptionsOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoveDeviceFromSubscriptionsOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoveDeviceFromSubscriptionsOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoveDeviceFromSubscriptionsOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& RemoveDeviceFromSubscriptionsOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* RemoveDeviceFromSubscriptionsOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* RemoveDeviceFromSubscriptionsOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ListSubscriptionsInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool ListSubscriptionsInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ListSubscriptionsInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ListSubscriptionsInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ListSubscriptionsInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& ListSubscriptionsInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* ListSubscriptionsInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* ListSubscriptionsInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 userId = 2;
inline bool ListSubscriptionsInput::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ListSubscriptionsInput::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ListSubscriptionsInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ListSubscriptionsInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 ListSubscriptionsInput::userid() const {
  return userid_;
}
inline void ListSubscriptionsInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required fixed64 deviceId = 3;
inline bool ListSubscriptionsInput::has_deviceid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ListSubscriptionsInput::set_has_deviceid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ListSubscriptionsInput::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ListSubscriptionsInput::clear_deviceid() {
  deviceid_ = GOOGLE_ULONGLONG(0);
  clear_has_deviceid();
}
inline ::google::protobuf::uint64 ListSubscriptionsInput::deviceid() const {
  return deviceid_;
}
inline void ListSubscriptionsInput::set_deviceid(::google::protobuf::uint64 value) {
  set_has_deviceid();
  deviceid_ = value;
}

// optional string version = 4;
inline bool ListSubscriptionsInput::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ListSubscriptionsInput::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ListSubscriptionsInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ListSubscriptionsInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& ListSubscriptionsInput::version() const {
  return *version_;
}
inline void ListSubscriptionsInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void ListSubscriptionsInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void ListSubscriptionsInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListSubscriptionsInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* ListSubscriptionsInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ListSubscriptionsOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool ListSubscriptionsOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ListSubscriptionsOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ListSubscriptionsOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ListSubscriptionsOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& ListSubscriptionsOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* ListSubscriptionsOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* ListSubscriptionsOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// repeated .vplex.vsDirectory.Subscription subscriptions = 2;
inline int ListSubscriptionsOutput::subscriptions_size() const {
  return subscriptions_.size();
}
inline void ListSubscriptionsOutput::clear_subscriptions() {
  subscriptions_.Clear();
}
inline const ::vplex::vsDirectory::Subscription& ListSubscriptionsOutput::subscriptions(int index) const {
  return subscriptions_.Get(index);
}
inline ::vplex::vsDirectory::Subscription* ListSubscriptionsOutput::mutable_subscriptions(int index) {
  return subscriptions_.Mutable(index);
}
inline ::vplex::vsDirectory::Subscription* ListSubscriptionsOutput::add_subscriptions() {
  return subscriptions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::Subscription >&
ListSubscriptionsOutput::subscriptions() const {
  return subscriptions_;
}
inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::Subscription >*
ListSubscriptionsOutput::mutable_subscriptions() {
  return &subscriptions_;
}

// -------------------------------------------------------------------

// AddSubscriptionsInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool AddSubscriptionsInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddSubscriptionsInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddSubscriptionsInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddSubscriptionsInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& AddSubscriptionsInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* AddSubscriptionsInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* AddSubscriptionsInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 userId = 2;
inline bool AddSubscriptionsInput::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddSubscriptionsInput::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddSubscriptionsInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddSubscriptionsInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 AddSubscriptionsInput::userid() const {
  return userid_;
}
inline void AddSubscriptionsInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required fixed64 deviceId = 3;
inline bool AddSubscriptionsInput::has_deviceid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AddSubscriptionsInput::set_has_deviceid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AddSubscriptionsInput::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AddSubscriptionsInput::clear_deviceid() {
  deviceid_ = GOOGLE_ULONGLONG(0);
  clear_has_deviceid();
}
inline ::google::protobuf::uint64 AddSubscriptionsInput::deviceid() const {
  return deviceid_;
}
inline void AddSubscriptionsInput::set_deviceid(::google::protobuf::uint64 value) {
  set_has_deviceid();
  deviceid_ = value;
}

// repeated .vplex.vsDirectory.Subscription subscriptions = 4;
inline int AddSubscriptionsInput::subscriptions_size() const {
  return subscriptions_.size();
}
inline void AddSubscriptionsInput::clear_subscriptions() {
  subscriptions_.Clear();
}
inline const ::vplex::vsDirectory::Subscription& AddSubscriptionsInput::subscriptions(int index) const {
  return subscriptions_.Get(index);
}
inline ::vplex::vsDirectory::Subscription* AddSubscriptionsInput::mutable_subscriptions(int index) {
  return subscriptions_.Mutable(index);
}
inline ::vplex::vsDirectory::Subscription* AddSubscriptionsInput::add_subscriptions() {
  return subscriptions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::Subscription >&
AddSubscriptionsInput::subscriptions() const {
  return subscriptions_;
}
inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::Subscription >*
AddSubscriptionsInput::mutable_subscriptions() {
  return &subscriptions_;
}

// optional string version = 5;
inline bool AddSubscriptionsInput::has_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AddSubscriptionsInput::set_has_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AddSubscriptionsInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AddSubscriptionsInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& AddSubscriptionsInput::version() const {
  return *version_;
}
inline void AddSubscriptionsInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void AddSubscriptionsInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void AddSubscriptionsInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddSubscriptionsInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* AddSubscriptionsInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AddSubscriptionsOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool AddSubscriptionsOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddSubscriptionsOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddSubscriptionsOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddSubscriptionsOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& AddSubscriptionsOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* AddSubscriptionsOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* AddSubscriptionsOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// AddUserDatasetSubscriptionInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool AddUserDatasetSubscriptionInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddUserDatasetSubscriptionInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddUserDatasetSubscriptionInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddUserDatasetSubscriptionInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& AddUserDatasetSubscriptionInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* AddUserDatasetSubscriptionInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* AddUserDatasetSubscriptionInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 userId = 2;
inline bool AddUserDatasetSubscriptionInput::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddUserDatasetSubscriptionInput::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddUserDatasetSubscriptionInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddUserDatasetSubscriptionInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 AddUserDatasetSubscriptionInput::userid() const {
  return userid_;
}
inline void AddUserDatasetSubscriptionInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required fixed64 deviceId = 3;
inline bool AddUserDatasetSubscriptionInput::has_deviceid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AddUserDatasetSubscriptionInput::set_has_deviceid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AddUserDatasetSubscriptionInput::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AddUserDatasetSubscriptionInput::clear_deviceid() {
  deviceid_ = GOOGLE_ULONGLONG(0);
  clear_has_deviceid();
}
inline ::google::protobuf::uint64 AddUserDatasetSubscriptionInput::deviceid() const {
  return deviceid_;
}
inline void AddUserDatasetSubscriptionInput::set_deviceid(::google::protobuf::uint64 value) {
  set_has_deviceid();
  deviceid_ = value;
}

// required fixed64 datasetId = 4;
inline bool AddUserDatasetSubscriptionInput::has_datasetid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AddUserDatasetSubscriptionInput::set_has_datasetid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AddUserDatasetSubscriptionInput::clear_has_datasetid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AddUserDatasetSubscriptionInput::clear_datasetid() {
  datasetid_ = GOOGLE_ULONGLONG(0);
  clear_has_datasetid();
}
inline ::google::protobuf::uint64 AddUserDatasetSubscriptionInput::datasetid() const {
  return datasetid_;
}
inline void AddUserDatasetSubscriptionInput::set_datasetid(::google::protobuf::uint64 value) {
  set_has_datasetid();
  datasetid_ = value;
}

// optional string deviceRoot = 5;
inline bool AddUserDatasetSubscriptionInput::has_deviceroot() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AddUserDatasetSubscriptionInput::set_has_deviceroot() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AddUserDatasetSubscriptionInput::clear_has_deviceroot() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AddUserDatasetSubscriptionInput::clear_deviceroot() {
  if (deviceroot_ != &::google::protobuf::internal::kEmptyString) {
    deviceroot_->clear();
  }
  clear_has_deviceroot();
}
inline const ::std::string& AddUserDatasetSubscriptionInput::deviceroot() const {
  return *deviceroot_;
}
inline void AddUserDatasetSubscriptionInput::set_deviceroot(const ::std::string& value) {
  set_has_deviceroot();
  if (deviceroot_ == &::google::protobuf::internal::kEmptyString) {
    deviceroot_ = new ::std::string;
  }
  deviceroot_->assign(value);
}
inline void AddUserDatasetSubscriptionInput::set_deviceroot(const char* value) {
  set_has_deviceroot();
  if (deviceroot_ == &::google::protobuf::internal::kEmptyString) {
    deviceroot_ = new ::std::string;
  }
  deviceroot_->assign(value);
}
inline void AddUserDatasetSubscriptionInput::set_deviceroot(const char* value, size_t size) {
  set_has_deviceroot();
  if (deviceroot_ == &::google::protobuf::internal::kEmptyString) {
    deviceroot_ = new ::std::string;
  }
  deviceroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddUserDatasetSubscriptionInput::mutable_deviceroot() {
  set_has_deviceroot();
  if (deviceroot_ == &::google::protobuf::internal::kEmptyString) {
    deviceroot_ = new ::std::string;
  }
  return deviceroot_;
}
inline ::std::string* AddUserDatasetSubscriptionInput::release_deviceroot() {
  clear_has_deviceroot();
  if (deviceroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deviceroot_;
    deviceroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string filter = 6;
inline bool AddUserDatasetSubscriptionInput::has_filter() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AddUserDatasetSubscriptionInput::set_has_filter() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AddUserDatasetSubscriptionInput::clear_has_filter() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AddUserDatasetSubscriptionInput::clear_filter() {
  if (filter_ != &::google::protobuf::internal::kEmptyString) {
    filter_->clear();
  }
  clear_has_filter();
}
inline const ::std::string& AddUserDatasetSubscriptionInput::filter() const {
  return *filter_;
}
inline void AddUserDatasetSubscriptionInput::set_filter(const ::std::string& value) {
  set_has_filter();
  if (filter_ == &::google::protobuf::internal::kEmptyString) {
    filter_ = new ::std::string;
  }
  filter_->assign(value);
}
inline void AddUserDatasetSubscriptionInput::set_filter(const char* value) {
  set_has_filter();
  if (filter_ == &::google::protobuf::internal::kEmptyString) {
    filter_ = new ::std::string;
  }
  filter_->assign(value);
}
inline void AddUserDatasetSubscriptionInput::set_filter(const char* value, size_t size) {
  set_has_filter();
  if (filter_ == &::google::protobuf::internal::kEmptyString) {
    filter_ = new ::std::string;
  }
  filter_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddUserDatasetSubscriptionInput::mutable_filter() {
  set_has_filter();
  if (filter_ == &::google::protobuf::internal::kEmptyString) {
    filter_ = new ::std::string;
  }
  return filter_;
}
inline ::std::string* AddUserDatasetSubscriptionInput::release_filter() {
  clear_has_filter();
  if (filter_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filter_;
    filter_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string version = 7;
inline bool AddUserDatasetSubscriptionInput::has_version() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AddUserDatasetSubscriptionInput::set_has_version() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AddUserDatasetSubscriptionInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AddUserDatasetSubscriptionInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& AddUserDatasetSubscriptionInput::version() const {
  return *version_;
}
inline void AddUserDatasetSubscriptionInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void AddUserDatasetSubscriptionInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void AddUserDatasetSubscriptionInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddUserDatasetSubscriptionInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* AddUserDatasetSubscriptionInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AddUserDatasetSubscriptionOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool AddUserDatasetSubscriptionOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddUserDatasetSubscriptionOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddUserDatasetSubscriptionOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddUserDatasetSubscriptionOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& AddUserDatasetSubscriptionOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* AddUserDatasetSubscriptionOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* AddUserDatasetSubscriptionOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// AddCameraSubscriptionInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool AddCameraSubscriptionInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddCameraSubscriptionInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddCameraSubscriptionInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddCameraSubscriptionInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& AddCameraSubscriptionInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* AddCameraSubscriptionInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* AddCameraSubscriptionInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 userId = 2;
inline bool AddCameraSubscriptionInput::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddCameraSubscriptionInput::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddCameraSubscriptionInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddCameraSubscriptionInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 AddCameraSubscriptionInput::userid() const {
  return userid_;
}
inline void AddCameraSubscriptionInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required fixed64 deviceId = 3;
inline bool AddCameraSubscriptionInput::has_deviceid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AddCameraSubscriptionInput::set_has_deviceid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AddCameraSubscriptionInput::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AddCameraSubscriptionInput::clear_deviceid() {
  deviceid_ = GOOGLE_ULONGLONG(0);
  clear_has_deviceid();
}
inline ::google::protobuf::uint64 AddCameraSubscriptionInput::deviceid() const {
  return deviceid_;
}
inline void AddCameraSubscriptionInput::set_deviceid(::google::protobuf::uint64 value) {
  set_has_deviceid();
  deviceid_ = value;
}

// required fixed64 datasetId = 4;
inline bool AddCameraSubscriptionInput::has_datasetid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AddCameraSubscriptionInput::set_has_datasetid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AddCameraSubscriptionInput::clear_has_datasetid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AddCameraSubscriptionInput::clear_datasetid() {
  datasetid_ = GOOGLE_ULONGLONG(0);
  clear_has_datasetid();
}
inline ::google::protobuf::uint64 AddCameraSubscriptionInput::datasetid() const {
  return datasetid_;
}
inline void AddCameraSubscriptionInput::set_datasetid(::google::protobuf::uint64 value) {
  set_has_datasetid();
  datasetid_ = value;
}

// optional string deviceRoot = 5;
inline bool AddCameraSubscriptionInput::has_deviceroot() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AddCameraSubscriptionInput::set_has_deviceroot() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AddCameraSubscriptionInput::clear_has_deviceroot() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AddCameraSubscriptionInput::clear_deviceroot() {
  if (deviceroot_ != &::google::protobuf::internal::kEmptyString) {
    deviceroot_->clear();
  }
  clear_has_deviceroot();
}
inline const ::std::string& AddCameraSubscriptionInput::deviceroot() const {
  return *deviceroot_;
}
inline void AddCameraSubscriptionInput::set_deviceroot(const ::std::string& value) {
  set_has_deviceroot();
  if (deviceroot_ == &::google::protobuf::internal::kEmptyString) {
    deviceroot_ = new ::std::string;
  }
  deviceroot_->assign(value);
}
inline void AddCameraSubscriptionInput::set_deviceroot(const char* value) {
  set_has_deviceroot();
  if (deviceroot_ == &::google::protobuf::internal::kEmptyString) {
    deviceroot_ = new ::std::string;
  }
  deviceroot_->assign(value);
}
inline void AddCameraSubscriptionInput::set_deviceroot(const char* value, size_t size) {
  set_has_deviceroot();
  if (deviceroot_ == &::google::protobuf::internal::kEmptyString) {
    deviceroot_ = new ::std::string;
  }
  deviceroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddCameraSubscriptionInput::mutable_deviceroot() {
  set_has_deviceroot();
  if (deviceroot_ == &::google::protobuf::internal::kEmptyString) {
    deviceroot_ = new ::std::string;
  }
  return deviceroot_;
}
inline ::std::string* AddCameraSubscriptionInput::release_deviceroot() {
  clear_has_deviceroot();
  if (deviceroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deviceroot_;
    deviceroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string filter = 6;
inline bool AddCameraSubscriptionInput::has_filter() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AddCameraSubscriptionInput::set_has_filter() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AddCameraSubscriptionInput::clear_has_filter() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AddCameraSubscriptionInput::clear_filter() {
  if (filter_ != &::google::protobuf::internal::kEmptyString) {
    filter_->clear();
  }
  clear_has_filter();
}
inline const ::std::string& AddCameraSubscriptionInput::filter() const {
  return *filter_;
}
inline void AddCameraSubscriptionInput::set_filter(const ::std::string& value) {
  set_has_filter();
  if (filter_ == &::google::protobuf::internal::kEmptyString) {
    filter_ = new ::std::string;
  }
  filter_->assign(value);
}
inline void AddCameraSubscriptionInput::set_filter(const char* value) {
  set_has_filter();
  if (filter_ == &::google::protobuf::internal::kEmptyString) {
    filter_ = new ::std::string;
  }
  filter_->assign(value);
}
inline void AddCameraSubscriptionInput::set_filter(const char* value, size_t size) {
  set_has_filter();
  if (filter_ == &::google::protobuf::internal::kEmptyString) {
    filter_ = new ::std::string;
  }
  filter_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddCameraSubscriptionInput::mutable_filter() {
  set_has_filter();
  if (filter_ == &::google::protobuf::internal::kEmptyString) {
    filter_ = new ::std::string;
  }
  return filter_;
}
inline ::std::string* AddCameraSubscriptionInput::release_filter() {
  clear_has_filter();
  if (filter_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filter_;
    filter_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string version = 7;
inline bool AddCameraSubscriptionInput::has_version() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AddCameraSubscriptionInput::set_has_version() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AddCameraSubscriptionInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AddCameraSubscriptionInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& AddCameraSubscriptionInput::version() const {
  return *version_;
}
inline void AddCameraSubscriptionInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void AddCameraSubscriptionInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void AddCameraSubscriptionInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddCameraSubscriptionInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* AddCameraSubscriptionInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AddCameraSubscriptionOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool AddCameraSubscriptionOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddCameraSubscriptionOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddCameraSubscriptionOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddCameraSubscriptionOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& AddCameraSubscriptionOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* AddCameraSubscriptionOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* AddCameraSubscriptionOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// AddDatasetSubscriptionInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool AddDatasetSubscriptionInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddDatasetSubscriptionInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddDatasetSubscriptionInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddDatasetSubscriptionInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& AddDatasetSubscriptionInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* AddDatasetSubscriptionInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* AddDatasetSubscriptionInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 userId = 2;
inline bool AddDatasetSubscriptionInput::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddDatasetSubscriptionInput::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddDatasetSubscriptionInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddDatasetSubscriptionInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 AddDatasetSubscriptionInput::userid() const {
  return userid_;
}
inline void AddDatasetSubscriptionInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required fixed64 deviceId = 3;
inline bool AddDatasetSubscriptionInput::has_deviceid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AddDatasetSubscriptionInput::set_has_deviceid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AddDatasetSubscriptionInput::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AddDatasetSubscriptionInput::clear_deviceid() {
  deviceid_ = GOOGLE_ULONGLONG(0);
  clear_has_deviceid();
}
inline ::google::protobuf::uint64 AddDatasetSubscriptionInput::deviceid() const {
  return deviceid_;
}
inline void AddDatasetSubscriptionInput::set_deviceid(::google::protobuf::uint64 value) {
  set_has_deviceid();
  deviceid_ = value;
}

// required fixed64 datasetId = 4;
inline bool AddDatasetSubscriptionInput::has_datasetid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AddDatasetSubscriptionInput::set_has_datasetid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AddDatasetSubscriptionInput::clear_has_datasetid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AddDatasetSubscriptionInput::clear_datasetid() {
  datasetid_ = GOOGLE_ULONGLONG(0);
  clear_has_datasetid();
}
inline ::google::protobuf::uint64 AddDatasetSubscriptionInput::datasetid() const {
  return datasetid_;
}
inline void AddDatasetSubscriptionInput::set_datasetid(::google::protobuf::uint64 value) {
  set_has_datasetid();
  datasetid_ = value;
}

// optional .vplex.vsDirectory.DatasetType datasetType = 5;
inline bool AddDatasetSubscriptionInput::has_datasettype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AddDatasetSubscriptionInput::set_has_datasettype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AddDatasetSubscriptionInput::clear_has_datasettype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AddDatasetSubscriptionInput::clear_datasettype() {
  datasettype_ = 1;
  clear_has_datasettype();
}
inline vplex::vsDirectory::DatasetType AddDatasetSubscriptionInput::datasettype() const {
  return static_cast< vplex::vsDirectory::DatasetType >(datasettype_);
}
inline void AddDatasetSubscriptionInput::set_datasettype(vplex::vsDirectory::DatasetType value) {
  GOOGLE_DCHECK(vplex::vsDirectory::DatasetType_IsValid(value));
  set_has_datasettype();
  datasettype_ = value;
}

// optional .vplex.vsDirectory.SubscriptionRole role = 6 [default = GENERAL];
inline bool AddDatasetSubscriptionInput::has_role() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AddDatasetSubscriptionInput::set_has_role() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AddDatasetSubscriptionInput::clear_has_role() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AddDatasetSubscriptionInput::clear_role() {
  role_ = 0;
  clear_has_role();
}
inline vplex::vsDirectory::SubscriptionRole AddDatasetSubscriptionInput::role() const {
  return static_cast< vplex::vsDirectory::SubscriptionRole >(role_);
}
inline void AddDatasetSubscriptionInput::set_role(vplex::vsDirectory::SubscriptionRole value) {
  GOOGLE_DCHECK(vplex::vsDirectory::SubscriptionRole_IsValid(value));
  set_has_role();
  role_ = value;
}

// optional string deviceRoot = 7;
inline bool AddDatasetSubscriptionInput::has_deviceroot() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AddDatasetSubscriptionInput::set_has_deviceroot() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AddDatasetSubscriptionInput::clear_has_deviceroot() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AddDatasetSubscriptionInput::clear_deviceroot() {
  if (deviceroot_ != &::google::protobuf::internal::kEmptyString) {
    deviceroot_->clear();
  }
  clear_has_deviceroot();
}
inline const ::std::string& AddDatasetSubscriptionInput::deviceroot() const {
  return *deviceroot_;
}
inline void AddDatasetSubscriptionInput::set_deviceroot(const ::std::string& value) {
  set_has_deviceroot();
  if (deviceroot_ == &::google::protobuf::internal::kEmptyString) {
    deviceroot_ = new ::std::string;
  }
  deviceroot_->assign(value);
}
inline void AddDatasetSubscriptionInput::set_deviceroot(const char* value) {
  set_has_deviceroot();
  if (deviceroot_ == &::google::protobuf::internal::kEmptyString) {
    deviceroot_ = new ::std::string;
  }
  deviceroot_->assign(value);
}
inline void AddDatasetSubscriptionInput::set_deviceroot(const char* value, size_t size) {
  set_has_deviceroot();
  if (deviceroot_ == &::google::protobuf::internal::kEmptyString) {
    deviceroot_ = new ::std::string;
  }
  deviceroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddDatasetSubscriptionInput::mutable_deviceroot() {
  set_has_deviceroot();
  if (deviceroot_ == &::google::protobuf::internal::kEmptyString) {
    deviceroot_ = new ::std::string;
  }
  return deviceroot_;
}
inline ::std::string* AddDatasetSubscriptionInput::release_deviceroot() {
  clear_has_deviceroot();
  if (deviceroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deviceroot_;
    deviceroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string filter = 8;
inline bool AddDatasetSubscriptionInput::has_filter() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AddDatasetSubscriptionInput::set_has_filter() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AddDatasetSubscriptionInput::clear_has_filter() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AddDatasetSubscriptionInput::clear_filter() {
  if (filter_ != &::google::protobuf::internal::kEmptyString) {
    filter_->clear();
  }
  clear_has_filter();
}
inline const ::std::string& AddDatasetSubscriptionInput::filter() const {
  return *filter_;
}
inline void AddDatasetSubscriptionInput::set_filter(const ::std::string& value) {
  set_has_filter();
  if (filter_ == &::google::protobuf::internal::kEmptyString) {
    filter_ = new ::std::string;
  }
  filter_->assign(value);
}
inline void AddDatasetSubscriptionInput::set_filter(const char* value) {
  set_has_filter();
  if (filter_ == &::google::protobuf::internal::kEmptyString) {
    filter_ = new ::std::string;
  }
  filter_->assign(value);
}
inline void AddDatasetSubscriptionInput::set_filter(const char* value, size_t size) {
  set_has_filter();
  if (filter_ == &::google::protobuf::internal::kEmptyString) {
    filter_ = new ::std::string;
  }
  filter_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddDatasetSubscriptionInput::mutable_filter() {
  set_has_filter();
  if (filter_ == &::google::protobuf::internal::kEmptyString) {
    filter_ = new ::std::string;
  }
  return filter_;
}
inline ::std::string* AddDatasetSubscriptionInput::release_filter() {
  clear_has_filter();
  if (filter_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filter_;
    filter_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional fixed64 maxSize = 9;
inline bool AddDatasetSubscriptionInput::has_maxsize() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AddDatasetSubscriptionInput::set_has_maxsize() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AddDatasetSubscriptionInput::clear_has_maxsize() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AddDatasetSubscriptionInput::clear_maxsize() {
  maxsize_ = GOOGLE_ULONGLONG(0);
  clear_has_maxsize();
}
inline ::google::protobuf::uint64 AddDatasetSubscriptionInput::maxsize() const {
  return maxsize_;
}
inline void AddDatasetSubscriptionInput::set_maxsize(::google::protobuf::uint64 value) {
  set_has_maxsize();
  maxsize_ = value;
}

// optional fixed64 maxFiles = 10;
inline bool AddDatasetSubscriptionInput::has_maxfiles() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AddDatasetSubscriptionInput::set_has_maxfiles() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AddDatasetSubscriptionInput::clear_has_maxfiles() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AddDatasetSubscriptionInput::clear_maxfiles() {
  maxfiles_ = GOOGLE_ULONGLONG(0);
  clear_has_maxfiles();
}
inline ::google::protobuf::uint64 AddDatasetSubscriptionInput::maxfiles() const {
  return maxfiles_;
}
inline void AddDatasetSubscriptionInput::set_maxfiles(::google::protobuf::uint64 value) {
  set_has_maxfiles();
  maxfiles_ = value;
}

// optional string version = 11;
inline bool AddDatasetSubscriptionInput::has_version() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AddDatasetSubscriptionInput::set_has_version() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AddDatasetSubscriptionInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AddDatasetSubscriptionInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& AddDatasetSubscriptionInput::version() const {
  return *version_;
}
inline void AddDatasetSubscriptionInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void AddDatasetSubscriptionInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void AddDatasetSubscriptionInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddDatasetSubscriptionInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* AddDatasetSubscriptionInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AddDatasetSubscriptionOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool AddDatasetSubscriptionOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddDatasetSubscriptionOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddDatasetSubscriptionOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddDatasetSubscriptionOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& AddDatasetSubscriptionOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* AddDatasetSubscriptionOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* AddDatasetSubscriptionOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// DeleteSubscriptionsInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool DeleteSubscriptionsInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteSubscriptionsInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteSubscriptionsInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteSubscriptionsInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& DeleteSubscriptionsInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* DeleteSubscriptionsInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* DeleteSubscriptionsInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 userId = 2;
inline bool DeleteSubscriptionsInput::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeleteSubscriptionsInput::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeleteSubscriptionsInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeleteSubscriptionsInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 DeleteSubscriptionsInput::userid() const {
  return userid_;
}
inline void DeleteSubscriptionsInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required fixed64 deviceId = 3;
inline bool DeleteSubscriptionsInput::has_deviceid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeleteSubscriptionsInput::set_has_deviceid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeleteSubscriptionsInput::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeleteSubscriptionsInput::clear_deviceid() {
  deviceid_ = GOOGLE_ULONGLONG(0);
  clear_has_deviceid();
}
inline ::google::protobuf::uint64 DeleteSubscriptionsInput::deviceid() const {
  return deviceid_;
}
inline void DeleteSubscriptionsInput::set_deviceid(::google::protobuf::uint64 value) {
  set_has_deviceid();
  deviceid_ = value;
}

// repeated string datasetNames = 4;
inline int DeleteSubscriptionsInput::datasetnames_size() const {
  return datasetnames_.size();
}
inline void DeleteSubscriptionsInput::clear_datasetnames() {
  datasetnames_.Clear();
}
inline const ::std::string& DeleteSubscriptionsInput::datasetnames(int index) const {
  return datasetnames_.Get(index);
}
inline ::std::string* DeleteSubscriptionsInput::mutable_datasetnames(int index) {
  return datasetnames_.Mutable(index);
}
inline void DeleteSubscriptionsInput::set_datasetnames(int index, const ::std::string& value) {
  datasetnames_.Mutable(index)->assign(value);
}
inline void DeleteSubscriptionsInput::set_datasetnames(int index, const char* value) {
  datasetnames_.Mutable(index)->assign(value);
}
inline void DeleteSubscriptionsInput::set_datasetnames(int index, const char* value, size_t size) {
  datasetnames_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeleteSubscriptionsInput::add_datasetnames() {
  return datasetnames_.Add();
}
inline void DeleteSubscriptionsInput::add_datasetnames(const ::std::string& value) {
  datasetnames_.Add()->assign(value);
}
inline void DeleteSubscriptionsInput::add_datasetnames(const char* value) {
  datasetnames_.Add()->assign(value);
}
inline void DeleteSubscriptionsInput::add_datasetnames(const char* value, size_t size) {
  datasetnames_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DeleteSubscriptionsInput::datasetnames() const {
  return datasetnames_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DeleteSubscriptionsInput::mutable_datasetnames() {
  return &datasetnames_;
}

// repeated fixed64 datasetIds = 5;
inline int DeleteSubscriptionsInput::datasetids_size() const {
  return datasetids_.size();
}
inline void DeleteSubscriptionsInput::clear_datasetids() {
  datasetids_.Clear();
}
inline ::google::protobuf::uint64 DeleteSubscriptionsInput::datasetids(int index) const {
  return datasetids_.Get(index);
}
inline void DeleteSubscriptionsInput::set_datasetids(int index, ::google::protobuf::uint64 value) {
  datasetids_.Set(index, value);
}
inline void DeleteSubscriptionsInput::add_datasetids(::google::protobuf::uint64 value) {
  datasetids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
DeleteSubscriptionsInput::datasetids() const {
  return datasetids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
DeleteSubscriptionsInput::mutable_datasetids() {
  return &datasetids_;
}

// optional string version = 6;
inline bool DeleteSubscriptionsInput::has_version() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DeleteSubscriptionsInput::set_has_version() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DeleteSubscriptionsInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DeleteSubscriptionsInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& DeleteSubscriptionsInput::version() const {
  return *version_;
}
inline void DeleteSubscriptionsInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void DeleteSubscriptionsInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void DeleteSubscriptionsInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeleteSubscriptionsInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* DeleteSubscriptionsInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// DeleteSubscriptionsOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool DeleteSubscriptionsOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteSubscriptionsOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteSubscriptionsOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteSubscriptionsOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& DeleteSubscriptionsOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* DeleteSubscriptionsOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* DeleteSubscriptionsOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// UpdateSubscriptionFilterInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool UpdateSubscriptionFilterInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateSubscriptionFilterInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateSubscriptionFilterInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateSubscriptionFilterInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& UpdateSubscriptionFilterInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* UpdateSubscriptionFilterInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* UpdateSubscriptionFilterInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 userId = 2;
inline bool UpdateSubscriptionFilterInput::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateSubscriptionFilterInput::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateSubscriptionFilterInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateSubscriptionFilterInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 UpdateSubscriptionFilterInput::userid() const {
  return userid_;
}
inline void UpdateSubscriptionFilterInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required fixed64 deviceId = 3;
inline bool UpdateSubscriptionFilterInput::has_deviceid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateSubscriptionFilterInput::set_has_deviceid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateSubscriptionFilterInput::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdateSubscriptionFilterInput::clear_deviceid() {
  deviceid_ = GOOGLE_ULONGLONG(0);
  clear_has_deviceid();
}
inline ::google::protobuf::uint64 UpdateSubscriptionFilterInput::deviceid() const {
  return deviceid_;
}
inline void UpdateSubscriptionFilterInput::set_deviceid(::google::protobuf::uint64 value) {
  set_has_deviceid();
  deviceid_ = value;
}

// optional string datasetName = 4;
inline bool UpdateSubscriptionFilterInput::has_datasetname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UpdateSubscriptionFilterInput::set_has_datasetname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UpdateSubscriptionFilterInput::clear_has_datasetname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UpdateSubscriptionFilterInput::clear_datasetname() {
  if (datasetname_ != &::google::protobuf::internal::kEmptyString) {
    datasetname_->clear();
  }
  clear_has_datasetname();
}
inline const ::std::string& UpdateSubscriptionFilterInput::datasetname() const {
  return *datasetname_;
}
inline void UpdateSubscriptionFilterInput::set_datasetname(const ::std::string& value) {
  set_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    datasetname_ = new ::std::string;
  }
  datasetname_->assign(value);
}
inline void UpdateSubscriptionFilterInput::set_datasetname(const char* value) {
  set_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    datasetname_ = new ::std::string;
  }
  datasetname_->assign(value);
}
inline void UpdateSubscriptionFilterInput::set_datasetname(const char* value, size_t size) {
  set_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    datasetname_ = new ::std::string;
  }
  datasetname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateSubscriptionFilterInput::mutable_datasetname() {
  set_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    datasetname_ = new ::std::string;
  }
  return datasetname_;
}
inline ::std::string* UpdateSubscriptionFilterInput::release_datasetname() {
  clear_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = datasetname_;
    datasetname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional fixed64 datasetId = 5;
inline bool UpdateSubscriptionFilterInput::has_datasetid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UpdateSubscriptionFilterInput::set_has_datasetid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UpdateSubscriptionFilterInput::clear_has_datasetid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UpdateSubscriptionFilterInput::clear_datasetid() {
  datasetid_ = GOOGLE_ULONGLONG(0);
  clear_has_datasetid();
}
inline ::google::protobuf::uint64 UpdateSubscriptionFilterInput::datasetid() const {
  return datasetid_;
}
inline void UpdateSubscriptionFilterInput::set_datasetid(::google::protobuf::uint64 value) {
  set_has_datasetid();
  datasetid_ = value;
}

// optional string filter = 6;
inline bool UpdateSubscriptionFilterInput::has_filter() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UpdateSubscriptionFilterInput::set_has_filter() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UpdateSubscriptionFilterInput::clear_has_filter() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UpdateSubscriptionFilterInput::clear_filter() {
  if (filter_ != &::google::protobuf::internal::kEmptyString) {
    filter_->clear();
  }
  clear_has_filter();
}
inline const ::std::string& UpdateSubscriptionFilterInput::filter() const {
  return *filter_;
}
inline void UpdateSubscriptionFilterInput::set_filter(const ::std::string& value) {
  set_has_filter();
  if (filter_ == &::google::protobuf::internal::kEmptyString) {
    filter_ = new ::std::string;
  }
  filter_->assign(value);
}
inline void UpdateSubscriptionFilterInput::set_filter(const char* value) {
  set_has_filter();
  if (filter_ == &::google::protobuf::internal::kEmptyString) {
    filter_ = new ::std::string;
  }
  filter_->assign(value);
}
inline void UpdateSubscriptionFilterInput::set_filter(const char* value, size_t size) {
  set_has_filter();
  if (filter_ == &::google::protobuf::internal::kEmptyString) {
    filter_ = new ::std::string;
  }
  filter_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateSubscriptionFilterInput::mutable_filter() {
  set_has_filter();
  if (filter_ == &::google::protobuf::internal::kEmptyString) {
    filter_ = new ::std::string;
  }
  return filter_;
}
inline ::std::string* UpdateSubscriptionFilterInput::release_filter() {
  clear_has_filter();
  if (filter_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filter_;
    filter_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string version = 7;
inline bool UpdateSubscriptionFilterInput::has_version() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UpdateSubscriptionFilterInput::set_has_version() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UpdateSubscriptionFilterInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UpdateSubscriptionFilterInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& UpdateSubscriptionFilterInput::version() const {
  return *version_;
}
inline void UpdateSubscriptionFilterInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void UpdateSubscriptionFilterInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void UpdateSubscriptionFilterInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateSubscriptionFilterInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* UpdateSubscriptionFilterInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// UpdateSubscriptionFilterOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool UpdateSubscriptionFilterOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateSubscriptionFilterOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateSubscriptionFilterOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateSubscriptionFilterOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& UpdateSubscriptionFilterOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* UpdateSubscriptionFilterOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* UpdateSubscriptionFilterOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// UpdateSubscriptionLimitsInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool UpdateSubscriptionLimitsInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateSubscriptionLimitsInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateSubscriptionLimitsInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateSubscriptionLimitsInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& UpdateSubscriptionLimitsInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* UpdateSubscriptionLimitsInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* UpdateSubscriptionLimitsInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 userId = 2;
inline bool UpdateSubscriptionLimitsInput::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateSubscriptionLimitsInput::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateSubscriptionLimitsInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateSubscriptionLimitsInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 UpdateSubscriptionLimitsInput::userid() const {
  return userid_;
}
inline void UpdateSubscriptionLimitsInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required fixed64 deviceId = 3;
inline bool UpdateSubscriptionLimitsInput::has_deviceid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateSubscriptionLimitsInput::set_has_deviceid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateSubscriptionLimitsInput::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdateSubscriptionLimitsInput::clear_deviceid() {
  deviceid_ = GOOGLE_ULONGLONG(0);
  clear_has_deviceid();
}
inline ::google::protobuf::uint64 UpdateSubscriptionLimitsInput::deviceid() const {
  return deviceid_;
}
inline void UpdateSubscriptionLimitsInput::set_deviceid(::google::protobuf::uint64 value) {
  set_has_deviceid();
  deviceid_ = value;
}

// optional string datasetName = 4;
inline bool UpdateSubscriptionLimitsInput::has_datasetname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UpdateSubscriptionLimitsInput::set_has_datasetname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UpdateSubscriptionLimitsInput::clear_has_datasetname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UpdateSubscriptionLimitsInput::clear_datasetname() {
  if (datasetname_ != &::google::protobuf::internal::kEmptyString) {
    datasetname_->clear();
  }
  clear_has_datasetname();
}
inline const ::std::string& UpdateSubscriptionLimitsInput::datasetname() const {
  return *datasetname_;
}
inline void UpdateSubscriptionLimitsInput::set_datasetname(const ::std::string& value) {
  set_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    datasetname_ = new ::std::string;
  }
  datasetname_->assign(value);
}
inline void UpdateSubscriptionLimitsInput::set_datasetname(const char* value) {
  set_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    datasetname_ = new ::std::string;
  }
  datasetname_->assign(value);
}
inline void UpdateSubscriptionLimitsInput::set_datasetname(const char* value, size_t size) {
  set_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    datasetname_ = new ::std::string;
  }
  datasetname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateSubscriptionLimitsInput::mutable_datasetname() {
  set_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    datasetname_ = new ::std::string;
  }
  return datasetname_;
}
inline ::std::string* UpdateSubscriptionLimitsInput::release_datasetname() {
  clear_has_datasetname();
  if (datasetname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = datasetname_;
    datasetname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional fixed64 datasetId = 5;
inline bool UpdateSubscriptionLimitsInput::has_datasetid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UpdateSubscriptionLimitsInput::set_has_datasetid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UpdateSubscriptionLimitsInput::clear_has_datasetid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UpdateSubscriptionLimitsInput::clear_datasetid() {
  datasetid_ = GOOGLE_ULONGLONG(0);
  clear_has_datasetid();
}
inline ::google::protobuf::uint64 UpdateSubscriptionLimitsInput::datasetid() const {
  return datasetid_;
}
inline void UpdateSubscriptionLimitsInput::set_datasetid(::google::protobuf::uint64 value) {
  set_has_datasetid();
  datasetid_ = value;
}

// optional string filter = 6;
inline bool UpdateSubscriptionLimitsInput::has_filter() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UpdateSubscriptionLimitsInput::set_has_filter() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UpdateSubscriptionLimitsInput::clear_has_filter() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UpdateSubscriptionLimitsInput::clear_filter() {
  if (filter_ != &::google::protobuf::internal::kEmptyString) {
    filter_->clear();
  }
  clear_has_filter();
}
inline const ::std::string& UpdateSubscriptionLimitsInput::filter() const {
  return *filter_;
}
inline void UpdateSubscriptionLimitsInput::set_filter(const ::std::string& value) {
  set_has_filter();
  if (filter_ == &::google::protobuf::internal::kEmptyString) {
    filter_ = new ::std::string;
  }
  filter_->assign(value);
}
inline void UpdateSubscriptionLimitsInput::set_filter(const char* value) {
  set_has_filter();
  if (filter_ == &::google::protobuf::internal::kEmptyString) {
    filter_ = new ::std::string;
  }
  filter_->assign(value);
}
inline void UpdateSubscriptionLimitsInput::set_filter(const char* value, size_t size) {
  set_has_filter();
  if (filter_ == &::google::protobuf::internal::kEmptyString) {
    filter_ = new ::std::string;
  }
  filter_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateSubscriptionLimitsInput::mutable_filter() {
  set_has_filter();
  if (filter_ == &::google::protobuf::internal::kEmptyString) {
    filter_ = new ::std::string;
  }
  return filter_;
}
inline ::std::string* UpdateSubscriptionLimitsInput::release_filter() {
  clear_has_filter();
  if (filter_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filter_;
    filter_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional fixed64 maxSize = 7;
inline bool UpdateSubscriptionLimitsInput::has_maxsize() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UpdateSubscriptionLimitsInput::set_has_maxsize() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UpdateSubscriptionLimitsInput::clear_has_maxsize() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UpdateSubscriptionLimitsInput::clear_maxsize() {
  maxsize_ = GOOGLE_ULONGLONG(0);
  clear_has_maxsize();
}
inline ::google::protobuf::uint64 UpdateSubscriptionLimitsInput::maxsize() const {
  return maxsize_;
}
inline void UpdateSubscriptionLimitsInput::set_maxsize(::google::protobuf::uint64 value) {
  set_has_maxsize();
  maxsize_ = value;
}

// optional fixed64 maxFiles = 8;
inline bool UpdateSubscriptionLimitsInput::has_maxfiles() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UpdateSubscriptionLimitsInput::set_has_maxfiles() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UpdateSubscriptionLimitsInput::clear_has_maxfiles() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UpdateSubscriptionLimitsInput::clear_maxfiles() {
  maxfiles_ = GOOGLE_ULONGLONG(0);
  clear_has_maxfiles();
}
inline ::google::protobuf::uint64 UpdateSubscriptionLimitsInput::maxfiles() const {
  return maxfiles_;
}
inline void UpdateSubscriptionLimitsInput::set_maxfiles(::google::protobuf::uint64 value) {
  set_has_maxfiles();
  maxfiles_ = value;
}

// optional string version = 9;
inline bool UpdateSubscriptionLimitsInput::has_version() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UpdateSubscriptionLimitsInput::set_has_version() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UpdateSubscriptionLimitsInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UpdateSubscriptionLimitsInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& UpdateSubscriptionLimitsInput::version() const {
  return *version_;
}
inline void UpdateSubscriptionLimitsInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void UpdateSubscriptionLimitsInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void UpdateSubscriptionLimitsInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateSubscriptionLimitsInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* UpdateSubscriptionLimitsInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// UpdateSubscriptionLimitsOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool UpdateSubscriptionLimitsOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateSubscriptionLimitsOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateSubscriptionLimitsOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateSubscriptionLimitsOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& UpdateSubscriptionLimitsOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* UpdateSubscriptionLimitsOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* UpdateSubscriptionLimitsOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// GetSubscriptionDetailsForDeviceInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool GetSubscriptionDetailsForDeviceInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetSubscriptionDetailsForDeviceInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetSubscriptionDetailsForDeviceInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetSubscriptionDetailsForDeviceInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& GetSubscriptionDetailsForDeviceInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* GetSubscriptionDetailsForDeviceInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* GetSubscriptionDetailsForDeviceInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 userId = 2;
inline bool GetSubscriptionDetailsForDeviceInput::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetSubscriptionDetailsForDeviceInput::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetSubscriptionDetailsForDeviceInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetSubscriptionDetailsForDeviceInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 GetSubscriptionDetailsForDeviceInput::userid() const {
  return userid_;
}
inline void GetSubscriptionDetailsForDeviceInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required fixed64 deviceId = 3;
inline bool GetSubscriptionDetailsForDeviceInput::has_deviceid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetSubscriptionDetailsForDeviceInput::set_has_deviceid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetSubscriptionDetailsForDeviceInput::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetSubscriptionDetailsForDeviceInput::clear_deviceid() {
  deviceid_ = GOOGLE_ULONGLONG(0);
  clear_has_deviceid();
}
inline ::google::protobuf::uint64 GetSubscriptionDetailsForDeviceInput::deviceid() const {
  return deviceid_;
}
inline void GetSubscriptionDetailsForDeviceInput::set_deviceid(::google::protobuf::uint64 value) {
  set_has_deviceid();
  deviceid_ = value;
}

// optional string version = 4;
inline bool GetSubscriptionDetailsForDeviceInput::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetSubscriptionDetailsForDeviceInput::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetSubscriptionDetailsForDeviceInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetSubscriptionDetailsForDeviceInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& GetSubscriptionDetailsForDeviceInput::version() const {
  return *version_;
}
inline void GetSubscriptionDetailsForDeviceInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetSubscriptionDetailsForDeviceInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetSubscriptionDetailsForDeviceInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetSubscriptionDetailsForDeviceInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* GetSubscriptionDetailsForDeviceInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetSubscriptionDetailsForDeviceOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool GetSubscriptionDetailsForDeviceOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetSubscriptionDetailsForDeviceOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetSubscriptionDetailsForDeviceOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetSubscriptionDetailsForDeviceOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& GetSubscriptionDetailsForDeviceOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* GetSubscriptionDetailsForDeviceOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* GetSubscriptionDetailsForDeviceOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// repeated .vplex.vsDirectory.Subscription subscriptions = 2;
inline int GetSubscriptionDetailsForDeviceOutput::subscriptions_size() const {
  return subscriptions_.size();
}
inline void GetSubscriptionDetailsForDeviceOutput::clear_subscriptions() {
  subscriptions_.Clear();
}
inline const ::vplex::vsDirectory::Subscription& GetSubscriptionDetailsForDeviceOutput::subscriptions(int index) const {
  return subscriptions_.Get(index);
}
inline ::vplex::vsDirectory::Subscription* GetSubscriptionDetailsForDeviceOutput::mutable_subscriptions(int index) {
  return subscriptions_.Mutable(index);
}
inline ::vplex::vsDirectory::Subscription* GetSubscriptionDetailsForDeviceOutput::add_subscriptions() {
  return subscriptions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::Subscription >&
GetSubscriptionDetailsForDeviceOutput::subscriptions() const {
  return subscriptions_;
}
inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::Subscription >*
GetSubscriptionDetailsForDeviceOutput::mutable_subscriptions() {
  return &subscriptions_;
}

// -------------------------------------------------------------------

// GetCloudInfoInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool GetCloudInfoInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetCloudInfoInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetCloudInfoInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetCloudInfoInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& GetCloudInfoInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* GetCloudInfoInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* GetCloudInfoInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 userId = 2;
inline bool GetCloudInfoInput::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetCloudInfoInput::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetCloudInfoInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetCloudInfoInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 GetCloudInfoInput::userid() const {
  return userid_;
}
inline void GetCloudInfoInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required fixed64 deviceId = 3;
inline bool GetCloudInfoInput::has_deviceid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetCloudInfoInput::set_has_deviceid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetCloudInfoInput::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetCloudInfoInput::clear_deviceid() {
  deviceid_ = GOOGLE_ULONGLONG(0);
  clear_has_deviceid();
}
inline ::google::protobuf::uint64 GetCloudInfoInput::deviceid() const {
  return deviceid_;
}
inline void GetCloudInfoInput::set_deviceid(::google::protobuf::uint64 value) {
  set_has_deviceid();
  deviceid_ = value;
}

// optional string version = 4;
inline bool GetCloudInfoInput::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetCloudInfoInput::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetCloudInfoInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetCloudInfoInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& GetCloudInfoInput::version() const {
  return *version_;
}
inline void GetCloudInfoInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetCloudInfoInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetCloudInfoInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetCloudInfoInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* GetCloudInfoInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetCloudInfoOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool GetCloudInfoOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetCloudInfoOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetCloudInfoOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetCloudInfoOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& GetCloudInfoOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* GetCloudInfoOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* GetCloudInfoOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// repeated .vplex.vsDirectory.DeviceInfo devices = 2;
inline int GetCloudInfoOutput::devices_size() const {
  return devices_.size();
}
inline void GetCloudInfoOutput::clear_devices() {
  devices_.Clear();
}
inline const ::vplex::vsDirectory::DeviceInfo& GetCloudInfoOutput::devices(int index) const {
  return devices_.Get(index);
}
inline ::vplex::vsDirectory::DeviceInfo* GetCloudInfoOutput::mutable_devices(int index) {
  return devices_.Mutable(index);
}
inline ::vplex::vsDirectory::DeviceInfo* GetCloudInfoOutput::add_devices() {
  return devices_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::DeviceInfo >&
GetCloudInfoOutput::devices() const {
  return devices_;
}
inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::DeviceInfo >*
GetCloudInfoOutput::mutable_devices() {
  return &devices_;
}

// repeated .vplex.vsDirectory.DatasetDetail datasets = 3;
inline int GetCloudInfoOutput::datasets_size() const {
  return datasets_.size();
}
inline void GetCloudInfoOutput::clear_datasets() {
  datasets_.Clear();
}
inline const ::vplex::vsDirectory::DatasetDetail& GetCloudInfoOutput::datasets(int index) const {
  return datasets_.Get(index);
}
inline ::vplex::vsDirectory::DatasetDetail* GetCloudInfoOutput::mutable_datasets(int index) {
  return datasets_.Mutable(index);
}
inline ::vplex::vsDirectory::DatasetDetail* GetCloudInfoOutput::add_datasets() {
  return datasets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::DatasetDetail >&
GetCloudInfoOutput::datasets() const {
  return datasets_;
}
inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::DatasetDetail >*
GetCloudInfoOutput::mutable_datasets() {
  return &datasets_;
}

// repeated .vplex.vsDirectory.Subscription subscriptions = 4;
inline int GetCloudInfoOutput::subscriptions_size() const {
  return subscriptions_.size();
}
inline void GetCloudInfoOutput::clear_subscriptions() {
  subscriptions_.Clear();
}
inline const ::vplex::vsDirectory::Subscription& GetCloudInfoOutput::subscriptions(int index) const {
  return subscriptions_.Get(index);
}
inline ::vplex::vsDirectory::Subscription* GetCloudInfoOutput::mutable_subscriptions(int index) {
  return subscriptions_.Mutable(index);
}
inline ::vplex::vsDirectory::Subscription* GetCloudInfoOutput::add_subscriptions() {
  return subscriptions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::Subscription >&
GetCloudInfoOutput::subscriptions() const {
  return subscriptions_;
}
inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::Subscription >*
GetCloudInfoOutput::mutable_subscriptions() {
  return &subscriptions_;
}

// repeated .vplex.vsDirectory.UserStorage storageAssignments = 5;
inline int GetCloudInfoOutput::storageassignments_size() const {
  return storageassignments_.size();
}
inline void GetCloudInfoOutput::clear_storageassignments() {
  storageassignments_.Clear();
}
inline const ::vplex::vsDirectory::UserStorage& GetCloudInfoOutput::storageassignments(int index) const {
  return storageassignments_.Get(index);
}
inline ::vplex::vsDirectory::UserStorage* GetCloudInfoOutput::mutable_storageassignments(int index) {
  return storageassignments_.Mutable(index);
}
inline ::vplex::vsDirectory::UserStorage* GetCloudInfoOutput::add_storageassignments() {
  return storageassignments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::UserStorage >&
GetCloudInfoOutput::storageassignments() const {
  return storageassignments_;
}
inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::UserStorage >*
GetCloudInfoOutput::mutable_storageassignments() {
  return &storageassignments_;
}

// -------------------------------------------------------------------

// GetSubscribedDatasetsInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool GetSubscribedDatasetsInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetSubscribedDatasetsInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetSubscribedDatasetsInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetSubscribedDatasetsInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& GetSubscribedDatasetsInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* GetSubscribedDatasetsInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* GetSubscribedDatasetsInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 deviceId = 2;
inline bool GetSubscribedDatasetsInput::has_deviceid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetSubscribedDatasetsInput::set_has_deviceid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetSubscribedDatasetsInput::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetSubscribedDatasetsInput::clear_deviceid() {
  deviceid_ = GOOGLE_ULONGLONG(0);
  clear_has_deviceid();
}
inline ::google::protobuf::uint64 GetSubscribedDatasetsInput::deviceid() const {
  return deviceid_;
}
inline void GetSubscribedDatasetsInput::set_deviceid(::google::protobuf::uint64 value) {
  set_has_deviceid();
  deviceid_ = value;
}

// required .vplex.vsDirectory.Localization l10n = 3;
inline bool GetSubscribedDatasetsInput::has_l10n() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetSubscribedDatasetsInput::set_has_l10n() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetSubscribedDatasetsInput::clear_has_l10n() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetSubscribedDatasetsInput::clear_l10n() {
  if (l10n_ != NULL) l10n_->::vplex::vsDirectory::Localization::Clear();
  clear_has_l10n();
}
inline const ::vplex::vsDirectory::Localization& GetSubscribedDatasetsInput::l10n() const {
  return l10n_ != NULL ? *l10n_ : *default_instance_->l10n_;
}
inline ::vplex::vsDirectory::Localization* GetSubscribedDatasetsInput::mutable_l10n() {
  set_has_l10n();
  if (l10n_ == NULL) l10n_ = new ::vplex::vsDirectory::Localization;
  return l10n_;
}
inline ::vplex::vsDirectory::Localization* GetSubscribedDatasetsInput::release_l10n() {
  clear_has_l10n();
  ::vplex::vsDirectory::Localization* temp = l10n_;
  l10n_ = NULL;
  return temp;
}

// optional string version = 4;
inline bool GetSubscribedDatasetsInput::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetSubscribedDatasetsInput::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetSubscribedDatasetsInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetSubscribedDatasetsInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& GetSubscribedDatasetsInput::version() const {
  return *version_;
}
inline void GetSubscribedDatasetsInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetSubscribedDatasetsInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetSubscribedDatasetsInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetSubscribedDatasetsInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* GetSubscribedDatasetsInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetSubscribedDatasetsOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool GetSubscribedDatasetsOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetSubscribedDatasetsOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetSubscribedDatasetsOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetSubscribedDatasetsOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& GetSubscribedDatasetsOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* GetSubscribedDatasetsOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* GetSubscribedDatasetsOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// repeated .vplex.vsDirectory.TitleData titleData = 2;
inline int GetSubscribedDatasetsOutput::titledata_size() const {
  return titledata_.size();
}
inline void GetSubscribedDatasetsOutput::clear_titledata() {
  titledata_.Clear();
}
inline const ::vplex::vsDirectory::TitleData& GetSubscribedDatasetsOutput::titledata(int index) const {
  return titledata_.Get(index);
}
inline ::vplex::vsDirectory::TitleData* GetSubscribedDatasetsOutput::mutable_titledata(int index) {
  return titledata_.Mutable(index);
}
inline ::vplex::vsDirectory::TitleData* GetSubscribedDatasetsOutput::add_titledata() {
  return titledata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::TitleData >&
GetSubscribedDatasetsOutput::titledata() const {
  return titledata_;
}
inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::TitleData >*
GetSubscribedDatasetsOutput::mutable_titledata() {
  return &titledata_;
}

// repeated .vplex.vsDirectory.DatasetData datasetData = 3;
inline int GetSubscribedDatasetsOutput::datasetdata_size() const {
  return datasetdata_.size();
}
inline void GetSubscribedDatasetsOutput::clear_datasetdata() {
  datasetdata_.Clear();
}
inline const ::vplex::vsDirectory::DatasetData& GetSubscribedDatasetsOutput::datasetdata(int index) const {
  return datasetdata_.Get(index);
}
inline ::vplex::vsDirectory::DatasetData* GetSubscribedDatasetsOutput::mutable_datasetdata(int index) {
  return datasetdata_.Mutable(index);
}
inline ::vplex::vsDirectory::DatasetData* GetSubscribedDatasetsOutput::add_datasetdata() {
  return datasetdata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::DatasetData >&
GetSubscribedDatasetsOutput::datasetdata() const {
  return datasetdata_;
}
inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::DatasetData >*
GetSubscribedDatasetsOutput::mutable_datasetdata() {
  return &datasetdata_;
}

// -------------------------------------------------------------------

// GetSubscriptionDetailsInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool GetSubscriptionDetailsInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetSubscriptionDetailsInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetSubscriptionDetailsInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetSubscriptionDetailsInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& GetSubscriptionDetailsInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* GetSubscriptionDetailsInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* GetSubscriptionDetailsInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 userId = 2;
inline bool GetSubscriptionDetailsInput::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetSubscriptionDetailsInput::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetSubscriptionDetailsInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetSubscriptionDetailsInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 GetSubscriptionDetailsInput::userid() const {
  return userid_;
}
inline void GetSubscriptionDetailsInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required fixed64 deviceId = 3;
inline bool GetSubscriptionDetailsInput::has_deviceid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetSubscriptionDetailsInput::set_has_deviceid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetSubscriptionDetailsInput::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetSubscriptionDetailsInput::clear_deviceid() {
  deviceid_ = GOOGLE_ULONGLONG(0);
  clear_has_deviceid();
}
inline ::google::protobuf::uint64 GetSubscriptionDetailsInput::deviceid() const {
  return deviceid_;
}
inline void GetSubscriptionDetailsInput::set_deviceid(::google::protobuf::uint64 value) {
  set_has_deviceid();
  deviceid_ = value;
}

// repeated fixed64 datasetIds = 4;
inline int GetSubscriptionDetailsInput::datasetids_size() const {
  return datasetids_.size();
}
inline void GetSubscriptionDetailsInput::clear_datasetids() {
  datasetids_.Clear();
}
inline ::google::protobuf::uint64 GetSubscriptionDetailsInput::datasetids(int index) const {
  return datasetids_.Get(index);
}
inline void GetSubscriptionDetailsInput::set_datasetids(int index, ::google::protobuf::uint64 value) {
  datasetids_.Set(index, value);
}
inline void GetSubscriptionDetailsInput::add_datasetids(::google::protobuf::uint64 value) {
  datasetids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
GetSubscriptionDetailsInput::datasetids() const {
  return datasetids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
GetSubscriptionDetailsInput::mutable_datasetids() {
  return &datasetids_;
}

// optional string version = 5;
inline bool GetSubscriptionDetailsInput::has_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetSubscriptionDetailsInput::set_has_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetSubscriptionDetailsInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetSubscriptionDetailsInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& GetSubscriptionDetailsInput::version() const {
  return *version_;
}
inline void GetSubscriptionDetailsInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetSubscriptionDetailsInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetSubscriptionDetailsInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetSubscriptionDetailsInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* GetSubscriptionDetailsInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetSubscriptionDetailsOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool GetSubscriptionDetailsOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetSubscriptionDetailsOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetSubscriptionDetailsOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetSubscriptionDetailsOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& GetSubscriptionDetailsOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* GetSubscriptionDetailsOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* GetSubscriptionDetailsOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// repeated .vplex.vsDirectory.Subscription subscriptions = 2;
inline int GetSubscriptionDetailsOutput::subscriptions_size() const {
  return subscriptions_.size();
}
inline void GetSubscriptionDetailsOutput::clear_subscriptions() {
  subscriptions_.Clear();
}
inline const ::vplex::vsDirectory::Subscription& GetSubscriptionDetailsOutput::subscriptions(int index) const {
  return subscriptions_.Get(index);
}
inline ::vplex::vsDirectory::Subscription* GetSubscriptionDetailsOutput::mutable_subscriptions(int index) {
  return subscriptions_.Mutable(index);
}
inline ::vplex::vsDirectory::Subscription* GetSubscriptionDetailsOutput::add_subscriptions() {
  return subscriptions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::Subscription >&
GetSubscriptionDetailsOutput::subscriptions() const {
  return subscriptions_;
}
inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::Subscription >*
GetSubscriptionDetailsOutput::mutable_subscriptions() {
  return &subscriptions_;
}

// -------------------------------------------------------------------

// LinkDeviceInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool LinkDeviceInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LinkDeviceInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LinkDeviceInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LinkDeviceInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& LinkDeviceInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* LinkDeviceInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* LinkDeviceInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 userId = 2;
inline bool LinkDeviceInput::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LinkDeviceInput::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LinkDeviceInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LinkDeviceInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 LinkDeviceInput::userid() const {
  return userid_;
}
inline void LinkDeviceInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required fixed64 deviceId = 3;
inline bool LinkDeviceInput::has_deviceid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LinkDeviceInput::set_has_deviceid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LinkDeviceInput::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LinkDeviceInput::clear_deviceid() {
  deviceid_ = GOOGLE_ULONGLONG(0);
  clear_has_deviceid();
}
inline ::google::protobuf::uint64 LinkDeviceInput::deviceid() const {
  return deviceid_;
}
inline void LinkDeviceInput::set_deviceid(::google::protobuf::uint64 value) {
  set_has_deviceid();
  deviceid_ = value;
}

// required string deviceClass = 4;
inline bool LinkDeviceInput::has_deviceclass() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LinkDeviceInput::set_has_deviceclass() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LinkDeviceInput::clear_has_deviceclass() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LinkDeviceInput::clear_deviceclass() {
  if (deviceclass_ != &::google::protobuf::internal::kEmptyString) {
    deviceclass_->clear();
  }
  clear_has_deviceclass();
}
inline const ::std::string& LinkDeviceInput::deviceclass() const {
  return *deviceclass_;
}
inline void LinkDeviceInput::set_deviceclass(const ::std::string& value) {
  set_has_deviceclass();
  if (deviceclass_ == &::google::protobuf::internal::kEmptyString) {
    deviceclass_ = new ::std::string;
  }
  deviceclass_->assign(value);
}
inline void LinkDeviceInput::set_deviceclass(const char* value) {
  set_has_deviceclass();
  if (deviceclass_ == &::google::protobuf::internal::kEmptyString) {
    deviceclass_ = new ::std::string;
  }
  deviceclass_->assign(value);
}
inline void LinkDeviceInput::set_deviceclass(const char* value, size_t size) {
  set_has_deviceclass();
  if (deviceclass_ == &::google::protobuf::internal::kEmptyString) {
    deviceclass_ = new ::std::string;
  }
  deviceclass_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LinkDeviceInput::mutable_deviceclass() {
  set_has_deviceclass();
  if (deviceclass_ == &::google::protobuf::internal::kEmptyString) {
    deviceclass_ = new ::std::string;
  }
  return deviceclass_;
}
inline ::std::string* LinkDeviceInput::release_deviceclass() {
  clear_has_deviceclass();
  if (deviceclass_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deviceclass_;
    deviceclass_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string deviceName = 5;
inline bool LinkDeviceInput::has_devicename() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LinkDeviceInput::set_has_devicename() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LinkDeviceInput::clear_has_devicename() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LinkDeviceInput::clear_devicename() {
  if (devicename_ != &::google::protobuf::internal::kEmptyString) {
    devicename_->clear();
  }
  clear_has_devicename();
}
inline const ::std::string& LinkDeviceInput::devicename() const {
  return *devicename_;
}
inline void LinkDeviceInput::set_devicename(const ::std::string& value) {
  set_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    devicename_ = new ::std::string;
  }
  devicename_->assign(value);
}
inline void LinkDeviceInput::set_devicename(const char* value) {
  set_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    devicename_ = new ::std::string;
  }
  devicename_->assign(value);
}
inline void LinkDeviceInput::set_devicename(const char* value, size_t size) {
  set_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    devicename_ = new ::std::string;
  }
  devicename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LinkDeviceInput::mutable_devicename() {
  set_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    devicename_ = new ::std::string;
  }
  return devicename_;
}
inline ::std::string* LinkDeviceInput::release_devicename() {
  clear_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devicename_;
    devicename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool isAcer = 6;
inline bool LinkDeviceInput::has_isacer() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LinkDeviceInput::set_has_isacer() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LinkDeviceInput::clear_has_isacer() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LinkDeviceInput::clear_isacer() {
  isacer_ = false;
  clear_has_isacer();
}
inline bool LinkDeviceInput::isacer() const {
  return isacer_;
}
inline void LinkDeviceInput::set_isacer(bool value) {
  set_has_isacer();
  isacer_ = value;
}

// optional bool hasCamera = 7;
inline bool LinkDeviceInput::has_hascamera() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LinkDeviceInput::set_has_hascamera() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LinkDeviceInput::clear_has_hascamera() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LinkDeviceInput::clear_hascamera() {
  hascamera_ = false;
  clear_has_hascamera();
}
inline bool LinkDeviceInput::hascamera() const {
  return hascamera_;
}
inline void LinkDeviceInput::set_hascamera(bool value) {
  set_has_hascamera();
  hascamera_ = value;
}

// optional string osVersion = 8;
inline bool LinkDeviceInput::has_osversion() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LinkDeviceInput::set_has_osversion() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LinkDeviceInput::clear_has_osversion() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LinkDeviceInput::clear_osversion() {
  if (osversion_ != &::google::protobuf::internal::kEmptyString) {
    osversion_->clear();
  }
  clear_has_osversion();
}
inline const ::std::string& LinkDeviceInput::osversion() const {
  return *osversion_;
}
inline void LinkDeviceInput::set_osversion(const ::std::string& value) {
  set_has_osversion();
  if (osversion_ == &::google::protobuf::internal::kEmptyString) {
    osversion_ = new ::std::string;
  }
  osversion_->assign(value);
}
inline void LinkDeviceInput::set_osversion(const char* value) {
  set_has_osversion();
  if (osversion_ == &::google::protobuf::internal::kEmptyString) {
    osversion_ = new ::std::string;
  }
  osversion_->assign(value);
}
inline void LinkDeviceInput::set_osversion(const char* value, size_t size) {
  set_has_osversion();
  if (osversion_ == &::google::protobuf::internal::kEmptyString) {
    osversion_ = new ::std::string;
  }
  osversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LinkDeviceInput::mutable_osversion() {
  set_has_osversion();
  if (osversion_ == &::google::protobuf::internal::kEmptyString) {
    osversion_ = new ::std::string;
  }
  return osversion_;
}
inline ::std::string* LinkDeviceInput::release_osversion() {
  clear_has_osversion();
  if (osversion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = osversion_;
    osversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string protocolVersion = 9;
inline bool LinkDeviceInput::has_protocolversion() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LinkDeviceInput::set_has_protocolversion() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LinkDeviceInput::clear_has_protocolversion() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LinkDeviceInput::clear_protocolversion() {
  if (protocolversion_ != &::google::protobuf::internal::kEmptyString) {
    protocolversion_->clear();
  }
  clear_has_protocolversion();
}
inline const ::std::string& LinkDeviceInput::protocolversion() const {
  return *protocolversion_;
}
inline void LinkDeviceInput::set_protocolversion(const ::std::string& value) {
  set_has_protocolversion();
  if (protocolversion_ == &::google::protobuf::internal::kEmptyString) {
    protocolversion_ = new ::std::string;
  }
  protocolversion_->assign(value);
}
inline void LinkDeviceInput::set_protocolversion(const char* value) {
  set_has_protocolversion();
  if (protocolversion_ == &::google::protobuf::internal::kEmptyString) {
    protocolversion_ = new ::std::string;
  }
  protocolversion_->assign(value);
}
inline void LinkDeviceInput::set_protocolversion(const char* value, size_t size) {
  set_has_protocolversion();
  if (protocolversion_ == &::google::protobuf::internal::kEmptyString) {
    protocolversion_ = new ::std::string;
  }
  protocolversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LinkDeviceInput::mutable_protocolversion() {
  set_has_protocolversion();
  if (protocolversion_ == &::google::protobuf::internal::kEmptyString) {
    protocolversion_ = new ::std::string;
  }
  return protocolversion_;
}
inline ::std::string* LinkDeviceInput::release_protocolversion() {
  clear_has_protocolversion();
  if (protocolversion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = protocolversion_;
    protocolversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string version = 10;
inline bool LinkDeviceInput::has_version() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LinkDeviceInput::set_has_version() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LinkDeviceInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LinkDeviceInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& LinkDeviceInput::version() const {
  return *version_;
}
inline void LinkDeviceInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void LinkDeviceInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void LinkDeviceInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LinkDeviceInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* LinkDeviceInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string modelNumber = 11;
inline bool LinkDeviceInput::has_modelnumber() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LinkDeviceInput::set_has_modelnumber() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LinkDeviceInput::clear_has_modelnumber() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LinkDeviceInput::clear_modelnumber() {
  if (modelnumber_ != &::google::protobuf::internal::kEmptyString) {
    modelnumber_->clear();
  }
  clear_has_modelnumber();
}
inline const ::std::string& LinkDeviceInput::modelnumber() const {
  return *modelnumber_;
}
inline void LinkDeviceInput::set_modelnumber(const ::std::string& value) {
  set_has_modelnumber();
  if (modelnumber_ == &::google::protobuf::internal::kEmptyString) {
    modelnumber_ = new ::std::string;
  }
  modelnumber_->assign(value);
}
inline void LinkDeviceInput::set_modelnumber(const char* value) {
  set_has_modelnumber();
  if (modelnumber_ == &::google::protobuf::internal::kEmptyString) {
    modelnumber_ = new ::std::string;
  }
  modelnumber_->assign(value);
}
inline void LinkDeviceInput::set_modelnumber(const char* value, size_t size) {
  set_has_modelnumber();
  if (modelnumber_ == &::google::protobuf::internal::kEmptyString) {
    modelnumber_ = new ::std::string;
  }
  modelnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LinkDeviceInput::mutable_modelnumber() {
  set_has_modelnumber();
  if (modelnumber_ == &::google::protobuf::internal::kEmptyString) {
    modelnumber_ = new ::std::string;
  }
  return modelnumber_;
}
inline ::std::string* LinkDeviceInput::release_modelnumber() {
  clear_has_modelnumber();
  if (modelnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = modelnumber_;
    modelnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string buildInfo = 12;
inline bool LinkDeviceInput::has_buildinfo() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void LinkDeviceInput::set_has_buildinfo() {
  _has_bits_[0] |= 0x00000800u;
}
inline void LinkDeviceInput::clear_has_buildinfo() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void LinkDeviceInput::clear_buildinfo() {
  if (buildinfo_ != &::google::protobuf::internal::kEmptyString) {
    buildinfo_->clear();
  }
  clear_has_buildinfo();
}
inline const ::std::string& LinkDeviceInput::buildinfo() const {
  return *buildinfo_;
}
inline void LinkDeviceInput::set_buildinfo(const ::std::string& value) {
  set_has_buildinfo();
  if (buildinfo_ == &::google::protobuf::internal::kEmptyString) {
    buildinfo_ = new ::std::string;
  }
  buildinfo_->assign(value);
}
inline void LinkDeviceInput::set_buildinfo(const char* value) {
  set_has_buildinfo();
  if (buildinfo_ == &::google::protobuf::internal::kEmptyString) {
    buildinfo_ = new ::std::string;
  }
  buildinfo_->assign(value);
}
inline void LinkDeviceInput::set_buildinfo(const char* value, size_t size) {
  set_has_buildinfo();
  if (buildinfo_ == &::google::protobuf::internal::kEmptyString) {
    buildinfo_ = new ::std::string;
  }
  buildinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LinkDeviceInput::mutable_buildinfo() {
  set_has_buildinfo();
  if (buildinfo_ == &::google::protobuf::internal::kEmptyString) {
    buildinfo_ = new ::std::string;
  }
  return buildinfo_;
}
inline ::std::string* LinkDeviceInput::release_buildinfo() {
  clear_has_buildinfo();
  if (buildinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buildinfo_;
    buildinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LinkDeviceOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool LinkDeviceOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LinkDeviceOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LinkDeviceOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LinkDeviceOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& LinkDeviceOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* LinkDeviceOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* LinkDeviceOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// UnlinkDeviceInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool UnlinkDeviceInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnlinkDeviceInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnlinkDeviceInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnlinkDeviceInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& UnlinkDeviceInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* UnlinkDeviceInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* UnlinkDeviceInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 userId = 2;
inline bool UnlinkDeviceInput::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UnlinkDeviceInput::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UnlinkDeviceInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UnlinkDeviceInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 UnlinkDeviceInput::userid() const {
  return userid_;
}
inline void UnlinkDeviceInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required fixed64 deviceId = 3;
inline bool UnlinkDeviceInput::has_deviceid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UnlinkDeviceInput::set_has_deviceid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UnlinkDeviceInput::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UnlinkDeviceInput::clear_deviceid() {
  deviceid_ = GOOGLE_ULONGLONG(0);
  clear_has_deviceid();
}
inline ::google::protobuf::uint64 UnlinkDeviceInput::deviceid() const {
  return deviceid_;
}
inline void UnlinkDeviceInput::set_deviceid(::google::protobuf::uint64 value) {
  set_has_deviceid();
  deviceid_ = value;
}

// optional string version = 4;
inline bool UnlinkDeviceInput::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UnlinkDeviceInput::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UnlinkDeviceInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UnlinkDeviceInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& UnlinkDeviceInput::version() const {
  return *version_;
}
inline void UnlinkDeviceInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void UnlinkDeviceInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void UnlinkDeviceInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnlinkDeviceInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* UnlinkDeviceInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// UnlinkDeviceOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool UnlinkDeviceOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnlinkDeviceOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnlinkDeviceOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnlinkDeviceOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& UnlinkDeviceOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* UnlinkDeviceOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* UnlinkDeviceOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// SetDeviceNameInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool SetDeviceNameInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetDeviceNameInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetDeviceNameInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetDeviceNameInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& SetDeviceNameInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* SetDeviceNameInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* SetDeviceNameInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 userId = 2;
inline bool SetDeviceNameInput::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetDeviceNameInput::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetDeviceNameInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetDeviceNameInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 SetDeviceNameInput::userid() const {
  return userid_;
}
inline void SetDeviceNameInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required fixed64 deviceId = 3;
inline bool SetDeviceNameInput::has_deviceid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SetDeviceNameInput::set_has_deviceid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SetDeviceNameInput::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SetDeviceNameInput::clear_deviceid() {
  deviceid_ = GOOGLE_ULONGLONG(0);
  clear_has_deviceid();
}
inline ::google::protobuf::uint64 SetDeviceNameInput::deviceid() const {
  return deviceid_;
}
inline void SetDeviceNameInput::set_deviceid(::google::protobuf::uint64 value) {
  set_has_deviceid();
  deviceid_ = value;
}

// required string deviceName = 4;
inline bool SetDeviceNameInput::has_devicename() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SetDeviceNameInput::set_has_devicename() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SetDeviceNameInput::clear_has_devicename() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SetDeviceNameInput::clear_devicename() {
  if (devicename_ != &::google::protobuf::internal::kEmptyString) {
    devicename_->clear();
  }
  clear_has_devicename();
}
inline const ::std::string& SetDeviceNameInput::devicename() const {
  return *devicename_;
}
inline void SetDeviceNameInput::set_devicename(const ::std::string& value) {
  set_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    devicename_ = new ::std::string;
  }
  devicename_->assign(value);
}
inline void SetDeviceNameInput::set_devicename(const char* value) {
  set_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    devicename_ = new ::std::string;
  }
  devicename_->assign(value);
}
inline void SetDeviceNameInput::set_devicename(const char* value, size_t size) {
  set_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    devicename_ = new ::std::string;
  }
  devicename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SetDeviceNameInput::mutable_devicename() {
  set_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    devicename_ = new ::std::string;
  }
  return devicename_;
}
inline ::std::string* SetDeviceNameInput::release_devicename() {
  clear_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devicename_;
    devicename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string version = 5;
inline bool SetDeviceNameInput::has_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SetDeviceNameInput::set_has_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SetDeviceNameInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SetDeviceNameInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& SetDeviceNameInput::version() const {
  return *version_;
}
inline void SetDeviceNameInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void SetDeviceNameInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void SetDeviceNameInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SetDeviceNameInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* SetDeviceNameInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// SetDeviceNameOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool SetDeviceNameOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetDeviceNameOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetDeviceNameOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetDeviceNameOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& SetDeviceNameOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* SetDeviceNameOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* SetDeviceNameOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// UpdateDeviceInfoInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool UpdateDeviceInfoInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateDeviceInfoInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateDeviceInfoInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateDeviceInfoInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& UpdateDeviceInfoInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* UpdateDeviceInfoInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* UpdateDeviceInfoInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 userId = 2;
inline bool UpdateDeviceInfoInput::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateDeviceInfoInput::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateDeviceInfoInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateDeviceInfoInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 UpdateDeviceInfoInput::userid() const {
  return userid_;
}
inline void UpdateDeviceInfoInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required fixed64 deviceId = 3;
inline bool UpdateDeviceInfoInput::has_deviceid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateDeviceInfoInput::set_has_deviceid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateDeviceInfoInput::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdateDeviceInfoInput::clear_deviceid() {
  deviceid_ = GOOGLE_ULONGLONG(0);
  clear_has_deviceid();
}
inline ::google::protobuf::uint64 UpdateDeviceInfoInput::deviceid() const {
  return deviceid_;
}
inline void UpdateDeviceInfoInput::set_deviceid(::google::protobuf::uint64 value) {
  set_has_deviceid();
  deviceid_ = value;
}

// optional string deviceName = 4;
inline bool UpdateDeviceInfoInput::has_devicename() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UpdateDeviceInfoInput::set_has_devicename() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UpdateDeviceInfoInput::clear_has_devicename() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UpdateDeviceInfoInput::clear_devicename() {
  if (devicename_ != &::google::protobuf::internal::kEmptyString) {
    devicename_->clear();
  }
  clear_has_devicename();
}
inline const ::std::string& UpdateDeviceInfoInput::devicename() const {
  return *devicename_;
}
inline void UpdateDeviceInfoInput::set_devicename(const ::std::string& value) {
  set_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    devicename_ = new ::std::string;
  }
  devicename_->assign(value);
}
inline void UpdateDeviceInfoInput::set_devicename(const char* value) {
  set_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    devicename_ = new ::std::string;
  }
  devicename_->assign(value);
}
inline void UpdateDeviceInfoInput::set_devicename(const char* value, size_t size) {
  set_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    devicename_ = new ::std::string;
  }
  devicename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateDeviceInfoInput::mutable_devicename() {
  set_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    devicename_ = new ::std::string;
  }
  return devicename_;
}
inline ::std::string* UpdateDeviceInfoInput::release_devicename() {
  clear_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devicename_;
    devicename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string osVersion = 5;
inline bool UpdateDeviceInfoInput::has_osversion() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UpdateDeviceInfoInput::set_has_osversion() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UpdateDeviceInfoInput::clear_has_osversion() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UpdateDeviceInfoInput::clear_osversion() {
  if (osversion_ != &::google::protobuf::internal::kEmptyString) {
    osversion_->clear();
  }
  clear_has_osversion();
}
inline const ::std::string& UpdateDeviceInfoInput::osversion() const {
  return *osversion_;
}
inline void UpdateDeviceInfoInput::set_osversion(const ::std::string& value) {
  set_has_osversion();
  if (osversion_ == &::google::protobuf::internal::kEmptyString) {
    osversion_ = new ::std::string;
  }
  osversion_->assign(value);
}
inline void UpdateDeviceInfoInput::set_osversion(const char* value) {
  set_has_osversion();
  if (osversion_ == &::google::protobuf::internal::kEmptyString) {
    osversion_ = new ::std::string;
  }
  osversion_->assign(value);
}
inline void UpdateDeviceInfoInput::set_osversion(const char* value, size_t size) {
  set_has_osversion();
  if (osversion_ == &::google::protobuf::internal::kEmptyString) {
    osversion_ = new ::std::string;
  }
  osversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateDeviceInfoInput::mutable_osversion() {
  set_has_osversion();
  if (osversion_ == &::google::protobuf::internal::kEmptyString) {
    osversion_ = new ::std::string;
  }
  return osversion_;
}
inline ::std::string* UpdateDeviceInfoInput::release_osversion() {
  clear_has_osversion();
  if (osversion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = osversion_;
    osversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string protocolVersion = 6;
inline bool UpdateDeviceInfoInput::has_protocolversion() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UpdateDeviceInfoInput::set_has_protocolversion() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UpdateDeviceInfoInput::clear_has_protocolversion() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UpdateDeviceInfoInput::clear_protocolversion() {
  if (protocolversion_ != &::google::protobuf::internal::kEmptyString) {
    protocolversion_->clear();
  }
  clear_has_protocolversion();
}
inline const ::std::string& UpdateDeviceInfoInput::protocolversion() const {
  return *protocolversion_;
}
inline void UpdateDeviceInfoInput::set_protocolversion(const ::std::string& value) {
  set_has_protocolversion();
  if (protocolversion_ == &::google::protobuf::internal::kEmptyString) {
    protocolversion_ = new ::std::string;
  }
  protocolversion_->assign(value);
}
inline void UpdateDeviceInfoInput::set_protocolversion(const char* value) {
  set_has_protocolversion();
  if (protocolversion_ == &::google::protobuf::internal::kEmptyString) {
    protocolversion_ = new ::std::string;
  }
  protocolversion_->assign(value);
}
inline void UpdateDeviceInfoInput::set_protocolversion(const char* value, size_t size) {
  set_has_protocolversion();
  if (protocolversion_ == &::google::protobuf::internal::kEmptyString) {
    protocolversion_ = new ::std::string;
  }
  protocolversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateDeviceInfoInput::mutable_protocolversion() {
  set_has_protocolversion();
  if (protocolversion_ == &::google::protobuf::internal::kEmptyString) {
    protocolversion_ = new ::std::string;
  }
  return protocolversion_;
}
inline ::std::string* UpdateDeviceInfoInput::release_protocolversion() {
  clear_has_protocolversion();
  if (protocolversion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = protocolversion_;
    protocolversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string version = 7;
inline bool UpdateDeviceInfoInput::has_version() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UpdateDeviceInfoInput::set_has_version() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UpdateDeviceInfoInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UpdateDeviceInfoInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& UpdateDeviceInfoInput::version() const {
  return *version_;
}
inline void UpdateDeviceInfoInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void UpdateDeviceInfoInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void UpdateDeviceInfoInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateDeviceInfoInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* UpdateDeviceInfoInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string modelNumber = 8;
inline bool UpdateDeviceInfoInput::has_modelnumber() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UpdateDeviceInfoInput::set_has_modelnumber() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UpdateDeviceInfoInput::clear_has_modelnumber() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UpdateDeviceInfoInput::clear_modelnumber() {
  if (modelnumber_ != &::google::protobuf::internal::kEmptyString) {
    modelnumber_->clear();
  }
  clear_has_modelnumber();
}
inline const ::std::string& UpdateDeviceInfoInput::modelnumber() const {
  return *modelnumber_;
}
inline void UpdateDeviceInfoInput::set_modelnumber(const ::std::string& value) {
  set_has_modelnumber();
  if (modelnumber_ == &::google::protobuf::internal::kEmptyString) {
    modelnumber_ = new ::std::string;
  }
  modelnumber_->assign(value);
}
inline void UpdateDeviceInfoInput::set_modelnumber(const char* value) {
  set_has_modelnumber();
  if (modelnumber_ == &::google::protobuf::internal::kEmptyString) {
    modelnumber_ = new ::std::string;
  }
  modelnumber_->assign(value);
}
inline void UpdateDeviceInfoInput::set_modelnumber(const char* value, size_t size) {
  set_has_modelnumber();
  if (modelnumber_ == &::google::protobuf::internal::kEmptyString) {
    modelnumber_ = new ::std::string;
  }
  modelnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateDeviceInfoInput::mutable_modelnumber() {
  set_has_modelnumber();
  if (modelnumber_ == &::google::protobuf::internal::kEmptyString) {
    modelnumber_ = new ::std::string;
  }
  return modelnumber_;
}
inline ::std::string* UpdateDeviceInfoInput::release_modelnumber() {
  clear_has_modelnumber();
  if (modelnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = modelnumber_;
    modelnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string buildInfo = 9;
inline bool UpdateDeviceInfoInput::has_buildinfo() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UpdateDeviceInfoInput::set_has_buildinfo() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UpdateDeviceInfoInput::clear_has_buildinfo() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UpdateDeviceInfoInput::clear_buildinfo() {
  if (buildinfo_ != &::google::protobuf::internal::kEmptyString) {
    buildinfo_->clear();
  }
  clear_has_buildinfo();
}
inline const ::std::string& UpdateDeviceInfoInput::buildinfo() const {
  return *buildinfo_;
}
inline void UpdateDeviceInfoInput::set_buildinfo(const ::std::string& value) {
  set_has_buildinfo();
  if (buildinfo_ == &::google::protobuf::internal::kEmptyString) {
    buildinfo_ = new ::std::string;
  }
  buildinfo_->assign(value);
}
inline void UpdateDeviceInfoInput::set_buildinfo(const char* value) {
  set_has_buildinfo();
  if (buildinfo_ == &::google::protobuf::internal::kEmptyString) {
    buildinfo_ = new ::std::string;
  }
  buildinfo_->assign(value);
}
inline void UpdateDeviceInfoInput::set_buildinfo(const char* value, size_t size) {
  set_has_buildinfo();
  if (buildinfo_ == &::google::protobuf::internal::kEmptyString) {
    buildinfo_ = new ::std::string;
  }
  buildinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateDeviceInfoInput::mutable_buildinfo() {
  set_has_buildinfo();
  if (buildinfo_ == &::google::protobuf::internal::kEmptyString) {
    buildinfo_ = new ::std::string;
  }
  return buildinfo_;
}
inline ::std::string* UpdateDeviceInfoInput::release_buildinfo() {
  clear_has_buildinfo();
  if (buildinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buildinfo_;
    buildinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// UpdateDeviceInfoOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool UpdateDeviceInfoOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateDeviceInfoOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateDeviceInfoOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateDeviceInfoOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& UpdateDeviceInfoOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* UpdateDeviceInfoOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* UpdateDeviceInfoOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// GetDeviceLinkStateInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool GetDeviceLinkStateInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetDeviceLinkStateInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetDeviceLinkStateInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetDeviceLinkStateInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& GetDeviceLinkStateInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* GetDeviceLinkStateInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* GetDeviceLinkStateInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 userId = 2;
inline bool GetDeviceLinkStateInput::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetDeviceLinkStateInput::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetDeviceLinkStateInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetDeviceLinkStateInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 GetDeviceLinkStateInput::userid() const {
  return userid_;
}
inline void GetDeviceLinkStateInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required fixed64 deviceId = 3;
inline bool GetDeviceLinkStateInput::has_deviceid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetDeviceLinkStateInput::set_has_deviceid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetDeviceLinkStateInput::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetDeviceLinkStateInput::clear_deviceid() {
  deviceid_ = GOOGLE_ULONGLONG(0);
  clear_has_deviceid();
}
inline ::google::protobuf::uint64 GetDeviceLinkStateInput::deviceid() const {
  return deviceid_;
}
inline void GetDeviceLinkStateInput::set_deviceid(::google::protobuf::uint64 value) {
  set_has_deviceid();
  deviceid_ = value;
}

// optional string version = 4;
inline bool GetDeviceLinkStateInput::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetDeviceLinkStateInput::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetDeviceLinkStateInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetDeviceLinkStateInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& GetDeviceLinkStateInput::version() const {
  return *version_;
}
inline void GetDeviceLinkStateInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetDeviceLinkStateInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetDeviceLinkStateInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetDeviceLinkStateInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* GetDeviceLinkStateInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetDeviceLinkStateOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool GetDeviceLinkStateOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetDeviceLinkStateOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetDeviceLinkStateOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetDeviceLinkStateOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& GetDeviceLinkStateOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* GetDeviceLinkStateOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* GetDeviceLinkStateOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// required bool linked = 2;
inline bool GetDeviceLinkStateOutput::has_linked() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetDeviceLinkStateOutput::set_has_linked() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetDeviceLinkStateOutput::clear_has_linked() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetDeviceLinkStateOutput::clear_linked() {
  linked_ = false;
  clear_has_linked();
}
inline bool GetDeviceLinkStateOutput::linked() const {
  return linked_;
}
inline void GetDeviceLinkStateOutput::set_linked(bool value) {
  set_has_linked();
  linked_ = value;
}

// -------------------------------------------------------------------

// GetDeviceNameInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool GetDeviceNameInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetDeviceNameInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetDeviceNameInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetDeviceNameInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& GetDeviceNameInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* GetDeviceNameInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* GetDeviceNameInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 userId = 2;
inline bool GetDeviceNameInput::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetDeviceNameInput::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetDeviceNameInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetDeviceNameInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 GetDeviceNameInput::userid() const {
  return userid_;
}
inline void GetDeviceNameInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required fixed64 deviceId = 3;
inline bool GetDeviceNameInput::has_deviceid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetDeviceNameInput::set_has_deviceid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetDeviceNameInput::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetDeviceNameInput::clear_deviceid() {
  deviceid_ = GOOGLE_ULONGLONG(0);
  clear_has_deviceid();
}
inline ::google::protobuf::uint64 GetDeviceNameInput::deviceid() const {
  return deviceid_;
}
inline void GetDeviceNameInput::set_deviceid(::google::protobuf::uint64 value) {
  set_has_deviceid();
  deviceid_ = value;
}

// optional string version = 4;
inline bool GetDeviceNameInput::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetDeviceNameInput::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetDeviceNameInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetDeviceNameInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& GetDeviceNameInput::version() const {
  return *version_;
}
inline void GetDeviceNameInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetDeviceNameInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetDeviceNameInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetDeviceNameInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* GetDeviceNameInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetDeviceNameOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool GetDeviceNameOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetDeviceNameOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetDeviceNameOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetDeviceNameOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& GetDeviceNameOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* GetDeviceNameOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* GetDeviceNameOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// optional string deviceName = 2;
inline bool GetDeviceNameOutput::has_devicename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetDeviceNameOutput::set_has_devicename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetDeviceNameOutput::clear_has_devicename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetDeviceNameOutput::clear_devicename() {
  if (devicename_ != &::google::protobuf::internal::kEmptyString) {
    devicename_->clear();
  }
  clear_has_devicename();
}
inline const ::std::string& GetDeviceNameOutput::devicename() const {
  return *devicename_;
}
inline void GetDeviceNameOutput::set_devicename(const ::std::string& value) {
  set_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    devicename_ = new ::std::string;
  }
  devicename_->assign(value);
}
inline void GetDeviceNameOutput::set_devicename(const char* value) {
  set_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    devicename_ = new ::std::string;
  }
  devicename_->assign(value);
}
inline void GetDeviceNameOutput::set_devicename(const char* value, size_t size) {
  set_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    devicename_ = new ::std::string;
  }
  devicename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetDeviceNameOutput::mutable_devicename() {
  set_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    devicename_ = new ::std::string;
  }
  return devicename_;
}
inline ::std::string* GetDeviceNameOutput::release_devicename() {
  clear_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devicename_;
    devicename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetLinkedDevicesInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool GetLinkedDevicesInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetLinkedDevicesInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetLinkedDevicesInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetLinkedDevicesInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& GetLinkedDevicesInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* GetLinkedDevicesInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* GetLinkedDevicesInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 userId = 2;
inline bool GetLinkedDevicesInput::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetLinkedDevicesInput::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetLinkedDevicesInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetLinkedDevicesInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 GetLinkedDevicesInput::userid() const {
  return userid_;
}
inline void GetLinkedDevicesInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// optional string version = 3;
inline bool GetLinkedDevicesInput::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetLinkedDevicesInput::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetLinkedDevicesInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetLinkedDevicesInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& GetLinkedDevicesInput::version() const {
  return *version_;
}
inline void GetLinkedDevicesInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetLinkedDevicesInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetLinkedDevicesInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetLinkedDevicesInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* GetLinkedDevicesInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetLinkedDevicesOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool GetLinkedDevicesOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetLinkedDevicesOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetLinkedDevicesOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetLinkedDevicesOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& GetLinkedDevicesOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* GetLinkedDevicesOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* GetLinkedDevicesOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// repeated .vplex.vsDirectory.DeviceInfo devices = 2;
inline int GetLinkedDevicesOutput::devices_size() const {
  return devices_.size();
}
inline void GetLinkedDevicesOutput::clear_devices() {
  devices_.Clear();
}
inline const ::vplex::vsDirectory::DeviceInfo& GetLinkedDevicesOutput::devices(int index) const {
  return devices_.Get(index);
}
inline ::vplex::vsDirectory::DeviceInfo* GetLinkedDevicesOutput::mutable_devices(int index) {
  return devices_.Mutable(index);
}
inline ::vplex::vsDirectory::DeviceInfo* GetLinkedDevicesOutput::add_devices() {
  return devices_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::DeviceInfo >&
GetLinkedDevicesOutput::devices() const {
  return devices_;
}
inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::DeviceInfo >*
GetLinkedDevicesOutput::mutable_devices() {
  return &devices_;
}

// -------------------------------------------------------------------

// GetLoginSessionInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool GetLoginSessionInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetLoginSessionInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetLoginSessionInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetLoginSessionInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& GetLoginSessionInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* GetLoginSessionInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* GetLoginSessionInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 userId = 2;
inline bool GetLoginSessionInput::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetLoginSessionInput::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetLoginSessionInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetLoginSessionInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 GetLoginSessionInput::userid() const {
  return userid_;
}
inline void GetLoginSessionInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// optional fixed64 deviceId = 3;
inline bool GetLoginSessionInput::has_deviceid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetLoginSessionInput::set_has_deviceid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetLoginSessionInput::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetLoginSessionInput::clear_deviceid() {
  deviceid_ = GOOGLE_ULONGLONG(0);
  clear_has_deviceid();
}
inline ::google::protobuf::uint64 GetLoginSessionInput::deviceid() const {
  return deviceid_;
}
inline void GetLoginSessionInput::set_deviceid(::google::protobuf::uint64 value) {
  set_has_deviceid();
  deviceid_ = value;
}

// required fixed64 sessionHandle = 4;
inline bool GetLoginSessionInput::has_sessionhandle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetLoginSessionInput::set_has_sessionhandle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetLoginSessionInput::clear_has_sessionhandle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetLoginSessionInput::clear_sessionhandle() {
  sessionhandle_ = GOOGLE_ULONGLONG(0);
  clear_has_sessionhandle();
}
inline ::google::protobuf::uint64 GetLoginSessionInput::sessionhandle() const {
  return sessionhandle_;
}
inline void GetLoginSessionInput::set_sessionhandle(::google::protobuf::uint64 value) {
  set_has_sessionhandle();
  sessionhandle_ = value;
}

// optional string version = 5;
inline bool GetLoginSessionInput::has_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetLoginSessionInput::set_has_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetLoginSessionInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetLoginSessionInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& GetLoginSessionInput::version() const {
  return *version_;
}
inline void GetLoginSessionInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetLoginSessionInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetLoginSessionInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetLoginSessionInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* GetLoginSessionInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetLoginSessionOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool GetLoginSessionOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetLoginSessionOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetLoginSessionOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetLoginSessionOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& GetLoginSessionOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* GetLoginSessionOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* GetLoginSessionOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// optional fixed64 userId = 2;
inline bool GetLoginSessionOutput::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetLoginSessionOutput::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetLoginSessionOutput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetLoginSessionOutput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 GetLoginSessionOutput::userid() const {
  return userid_;
}
inline void GetLoginSessionOutput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// optional bytes serviceTicket = 3;
inline bool GetLoginSessionOutput::has_serviceticket() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetLoginSessionOutput::set_has_serviceticket() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetLoginSessionOutput::clear_has_serviceticket() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetLoginSessionOutput::clear_serviceticket() {
  if (serviceticket_ != &::google::protobuf::internal::kEmptyString) {
    serviceticket_->clear();
  }
  clear_has_serviceticket();
}
inline const ::std::string& GetLoginSessionOutput::serviceticket() const {
  return *serviceticket_;
}
inline void GetLoginSessionOutput::set_serviceticket(const ::std::string& value) {
  set_has_serviceticket();
  if (serviceticket_ == &::google::protobuf::internal::kEmptyString) {
    serviceticket_ = new ::std::string;
  }
  serviceticket_->assign(value);
}
inline void GetLoginSessionOutput::set_serviceticket(const char* value) {
  set_has_serviceticket();
  if (serviceticket_ == &::google::protobuf::internal::kEmptyString) {
    serviceticket_ = new ::std::string;
  }
  serviceticket_->assign(value);
}
inline void GetLoginSessionOutput::set_serviceticket(const void* value, size_t size) {
  set_has_serviceticket();
  if (serviceticket_ == &::google::protobuf::internal::kEmptyString) {
    serviceticket_ = new ::std::string;
  }
  serviceticket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetLoginSessionOutput::mutable_serviceticket() {
  set_has_serviceticket();
  if (serviceticket_ == &::google::protobuf::internal::kEmptyString) {
    serviceticket_ = new ::std::string;
  }
  return serviceticket_;
}
inline ::std::string* GetLoginSessionOutput::release_serviceticket() {
  clear_has_serviceticket();
  if (serviceticket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serviceticket_;
    serviceticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// CreatePersonalStorageNodeInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool CreatePersonalStorageNodeInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreatePersonalStorageNodeInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreatePersonalStorageNodeInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreatePersonalStorageNodeInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& CreatePersonalStorageNodeInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* CreatePersonalStorageNodeInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* CreatePersonalStorageNodeInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 userId = 2;
inline bool CreatePersonalStorageNodeInput::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreatePersonalStorageNodeInput::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreatePersonalStorageNodeInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreatePersonalStorageNodeInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 CreatePersonalStorageNodeInput::userid() const {
  return userid_;
}
inline void CreatePersonalStorageNodeInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required fixed64 clusterId = 3;
inline bool CreatePersonalStorageNodeInput::has_clusterid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreatePersonalStorageNodeInput::set_has_clusterid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreatePersonalStorageNodeInput::clear_has_clusterid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreatePersonalStorageNodeInput::clear_clusterid() {
  clusterid_ = GOOGLE_ULONGLONG(0);
  clear_has_clusterid();
}
inline ::google::protobuf::uint64 CreatePersonalStorageNodeInput::clusterid() const {
  return clusterid_;
}
inline void CreatePersonalStorageNodeInput::set_clusterid(::google::protobuf::uint64 value) {
  set_has_clusterid();
  clusterid_ = value;
}

// required string clusterName = 4;
inline bool CreatePersonalStorageNodeInput::has_clustername() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CreatePersonalStorageNodeInput::set_has_clustername() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CreatePersonalStorageNodeInput::clear_has_clustername() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CreatePersonalStorageNodeInput::clear_clustername() {
  if (clustername_ != &::google::protobuf::internal::kEmptyString) {
    clustername_->clear();
  }
  clear_has_clustername();
}
inline const ::std::string& CreatePersonalStorageNodeInput::clustername() const {
  return *clustername_;
}
inline void CreatePersonalStorageNodeInput::set_clustername(const ::std::string& value) {
  set_has_clustername();
  if (clustername_ == &::google::protobuf::internal::kEmptyString) {
    clustername_ = new ::std::string;
  }
  clustername_->assign(value);
}
inline void CreatePersonalStorageNodeInput::set_clustername(const char* value) {
  set_has_clustername();
  if (clustername_ == &::google::protobuf::internal::kEmptyString) {
    clustername_ = new ::std::string;
  }
  clustername_->assign(value);
}
inline void CreatePersonalStorageNodeInput::set_clustername(const char* value, size_t size) {
  set_has_clustername();
  if (clustername_ == &::google::protobuf::internal::kEmptyString) {
    clustername_ = new ::std::string;
  }
  clustername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreatePersonalStorageNodeInput::mutable_clustername() {
  set_has_clustername();
  if (clustername_ == &::google::protobuf::internal::kEmptyString) {
    clustername_ = new ::std::string;
  }
  return clustername_;
}
inline ::std::string* CreatePersonalStorageNodeInput::release_clustername() {
  clear_has_clustername();
  if (clustername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clustername_;
    clustername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool virtDriveCapable = 5;
inline bool CreatePersonalStorageNodeInput::has_virtdrivecapable() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CreatePersonalStorageNodeInput::set_has_virtdrivecapable() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CreatePersonalStorageNodeInput::clear_has_virtdrivecapable() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CreatePersonalStorageNodeInput::clear_virtdrivecapable() {
  virtdrivecapable_ = false;
  clear_has_virtdrivecapable();
}
inline bool CreatePersonalStorageNodeInput::virtdrivecapable() const {
  return virtdrivecapable_;
}
inline void CreatePersonalStorageNodeInput::set_virtdrivecapable(bool value) {
  set_has_virtdrivecapable();
  virtdrivecapable_ = value;
}

// optional bool mediaServerCapable = 6;
inline bool CreatePersonalStorageNodeInput::has_mediaservercapable() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CreatePersonalStorageNodeInput::set_has_mediaservercapable() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CreatePersonalStorageNodeInput::clear_has_mediaservercapable() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CreatePersonalStorageNodeInput::clear_mediaservercapable() {
  mediaservercapable_ = false;
  clear_has_mediaservercapable();
}
inline bool CreatePersonalStorageNodeInput::mediaservercapable() const {
  return mediaservercapable_;
}
inline void CreatePersonalStorageNodeInput::set_mediaservercapable(bool value) {
  set_has_mediaservercapable();
  mediaservercapable_ = value;
}

// optional bool featureMediaServerCapable = 7;
inline bool CreatePersonalStorageNodeInput::has_featuremediaservercapable() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CreatePersonalStorageNodeInput::set_has_featuremediaservercapable() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CreatePersonalStorageNodeInput::clear_has_featuremediaservercapable() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CreatePersonalStorageNodeInput::clear_featuremediaservercapable() {
  featuremediaservercapable_ = false;
  clear_has_featuremediaservercapable();
}
inline bool CreatePersonalStorageNodeInput::featuremediaservercapable() const {
  return featuremediaservercapable_;
}
inline void CreatePersonalStorageNodeInput::set_featuremediaservercapable(bool value) {
  set_has_featuremediaservercapable();
  featuremediaservercapable_ = value;
}

// optional bool featureVirtDriveCapable = 8;
inline bool CreatePersonalStorageNodeInput::has_featurevirtdrivecapable() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CreatePersonalStorageNodeInput::set_has_featurevirtdrivecapable() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CreatePersonalStorageNodeInput::clear_has_featurevirtdrivecapable() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CreatePersonalStorageNodeInput::clear_featurevirtdrivecapable() {
  featurevirtdrivecapable_ = false;
  clear_has_featurevirtdrivecapable();
}
inline bool CreatePersonalStorageNodeInput::featurevirtdrivecapable() const {
  return featurevirtdrivecapable_;
}
inline void CreatePersonalStorageNodeInput::set_featurevirtdrivecapable(bool value) {
  set_has_featurevirtdrivecapable();
  featurevirtdrivecapable_ = value;
}

// optional bool featureRemoteFileAccessCapable = 9;
inline bool CreatePersonalStorageNodeInput::has_featureremotefileaccesscapable() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CreatePersonalStorageNodeInput::set_has_featureremotefileaccesscapable() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CreatePersonalStorageNodeInput::clear_has_featureremotefileaccesscapable() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CreatePersonalStorageNodeInput::clear_featureremotefileaccesscapable() {
  featureremotefileaccesscapable_ = false;
  clear_has_featureremotefileaccesscapable();
}
inline bool CreatePersonalStorageNodeInput::featureremotefileaccesscapable() const {
  return featureremotefileaccesscapable_;
}
inline void CreatePersonalStorageNodeInput::set_featureremotefileaccesscapable(bool value) {
  set_has_featureremotefileaccesscapable();
  featureremotefileaccesscapable_ = value;
}

// optional bool featureFSDatasetTypeCapable = 10;
inline bool CreatePersonalStorageNodeInput::has_featurefsdatasettypecapable() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CreatePersonalStorageNodeInput::set_has_featurefsdatasettypecapable() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CreatePersonalStorageNodeInput::clear_has_featurefsdatasettypecapable() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CreatePersonalStorageNodeInput::clear_featurefsdatasettypecapable() {
  featurefsdatasettypecapable_ = false;
  clear_has_featurefsdatasettypecapable();
}
inline bool CreatePersonalStorageNodeInput::featurefsdatasettypecapable() const {
  return featurefsdatasettypecapable_;
}
inline void CreatePersonalStorageNodeInput::set_featurefsdatasettypecapable(bool value) {
  set_has_featurefsdatasettypecapable();
  featurefsdatasettypecapable_ = value;
}

// optional string version = 11;
inline bool CreatePersonalStorageNodeInput::has_version() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CreatePersonalStorageNodeInput::set_has_version() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CreatePersonalStorageNodeInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CreatePersonalStorageNodeInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& CreatePersonalStorageNodeInput::version() const {
  return *version_;
}
inline void CreatePersonalStorageNodeInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void CreatePersonalStorageNodeInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void CreatePersonalStorageNodeInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreatePersonalStorageNodeInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* CreatePersonalStorageNodeInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool featureVirtSyncCapable = 12;
inline bool CreatePersonalStorageNodeInput::has_featurevirtsynccapable() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CreatePersonalStorageNodeInput::set_has_featurevirtsynccapable() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CreatePersonalStorageNodeInput::clear_has_featurevirtsynccapable() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CreatePersonalStorageNodeInput::clear_featurevirtsynccapable() {
  featurevirtsynccapable_ = false;
  clear_has_featurevirtsynccapable();
}
inline bool CreatePersonalStorageNodeInput::featurevirtsynccapable() const {
  return featurevirtsynccapable_;
}
inline void CreatePersonalStorageNodeInput::set_featurevirtsynccapable(bool value) {
  set_has_featurevirtsynccapable();
  featurevirtsynccapable_ = value;
}

// optional bool featureMyStorageServerCapable = 13;
inline bool CreatePersonalStorageNodeInput::has_featuremystorageservercapable() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CreatePersonalStorageNodeInput::set_has_featuremystorageservercapable() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CreatePersonalStorageNodeInput::clear_has_featuremystorageservercapable() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CreatePersonalStorageNodeInput::clear_featuremystorageservercapable() {
  featuremystorageservercapable_ = false;
  clear_has_featuremystorageservercapable();
}
inline bool CreatePersonalStorageNodeInput::featuremystorageservercapable() const {
  return featuremystorageservercapable_;
}
inline void CreatePersonalStorageNodeInput::set_featuremystorageservercapable(bool value) {
  set_has_featuremystorageservercapable();
  featuremystorageservercapable_ = value;
}

// -------------------------------------------------------------------

// CreatePersonalStorageNodeOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool CreatePersonalStorageNodeOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreatePersonalStorageNodeOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreatePersonalStorageNodeOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreatePersonalStorageNodeOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& CreatePersonalStorageNodeOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* CreatePersonalStorageNodeOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* CreatePersonalStorageNodeOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// GetAsyncNoticeServerInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool GetAsyncNoticeServerInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetAsyncNoticeServerInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetAsyncNoticeServerInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetAsyncNoticeServerInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& GetAsyncNoticeServerInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* GetAsyncNoticeServerInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* GetAsyncNoticeServerInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 userId = 2;
inline bool GetAsyncNoticeServerInput::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetAsyncNoticeServerInput::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetAsyncNoticeServerInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetAsyncNoticeServerInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 GetAsyncNoticeServerInput::userid() const {
  return userid_;
}
inline void GetAsyncNoticeServerInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required fixed64 clusterId = 3;
inline bool GetAsyncNoticeServerInput::has_clusterid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetAsyncNoticeServerInput::set_has_clusterid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetAsyncNoticeServerInput::clear_has_clusterid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetAsyncNoticeServerInput::clear_clusterid() {
  clusterid_ = GOOGLE_ULONGLONG(0);
  clear_has_clusterid();
}
inline ::google::protobuf::uint64 GetAsyncNoticeServerInput::clusterid() const {
  return clusterid_;
}
inline void GetAsyncNoticeServerInput::set_clusterid(::google::protobuf::uint64 value) {
  set_has_clusterid();
  clusterid_ = value;
}

// optional string version = 4;
inline bool GetAsyncNoticeServerInput::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetAsyncNoticeServerInput::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetAsyncNoticeServerInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetAsyncNoticeServerInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& GetAsyncNoticeServerInput::version() const {
  return *version_;
}
inline void GetAsyncNoticeServerInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetAsyncNoticeServerInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetAsyncNoticeServerInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetAsyncNoticeServerInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* GetAsyncNoticeServerInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetAsyncNoticeServerOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool GetAsyncNoticeServerOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetAsyncNoticeServerOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetAsyncNoticeServerOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetAsyncNoticeServerOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& GetAsyncNoticeServerOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* GetAsyncNoticeServerOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* GetAsyncNoticeServerOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// optional string address = 2;
inline bool GetAsyncNoticeServerOutput::has_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetAsyncNoticeServerOutput::set_has_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetAsyncNoticeServerOutput::clear_has_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetAsyncNoticeServerOutput::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& GetAsyncNoticeServerOutput::address() const {
  return *address_;
}
inline void GetAsyncNoticeServerOutput::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void GetAsyncNoticeServerOutput::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void GetAsyncNoticeServerOutput::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetAsyncNoticeServerOutput::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* GetAsyncNoticeServerOutput::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 port = 3;
inline bool GetAsyncNoticeServerOutput::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetAsyncNoticeServerOutput::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetAsyncNoticeServerOutput::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetAsyncNoticeServerOutput::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 GetAsyncNoticeServerOutput::port() const {
  return port_;
}
inline void GetAsyncNoticeServerOutput::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// optional fixed64 clusterId = 4;
inline bool GetAsyncNoticeServerOutput::has_clusterid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetAsyncNoticeServerOutput::set_has_clusterid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetAsyncNoticeServerOutput::clear_has_clusterid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetAsyncNoticeServerOutput::clear_clusterid() {
  clusterid_ = GOOGLE_ULONGLONG(0);
  clear_has_clusterid();
}
inline ::google::protobuf::uint64 GetAsyncNoticeServerOutput::clusterid() const {
  return clusterid_;
}
inline void GetAsyncNoticeServerOutput::set_clusterid(::google::protobuf::uint64 value) {
  set_has_clusterid();
  clusterid_ = value;
}

// -------------------------------------------------------------------

// UpdateStorageNodeConnectionInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool UpdateStorageNodeConnectionInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateStorageNodeConnectionInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateStorageNodeConnectionInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateStorageNodeConnectionInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& UpdateStorageNodeConnectionInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* UpdateStorageNodeConnectionInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* UpdateStorageNodeConnectionInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 userId = 2;
inline bool UpdateStorageNodeConnectionInput::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateStorageNodeConnectionInput::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateStorageNodeConnectionInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateStorageNodeConnectionInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 UpdateStorageNodeConnectionInput::userid() const {
  return userid_;
}
inline void UpdateStorageNodeConnectionInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required fixed64 clusterId = 3;
inline bool UpdateStorageNodeConnectionInput::has_clusterid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateStorageNodeConnectionInput::set_has_clusterid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateStorageNodeConnectionInput::clear_has_clusterid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdateStorageNodeConnectionInput::clear_clusterid() {
  clusterid_ = GOOGLE_ULONGLONG(0);
  clear_has_clusterid();
}
inline ::google::protobuf::uint64 UpdateStorageNodeConnectionInput::clusterid() const {
  return clusterid_;
}
inline void UpdateStorageNodeConnectionInput::set_clusterid(::google::protobuf::uint64 value) {
  set_has_clusterid();
  clusterid_ = value;
}

// required string reportedName = 4;
inline bool UpdateStorageNodeConnectionInput::has_reportedname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UpdateStorageNodeConnectionInput::set_has_reportedname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UpdateStorageNodeConnectionInput::clear_has_reportedname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UpdateStorageNodeConnectionInput::clear_reportedname() {
  if (reportedname_ != &::google::protobuf::internal::kEmptyString) {
    reportedname_->clear();
  }
  clear_has_reportedname();
}
inline const ::std::string& UpdateStorageNodeConnectionInput::reportedname() const {
  return *reportedname_;
}
inline void UpdateStorageNodeConnectionInput::set_reportedname(const ::std::string& value) {
  set_has_reportedname();
  if (reportedname_ == &::google::protobuf::internal::kEmptyString) {
    reportedname_ = new ::std::string;
  }
  reportedname_->assign(value);
}
inline void UpdateStorageNodeConnectionInput::set_reportedname(const char* value) {
  set_has_reportedname();
  if (reportedname_ == &::google::protobuf::internal::kEmptyString) {
    reportedname_ = new ::std::string;
  }
  reportedname_->assign(value);
}
inline void UpdateStorageNodeConnectionInput::set_reportedname(const char* value, size_t size) {
  set_has_reportedname();
  if (reportedname_ == &::google::protobuf::internal::kEmptyString) {
    reportedname_ = new ::std::string;
  }
  reportedname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateStorageNodeConnectionInput::mutable_reportedname() {
  set_has_reportedname();
  if (reportedname_ == &::google::protobuf::internal::kEmptyString) {
    reportedname_ = new ::std::string;
  }
  return reportedname_;
}
inline ::std::string* UpdateStorageNodeConnectionInput::release_reportedname() {
  clear_has_reportedname();
  if (reportedname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reportedname_;
    reportedname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 reportedPort = 5;
inline bool UpdateStorageNodeConnectionInput::has_reportedport() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UpdateStorageNodeConnectionInput::set_has_reportedport() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UpdateStorageNodeConnectionInput::clear_has_reportedport() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UpdateStorageNodeConnectionInput::clear_reportedport() {
  reportedport_ = 0;
  clear_has_reportedport();
}
inline ::google::protobuf::int32 UpdateStorageNodeConnectionInput::reportedport() const {
  return reportedport_;
}
inline void UpdateStorageNodeConnectionInput::set_reportedport(::google::protobuf::int32 value) {
  set_has_reportedport();
  reportedport_ = value;
}

// required int32 reportedHTTPPort = 6;
inline bool UpdateStorageNodeConnectionInput::has_reportedhttpport() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UpdateStorageNodeConnectionInput::set_has_reportedhttpport() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UpdateStorageNodeConnectionInput::clear_has_reportedhttpport() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UpdateStorageNodeConnectionInput::clear_reportedhttpport() {
  reportedhttpport_ = 0;
  clear_has_reportedhttpport();
}
inline ::google::protobuf::int32 UpdateStorageNodeConnectionInput::reportedhttpport() const {
  return reportedhttpport_;
}
inline void UpdateStorageNodeConnectionInput::set_reportedhttpport(::google::protobuf::int32 value) {
  set_has_reportedhttpport();
  reportedhttpport_ = value;
}

// optional fixed64 proxyClusterId = 7;
inline bool UpdateStorageNodeConnectionInput::has_proxyclusterid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UpdateStorageNodeConnectionInput::set_has_proxyclusterid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UpdateStorageNodeConnectionInput::clear_has_proxyclusterid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UpdateStorageNodeConnectionInput::clear_proxyclusterid() {
  proxyclusterid_ = GOOGLE_ULONGLONG(0);
  clear_has_proxyclusterid();
}
inline ::google::protobuf::uint64 UpdateStorageNodeConnectionInput::proxyclusterid() const {
  return proxyclusterid_;
}
inline void UpdateStorageNodeConnectionInput::set_proxyclusterid(::google::protobuf::uint64 value) {
  set_has_proxyclusterid();
  proxyclusterid_ = value;
}

// optional int32 proxyConnectionCookie = 8;
inline bool UpdateStorageNodeConnectionInput::has_proxyconnectioncookie() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UpdateStorageNodeConnectionInput::set_has_proxyconnectioncookie() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UpdateStorageNodeConnectionInput::clear_has_proxyconnectioncookie() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UpdateStorageNodeConnectionInput::clear_proxyconnectioncookie() {
  proxyconnectioncookie_ = 0;
  clear_has_proxyconnectioncookie();
}
inline ::google::protobuf::int32 UpdateStorageNodeConnectionInput::proxyconnectioncookie() const {
  return proxyconnectioncookie_;
}
inline void UpdateStorageNodeConnectionInput::set_proxyconnectioncookie(::google::protobuf::int32 value) {
  set_has_proxyconnectioncookie();
  proxyconnectioncookie_ = value;
}

// optional int32 reportedClearFiPort = 9;
inline bool UpdateStorageNodeConnectionInput::has_reportedclearfiport() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UpdateStorageNodeConnectionInput::set_has_reportedclearfiport() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UpdateStorageNodeConnectionInput::clear_has_reportedclearfiport() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UpdateStorageNodeConnectionInput::clear_reportedclearfiport() {
  reportedclearfiport_ = 0;
  clear_has_reportedclearfiport();
}
inline ::google::protobuf::int32 UpdateStorageNodeConnectionInput::reportedclearfiport() const {
  return reportedclearfiport_;
}
inline void UpdateStorageNodeConnectionInput::set_reportedclearfiport(::google::protobuf::int32 value) {
  set_has_reportedclearfiport();
  reportedclearfiport_ = value;
}

// optional int32 reportedClearFiSecurePort = 10;
inline bool UpdateStorageNodeConnectionInput::has_reportedclearfisecureport() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UpdateStorageNodeConnectionInput::set_has_reportedclearfisecureport() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UpdateStorageNodeConnectionInput::clear_has_reportedclearfisecureport() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UpdateStorageNodeConnectionInput::clear_reportedclearfisecureport() {
  reportedclearfisecureport_ = 0;
  clear_has_reportedclearfisecureport();
}
inline ::google::protobuf::int32 UpdateStorageNodeConnectionInput::reportedclearfisecureport() const {
  return reportedclearfisecureport_;
}
inline void UpdateStorageNodeConnectionInput::set_reportedclearfisecureport(::google::protobuf::int32 value) {
  set_has_reportedclearfisecureport();
  reportedclearfisecureport_ = value;
}

// optional fixed64 accessHandle = 11;
inline bool UpdateStorageNodeConnectionInput::has_accesshandle() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UpdateStorageNodeConnectionInput::set_has_accesshandle() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UpdateStorageNodeConnectionInput::clear_has_accesshandle() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UpdateStorageNodeConnectionInput::clear_accesshandle() {
  accesshandle_ = GOOGLE_ULONGLONG(0);
  clear_has_accesshandle();
}
inline ::google::protobuf::uint64 UpdateStorageNodeConnectionInput::accesshandle() const {
  return accesshandle_;
}
inline void UpdateStorageNodeConnectionInput::set_accesshandle(::google::protobuf::uint64 value) {
  set_has_accesshandle();
  accesshandle_ = value;
}

// optional bytes accessTicket = 12;
inline bool UpdateStorageNodeConnectionInput::has_accessticket() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UpdateStorageNodeConnectionInput::set_has_accessticket() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UpdateStorageNodeConnectionInput::clear_has_accessticket() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UpdateStorageNodeConnectionInput::clear_accessticket() {
  if (accessticket_ != &::google::protobuf::internal::kEmptyString) {
    accessticket_->clear();
  }
  clear_has_accessticket();
}
inline const ::std::string& UpdateStorageNodeConnectionInput::accessticket() const {
  return *accessticket_;
}
inline void UpdateStorageNodeConnectionInput::set_accessticket(const ::std::string& value) {
  set_has_accessticket();
  if (accessticket_ == &::google::protobuf::internal::kEmptyString) {
    accessticket_ = new ::std::string;
  }
  accessticket_->assign(value);
}
inline void UpdateStorageNodeConnectionInput::set_accessticket(const char* value) {
  set_has_accessticket();
  if (accessticket_ == &::google::protobuf::internal::kEmptyString) {
    accessticket_ = new ::std::string;
  }
  accessticket_->assign(value);
}
inline void UpdateStorageNodeConnectionInput::set_accessticket(const void* value, size_t size) {
  set_has_accessticket();
  if (accessticket_ == &::google::protobuf::internal::kEmptyString) {
    accessticket_ = new ::std::string;
  }
  accessticket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateStorageNodeConnectionInput::mutable_accessticket() {
  set_has_accessticket();
  if (accessticket_ == &::google::protobuf::internal::kEmptyString) {
    accessticket_ = new ::std::string;
  }
  return accessticket_;
}
inline ::std::string* UpdateStorageNodeConnectionInput::release_accessticket() {
  clear_has_accessticket();
  if (accessticket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = accessticket_;
    accessticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .vplex.vsDirectory.DeviceAccessTicket accessTickets = 13;
inline int UpdateStorageNodeConnectionInput::accesstickets_size() const {
  return accesstickets_.size();
}
inline void UpdateStorageNodeConnectionInput::clear_accesstickets() {
  accesstickets_.Clear();
}
inline const ::vplex::vsDirectory::DeviceAccessTicket& UpdateStorageNodeConnectionInput::accesstickets(int index) const {
  return accesstickets_.Get(index);
}
inline ::vplex::vsDirectory::DeviceAccessTicket* UpdateStorageNodeConnectionInput::mutable_accesstickets(int index) {
  return accesstickets_.Mutable(index);
}
inline ::vplex::vsDirectory::DeviceAccessTicket* UpdateStorageNodeConnectionInput::add_accesstickets() {
  return accesstickets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::DeviceAccessTicket >&
UpdateStorageNodeConnectionInput::accesstickets() const {
  return accesstickets_;
}
inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::DeviceAccessTicket >*
UpdateStorageNodeConnectionInput::mutable_accesstickets() {
  return &accesstickets_;
}

// optional string version = 14;
inline bool UpdateStorageNodeConnectionInput::has_version() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void UpdateStorageNodeConnectionInput::set_has_version() {
  _has_bits_[0] |= 0x00002000u;
}
inline void UpdateStorageNodeConnectionInput::clear_has_version() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void UpdateStorageNodeConnectionInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& UpdateStorageNodeConnectionInput::version() const {
  return *version_;
}
inline void UpdateStorageNodeConnectionInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void UpdateStorageNodeConnectionInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void UpdateStorageNodeConnectionInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateStorageNodeConnectionInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* UpdateStorageNodeConnectionInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// UpdateStorageNodeConnectionOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool UpdateStorageNodeConnectionOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateStorageNodeConnectionOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateStorageNodeConnectionOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateStorageNodeConnectionOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& UpdateStorageNodeConnectionOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* UpdateStorageNodeConnectionOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* UpdateStorageNodeConnectionOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// UpdateStorageNodeFeaturesInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool UpdateStorageNodeFeaturesInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateStorageNodeFeaturesInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateStorageNodeFeaturesInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateStorageNodeFeaturesInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& UpdateStorageNodeFeaturesInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* UpdateStorageNodeFeaturesInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* UpdateStorageNodeFeaturesInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 userId = 2;
inline bool UpdateStorageNodeFeaturesInput::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateStorageNodeFeaturesInput::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateStorageNodeFeaturesInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateStorageNodeFeaturesInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 UpdateStorageNodeFeaturesInput::userid() const {
  return userid_;
}
inline void UpdateStorageNodeFeaturesInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required fixed64 clusterId = 3;
inline bool UpdateStorageNodeFeaturesInput::has_clusterid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateStorageNodeFeaturesInput::set_has_clusterid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateStorageNodeFeaturesInput::clear_has_clusterid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdateStorageNodeFeaturesInput::clear_clusterid() {
  clusterid_ = GOOGLE_ULONGLONG(0);
  clear_has_clusterid();
}
inline ::google::protobuf::uint64 UpdateStorageNodeFeaturesInput::clusterid() const {
  return clusterid_;
}
inline void UpdateStorageNodeFeaturesInput::set_clusterid(::google::protobuf::uint64 value) {
  set_has_clusterid();
  clusterid_ = value;
}

// optional bool isVirtDrive = 4;
inline bool UpdateStorageNodeFeaturesInput::has_isvirtdrive() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UpdateStorageNodeFeaturesInput::set_has_isvirtdrive() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UpdateStorageNodeFeaturesInput::clear_has_isvirtdrive() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UpdateStorageNodeFeaturesInput::clear_isvirtdrive() {
  isvirtdrive_ = false;
  clear_has_isvirtdrive();
}
inline bool UpdateStorageNodeFeaturesInput::isvirtdrive() const {
  return isvirtdrive_;
}
inline void UpdateStorageNodeFeaturesInput::set_isvirtdrive(bool value) {
  set_has_isvirtdrive();
  isvirtdrive_ = value;
}

// optional bool isMediaServer = 5;
inline bool UpdateStorageNodeFeaturesInput::has_ismediaserver() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UpdateStorageNodeFeaturesInput::set_has_ismediaserver() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UpdateStorageNodeFeaturesInput::clear_has_ismediaserver() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UpdateStorageNodeFeaturesInput::clear_ismediaserver() {
  ismediaserver_ = false;
  clear_has_ismediaserver();
}
inline bool UpdateStorageNodeFeaturesInput::ismediaserver() const {
  return ismediaserver_;
}
inline void UpdateStorageNodeFeaturesInput::set_ismediaserver(bool value) {
  set_has_ismediaserver();
  ismediaserver_ = value;
}

// optional bool featureMediaServerEnabled = 6;
inline bool UpdateStorageNodeFeaturesInput::has_featuremediaserverenabled() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UpdateStorageNodeFeaturesInput::set_has_featuremediaserverenabled() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UpdateStorageNodeFeaturesInput::clear_has_featuremediaserverenabled() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UpdateStorageNodeFeaturesInput::clear_featuremediaserverenabled() {
  featuremediaserverenabled_ = false;
  clear_has_featuremediaserverenabled();
}
inline bool UpdateStorageNodeFeaturesInput::featuremediaserverenabled() const {
  return featuremediaserverenabled_;
}
inline void UpdateStorageNodeFeaturesInput::set_featuremediaserverenabled(bool value) {
  set_has_featuremediaserverenabled();
  featuremediaserverenabled_ = value;
}

// optional bool featureVirtDriveEnabled = 7;
inline bool UpdateStorageNodeFeaturesInput::has_featurevirtdriveenabled() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UpdateStorageNodeFeaturesInput::set_has_featurevirtdriveenabled() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UpdateStorageNodeFeaturesInput::clear_has_featurevirtdriveenabled() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UpdateStorageNodeFeaturesInput::clear_featurevirtdriveenabled() {
  featurevirtdriveenabled_ = false;
  clear_has_featurevirtdriveenabled();
}
inline bool UpdateStorageNodeFeaturesInput::featurevirtdriveenabled() const {
  return featurevirtdriveenabled_;
}
inline void UpdateStorageNodeFeaturesInput::set_featurevirtdriveenabled(bool value) {
  set_has_featurevirtdriveenabled();
  featurevirtdriveenabled_ = value;
}

// optional bool featureRemoteFileAccessEnabled = 8;
inline bool UpdateStorageNodeFeaturesInput::has_featureremotefileaccessenabled() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UpdateStorageNodeFeaturesInput::set_has_featureremotefileaccessenabled() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UpdateStorageNodeFeaturesInput::clear_has_featureremotefileaccessenabled() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UpdateStorageNodeFeaturesInput::clear_featureremotefileaccessenabled() {
  featureremotefileaccessenabled_ = false;
  clear_has_featureremotefileaccessenabled();
}
inline bool UpdateStorageNodeFeaturesInput::featureremotefileaccessenabled() const {
  return featureremotefileaccessenabled_;
}
inline void UpdateStorageNodeFeaturesInput::set_featureremotefileaccessenabled(bool value) {
  set_has_featureremotefileaccessenabled();
  featureremotefileaccessenabled_ = value;
}

// optional bool featureFSDatasetTypeEnabled = 9;
inline bool UpdateStorageNodeFeaturesInput::has_featurefsdatasettypeenabled() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UpdateStorageNodeFeaturesInput::set_has_featurefsdatasettypeenabled() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UpdateStorageNodeFeaturesInput::clear_has_featurefsdatasettypeenabled() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UpdateStorageNodeFeaturesInput::clear_featurefsdatasettypeenabled() {
  featurefsdatasettypeenabled_ = false;
  clear_has_featurefsdatasettypeenabled();
}
inline bool UpdateStorageNodeFeaturesInput::featurefsdatasettypeenabled() const {
  return featurefsdatasettypeenabled_;
}
inline void UpdateStorageNodeFeaturesInput::set_featurefsdatasettypeenabled(bool value) {
  set_has_featurefsdatasettypeenabled();
  featurefsdatasettypeenabled_ = value;
}

// optional string version = 10;
inline bool UpdateStorageNodeFeaturesInput::has_version() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UpdateStorageNodeFeaturesInput::set_has_version() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UpdateStorageNodeFeaturesInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UpdateStorageNodeFeaturesInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& UpdateStorageNodeFeaturesInput::version() const {
  return *version_;
}
inline void UpdateStorageNodeFeaturesInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void UpdateStorageNodeFeaturesInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void UpdateStorageNodeFeaturesInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateStorageNodeFeaturesInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* UpdateStorageNodeFeaturesInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool featureVirtSyncEnabled = 11;
inline bool UpdateStorageNodeFeaturesInput::has_featurevirtsyncenabled() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UpdateStorageNodeFeaturesInput::set_has_featurevirtsyncenabled() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UpdateStorageNodeFeaturesInput::clear_has_featurevirtsyncenabled() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UpdateStorageNodeFeaturesInput::clear_featurevirtsyncenabled() {
  featurevirtsyncenabled_ = false;
  clear_has_featurevirtsyncenabled();
}
inline bool UpdateStorageNodeFeaturesInput::featurevirtsyncenabled() const {
  return featurevirtsyncenabled_;
}
inline void UpdateStorageNodeFeaturesInput::set_featurevirtsyncenabled(bool value) {
  set_has_featurevirtsyncenabled();
  featurevirtsyncenabled_ = value;
}

// optional bool featureMyStorageServerEnabled = 12;
inline bool UpdateStorageNodeFeaturesInput::has_featuremystorageserverenabled() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UpdateStorageNodeFeaturesInput::set_has_featuremystorageserverenabled() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UpdateStorageNodeFeaturesInput::clear_has_featuremystorageserverenabled() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UpdateStorageNodeFeaturesInput::clear_featuremystorageserverenabled() {
  featuremystorageserverenabled_ = false;
  clear_has_featuremystorageserverenabled();
}
inline bool UpdateStorageNodeFeaturesInput::featuremystorageserverenabled() const {
  return featuremystorageserverenabled_;
}
inline void UpdateStorageNodeFeaturesInput::set_featuremystorageserverenabled(bool value) {
  set_has_featuremystorageserverenabled();
  featuremystorageserverenabled_ = value;
}

// -------------------------------------------------------------------

// UpdateStorageNodeFeaturesOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool UpdateStorageNodeFeaturesOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateStorageNodeFeaturesOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateStorageNodeFeaturesOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateStorageNodeFeaturesOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& UpdateStorageNodeFeaturesOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* UpdateStorageNodeFeaturesOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* UpdateStorageNodeFeaturesOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// GetPSNDatasetLocationInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool GetPSNDatasetLocationInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetPSNDatasetLocationInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetPSNDatasetLocationInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetPSNDatasetLocationInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& GetPSNDatasetLocationInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* GetPSNDatasetLocationInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* GetPSNDatasetLocationInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 userId = 2;
inline bool GetPSNDatasetLocationInput::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetPSNDatasetLocationInput::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetPSNDatasetLocationInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetPSNDatasetLocationInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 GetPSNDatasetLocationInput::userid() const {
  return userid_;
}
inline void GetPSNDatasetLocationInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required fixed64 datasetUserId = 3;
inline bool GetPSNDatasetLocationInput::has_datasetuserid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetPSNDatasetLocationInput::set_has_datasetuserid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetPSNDatasetLocationInput::clear_has_datasetuserid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetPSNDatasetLocationInput::clear_datasetuserid() {
  datasetuserid_ = GOOGLE_ULONGLONG(0);
  clear_has_datasetuserid();
}
inline ::google::protobuf::uint64 GetPSNDatasetLocationInput::datasetuserid() const {
  return datasetuserid_;
}
inline void GetPSNDatasetLocationInput::set_datasetuserid(::google::protobuf::uint64 value) {
  set_has_datasetuserid();
  datasetuserid_ = value;
}

// required fixed64 datasetId = 4;
inline bool GetPSNDatasetLocationInput::has_datasetid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetPSNDatasetLocationInput::set_has_datasetid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetPSNDatasetLocationInput::clear_has_datasetid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetPSNDatasetLocationInput::clear_datasetid() {
  datasetid_ = GOOGLE_ULONGLONG(0);
  clear_has_datasetid();
}
inline ::google::protobuf::uint64 GetPSNDatasetLocationInput::datasetid() const {
  return datasetid_;
}
inline void GetPSNDatasetLocationInput::set_datasetid(::google::protobuf::uint64 value) {
  set_has_datasetid();
  datasetid_ = value;
}

// optional string version = 5;
inline bool GetPSNDatasetLocationInput::has_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetPSNDatasetLocationInput::set_has_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetPSNDatasetLocationInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetPSNDatasetLocationInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& GetPSNDatasetLocationInput::version() const {
  return *version_;
}
inline void GetPSNDatasetLocationInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetPSNDatasetLocationInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetPSNDatasetLocationInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetPSNDatasetLocationInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* GetPSNDatasetLocationInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetPSNDatasetLocationOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool GetPSNDatasetLocationOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetPSNDatasetLocationOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetPSNDatasetLocationOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetPSNDatasetLocationOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& GetPSNDatasetLocationOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* GetPSNDatasetLocationOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* GetPSNDatasetLocationOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// optional fixed64 storageClusterId = 2;
inline bool GetPSNDatasetLocationOutput::has_storageclusterid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetPSNDatasetLocationOutput::set_has_storageclusterid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetPSNDatasetLocationOutput::clear_has_storageclusterid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetPSNDatasetLocationOutput::clear_storageclusterid() {
  storageclusterid_ = GOOGLE_ULONGLONG(0);
  clear_has_storageclusterid();
}
inline ::google::protobuf::uint64 GetPSNDatasetLocationOutput::storageclusterid() const {
  return storageclusterid_;
}
inline void GetPSNDatasetLocationOutput::set_storageclusterid(::google::protobuf::uint64 value) {
  set_has_storageclusterid();
  storageclusterid_ = value;
}

// -------------------------------------------------------------------

// UpdatePSNDatasetStatusInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool UpdatePSNDatasetStatusInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdatePSNDatasetStatusInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdatePSNDatasetStatusInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdatePSNDatasetStatusInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& UpdatePSNDatasetStatusInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* UpdatePSNDatasetStatusInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* UpdatePSNDatasetStatusInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 userId = 2;
inline bool UpdatePSNDatasetStatusInput::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdatePSNDatasetStatusInput::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdatePSNDatasetStatusInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdatePSNDatasetStatusInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 UpdatePSNDatasetStatusInput::userid() const {
  return userid_;
}
inline void UpdatePSNDatasetStatusInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required fixed64 datasetUserId = 3;
inline bool UpdatePSNDatasetStatusInput::has_datasetuserid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdatePSNDatasetStatusInput::set_has_datasetuserid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdatePSNDatasetStatusInput::clear_has_datasetuserid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdatePSNDatasetStatusInput::clear_datasetuserid() {
  datasetuserid_ = GOOGLE_ULONGLONG(0);
  clear_has_datasetuserid();
}
inline ::google::protobuf::uint64 UpdatePSNDatasetStatusInput::datasetuserid() const {
  return datasetuserid_;
}
inline void UpdatePSNDatasetStatusInput::set_datasetuserid(::google::protobuf::uint64 value) {
  set_has_datasetuserid();
  datasetuserid_ = value;
}

// required fixed64 datasetId = 4;
inline bool UpdatePSNDatasetStatusInput::has_datasetid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UpdatePSNDatasetStatusInput::set_has_datasetid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UpdatePSNDatasetStatusInput::clear_has_datasetid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UpdatePSNDatasetStatusInput::clear_datasetid() {
  datasetid_ = GOOGLE_ULONGLONG(0);
  clear_has_datasetid();
}
inline ::google::protobuf::uint64 UpdatePSNDatasetStatusInput::datasetid() const {
  return datasetid_;
}
inline void UpdatePSNDatasetStatusInput::set_datasetid(::google::protobuf::uint64 value) {
  set_has_datasetid();
  datasetid_ = value;
}

// required fixed64 clusterId = 5;
inline bool UpdatePSNDatasetStatusInput::has_clusterid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UpdatePSNDatasetStatusInput::set_has_clusterid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UpdatePSNDatasetStatusInput::clear_has_clusterid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UpdatePSNDatasetStatusInput::clear_clusterid() {
  clusterid_ = GOOGLE_ULONGLONG(0);
  clear_has_clusterid();
}
inline ::google::protobuf::uint64 UpdatePSNDatasetStatusInput::clusterid() const {
  return clusterid_;
}
inline void UpdatePSNDatasetStatusInput::set_clusterid(::google::protobuf::uint64 value) {
  set_has_clusterid();
  clusterid_ = value;
}

// required fixed64 datasetSize = 6;
inline bool UpdatePSNDatasetStatusInput::has_datasetsize() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UpdatePSNDatasetStatusInput::set_has_datasetsize() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UpdatePSNDatasetStatusInput::clear_has_datasetsize() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UpdatePSNDatasetStatusInput::clear_datasetsize() {
  datasetsize_ = GOOGLE_ULONGLONG(0);
  clear_has_datasetsize();
}
inline ::google::protobuf::uint64 UpdatePSNDatasetStatusInput::datasetsize() const {
  return datasetsize_;
}
inline void UpdatePSNDatasetStatusInput::set_datasetsize(::google::protobuf::uint64 value) {
  set_has_datasetsize();
  datasetsize_ = value;
}

// required fixed64 datasetVersion = 7;
inline bool UpdatePSNDatasetStatusInput::has_datasetversion() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UpdatePSNDatasetStatusInput::set_has_datasetversion() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UpdatePSNDatasetStatusInput::clear_has_datasetversion() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UpdatePSNDatasetStatusInput::clear_datasetversion() {
  datasetversion_ = GOOGLE_ULONGLONG(0);
  clear_has_datasetversion();
}
inline ::google::protobuf::uint64 UpdatePSNDatasetStatusInput::datasetversion() const {
  return datasetversion_;
}
inline void UpdatePSNDatasetStatusInput::set_datasetversion(::google::protobuf::uint64 value) {
  set_has_datasetversion();
  datasetversion_ = value;
}

// optional string version = 8;
inline bool UpdatePSNDatasetStatusInput::has_version() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UpdatePSNDatasetStatusInput::set_has_version() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UpdatePSNDatasetStatusInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UpdatePSNDatasetStatusInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& UpdatePSNDatasetStatusInput::version() const {
  return *version_;
}
inline void UpdatePSNDatasetStatusInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void UpdatePSNDatasetStatusInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void UpdatePSNDatasetStatusInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdatePSNDatasetStatusInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* UpdatePSNDatasetStatusInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// UpdatePSNDatasetStatusOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool UpdatePSNDatasetStatusOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdatePSNDatasetStatusOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdatePSNDatasetStatusOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdatePSNDatasetStatusOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& UpdatePSNDatasetStatusOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* UpdatePSNDatasetStatusOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* UpdatePSNDatasetStatusOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// AddUserStorageInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool AddUserStorageInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddUserStorageInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddUserStorageInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddUserStorageInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& AddUserStorageInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* AddUserStorageInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* AddUserStorageInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 userId = 2;
inline bool AddUserStorageInput::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddUserStorageInput::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddUserStorageInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddUserStorageInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 AddUserStorageInput::userid() const {
  return userid_;
}
inline void AddUserStorageInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required fixed64 storageClusterId = 3;
inline bool AddUserStorageInput::has_storageclusterid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AddUserStorageInput::set_has_storageclusterid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AddUserStorageInput::clear_has_storageclusterid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AddUserStorageInput::clear_storageclusterid() {
  storageclusterid_ = GOOGLE_ULONGLONG(0);
  clear_has_storageclusterid();
}
inline ::google::protobuf::uint64 AddUserStorageInput::storageclusterid() const {
  return storageclusterid_;
}
inline void AddUserStorageInput::set_storageclusterid(::google::protobuf::uint64 value) {
  set_has_storageclusterid();
  storageclusterid_ = value;
}

// required string storageName = 4;
inline bool AddUserStorageInput::has_storagename() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AddUserStorageInput::set_has_storagename() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AddUserStorageInput::clear_has_storagename() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AddUserStorageInput::clear_storagename() {
  if (storagename_ != &::google::protobuf::internal::kEmptyString) {
    storagename_->clear();
  }
  clear_has_storagename();
}
inline const ::std::string& AddUserStorageInput::storagename() const {
  return *storagename_;
}
inline void AddUserStorageInput::set_storagename(const ::std::string& value) {
  set_has_storagename();
  if (storagename_ == &::google::protobuf::internal::kEmptyString) {
    storagename_ = new ::std::string;
  }
  storagename_->assign(value);
}
inline void AddUserStorageInput::set_storagename(const char* value) {
  set_has_storagename();
  if (storagename_ == &::google::protobuf::internal::kEmptyString) {
    storagename_ = new ::std::string;
  }
  storagename_->assign(value);
}
inline void AddUserStorageInput::set_storagename(const char* value, size_t size) {
  set_has_storagename();
  if (storagename_ == &::google::protobuf::internal::kEmptyString) {
    storagename_ = new ::std::string;
  }
  storagename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddUserStorageInput::mutable_storagename() {
  set_has_storagename();
  if (storagename_ == &::google::protobuf::internal::kEmptyString) {
    storagename_ = new ::std::string;
  }
  return storagename_;
}
inline ::std::string* AddUserStorageInput::release_storagename() {
  clear_has_storagename();
  if (storagename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = storagename_;
    storagename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required fixed64 usageLimit = 5;
inline bool AddUserStorageInput::has_usagelimit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AddUserStorageInput::set_has_usagelimit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AddUserStorageInput::clear_has_usagelimit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AddUserStorageInput::clear_usagelimit() {
  usagelimit_ = GOOGLE_ULONGLONG(0);
  clear_has_usagelimit();
}
inline ::google::protobuf::uint64 AddUserStorageInput::usagelimit() const {
  return usagelimit_;
}
inline void AddUserStorageInput::set_usagelimit(::google::protobuf::uint64 value) {
  set_has_usagelimit();
  usagelimit_ = value;
}

// optional string version = 6;
inline bool AddUserStorageInput::has_version() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AddUserStorageInput::set_has_version() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AddUserStorageInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AddUserStorageInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& AddUserStorageInput::version() const {
  return *version_;
}
inline void AddUserStorageInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void AddUserStorageInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void AddUserStorageInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddUserStorageInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* AddUserStorageInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AddUserStorageOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool AddUserStorageOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddUserStorageOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddUserStorageOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddUserStorageOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& AddUserStorageOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* AddUserStorageOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* AddUserStorageOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// DeleteUserStorageInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool DeleteUserStorageInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteUserStorageInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteUserStorageInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteUserStorageInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& DeleteUserStorageInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* DeleteUserStorageInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* DeleteUserStorageInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 userId = 2;
inline bool DeleteUserStorageInput::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeleteUserStorageInput::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeleteUserStorageInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeleteUserStorageInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 DeleteUserStorageInput::userid() const {
  return userid_;
}
inline void DeleteUserStorageInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required fixed64 storageClusterId = 3;
inline bool DeleteUserStorageInput::has_storageclusterid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeleteUserStorageInput::set_has_storageclusterid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeleteUserStorageInput::clear_has_storageclusterid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeleteUserStorageInput::clear_storageclusterid() {
  storageclusterid_ = GOOGLE_ULONGLONG(0);
  clear_has_storageclusterid();
}
inline ::google::protobuf::uint64 DeleteUserStorageInput::storageclusterid() const {
  return storageclusterid_;
}
inline void DeleteUserStorageInput::set_storageclusterid(::google::protobuf::uint64 value) {
  set_has_storageclusterid();
  storageclusterid_ = value;
}

// optional string version = 4;
inline bool DeleteUserStorageInput::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeleteUserStorageInput::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DeleteUserStorageInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DeleteUserStorageInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& DeleteUserStorageInput::version() const {
  return *version_;
}
inline void DeleteUserStorageInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void DeleteUserStorageInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void DeleteUserStorageInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeleteUserStorageInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* DeleteUserStorageInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// DeleteUserStorageOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool DeleteUserStorageOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteUserStorageOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteUserStorageOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteUserStorageOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& DeleteUserStorageOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* DeleteUserStorageOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* DeleteUserStorageOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ChangeUserStorageNameInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool ChangeUserStorageNameInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeUserStorageNameInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeUserStorageNameInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeUserStorageNameInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& ChangeUserStorageNameInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* ChangeUserStorageNameInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* ChangeUserStorageNameInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 userId = 2;
inline bool ChangeUserStorageNameInput::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChangeUserStorageNameInput::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChangeUserStorageNameInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChangeUserStorageNameInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 ChangeUserStorageNameInput::userid() const {
  return userid_;
}
inline void ChangeUserStorageNameInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required fixed64 storageClusterId = 3;
inline bool ChangeUserStorageNameInput::has_storageclusterid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChangeUserStorageNameInput::set_has_storageclusterid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChangeUserStorageNameInput::clear_has_storageclusterid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChangeUserStorageNameInput::clear_storageclusterid() {
  storageclusterid_ = GOOGLE_ULONGLONG(0);
  clear_has_storageclusterid();
}
inline ::google::protobuf::uint64 ChangeUserStorageNameInput::storageclusterid() const {
  return storageclusterid_;
}
inline void ChangeUserStorageNameInput::set_storageclusterid(::google::protobuf::uint64 value) {
  set_has_storageclusterid();
  storageclusterid_ = value;
}

// required string newStorageName = 4;
inline bool ChangeUserStorageNameInput::has_newstoragename() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChangeUserStorageNameInput::set_has_newstoragename() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChangeUserStorageNameInput::clear_has_newstoragename() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChangeUserStorageNameInput::clear_newstoragename() {
  if (newstoragename_ != &::google::protobuf::internal::kEmptyString) {
    newstoragename_->clear();
  }
  clear_has_newstoragename();
}
inline const ::std::string& ChangeUserStorageNameInput::newstoragename() const {
  return *newstoragename_;
}
inline void ChangeUserStorageNameInput::set_newstoragename(const ::std::string& value) {
  set_has_newstoragename();
  if (newstoragename_ == &::google::protobuf::internal::kEmptyString) {
    newstoragename_ = new ::std::string;
  }
  newstoragename_->assign(value);
}
inline void ChangeUserStorageNameInput::set_newstoragename(const char* value) {
  set_has_newstoragename();
  if (newstoragename_ == &::google::protobuf::internal::kEmptyString) {
    newstoragename_ = new ::std::string;
  }
  newstoragename_->assign(value);
}
inline void ChangeUserStorageNameInput::set_newstoragename(const char* value, size_t size) {
  set_has_newstoragename();
  if (newstoragename_ == &::google::protobuf::internal::kEmptyString) {
    newstoragename_ = new ::std::string;
  }
  newstoragename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChangeUserStorageNameInput::mutable_newstoragename() {
  set_has_newstoragename();
  if (newstoragename_ == &::google::protobuf::internal::kEmptyString) {
    newstoragename_ = new ::std::string;
  }
  return newstoragename_;
}
inline ::std::string* ChangeUserStorageNameInput::release_newstoragename() {
  clear_has_newstoragename();
  if (newstoragename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = newstoragename_;
    newstoragename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string version = 5;
inline bool ChangeUserStorageNameInput::has_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ChangeUserStorageNameInput::set_has_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ChangeUserStorageNameInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ChangeUserStorageNameInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& ChangeUserStorageNameInput::version() const {
  return *version_;
}
inline void ChangeUserStorageNameInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void ChangeUserStorageNameInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void ChangeUserStorageNameInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChangeUserStorageNameInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* ChangeUserStorageNameInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ChangeUserStorageNameOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool ChangeUserStorageNameOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeUserStorageNameOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeUserStorageNameOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeUserStorageNameOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& ChangeUserStorageNameOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* ChangeUserStorageNameOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* ChangeUserStorageNameOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ChangeUserStorageQuotaInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool ChangeUserStorageQuotaInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeUserStorageQuotaInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeUserStorageQuotaInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeUserStorageQuotaInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& ChangeUserStorageQuotaInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* ChangeUserStorageQuotaInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* ChangeUserStorageQuotaInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 userId = 2;
inline bool ChangeUserStorageQuotaInput::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChangeUserStorageQuotaInput::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChangeUserStorageQuotaInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChangeUserStorageQuotaInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 ChangeUserStorageQuotaInput::userid() const {
  return userid_;
}
inline void ChangeUserStorageQuotaInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required fixed64 storageClusterId = 3;
inline bool ChangeUserStorageQuotaInput::has_storageclusterid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChangeUserStorageQuotaInput::set_has_storageclusterid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChangeUserStorageQuotaInput::clear_has_storageclusterid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChangeUserStorageQuotaInput::clear_storageclusterid() {
  storageclusterid_ = GOOGLE_ULONGLONG(0);
  clear_has_storageclusterid();
}
inline ::google::protobuf::uint64 ChangeUserStorageQuotaInput::storageclusterid() const {
  return storageclusterid_;
}
inline void ChangeUserStorageQuotaInput::set_storageclusterid(::google::protobuf::uint64 value) {
  set_has_storageclusterid();
  storageclusterid_ = value;
}

// required fixed64 newLimit = 4;
inline bool ChangeUserStorageQuotaInput::has_newlimit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChangeUserStorageQuotaInput::set_has_newlimit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChangeUserStorageQuotaInput::clear_has_newlimit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChangeUserStorageQuotaInput::clear_newlimit() {
  newlimit_ = GOOGLE_ULONGLONG(0);
  clear_has_newlimit();
}
inline ::google::protobuf::uint64 ChangeUserStorageQuotaInput::newlimit() const {
  return newlimit_;
}
inline void ChangeUserStorageQuotaInput::set_newlimit(::google::protobuf::uint64 value) {
  set_has_newlimit();
  newlimit_ = value;
}

// optional string version = 5;
inline bool ChangeUserStorageQuotaInput::has_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ChangeUserStorageQuotaInput::set_has_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ChangeUserStorageQuotaInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ChangeUserStorageQuotaInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& ChangeUserStorageQuotaInput::version() const {
  return *version_;
}
inline void ChangeUserStorageQuotaInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void ChangeUserStorageQuotaInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void ChangeUserStorageQuotaInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChangeUserStorageQuotaInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* ChangeUserStorageQuotaInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ChangeUserStorageQuotaOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool ChangeUserStorageQuotaOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeUserStorageQuotaOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeUserStorageQuotaOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeUserStorageQuotaOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& ChangeUserStorageQuotaOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* ChangeUserStorageQuotaOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* ChangeUserStorageQuotaOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ListUserStorageInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool ListUserStorageInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ListUserStorageInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ListUserStorageInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ListUserStorageInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& ListUserStorageInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* ListUserStorageInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* ListUserStorageInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 userId = 2;
inline bool ListUserStorageInput::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ListUserStorageInput::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ListUserStorageInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ListUserStorageInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 ListUserStorageInput::userid() const {
  return userid_;
}
inline void ListUserStorageInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// optional fixed64 deviceId = 3;
inline bool ListUserStorageInput::has_deviceid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ListUserStorageInput::set_has_deviceid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ListUserStorageInput::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ListUserStorageInput::clear_deviceid() {
  deviceid_ = GOOGLE_ULONGLONG(0);
  clear_has_deviceid();
}
inline ::google::protobuf::uint64 ListUserStorageInput::deviceid() const {
  return deviceid_;
}
inline void ListUserStorageInput::set_deviceid(::google::protobuf::uint64 value) {
  set_has_deviceid();
  deviceid_ = value;
}

// optional string version = 4;
inline bool ListUserStorageInput::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ListUserStorageInput::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ListUserStorageInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ListUserStorageInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& ListUserStorageInput::version() const {
  return *version_;
}
inline void ListUserStorageInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void ListUserStorageInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void ListUserStorageInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListUserStorageInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* ListUserStorageInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ListUserStorageOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool ListUserStorageOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ListUserStorageOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ListUserStorageOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ListUserStorageOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& ListUserStorageOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* ListUserStorageOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* ListUserStorageOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// repeated .vplex.vsDirectory.UserStorage storageAssignments = 2;
inline int ListUserStorageOutput::storageassignments_size() const {
  return storageassignments_.size();
}
inline void ListUserStorageOutput::clear_storageassignments() {
  storageassignments_.Clear();
}
inline const ::vplex::vsDirectory::UserStorage& ListUserStorageOutput::storageassignments(int index) const {
  return storageassignments_.Get(index);
}
inline ::vplex::vsDirectory::UserStorage* ListUserStorageOutput::mutable_storageassignments(int index) {
  return storageassignments_.Mutable(index);
}
inline ::vplex::vsDirectory::UserStorage* ListUserStorageOutput::add_storageassignments() {
  return storageassignments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::UserStorage >&
ListUserStorageOutput::storageassignments() const {
  return storageassignments_;
}
inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::UserStorage >*
ListUserStorageOutput::mutable_storageassignments() {
  return &storageassignments_;
}

// -------------------------------------------------------------------

// GetUserStorageAddressInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool GetUserStorageAddressInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetUserStorageAddressInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetUserStorageAddressInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetUserStorageAddressInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& GetUserStorageAddressInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* GetUserStorageAddressInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* GetUserStorageAddressInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 userId = 2;
inline bool GetUserStorageAddressInput::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetUserStorageAddressInput::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetUserStorageAddressInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetUserStorageAddressInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 GetUserStorageAddressInput::userid() const {
  return userid_;
}
inline void GetUserStorageAddressInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required fixed64 storageClusterId = 3;
inline bool GetUserStorageAddressInput::has_storageclusterid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetUserStorageAddressInput::set_has_storageclusterid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetUserStorageAddressInput::clear_has_storageclusterid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetUserStorageAddressInput::clear_storageclusterid() {
  storageclusterid_ = GOOGLE_ULONGLONG(0);
  clear_has_storageclusterid();
}
inline ::google::protobuf::uint64 GetUserStorageAddressInput::storageclusterid() const {
  return storageclusterid_;
}
inline void GetUserStorageAddressInput::set_storageclusterid(::google::protobuf::uint64 value) {
  set_has_storageclusterid();
  storageclusterid_ = value;
}

// optional string version = 4;
inline bool GetUserStorageAddressInput::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetUserStorageAddressInput::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetUserStorageAddressInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetUserStorageAddressInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& GetUserStorageAddressInput::version() const {
  return *version_;
}
inline void GetUserStorageAddressInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetUserStorageAddressInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetUserStorageAddressInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetUserStorageAddressInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* GetUserStorageAddressInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// UserStorageAddress

// optional string direct_address = 1;
inline bool UserStorageAddress::has_direct_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserStorageAddress::set_has_direct_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserStorageAddress::clear_has_direct_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserStorageAddress::clear_direct_address() {
  if (direct_address_ != &::google::protobuf::internal::kEmptyString) {
    direct_address_->clear();
  }
  clear_has_direct_address();
}
inline const ::std::string& UserStorageAddress::direct_address() const {
  return *direct_address_;
}
inline void UserStorageAddress::set_direct_address(const ::std::string& value) {
  set_has_direct_address();
  if (direct_address_ == &::google::protobuf::internal::kEmptyString) {
    direct_address_ = new ::std::string;
  }
  direct_address_->assign(value);
}
inline void UserStorageAddress::set_direct_address(const char* value) {
  set_has_direct_address();
  if (direct_address_ == &::google::protobuf::internal::kEmptyString) {
    direct_address_ = new ::std::string;
  }
  direct_address_->assign(value);
}
inline void UserStorageAddress::set_direct_address(const char* value, size_t size) {
  set_has_direct_address();
  if (direct_address_ == &::google::protobuf::internal::kEmptyString) {
    direct_address_ = new ::std::string;
  }
  direct_address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserStorageAddress::mutable_direct_address() {
  set_has_direct_address();
  if (direct_address_ == &::google::protobuf::internal::kEmptyString) {
    direct_address_ = new ::std::string;
  }
  return direct_address_;
}
inline ::std::string* UserStorageAddress::release_direct_address() {
  clear_has_direct_address();
  if (direct_address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = direct_address_;
    direct_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 direct_port = 2;
inline bool UserStorageAddress::has_direct_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserStorageAddress::set_has_direct_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserStorageAddress::clear_has_direct_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserStorageAddress::clear_direct_port() {
  direct_port_ = 0;
  clear_has_direct_port();
}
inline ::google::protobuf::int32 UserStorageAddress::direct_port() const {
  return direct_port_;
}
inline void UserStorageAddress::set_direct_port(::google::protobuf::int32 value) {
  set_has_direct_port();
  direct_port_ = value;
}

// optional string proxy_address = 3;
inline bool UserStorageAddress::has_proxy_address() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserStorageAddress::set_has_proxy_address() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserStorageAddress::clear_has_proxy_address() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserStorageAddress::clear_proxy_address() {
  if (proxy_address_ != &::google::protobuf::internal::kEmptyString) {
    proxy_address_->clear();
  }
  clear_has_proxy_address();
}
inline const ::std::string& UserStorageAddress::proxy_address() const {
  return *proxy_address_;
}
inline void UserStorageAddress::set_proxy_address(const ::std::string& value) {
  set_has_proxy_address();
  if (proxy_address_ == &::google::protobuf::internal::kEmptyString) {
    proxy_address_ = new ::std::string;
  }
  proxy_address_->assign(value);
}
inline void UserStorageAddress::set_proxy_address(const char* value) {
  set_has_proxy_address();
  if (proxy_address_ == &::google::protobuf::internal::kEmptyString) {
    proxy_address_ = new ::std::string;
  }
  proxy_address_->assign(value);
}
inline void UserStorageAddress::set_proxy_address(const char* value, size_t size) {
  set_has_proxy_address();
  if (proxy_address_ == &::google::protobuf::internal::kEmptyString) {
    proxy_address_ = new ::std::string;
  }
  proxy_address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserStorageAddress::mutable_proxy_address() {
  set_has_proxy_address();
  if (proxy_address_ == &::google::protobuf::internal::kEmptyString) {
    proxy_address_ = new ::std::string;
  }
  return proxy_address_;
}
inline ::std::string* UserStorageAddress::release_proxy_address() {
  clear_has_proxy_address();
  if (proxy_address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = proxy_address_;
    proxy_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 proxy_port = 4;
inline bool UserStorageAddress::has_proxy_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserStorageAddress::set_has_proxy_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserStorageAddress::clear_has_proxy_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserStorageAddress::clear_proxy_port() {
  proxy_port_ = 0;
  clear_has_proxy_port();
}
inline ::google::protobuf::int32 UserStorageAddress::proxy_port() const {
  return proxy_port_;
}
inline void UserStorageAddress::set_proxy_port(::google::protobuf::int32 value) {
  set_has_proxy_port();
  proxy_port_ = value;
}

// optional string internal_direct_address = 5;
inline bool UserStorageAddress::has_internal_direct_address() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserStorageAddress::set_has_internal_direct_address() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserStorageAddress::clear_has_internal_direct_address() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserStorageAddress::clear_internal_direct_address() {
  if (internal_direct_address_ != &::google::protobuf::internal::kEmptyString) {
    internal_direct_address_->clear();
  }
  clear_has_internal_direct_address();
}
inline const ::std::string& UserStorageAddress::internal_direct_address() const {
  return *internal_direct_address_;
}
inline void UserStorageAddress::set_internal_direct_address(const ::std::string& value) {
  set_has_internal_direct_address();
  if (internal_direct_address_ == &::google::protobuf::internal::kEmptyString) {
    internal_direct_address_ = new ::std::string;
  }
  internal_direct_address_->assign(value);
}
inline void UserStorageAddress::set_internal_direct_address(const char* value) {
  set_has_internal_direct_address();
  if (internal_direct_address_ == &::google::protobuf::internal::kEmptyString) {
    internal_direct_address_ = new ::std::string;
  }
  internal_direct_address_->assign(value);
}
inline void UserStorageAddress::set_internal_direct_address(const char* value, size_t size) {
  set_has_internal_direct_address();
  if (internal_direct_address_ == &::google::protobuf::internal::kEmptyString) {
    internal_direct_address_ = new ::std::string;
  }
  internal_direct_address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserStorageAddress::mutable_internal_direct_address() {
  set_has_internal_direct_address();
  if (internal_direct_address_ == &::google::protobuf::internal::kEmptyString) {
    internal_direct_address_ = new ::std::string;
  }
  return internal_direct_address_;
}
inline ::std::string* UserStorageAddress::release_internal_direct_address() {
  clear_has_internal_direct_address();
  if (internal_direct_address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = internal_direct_address_;
    internal_direct_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 direct_secure_port = 6;
inline bool UserStorageAddress::has_direct_secure_port() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserStorageAddress::set_has_direct_secure_port() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserStorageAddress::clear_has_direct_secure_port() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserStorageAddress::clear_direct_secure_port() {
  direct_secure_port_ = 0;
  clear_has_direct_secure_port();
}
inline ::google::protobuf::int32 UserStorageAddress::direct_secure_port() const {
  return direct_secure_port_;
}
inline void UserStorageAddress::set_direct_secure_port(::google::protobuf::int32 value) {
  set_has_direct_secure_port();
  direct_secure_port_ = value;
}

// optional fixed64 access_handle = 7;
inline bool UserStorageAddress::has_access_handle() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserStorageAddress::set_has_access_handle() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserStorageAddress::clear_has_access_handle() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserStorageAddress::clear_access_handle() {
  access_handle_ = GOOGLE_ULONGLONG(0);
  clear_has_access_handle();
}
inline ::google::protobuf::uint64 UserStorageAddress::access_handle() const {
  return access_handle_;
}
inline void UserStorageAddress::set_access_handle(::google::protobuf::uint64 value) {
  set_has_access_handle();
  access_handle_ = value;
}

// optional bytes access_ticket = 8;
inline bool UserStorageAddress::has_access_ticket() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserStorageAddress::set_has_access_ticket() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserStorageAddress::clear_has_access_ticket() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserStorageAddress::clear_access_ticket() {
  if (access_ticket_ != &::google::protobuf::internal::kEmptyString) {
    access_ticket_->clear();
  }
  clear_has_access_ticket();
}
inline const ::std::string& UserStorageAddress::access_ticket() const {
  return *access_ticket_;
}
inline void UserStorageAddress::set_access_ticket(const ::std::string& value) {
  set_has_access_ticket();
  if (access_ticket_ == &::google::protobuf::internal::kEmptyString) {
    access_ticket_ = new ::std::string;
  }
  access_ticket_->assign(value);
}
inline void UserStorageAddress::set_access_ticket(const char* value) {
  set_has_access_ticket();
  if (access_ticket_ == &::google::protobuf::internal::kEmptyString) {
    access_ticket_ = new ::std::string;
  }
  access_ticket_->assign(value);
}
inline void UserStorageAddress::set_access_ticket(const void* value, size_t size) {
  set_has_access_ticket();
  if (access_ticket_ == &::google::protobuf::internal::kEmptyString) {
    access_ticket_ = new ::std::string;
  }
  access_ticket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserStorageAddress::mutable_access_ticket() {
  set_has_access_ticket();
  if (access_ticket_ == &::google::protobuf::internal::kEmptyString) {
    access_ticket_ = new ::std::string;
  }
  return access_ticket_;
}
inline ::std::string* UserStorageAddress::release_access_ticket() {
  clear_has_access_ticket();
  if (access_ticket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = access_ticket_;
    access_ticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetUserStorageAddressOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool GetUserStorageAddressOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetUserStorageAddressOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetUserStorageAddressOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetUserStorageAddressOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& GetUserStorageAddressOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* GetUserStorageAddressOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* GetUserStorageAddressOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// optional string directAddress = 2;
inline bool GetUserStorageAddressOutput::has_directaddress() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetUserStorageAddressOutput::set_has_directaddress() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetUserStorageAddressOutput::clear_has_directaddress() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetUserStorageAddressOutput::clear_directaddress() {
  if (directaddress_ != &::google::protobuf::internal::kEmptyString) {
    directaddress_->clear();
  }
  clear_has_directaddress();
}
inline const ::std::string& GetUserStorageAddressOutput::directaddress() const {
  return *directaddress_;
}
inline void GetUserStorageAddressOutput::set_directaddress(const ::std::string& value) {
  set_has_directaddress();
  if (directaddress_ == &::google::protobuf::internal::kEmptyString) {
    directaddress_ = new ::std::string;
  }
  directaddress_->assign(value);
}
inline void GetUserStorageAddressOutput::set_directaddress(const char* value) {
  set_has_directaddress();
  if (directaddress_ == &::google::protobuf::internal::kEmptyString) {
    directaddress_ = new ::std::string;
  }
  directaddress_->assign(value);
}
inline void GetUserStorageAddressOutput::set_directaddress(const char* value, size_t size) {
  set_has_directaddress();
  if (directaddress_ == &::google::protobuf::internal::kEmptyString) {
    directaddress_ = new ::std::string;
  }
  directaddress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetUserStorageAddressOutput::mutable_directaddress() {
  set_has_directaddress();
  if (directaddress_ == &::google::protobuf::internal::kEmptyString) {
    directaddress_ = new ::std::string;
  }
  return directaddress_;
}
inline ::std::string* GetUserStorageAddressOutput::release_directaddress() {
  clear_has_directaddress();
  if (directaddress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = directaddress_;
    directaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 directPort = 3;
inline bool GetUserStorageAddressOutput::has_directport() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetUserStorageAddressOutput::set_has_directport() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetUserStorageAddressOutput::clear_has_directport() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetUserStorageAddressOutput::clear_directport() {
  directport_ = 0;
  clear_has_directport();
}
inline ::google::protobuf::int32 GetUserStorageAddressOutput::directport() const {
  return directport_;
}
inline void GetUserStorageAddressOutput::set_directport(::google::protobuf::int32 value) {
  set_has_directport();
  directport_ = value;
}

// optional string proxyAddress = 4;
inline bool GetUserStorageAddressOutput::has_proxyaddress() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetUserStorageAddressOutput::set_has_proxyaddress() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetUserStorageAddressOutput::clear_has_proxyaddress() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetUserStorageAddressOutput::clear_proxyaddress() {
  if (proxyaddress_ != &::google::protobuf::internal::kEmptyString) {
    proxyaddress_->clear();
  }
  clear_has_proxyaddress();
}
inline const ::std::string& GetUserStorageAddressOutput::proxyaddress() const {
  return *proxyaddress_;
}
inline void GetUserStorageAddressOutput::set_proxyaddress(const ::std::string& value) {
  set_has_proxyaddress();
  if (proxyaddress_ == &::google::protobuf::internal::kEmptyString) {
    proxyaddress_ = new ::std::string;
  }
  proxyaddress_->assign(value);
}
inline void GetUserStorageAddressOutput::set_proxyaddress(const char* value) {
  set_has_proxyaddress();
  if (proxyaddress_ == &::google::protobuf::internal::kEmptyString) {
    proxyaddress_ = new ::std::string;
  }
  proxyaddress_->assign(value);
}
inline void GetUserStorageAddressOutput::set_proxyaddress(const char* value, size_t size) {
  set_has_proxyaddress();
  if (proxyaddress_ == &::google::protobuf::internal::kEmptyString) {
    proxyaddress_ = new ::std::string;
  }
  proxyaddress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetUserStorageAddressOutput::mutable_proxyaddress() {
  set_has_proxyaddress();
  if (proxyaddress_ == &::google::protobuf::internal::kEmptyString) {
    proxyaddress_ = new ::std::string;
  }
  return proxyaddress_;
}
inline ::std::string* GetUserStorageAddressOutput::release_proxyaddress() {
  clear_has_proxyaddress();
  if (proxyaddress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = proxyaddress_;
    proxyaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 proxyPort = 5;
inline bool GetUserStorageAddressOutput::has_proxyport() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetUserStorageAddressOutput::set_has_proxyport() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetUserStorageAddressOutput::clear_has_proxyport() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetUserStorageAddressOutput::clear_proxyport() {
  proxyport_ = 0;
  clear_has_proxyport();
}
inline ::google::protobuf::int32 GetUserStorageAddressOutput::proxyport() const {
  return proxyport_;
}
inline void GetUserStorageAddressOutput::set_proxyport(::google::protobuf::int32 value) {
  set_has_proxyport();
  proxyport_ = value;
}

// optional string internalDirectAddress = 6;
inline bool GetUserStorageAddressOutput::has_internaldirectaddress() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GetUserStorageAddressOutput::set_has_internaldirectaddress() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GetUserStorageAddressOutput::clear_has_internaldirectaddress() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GetUserStorageAddressOutput::clear_internaldirectaddress() {
  if (internaldirectaddress_ != &::google::protobuf::internal::kEmptyString) {
    internaldirectaddress_->clear();
  }
  clear_has_internaldirectaddress();
}
inline const ::std::string& GetUserStorageAddressOutput::internaldirectaddress() const {
  return *internaldirectaddress_;
}
inline void GetUserStorageAddressOutput::set_internaldirectaddress(const ::std::string& value) {
  set_has_internaldirectaddress();
  if (internaldirectaddress_ == &::google::protobuf::internal::kEmptyString) {
    internaldirectaddress_ = new ::std::string;
  }
  internaldirectaddress_->assign(value);
}
inline void GetUserStorageAddressOutput::set_internaldirectaddress(const char* value) {
  set_has_internaldirectaddress();
  if (internaldirectaddress_ == &::google::protobuf::internal::kEmptyString) {
    internaldirectaddress_ = new ::std::string;
  }
  internaldirectaddress_->assign(value);
}
inline void GetUserStorageAddressOutput::set_internaldirectaddress(const char* value, size_t size) {
  set_has_internaldirectaddress();
  if (internaldirectaddress_ == &::google::protobuf::internal::kEmptyString) {
    internaldirectaddress_ = new ::std::string;
  }
  internaldirectaddress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetUserStorageAddressOutput::mutable_internaldirectaddress() {
  set_has_internaldirectaddress();
  if (internaldirectaddress_ == &::google::protobuf::internal::kEmptyString) {
    internaldirectaddress_ = new ::std::string;
  }
  return internaldirectaddress_;
}
inline ::std::string* GetUserStorageAddressOutput::release_internaldirectaddress() {
  clear_has_internaldirectaddress();
  if (internaldirectaddress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = internaldirectaddress_;
    internaldirectaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 directSecurePort = 7;
inline bool GetUserStorageAddressOutput::has_directsecureport() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GetUserStorageAddressOutput::set_has_directsecureport() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GetUserStorageAddressOutput::clear_has_directsecureport() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GetUserStorageAddressOutput::clear_directsecureport() {
  directsecureport_ = 0;
  clear_has_directsecureport();
}
inline ::google::protobuf::int32 GetUserStorageAddressOutput::directsecureport() const {
  return directsecureport_;
}
inline void GetUserStorageAddressOutput::set_directsecureport(::google::protobuf::int32 value) {
  set_has_directsecureport();
  directsecureport_ = value;
}

// optional fixed64 accessHandle = 8;
inline bool GetUserStorageAddressOutput::has_accesshandle() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GetUserStorageAddressOutput::set_has_accesshandle() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GetUserStorageAddressOutput::clear_has_accesshandle() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GetUserStorageAddressOutput::clear_accesshandle() {
  accesshandle_ = GOOGLE_ULONGLONG(0);
  clear_has_accesshandle();
}
inline ::google::protobuf::uint64 GetUserStorageAddressOutput::accesshandle() const {
  return accesshandle_;
}
inline void GetUserStorageAddressOutput::set_accesshandle(::google::protobuf::uint64 value) {
  set_has_accesshandle();
  accesshandle_ = value;
}

// optional bytes accessTicket = 9;
inline bool GetUserStorageAddressOutput::has_accessticket() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GetUserStorageAddressOutput::set_has_accessticket() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GetUserStorageAddressOutput::clear_has_accessticket() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GetUserStorageAddressOutput::clear_accessticket() {
  if (accessticket_ != &::google::protobuf::internal::kEmptyString) {
    accessticket_->clear();
  }
  clear_has_accessticket();
}
inline const ::std::string& GetUserStorageAddressOutput::accessticket() const {
  return *accessticket_;
}
inline void GetUserStorageAddressOutput::set_accessticket(const ::std::string& value) {
  set_has_accessticket();
  if (accessticket_ == &::google::protobuf::internal::kEmptyString) {
    accessticket_ = new ::std::string;
  }
  accessticket_->assign(value);
}
inline void GetUserStorageAddressOutput::set_accessticket(const char* value) {
  set_has_accessticket();
  if (accessticket_ == &::google::protobuf::internal::kEmptyString) {
    accessticket_ = new ::std::string;
  }
  accessticket_->assign(value);
}
inline void GetUserStorageAddressOutput::set_accessticket(const void* value, size_t size) {
  set_has_accessticket();
  if (accessticket_ == &::google::protobuf::internal::kEmptyString) {
    accessticket_ = new ::std::string;
  }
  accessticket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetUserStorageAddressOutput::mutable_accessticket() {
  set_has_accessticket();
  if (accessticket_ == &::google::protobuf::internal::kEmptyString) {
    accessticket_ = new ::std::string;
  }
  return accessticket_;
}
inline ::std::string* GetUserStorageAddressOutput::release_accessticket() {
  clear_has_accessticket();
  if (accessticket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = accessticket_;
    accessticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AssignUserDatacenterStorageInput

// required fixed64 userId = 1;
inline bool AssignUserDatacenterStorageInput::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AssignUserDatacenterStorageInput::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AssignUserDatacenterStorageInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AssignUserDatacenterStorageInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 AssignUserDatacenterStorageInput::userid() const {
  return userid_;
}
inline void AssignUserDatacenterStorageInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required string region = 2;
inline bool AssignUserDatacenterStorageInput::has_region() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AssignUserDatacenterStorageInput::set_has_region() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AssignUserDatacenterStorageInput::clear_has_region() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AssignUserDatacenterStorageInput::clear_region() {
  if (region_ != &::google::protobuf::internal::kEmptyString) {
    region_->clear();
  }
  clear_has_region();
}
inline const ::std::string& AssignUserDatacenterStorageInput::region() const {
  return *region_;
}
inline void AssignUserDatacenterStorageInput::set_region(const ::std::string& value) {
  set_has_region();
  if (region_ == &::google::protobuf::internal::kEmptyString) {
    region_ = new ::std::string;
  }
  region_->assign(value);
}
inline void AssignUserDatacenterStorageInput::set_region(const char* value) {
  set_has_region();
  if (region_ == &::google::protobuf::internal::kEmptyString) {
    region_ = new ::std::string;
  }
  region_->assign(value);
}
inline void AssignUserDatacenterStorageInput::set_region(const char* value, size_t size) {
  set_has_region();
  if (region_ == &::google::protobuf::internal::kEmptyString) {
    region_ = new ::std::string;
  }
  region_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AssignUserDatacenterStorageInput::mutable_region() {
  set_has_region();
  if (region_ == &::google::protobuf::internal::kEmptyString) {
    region_ = new ::std::string;
  }
  return region_;
}
inline ::std::string* AssignUserDatacenterStorageInput::release_region() {
  clear_has_region();
  if (region_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = region_;
    region_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required fixed64 usageLimit = 3;
inline bool AssignUserDatacenterStorageInput::has_usagelimit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AssignUserDatacenterStorageInput::set_has_usagelimit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AssignUserDatacenterStorageInput::clear_has_usagelimit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AssignUserDatacenterStorageInput::clear_usagelimit() {
  usagelimit_ = GOOGLE_ULONGLONG(0);
  clear_has_usagelimit();
}
inline ::google::protobuf::uint64 AssignUserDatacenterStorageInput::usagelimit() const {
  return usagelimit_;
}
inline void AssignUserDatacenterStorageInput::set_usagelimit(::google::protobuf::uint64 value) {
  set_has_usagelimit();
  usagelimit_ = value;
}

// optional fixed64 storageClusterId = 4;
inline bool AssignUserDatacenterStorageInput::has_storageclusterid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AssignUserDatacenterStorageInput::set_has_storageclusterid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AssignUserDatacenterStorageInput::clear_has_storageclusterid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AssignUserDatacenterStorageInput::clear_storageclusterid() {
  storageclusterid_ = GOOGLE_ULONGLONG(0);
  clear_has_storageclusterid();
}
inline ::google::protobuf::uint64 AssignUserDatacenterStorageInput::storageclusterid() const {
  return storageclusterid_;
}
inline void AssignUserDatacenterStorageInput::set_storageclusterid(::google::protobuf::uint64 value) {
  set_has_storageclusterid();
  storageclusterid_ = value;
}

// optional fixed64 primaryStorageId = 5;
inline bool AssignUserDatacenterStorageInput::has_primarystorageid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AssignUserDatacenterStorageInput::set_has_primarystorageid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AssignUserDatacenterStorageInput::clear_has_primarystorageid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AssignUserDatacenterStorageInput::clear_primarystorageid() {
  primarystorageid_ = GOOGLE_ULONGLONG(0);
  clear_has_primarystorageid();
}
inline ::google::protobuf::uint64 AssignUserDatacenterStorageInput::primarystorageid() const {
  return primarystorageid_;
}
inline void AssignUserDatacenterStorageInput::set_primarystorageid(::google::protobuf::uint64 value) {
  set_has_primarystorageid();
  primarystorageid_ = value;
}

// optional fixed64 secondaryStorageId = 6;
inline bool AssignUserDatacenterStorageInput::has_secondarystorageid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AssignUserDatacenterStorageInput::set_has_secondarystorageid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AssignUserDatacenterStorageInput::clear_has_secondarystorageid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AssignUserDatacenterStorageInput::clear_secondarystorageid() {
  secondarystorageid_ = GOOGLE_ULONGLONG(0);
  clear_has_secondarystorageid();
}
inline ::google::protobuf::uint64 AssignUserDatacenterStorageInput::secondarystorageid() const {
  return secondarystorageid_;
}
inline void AssignUserDatacenterStorageInput::set_secondarystorageid(::google::protobuf::uint64 value) {
  set_has_secondarystorageid();
  secondarystorageid_ = value;
}

// optional string version = 7;
inline bool AssignUserDatacenterStorageInput::has_version() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AssignUserDatacenterStorageInput::set_has_version() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AssignUserDatacenterStorageInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AssignUserDatacenterStorageInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& AssignUserDatacenterStorageInput::version() const {
  return *version_;
}
inline void AssignUserDatacenterStorageInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void AssignUserDatacenterStorageInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void AssignUserDatacenterStorageInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AssignUserDatacenterStorageInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* AssignUserDatacenterStorageInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AssignUserDatacenterStorageOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool AssignUserDatacenterStorageOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AssignUserDatacenterStorageOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AssignUserDatacenterStorageOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AssignUserDatacenterStorageOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& AssignUserDatacenterStorageOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* AssignUserDatacenterStorageOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* AssignUserDatacenterStorageOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// optional .vplex.vsDirectory.UserStorage storageAssignment = 2;
inline bool AssignUserDatacenterStorageOutput::has_storageassignment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AssignUserDatacenterStorageOutput::set_has_storageassignment() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AssignUserDatacenterStorageOutput::clear_has_storageassignment() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AssignUserDatacenterStorageOutput::clear_storageassignment() {
  if (storageassignment_ != NULL) storageassignment_->::vplex::vsDirectory::UserStorage::Clear();
  clear_has_storageassignment();
}
inline const ::vplex::vsDirectory::UserStorage& AssignUserDatacenterStorageOutput::storageassignment() const {
  return storageassignment_ != NULL ? *storageassignment_ : *default_instance_->storageassignment_;
}
inline ::vplex::vsDirectory::UserStorage* AssignUserDatacenterStorageOutput::mutable_storageassignment() {
  set_has_storageassignment();
  if (storageassignment_ == NULL) storageassignment_ = new ::vplex::vsDirectory::UserStorage;
  return storageassignment_;
}
inline ::vplex::vsDirectory::UserStorage* AssignUserDatacenterStorageOutput::release_storageassignment() {
  clear_has_storageassignment();
  ::vplex::vsDirectory::UserStorage* temp = storageassignment_;
  storageassignment_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// GetStorageUnitForDatasetInput

// required fixed64 userId = 1;
inline bool GetStorageUnitForDatasetInput::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetStorageUnitForDatasetInput::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetStorageUnitForDatasetInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetStorageUnitForDatasetInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 GetStorageUnitForDatasetInput::userid() const {
  return userid_;
}
inline void GetStorageUnitForDatasetInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required fixed64 datasetId = 2;
inline bool GetStorageUnitForDatasetInput::has_datasetid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetStorageUnitForDatasetInput::set_has_datasetid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetStorageUnitForDatasetInput::clear_has_datasetid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetStorageUnitForDatasetInput::clear_datasetid() {
  datasetid_ = GOOGLE_ULONGLONG(0);
  clear_has_datasetid();
}
inline ::google::protobuf::uint64 GetStorageUnitForDatasetInput::datasetid() const {
  return datasetid_;
}
inline void GetStorageUnitForDatasetInput::set_datasetid(::google::protobuf::uint64 value) {
  set_has_datasetid();
  datasetid_ = value;
}

// optional string version = 3;
inline bool GetStorageUnitForDatasetInput::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetStorageUnitForDatasetInput::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetStorageUnitForDatasetInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetStorageUnitForDatasetInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& GetStorageUnitForDatasetInput::version() const {
  return *version_;
}
inline void GetStorageUnitForDatasetInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetStorageUnitForDatasetInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetStorageUnitForDatasetInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetStorageUnitForDatasetInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* GetStorageUnitForDatasetInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetStorageUnitForDatasetOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool GetStorageUnitForDatasetOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetStorageUnitForDatasetOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetStorageUnitForDatasetOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetStorageUnitForDatasetOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& GetStorageUnitForDatasetOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* GetStorageUnitForDatasetOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* GetStorageUnitForDatasetOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// optional fixed64 storageClusterId = 2;
inline bool GetStorageUnitForDatasetOutput::has_storageclusterid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetStorageUnitForDatasetOutput::set_has_storageclusterid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetStorageUnitForDatasetOutput::clear_has_storageclusterid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetStorageUnitForDatasetOutput::clear_storageclusterid() {
  storageclusterid_ = GOOGLE_ULONGLONG(0);
  clear_has_storageclusterid();
}
inline ::google::protobuf::uint64 GetStorageUnitForDatasetOutput::storageclusterid() const {
  return storageclusterid_;
}
inline void GetStorageUnitForDatasetOutput::set_storageclusterid(::google::protobuf::uint64 value) {
  set_has_storageclusterid();
  storageclusterid_ = value;
}

// optional fixed64 primaryStorageId = 3;
inline bool GetStorageUnitForDatasetOutput::has_primarystorageid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetStorageUnitForDatasetOutput::set_has_primarystorageid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetStorageUnitForDatasetOutput::clear_has_primarystorageid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetStorageUnitForDatasetOutput::clear_primarystorageid() {
  primarystorageid_ = GOOGLE_ULONGLONG(0);
  clear_has_primarystorageid();
}
inline ::google::protobuf::uint64 GetStorageUnitForDatasetOutput::primarystorageid() const {
  return primarystorageid_;
}
inline void GetStorageUnitForDatasetOutput::set_primarystorageid(::google::protobuf::uint64 value) {
  set_has_primarystorageid();
  primarystorageid_ = value;
}

// optional fixed64 secondaryStorageId = 4;
inline bool GetStorageUnitForDatasetOutput::has_secondarystorageid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetStorageUnitForDatasetOutput::set_has_secondarystorageid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetStorageUnitForDatasetOutput::clear_has_secondarystorageid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetStorageUnitForDatasetOutput::clear_secondarystorageid() {
  secondarystorageid_ = GOOGLE_ULONGLONG(0);
  clear_has_secondarystorageid();
}
inline ::google::protobuf::uint64 GetStorageUnitForDatasetOutput::secondarystorageid() const {
  return secondarystorageid_;
}
inline void GetStorageUnitForDatasetOutput::set_secondarystorageid(::google::protobuf::uint64 value) {
  set_has_secondarystorageid();
  secondarystorageid_ = value;
}

// optional fixed64 backupStorageId = 5;
inline bool GetStorageUnitForDatasetOutput::has_backupstorageid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetStorageUnitForDatasetOutput::set_has_backupstorageid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetStorageUnitForDatasetOutput::clear_has_backupstorageid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetStorageUnitForDatasetOutput::clear_backupstorageid() {
  backupstorageid_ = GOOGLE_ULONGLONG(0);
  clear_has_backupstorageid();
}
inline ::google::protobuf::uint64 GetStorageUnitForDatasetOutput::backupstorageid() const {
  return backupstorageid_;
}
inline void GetStorageUnitForDatasetOutput::set_backupstorageid(::google::protobuf::uint64 value) {
  set_has_backupstorageid();
  backupstorageid_ = value;
}

// -------------------------------------------------------------------

// GetStoredDatasetsInput

// required fixed64 clusterId = 1;
inline bool GetStoredDatasetsInput::has_clusterid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetStoredDatasetsInput::set_has_clusterid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetStoredDatasetsInput::clear_has_clusterid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetStoredDatasetsInput::clear_clusterid() {
  clusterid_ = GOOGLE_ULONGLONG(0);
  clear_has_clusterid();
}
inline ::google::protobuf::uint64 GetStoredDatasetsInput::clusterid() const {
  return clusterid_;
}
inline void GetStoredDatasetsInput::set_clusterid(::google::protobuf::uint64 value) {
  set_has_clusterid();
  clusterid_ = value;
}

// required fixed64 storageId = 2;
inline bool GetStoredDatasetsInput::has_storageid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetStoredDatasetsInput::set_has_storageid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetStoredDatasetsInput::clear_has_storageid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetStoredDatasetsInput::clear_storageid() {
  storageid_ = GOOGLE_ULONGLONG(0);
  clear_has_storageid();
}
inline ::google::protobuf::uint64 GetStoredDatasetsInput::storageid() const {
  return storageid_;
}
inline void GetStoredDatasetsInput::set_storageid(::google::protobuf::uint64 value) {
  set_has_storageid();
  storageid_ = value;
}

// optional string version = 3;
inline bool GetStoredDatasetsInput::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetStoredDatasetsInput::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetStoredDatasetsInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetStoredDatasetsInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& GetStoredDatasetsInput::version() const {
  return *version_;
}
inline void GetStoredDatasetsInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetStoredDatasetsInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetStoredDatasetsInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetStoredDatasetsInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* GetStoredDatasetsInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetStoredDatasetsOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool GetStoredDatasetsOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetStoredDatasetsOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetStoredDatasetsOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetStoredDatasetsOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& GetStoredDatasetsOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* GetStoredDatasetsOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* GetStoredDatasetsOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// repeated .vplex.vsDirectory.StoredDataset datasets = 2;
inline int GetStoredDatasetsOutput::datasets_size() const {
  return datasets_.size();
}
inline void GetStoredDatasetsOutput::clear_datasets() {
  datasets_.Clear();
}
inline const ::vplex::vsDirectory::StoredDataset& GetStoredDatasetsOutput::datasets(int index) const {
  return datasets_.Get(index);
}
inline ::vplex::vsDirectory::StoredDataset* GetStoredDatasetsOutput::mutable_datasets(int index) {
  return datasets_.Mutable(index);
}
inline ::vplex::vsDirectory::StoredDataset* GetStoredDatasetsOutput::add_datasets() {
  return datasets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::StoredDataset >&
GetStoredDatasetsOutput::datasets() const {
  return datasets_;
}
inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::StoredDataset >*
GetStoredDatasetsOutput::mutable_datasets() {
  return &datasets_;
}

// -------------------------------------------------------------------

// GetProxyConnectionForClusterInput

// required fixed64 clusterId = 1;
inline bool GetProxyConnectionForClusterInput::has_clusterid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetProxyConnectionForClusterInput::set_has_clusterid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetProxyConnectionForClusterInput::clear_has_clusterid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetProxyConnectionForClusterInput::clear_clusterid() {
  clusterid_ = GOOGLE_ULONGLONG(0);
  clear_has_clusterid();
}
inline ::google::protobuf::uint64 GetProxyConnectionForClusterInput::clusterid() const {
  return clusterid_;
}
inline void GetProxyConnectionForClusterInput::set_clusterid(::google::protobuf::uint64 value) {
  set_has_clusterid();
  clusterid_ = value;
}

// optional string version = 2;
inline bool GetProxyConnectionForClusterInput::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetProxyConnectionForClusterInput::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetProxyConnectionForClusterInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetProxyConnectionForClusterInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& GetProxyConnectionForClusterInput::version() const {
  return *version_;
}
inline void GetProxyConnectionForClusterInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetProxyConnectionForClusterInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetProxyConnectionForClusterInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetProxyConnectionForClusterInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* GetProxyConnectionForClusterInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetProxyConnectionForClusterOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool GetProxyConnectionForClusterOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetProxyConnectionForClusterOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetProxyConnectionForClusterOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetProxyConnectionForClusterOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& GetProxyConnectionForClusterOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* GetProxyConnectionForClusterOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* GetProxyConnectionForClusterOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// optional fixed32 cookie = 2;
inline bool GetProxyConnectionForClusterOutput::has_cookie() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetProxyConnectionForClusterOutput::set_has_cookie() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetProxyConnectionForClusterOutput::clear_has_cookie() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetProxyConnectionForClusterOutput::clear_cookie() {
  cookie_ = 0u;
  clear_has_cookie();
}
inline ::google::protobuf::uint32 GetProxyConnectionForClusterOutput::cookie() const {
  return cookie_;
}
inline void GetProxyConnectionForClusterOutput::set_cookie(::google::protobuf::uint32 value) {
  set_has_cookie();
  cookie_ = value;
}

// -------------------------------------------------------------------

// SendMessageToPSNInput

// required fixed64 clusterId = 1;
inline bool SendMessageToPSNInput::has_clusterid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendMessageToPSNInput::set_has_clusterid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendMessageToPSNInput::clear_has_clusterid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendMessageToPSNInput::clear_clusterid() {
  clusterid_ = GOOGLE_ULONGLONG(0);
  clear_has_clusterid();
}
inline ::google::protobuf::uint64 SendMessageToPSNInput::clusterid() const {
  return clusterid_;
}
inline void SendMessageToPSNInput::set_clusterid(::google::protobuf::uint64 value) {
  set_has_clusterid();
  clusterid_ = value;
}

// required bytes message = 2;
inline bool SendMessageToPSNInput::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SendMessageToPSNInput::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SendMessageToPSNInput::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SendMessageToPSNInput::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& SendMessageToPSNInput::message() const {
  return *message_;
}
inline void SendMessageToPSNInput::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void SendMessageToPSNInput::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void SendMessageToPSNInput::set_message(const void* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SendMessageToPSNInput::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* SendMessageToPSNInput::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string version = 3;
inline bool SendMessageToPSNInput::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SendMessageToPSNInput::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SendMessageToPSNInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SendMessageToPSNInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& SendMessageToPSNInput::version() const {
  return *version_;
}
inline void SendMessageToPSNInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void SendMessageToPSNInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void SendMessageToPSNInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SendMessageToPSNInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* SendMessageToPSNInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// SendMessageToPSNOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool SendMessageToPSNOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendMessageToPSNOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendMessageToPSNOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendMessageToPSNOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& SendMessageToPSNOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* SendMessageToPSNOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* SendMessageToPSNOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ChangeStorageUnitForDatasetInput

// required fixed64 userId = 1;
inline bool ChangeStorageUnitForDatasetInput::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeStorageUnitForDatasetInput::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeStorageUnitForDatasetInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeStorageUnitForDatasetInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 ChangeStorageUnitForDatasetInput::userid() const {
  return userid_;
}
inline void ChangeStorageUnitForDatasetInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required fixed64 datasetId = 2;
inline bool ChangeStorageUnitForDatasetInput::has_datasetid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChangeStorageUnitForDatasetInput::set_has_datasetid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChangeStorageUnitForDatasetInput::clear_has_datasetid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChangeStorageUnitForDatasetInput::clear_datasetid() {
  datasetid_ = GOOGLE_ULONGLONG(0);
  clear_has_datasetid();
}
inline ::google::protobuf::uint64 ChangeStorageUnitForDatasetInput::datasetid() const {
  return datasetid_;
}
inline void ChangeStorageUnitForDatasetInput::set_datasetid(::google::protobuf::uint64 value) {
  set_has_datasetid();
  datasetid_ = value;
}

// required fixed64 currentStorageId = 3;
inline bool ChangeStorageUnitForDatasetInput::has_currentstorageid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChangeStorageUnitForDatasetInput::set_has_currentstorageid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChangeStorageUnitForDatasetInput::clear_has_currentstorageid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChangeStorageUnitForDatasetInput::clear_currentstorageid() {
  currentstorageid_ = GOOGLE_ULONGLONG(0);
  clear_has_currentstorageid();
}
inline ::google::protobuf::uint64 ChangeStorageUnitForDatasetInput::currentstorageid() const {
  return currentstorageid_;
}
inline void ChangeStorageUnitForDatasetInput::set_currentstorageid(::google::protobuf::uint64 value) {
  set_has_currentstorageid();
  currentstorageid_ = value;
}

// required fixed64 newStorageId = 4;
inline bool ChangeStorageUnitForDatasetInput::has_newstorageid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChangeStorageUnitForDatasetInput::set_has_newstorageid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChangeStorageUnitForDatasetInput::clear_has_newstorageid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChangeStorageUnitForDatasetInput::clear_newstorageid() {
  newstorageid_ = GOOGLE_ULONGLONG(0);
  clear_has_newstorageid();
}
inline ::google::protobuf::uint64 ChangeStorageUnitForDatasetInput::newstorageid() const {
  return newstorageid_;
}
inline void ChangeStorageUnitForDatasetInput::set_newstorageid(::google::protobuf::uint64 value) {
  set_has_newstorageid();
  newstorageid_ = value;
}

// optional string version = 5;
inline bool ChangeStorageUnitForDatasetInput::has_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ChangeStorageUnitForDatasetInput::set_has_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ChangeStorageUnitForDatasetInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ChangeStorageUnitForDatasetInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& ChangeStorageUnitForDatasetInput::version() const {
  return *version_;
}
inline void ChangeStorageUnitForDatasetInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void ChangeStorageUnitForDatasetInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void ChangeStorageUnitForDatasetInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChangeStorageUnitForDatasetInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* ChangeStorageUnitForDatasetInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ChangeStorageUnitForDatasetOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool ChangeStorageUnitForDatasetOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeStorageUnitForDatasetOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeStorageUnitForDatasetOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeStorageUnitForDatasetOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& ChangeStorageUnitForDatasetOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* ChangeStorageUnitForDatasetOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* ChangeStorageUnitForDatasetOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// optional fixed64 storageId = 2;
inline bool ChangeStorageUnitForDatasetOutput::has_storageid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChangeStorageUnitForDatasetOutput::set_has_storageid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChangeStorageUnitForDatasetOutput::clear_has_storageid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChangeStorageUnitForDatasetOutput::clear_storageid() {
  storageid_ = GOOGLE_ULONGLONG(0);
  clear_has_storageid();
}
inline ::google::protobuf::uint64 ChangeStorageUnitForDatasetOutput::storageid() const {
  return storageid_;
}
inline void ChangeStorageUnitForDatasetOutput::set_storageid(::google::protobuf::uint64 value) {
  set_has_storageid();
  storageid_ = value;
}

// -------------------------------------------------------------------

// CreateStorageClusterInput

// required fixed64 clusterId = 1;
inline bool CreateStorageClusterInput::has_clusterid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateStorageClusterInput::set_has_clusterid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateStorageClusterInput::clear_has_clusterid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateStorageClusterInput::clear_clusterid() {
  clusterid_ = GOOGLE_ULONGLONG(0);
  clear_has_clusterid();
}
inline ::google::protobuf::uint64 CreateStorageClusterInput::clusterid() const {
  return clusterid_;
}
inline void CreateStorageClusterInput::set_clusterid(::google::protobuf::uint64 value) {
  set_has_clusterid();
  clusterid_ = value;
}

// required string clusterName = 2;
inline bool CreateStorageClusterInput::has_clustername() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateStorageClusterInput::set_has_clustername() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateStorageClusterInput::clear_has_clustername() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateStorageClusterInput::clear_clustername() {
  if (clustername_ != &::google::protobuf::internal::kEmptyString) {
    clustername_->clear();
  }
  clear_has_clustername();
}
inline const ::std::string& CreateStorageClusterInput::clustername() const {
  return *clustername_;
}
inline void CreateStorageClusterInput::set_clustername(const ::std::string& value) {
  set_has_clustername();
  if (clustername_ == &::google::protobuf::internal::kEmptyString) {
    clustername_ = new ::std::string;
  }
  clustername_->assign(value);
}
inline void CreateStorageClusterInput::set_clustername(const char* value) {
  set_has_clustername();
  if (clustername_ == &::google::protobuf::internal::kEmptyString) {
    clustername_ = new ::std::string;
  }
  clustername_->assign(value);
}
inline void CreateStorageClusterInput::set_clustername(const char* value, size_t size) {
  set_has_clustername();
  if (clustername_ == &::google::protobuf::internal::kEmptyString) {
    clustername_ = new ::std::string;
  }
  clustername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateStorageClusterInput::mutable_clustername() {
  set_has_clustername();
  if (clustername_ == &::google::protobuf::internal::kEmptyString) {
    clustername_ = new ::std::string;
  }
  return clustername_;
}
inline ::std::string* CreateStorageClusterInput::release_clustername() {
  clear_has_clustername();
  if (clustername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clustername_;
    clustername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 clusterType = 3;
inline bool CreateStorageClusterInput::has_clustertype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateStorageClusterInput::set_has_clustertype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateStorageClusterInput::clear_has_clustertype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateStorageClusterInput::clear_clustertype() {
  clustertype_ = 0;
  clear_has_clustertype();
}
inline ::google::protobuf::int32 CreateStorageClusterInput::clustertype() const {
  return clustertype_;
}
inline void CreateStorageClusterInput::set_clustertype(::google::protobuf::int32 value) {
  set_has_clustertype();
  clustertype_ = value;
}

// optional string region = 4;
inline bool CreateStorageClusterInput::has_region() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CreateStorageClusterInput::set_has_region() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CreateStorageClusterInput::clear_has_region() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CreateStorageClusterInput::clear_region() {
  if (region_ != &::google::protobuf::internal::kEmptyString) {
    region_->clear();
  }
  clear_has_region();
}
inline const ::std::string& CreateStorageClusterInput::region() const {
  return *region_;
}
inline void CreateStorageClusterInput::set_region(const ::std::string& value) {
  set_has_region();
  if (region_ == &::google::protobuf::internal::kEmptyString) {
    region_ = new ::std::string;
  }
  region_->assign(value);
}
inline void CreateStorageClusterInput::set_region(const char* value) {
  set_has_region();
  if (region_ == &::google::protobuf::internal::kEmptyString) {
    region_ = new ::std::string;
  }
  region_->assign(value);
}
inline void CreateStorageClusterInput::set_region(const char* value, size_t size) {
  set_has_region();
  if (region_ == &::google::protobuf::internal::kEmptyString) {
    region_ = new ::std::string;
  }
  region_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateStorageClusterInput::mutable_region() {
  set_has_region();
  if (region_ == &::google::protobuf::internal::kEmptyString) {
    region_ = new ::std::string;
  }
  return region_;
}
inline ::std::string* CreateStorageClusterInput::release_region() {
  clear_has_region();
  if (region_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = region_;
    region_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string version = 5;
inline bool CreateStorageClusterInput::has_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CreateStorageClusterInput::set_has_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CreateStorageClusterInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CreateStorageClusterInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& CreateStorageClusterInput::version() const {
  return *version_;
}
inline void CreateStorageClusterInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void CreateStorageClusterInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void CreateStorageClusterInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateStorageClusterInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* CreateStorageClusterInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// CreateStorageClusterOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool CreateStorageClusterOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateStorageClusterOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateStorageClusterOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateStorageClusterOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& CreateStorageClusterOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* CreateStorageClusterOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* CreateStorageClusterOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// GetMssInstancesForClusterInput

// required fixed64 clusterId = 1;
inline bool GetMssInstancesForClusterInput::has_clusterid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetMssInstancesForClusterInput::set_has_clusterid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetMssInstancesForClusterInput::clear_has_clusterid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetMssInstancesForClusterInput::clear_clusterid() {
  clusterid_ = GOOGLE_ULONGLONG(0);
  clear_has_clusterid();
}
inline ::google::protobuf::uint64 GetMssInstancesForClusterInput::clusterid() const {
  return clusterid_;
}
inline void GetMssInstancesForClusterInput::set_clusterid(::google::protobuf::uint64 value) {
  set_has_clusterid();
  clusterid_ = value;
}

// optional string version = 2;
inline bool GetMssInstancesForClusterInput::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetMssInstancesForClusterInput::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetMssInstancesForClusterInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetMssInstancesForClusterInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& GetMssInstancesForClusterInput::version() const {
  return *version_;
}
inline void GetMssInstancesForClusterInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetMssInstancesForClusterInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetMssInstancesForClusterInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetMssInstancesForClusterInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* GetMssInstancesForClusterInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetMssInstancesForClusterOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool GetMssInstancesForClusterOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetMssInstancesForClusterOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetMssInstancesForClusterOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetMssInstancesForClusterOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& GetMssInstancesForClusterOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* GetMssInstancesForClusterOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* GetMssInstancesForClusterOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// repeated .vplex.vsDirectory.MssDetail mssInstances = 2;
inline int GetMssInstancesForClusterOutput::mssinstances_size() const {
  return mssinstances_.size();
}
inline void GetMssInstancesForClusterOutput::clear_mssinstances() {
  mssinstances_.Clear();
}
inline const ::vplex::vsDirectory::MssDetail& GetMssInstancesForClusterOutput::mssinstances(int index) const {
  return mssinstances_.Get(index);
}
inline ::vplex::vsDirectory::MssDetail* GetMssInstancesForClusterOutput::mutable_mssinstances(int index) {
  return mssinstances_.Mutable(index);
}
inline ::vplex::vsDirectory::MssDetail* GetMssInstancesForClusterOutput::add_mssinstances() {
  return mssinstances_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::MssDetail >&
GetMssInstancesForClusterOutput::mssinstances() const {
  return mssinstances_;
}
inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::MssDetail >*
GetMssInstancesForClusterOutput::mutable_mssinstances() {
  return &mssinstances_;
}

// -------------------------------------------------------------------

// GetStorageUnitsForClusterInput

// required fixed64 clusterId = 1;
inline bool GetStorageUnitsForClusterInput::has_clusterid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetStorageUnitsForClusterInput::set_has_clusterid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetStorageUnitsForClusterInput::clear_has_clusterid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetStorageUnitsForClusterInput::clear_clusterid() {
  clusterid_ = GOOGLE_ULONGLONG(0);
  clear_has_clusterid();
}
inline ::google::protobuf::uint64 GetStorageUnitsForClusterInput::clusterid() const {
  return clusterid_;
}
inline void GetStorageUnitsForClusterInput::set_clusterid(::google::protobuf::uint64 value) {
  set_has_clusterid();
  clusterid_ = value;
}

// optional string version = 2;
inline bool GetStorageUnitsForClusterInput::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetStorageUnitsForClusterInput::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetStorageUnitsForClusterInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetStorageUnitsForClusterInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& GetStorageUnitsForClusterInput::version() const {
  return *version_;
}
inline void GetStorageUnitsForClusterInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetStorageUnitsForClusterInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetStorageUnitsForClusterInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetStorageUnitsForClusterInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* GetStorageUnitsForClusterInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetStorageUnitsForClusterOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool GetStorageUnitsForClusterOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetStorageUnitsForClusterOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetStorageUnitsForClusterOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetStorageUnitsForClusterOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& GetStorageUnitsForClusterOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* GetStorageUnitsForClusterOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* GetStorageUnitsForClusterOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// repeated .vplex.vsDirectory.StorageUnitDetail storageUnits = 2;
inline int GetStorageUnitsForClusterOutput::storageunits_size() const {
  return storageunits_.size();
}
inline void GetStorageUnitsForClusterOutput::clear_storageunits() {
  storageunits_.Clear();
}
inline const ::vplex::vsDirectory::StorageUnitDetail& GetStorageUnitsForClusterOutput::storageunits(int index) const {
  return storageunits_.Get(index);
}
inline ::vplex::vsDirectory::StorageUnitDetail* GetStorageUnitsForClusterOutput::mutable_storageunits(int index) {
  return storageunits_.Mutable(index);
}
inline ::vplex::vsDirectory::StorageUnitDetail* GetStorageUnitsForClusterOutput::add_storageunits() {
  return storageunits_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::StorageUnitDetail >&
GetStorageUnitsForClusterOutput::storageunits() const {
  return storageunits_;
}
inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::StorageUnitDetail >*
GetStorageUnitsForClusterOutput::mutable_storageunits() {
  return &storageunits_;
}

// -------------------------------------------------------------------

// GetBrsInstancesForClusterInput

// required fixed64 clusterId = 1;
inline bool GetBrsInstancesForClusterInput::has_clusterid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetBrsInstancesForClusterInput::set_has_clusterid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetBrsInstancesForClusterInput::clear_has_clusterid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetBrsInstancesForClusterInput::clear_clusterid() {
  clusterid_ = GOOGLE_ULONGLONG(0);
  clear_has_clusterid();
}
inline ::google::protobuf::uint64 GetBrsInstancesForClusterInput::clusterid() const {
  return clusterid_;
}
inline void GetBrsInstancesForClusterInput::set_clusterid(::google::protobuf::uint64 value) {
  set_has_clusterid();
  clusterid_ = value;
}

// optional string version = 2;
inline bool GetBrsInstancesForClusterInput::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetBrsInstancesForClusterInput::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetBrsInstancesForClusterInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetBrsInstancesForClusterInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& GetBrsInstancesForClusterInput::version() const {
  return *version_;
}
inline void GetBrsInstancesForClusterInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetBrsInstancesForClusterInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetBrsInstancesForClusterInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetBrsInstancesForClusterInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* GetBrsInstancesForClusterInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetBrsInstancesForClusterOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool GetBrsInstancesForClusterOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetBrsInstancesForClusterOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetBrsInstancesForClusterOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetBrsInstancesForClusterOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& GetBrsInstancesForClusterOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* GetBrsInstancesForClusterOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* GetBrsInstancesForClusterOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// repeated .vplex.vsDirectory.BrsDetail brsInstances = 2;
inline int GetBrsInstancesForClusterOutput::brsinstances_size() const {
  return brsinstances_.size();
}
inline void GetBrsInstancesForClusterOutput::clear_brsinstances() {
  brsinstances_.Clear();
}
inline const ::vplex::vsDirectory::BrsDetail& GetBrsInstancesForClusterOutput::brsinstances(int index) const {
  return brsinstances_.Get(index);
}
inline ::vplex::vsDirectory::BrsDetail* GetBrsInstancesForClusterOutput::mutable_brsinstances(int index) {
  return brsinstances_.Mutable(index);
}
inline ::vplex::vsDirectory::BrsDetail* GetBrsInstancesForClusterOutput::add_brsinstances() {
  return brsinstances_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::BrsDetail >&
GetBrsInstancesForClusterOutput::brsinstances() const {
  return brsinstances_;
}
inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::BrsDetail >*
GetBrsInstancesForClusterOutput::mutable_brsinstances() {
  return &brsinstances_;
}

// -------------------------------------------------------------------

// GetBrsStorageUnitsForClusterInput

// required fixed64 clusterId = 1;
inline bool GetBrsStorageUnitsForClusterInput::has_clusterid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetBrsStorageUnitsForClusterInput::set_has_clusterid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetBrsStorageUnitsForClusterInput::clear_has_clusterid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetBrsStorageUnitsForClusterInput::clear_clusterid() {
  clusterid_ = GOOGLE_ULONGLONG(0);
  clear_has_clusterid();
}
inline ::google::protobuf::uint64 GetBrsStorageUnitsForClusterInput::clusterid() const {
  return clusterid_;
}
inline void GetBrsStorageUnitsForClusterInput::set_clusterid(::google::protobuf::uint64 value) {
  set_has_clusterid();
  clusterid_ = value;
}

// optional string version = 2;
inline bool GetBrsStorageUnitsForClusterInput::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetBrsStorageUnitsForClusterInput::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetBrsStorageUnitsForClusterInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetBrsStorageUnitsForClusterInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& GetBrsStorageUnitsForClusterInput::version() const {
  return *version_;
}
inline void GetBrsStorageUnitsForClusterInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetBrsStorageUnitsForClusterInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetBrsStorageUnitsForClusterInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetBrsStorageUnitsForClusterInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* GetBrsStorageUnitsForClusterInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetBrsStorageUnitsForClusterOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool GetBrsStorageUnitsForClusterOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetBrsStorageUnitsForClusterOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetBrsStorageUnitsForClusterOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetBrsStorageUnitsForClusterOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& GetBrsStorageUnitsForClusterOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* GetBrsStorageUnitsForClusterOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* GetBrsStorageUnitsForClusterOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// repeated .vplex.vsDirectory.BrsStorageUnitDetail brsStorageUnits = 2;
inline int GetBrsStorageUnitsForClusterOutput::brsstorageunits_size() const {
  return brsstorageunits_.size();
}
inline void GetBrsStorageUnitsForClusterOutput::clear_brsstorageunits() {
  brsstorageunits_.Clear();
}
inline const ::vplex::vsDirectory::BrsStorageUnitDetail& GetBrsStorageUnitsForClusterOutput::brsstorageunits(int index) const {
  return brsstorageunits_.Get(index);
}
inline ::vplex::vsDirectory::BrsStorageUnitDetail* GetBrsStorageUnitsForClusterOutput::mutable_brsstorageunits(int index) {
  return brsstorageunits_.Mutable(index);
}
inline ::vplex::vsDirectory::BrsStorageUnitDetail* GetBrsStorageUnitsForClusterOutput::add_brsstorageunits() {
  return brsstorageunits_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::BrsStorageUnitDetail >&
GetBrsStorageUnitsForClusterOutput::brsstorageunits() const {
  return brsstorageunits_;
}
inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::BrsStorageUnitDetail >*
GetBrsStorageUnitsForClusterOutput::mutable_brsstorageunits() {
  return &brsstorageunits_;
}

// -------------------------------------------------------------------

// ChangeStorageAssignmentsForDatasetInput

// required fixed64 userId = 1;
inline bool ChangeStorageAssignmentsForDatasetInput::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeStorageAssignmentsForDatasetInput::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeStorageAssignmentsForDatasetInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeStorageAssignmentsForDatasetInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 ChangeStorageAssignmentsForDatasetInput::userid() const {
  return userid_;
}
inline void ChangeStorageAssignmentsForDatasetInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required fixed64 datasetId = 2;
inline bool ChangeStorageAssignmentsForDatasetInput::has_datasetid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChangeStorageAssignmentsForDatasetInput::set_has_datasetid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChangeStorageAssignmentsForDatasetInput::clear_has_datasetid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChangeStorageAssignmentsForDatasetInput::clear_datasetid() {
  datasetid_ = GOOGLE_ULONGLONG(0);
  clear_has_datasetid();
}
inline ::google::protobuf::uint64 ChangeStorageAssignmentsForDatasetInput::datasetid() const {
  return datasetid_;
}
inline void ChangeStorageAssignmentsForDatasetInput::set_datasetid(::google::protobuf::uint64 value) {
  set_has_datasetid();
  datasetid_ = value;
}

// required fixed64 clusterId = 3;
inline bool ChangeStorageAssignmentsForDatasetInput::has_clusterid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChangeStorageAssignmentsForDatasetInput::set_has_clusterid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChangeStorageAssignmentsForDatasetInput::clear_has_clusterid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChangeStorageAssignmentsForDatasetInput::clear_clusterid() {
  clusterid_ = GOOGLE_ULONGLONG(0);
  clear_has_clusterid();
}
inline ::google::protobuf::uint64 ChangeStorageAssignmentsForDatasetInput::clusterid() const {
  return clusterid_;
}
inline void ChangeStorageAssignmentsForDatasetInput::set_clusterid(::google::protobuf::uint64 value) {
  set_has_clusterid();
  clusterid_ = value;
}

// required fixed64 primaryStorageId = 4;
inline bool ChangeStorageAssignmentsForDatasetInput::has_primarystorageid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChangeStorageAssignmentsForDatasetInput::set_has_primarystorageid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChangeStorageAssignmentsForDatasetInput::clear_has_primarystorageid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChangeStorageAssignmentsForDatasetInput::clear_primarystorageid() {
  primarystorageid_ = GOOGLE_ULONGLONG(0);
  clear_has_primarystorageid();
}
inline ::google::protobuf::uint64 ChangeStorageAssignmentsForDatasetInput::primarystorageid() const {
  return primarystorageid_;
}
inline void ChangeStorageAssignmentsForDatasetInput::set_primarystorageid(::google::protobuf::uint64 value) {
  set_has_primarystorageid();
  primarystorageid_ = value;
}

// required fixed64 secondaryStorageId = 5;
inline bool ChangeStorageAssignmentsForDatasetInput::has_secondarystorageid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ChangeStorageAssignmentsForDatasetInput::set_has_secondarystorageid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ChangeStorageAssignmentsForDatasetInput::clear_has_secondarystorageid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ChangeStorageAssignmentsForDatasetInput::clear_secondarystorageid() {
  secondarystorageid_ = GOOGLE_ULONGLONG(0);
  clear_has_secondarystorageid();
}
inline ::google::protobuf::uint64 ChangeStorageAssignmentsForDatasetInput::secondarystorageid() const {
  return secondarystorageid_;
}
inline void ChangeStorageAssignmentsForDatasetInput::set_secondarystorageid(::google::protobuf::uint64 value) {
  set_has_secondarystorageid();
  secondarystorageid_ = value;
}

// required fixed64 backupStorageId = 6;
inline bool ChangeStorageAssignmentsForDatasetInput::has_backupstorageid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ChangeStorageAssignmentsForDatasetInput::set_has_backupstorageid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ChangeStorageAssignmentsForDatasetInput::clear_has_backupstorageid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ChangeStorageAssignmentsForDatasetInput::clear_backupstorageid() {
  backupstorageid_ = GOOGLE_ULONGLONG(0);
  clear_has_backupstorageid();
}
inline ::google::protobuf::uint64 ChangeStorageAssignmentsForDatasetInput::backupstorageid() const {
  return backupstorageid_;
}
inline void ChangeStorageAssignmentsForDatasetInput::set_backupstorageid(::google::protobuf::uint64 value) {
  set_has_backupstorageid();
  backupstorageid_ = value;
}

// optional string version = 7;
inline bool ChangeStorageAssignmentsForDatasetInput::has_version() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ChangeStorageAssignmentsForDatasetInput::set_has_version() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ChangeStorageAssignmentsForDatasetInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ChangeStorageAssignmentsForDatasetInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& ChangeStorageAssignmentsForDatasetInput::version() const {
  return *version_;
}
inline void ChangeStorageAssignmentsForDatasetInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void ChangeStorageAssignmentsForDatasetInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void ChangeStorageAssignmentsForDatasetInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChangeStorageAssignmentsForDatasetInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* ChangeStorageAssignmentsForDatasetInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ChangeStorageAssignmentsForDatasetOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool ChangeStorageAssignmentsForDatasetOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeStorageAssignmentsForDatasetOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeStorageAssignmentsForDatasetOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeStorageAssignmentsForDatasetOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& ChangeStorageAssignmentsForDatasetOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* ChangeStorageAssignmentsForDatasetOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* ChangeStorageAssignmentsForDatasetOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// UpdateDatasetStatusInput

// required fixed64 userId = 1;
inline bool UpdateDatasetStatusInput::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateDatasetStatusInput::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateDatasetStatusInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateDatasetStatusInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 UpdateDatasetStatusInput::userid() const {
  return userid_;
}
inline void UpdateDatasetStatusInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required fixed64 datasetId = 2;
inline bool UpdateDatasetStatusInput::has_datasetid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateDatasetStatusInput::set_has_datasetid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateDatasetStatusInput::clear_has_datasetid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateDatasetStatusInput::clear_datasetid() {
  datasetid_ = GOOGLE_ULONGLONG(0);
  clear_has_datasetid();
}
inline ::google::protobuf::uint64 UpdateDatasetStatusInput::datasetid() const {
  return datasetid_;
}
inline void UpdateDatasetStatusInput::set_datasetid(::google::protobuf::uint64 value) {
  set_has_datasetid();
  datasetid_ = value;
}

// required fixed64 clusterId = 3;
inline bool UpdateDatasetStatusInput::has_clusterid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateDatasetStatusInput::set_has_clusterid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateDatasetStatusInput::clear_has_clusterid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdateDatasetStatusInput::clear_clusterid() {
  clusterid_ = GOOGLE_ULONGLONG(0);
  clear_has_clusterid();
}
inline ::google::protobuf::uint64 UpdateDatasetStatusInput::clusterid() const {
  return clusterid_;
}
inline void UpdateDatasetStatusInput::set_clusterid(::google::protobuf::uint64 value) {
  set_has_clusterid();
  clusterid_ = value;
}

// required fixed64 storageId = 4;
inline bool UpdateDatasetStatusInput::has_storageid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UpdateDatasetStatusInput::set_has_storageid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UpdateDatasetStatusInput::clear_has_storageid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UpdateDatasetStatusInput::clear_storageid() {
  storageid_ = GOOGLE_ULONGLONG(0);
  clear_has_storageid();
}
inline ::google::protobuf::uint64 UpdateDatasetStatusInput::storageid() const {
  return storageid_;
}
inline void UpdateDatasetStatusInput::set_storageid(::google::protobuf::uint64 value) {
  set_has_storageid();
  storageid_ = value;
}

// required fixed64 datasetSize = 5;
inline bool UpdateDatasetStatusInput::has_datasetsize() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UpdateDatasetStatusInput::set_has_datasetsize() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UpdateDatasetStatusInput::clear_has_datasetsize() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UpdateDatasetStatusInput::clear_datasetsize() {
  datasetsize_ = GOOGLE_ULONGLONG(0);
  clear_has_datasetsize();
}
inline ::google::protobuf::uint64 UpdateDatasetStatusInput::datasetsize() const {
  return datasetsize_;
}
inline void UpdateDatasetStatusInput::set_datasetsize(::google::protobuf::uint64 value) {
  set_has_datasetsize();
  datasetsize_ = value;
}

// required fixed64 datasetVersion = 6;
inline bool UpdateDatasetStatusInput::has_datasetversion() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UpdateDatasetStatusInput::set_has_datasetversion() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UpdateDatasetStatusInput::clear_has_datasetversion() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UpdateDatasetStatusInput::clear_datasetversion() {
  datasetversion_ = GOOGLE_ULONGLONG(0);
  clear_has_datasetversion();
}
inline ::google::protobuf::uint64 UpdateDatasetStatusInput::datasetversion() const {
  return datasetversion_;
}
inline void UpdateDatasetStatusInput::set_datasetversion(::google::protobuf::uint64 value) {
  set_has_datasetversion();
  datasetversion_ = value;
}

// optional string version = 7;
inline bool UpdateDatasetStatusInput::has_version() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UpdateDatasetStatusInput::set_has_version() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UpdateDatasetStatusInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UpdateDatasetStatusInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& UpdateDatasetStatusInput::version() const {
  return *version_;
}
inline void UpdateDatasetStatusInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void UpdateDatasetStatusInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void UpdateDatasetStatusInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateDatasetStatusInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* UpdateDatasetStatusInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool ansNotificationOff = 8;
inline bool UpdateDatasetStatusInput::has_ansnotificationoff() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UpdateDatasetStatusInput::set_has_ansnotificationoff() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UpdateDatasetStatusInput::clear_has_ansnotificationoff() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UpdateDatasetStatusInput::clear_ansnotificationoff() {
  ansnotificationoff_ = false;
  clear_has_ansnotificationoff();
}
inline bool UpdateDatasetStatusInput::ansnotificationoff() const {
  return ansnotificationoff_;
}
inline void UpdateDatasetStatusInput::set_ansnotificationoff(bool value) {
  set_has_ansnotificationoff();
  ansnotificationoff_ = value;
}

// -------------------------------------------------------------------

// UpdateDatasetStatusOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool UpdateDatasetStatusOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateDatasetStatusOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateDatasetStatusOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateDatasetStatusOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& UpdateDatasetStatusOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* UpdateDatasetStatusOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* UpdateDatasetStatusOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// UpdateDatasetBackupStatusInput

// required fixed64 userId = 1;
inline bool UpdateDatasetBackupStatusInput::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateDatasetBackupStatusInput::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateDatasetBackupStatusInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateDatasetBackupStatusInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 UpdateDatasetBackupStatusInput::userid() const {
  return userid_;
}
inline void UpdateDatasetBackupStatusInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required fixed64 datasetId = 2;
inline bool UpdateDatasetBackupStatusInput::has_datasetid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateDatasetBackupStatusInput::set_has_datasetid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateDatasetBackupStatusInput::clear_has_datasetid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateDatasetBackupStatusInput::clear_datasetid() {
  datasetid_ = GOOGLE_ULONGLONG(0);
  clear_has_datasetid();
}
inline ::google::protobuf::uint64 UpdateDatasetBackupStatusInput::datasetid() const {
  return datasetid_;
}
inline void UpdateDatasetBackupStatusInput::set_datasetid(::google::protobuf::uint64 value) {
  set_has_datasetid();
  datasetid_ = value;
}

// required fixed64 clusterId = 3;
inline bool UpdateDatasetBackupStatusInput::has_clusterid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateDatasetBackupStatusInput::set_has_clusterid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateDatasetBackupStatusInput::clear_has_clusterid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdateDatasetBackupStatusInput::clear_clusterid() {
  clusterid_ = GOOGLE_ULONGLONG(0);
  clear_has_clusterid();
}
inline ::google::protobuf::uint64 UpdateDatasetBackupStatusInput::clusterid() const {
  return clusterid_;
}
inline void UpdateDatasetBackupStatusInput::set_clusterid(::google::protobuf::uint64 value) {
  set_has_clusterid();
  clusterid_ = value;
}

// required fixed64 backupStorageId = 4;
inline bool UpdateDatasetBackupStatusInput::has_backupstorageid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UpdateDatasetBackupStatusInput::set_has_backupstorageid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UpdateDatasetBackupStatusInput::clear_has_backupstorageid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UpdateDatasetBackupStatusInput::clear_backupstorageid() {
  backupstorageid_ = GOOGLE_ULONGLONG(0);
  clear_has_backupstorageid();
}
inline ::google::protobuf::uint64 UpdateDatasetBackupStatusInput::backupstorageid() const {
  return backupstorageid_;
}
inline void UpdateDatasetBackupStatusInput::set_backupstorageid(::google::protobuf::uint64 value) {
  set_has_backupstorageid();
  backupstorageid_ = value;
}

// required fixed64 datasetVersion = 5;
inline bool UpdateDatasetBackupStatusInput::has_datasetversion() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UpdateDatasetBackupStatusInput::set_has_datasetversion() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UpdateDatasetBackupStatusInput::clear_has_datasetversion() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UpdateDatasetBackupStatusInput::clear_datasetversion() {
  datasetversion_ = GOOGLE_ULONGLONG(0);
  clear_has_datasetversion();
}
inline ::google::protobuf::uint64 UpdateDatasetBackupStatusInput::datasetversion() const {
  return datasetversion_;
}
inline void UpdateDatasetBackupStatusInput::set_datasetversion(::google::protobuf::uint64 value) {
  set_has_datasetversion();
  datasetversion_ = value;
}

// optional string version = 6;
inline bool UpdateDatasetBackupStatusInput::has_version() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UpdateDatasetBackupStatusInput::set_has_version() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UpdateDatasetBackupStatusInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UpdateDatasetBackupStatusInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& UpdateDatasetBackupStatusInput::version() const {
  return *version_;
}
inline void UpdateDatasetBackupStatusInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void UpdateDatasetBackupStatusInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void UpdateDatasetBackupStatusInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateDatasetBackupStatusInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* UpdateDatasetBackupStatusInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// UpdateDatasetBackupStatusOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool UpdateDatasetBackupStatusOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateDatasetBackupStatusOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateDatasetBackupStatusOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateDatasetBackupStatusOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& UpdateDatasetBackupStatusOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* UpdateDatasetBackupStatusOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* UpdateDatasetBackupStatusOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// UpdateDatasetArchiveStatusInput

// required fixed64 userId = 1;
inline bool UpdateDatasetArchiveStatusInput::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateDatasetArchiveStatusInput::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateDatasetArchiveStatusInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateDatasetArchiveStatusInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 UpdateDatasetArchiveStatusInput::userid() const {
  return userid_;
}
inline void UpdateDatasetArchiveStatusInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required fixed64 datasetId = 2;
inline bool UpdateDatasetArchiveStatusInput::has_datasetid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateDatasetArchiveStatusInput::set_has_datasetid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateDatasetArchiveStatusInput::clear_has_datasetid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateDatasetArchiveStatusInput::clear_datasetid() {
  datasetid_ = GOOGLE_ULONGLONG(0);
  clear_has_datasetid();
}
inline ::google::protobuf::uint64 UpdateDatasetArchiveStatusInput::datasetid() const {
  return datasetid_;
}
inline void UpdateDatasetArchiveStatusInput::set_datasetid(::google::protobuf::uint64 value) {
  set_has_datasetid();
  datasetid_ = value;
}

// required fixed64 clusterId = 3;
inline bool UpdateDatasetArchiveStatusInput::has_clusterid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateDatasetArchiveStatusInput::set_has_clusterid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateDatasetArchiveStatusInput::clear_has_clusterid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdateDatasetArchiveStatusInput::clear_clusterid() {
  clusterid_ = GOOGLE_ULONGLONG(0);
  clear_has_clusterid();
}
inline ::google::protobuf::uint64 UpdateDatasetArchiveStatusInput::clusterid() const {
  return clusterid_;
}
inline void UpdateDatasetArchiveStatusInput::set_clusterid(::google::protobuf::uint64 value) {
  set_has_clusterid();
  clusterid_ = value;
}

// required fixed64 backupStorageId = 4;
inline bool UpdateDatasetArchiveStatusInput::has_backupstorageid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UpdateDatasetArchiveStatusInput::set_has_backupstorageid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UpdateDatasetArchiveStatusInput::clear_has_backupstorageid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UpdateDatasetArchiveStatusInput::clear_backupstorageid() {
  backupstorageid_ = GOOGLE_ULONGLONG(0);
  clear_has_backupstorageid();
}
inline ::google::protobuf::uint64 UpdateDatasetArchiveStatusInput::backupstorageid() const {
  return backupstorageid_;
}
inline void UpdateDatasetArchiveStatusInput::set_backupstorageid(::google::protobuf::uint64 value) {
  set_has_backupstorageid();
  backupstorageid_ = value;
}

// required fixed64 datasetVersion = 5;
inline bool UpdateDatasetArchiveStatusInput::has_datasetversion() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UpdateDatasetArchiveStatusInput::set_has_datasetversion() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UpdateDatasetArchiveStatusInput::clear_has_datasetversion() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UpdateDatasetArchiveStatusInput::clear_datasetversion() {
  datasetversion_ = GOOGLE_ULONGLONG(0);
  clear_has_datasetversion();
}
inline ::google::protobuf::uint64 UpdateDatasetArchiveStatusInput::datasetversion() const {
  return datasetversion_;
}
inline void UpdateDatasetArchiveStatusInput::set_datasetversion(::google::protobuf::uint64 value) {
  set_has_datasetversion();
  datasetversion_ = value;
}

// optional string version = 6;
inline bool UpdateDatasetArchiveStatusInput::has_version() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UpdateDatasetArchiveStatusInput::set_has_version() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UpdateDatasetArchiveStatusInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UpdateDatasetArchiveStatusInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& UpdateDatasetArchiveStatusInput::version() const {
  return *version_;
}
inline void UpdateDatasetArchiveStatusInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void UpdateDatasetArchiveStatusInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void UpdateDatasetArchiveStatusInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateDatasetArchiveStatusInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* UpdateDatasetArchiveStatusInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// UpdateDatasetArchiveStatusOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool UpdateDatasetArchiveStatusOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateDatasetArchiveStatusOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateDatasetArchiveStatusOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateDatasetArchiveStatusOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& UpdateDatasetArchiveStatusOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* UpdateDatasetArchiveStatusOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* UpdateDatasetArchiveStatusOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// GetDatasetStatusInput

// required fixed64 userId = 1;
inline bool GetDatasetStatusInput::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetDatasetStatusInput::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetDatasetStatusInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetDatasetStatusInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 GetDatasetStatusInput::userid() const {
  return userid_;
}
inline void GetDatasetStatusInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required fixed64 datasetId = 2;
inline bool GetDatasetStatusInput::has_datasetid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetDatasetStatusInput::set_has_datasetid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetDatasetStatusInput::clear_has_datasetid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetDatasetStatusInput::clear_datasetid() {
  datasetid_ = GOOGLE_ULONGLONG(0);
  clear_has_datasetid();
}
inline ::google::protobuf::uint64 GetDatasetStatusInput::datasetid() const {
  return datasetid_;
}
inline void GetDatasetStatusInput::set_datasetid(::google::protobuf::uint64 value) {
  set_has_datasetid();
  datasetid_ = value;
}

// optional string version = 3;
inline bool GetDatasetStatusInput::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetDatasetStatusInput::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetDatasetStatusInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetDatasetStatusInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& GetDatasetStatusInput::version() const {
  return *version_;
}
inline void GetDatasetStatusInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetDatasetStatusInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetDatasetStatusInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetDatasetStatusInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* GetDatasetStatusInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetDatasetStatusOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool GetDatasetStatusOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetDatasetStatusOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetDatasetStatusOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetDatasetStatusOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& GetDatasetStatusOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* GetDatasetStatusOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* GetDatasetStatusOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// optional fixed64 clusterId = 2;
inline bool GetDatasetStatusOutput::has_clusterid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetDatasetStatusOutput::set_has_clusterid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetDatasetStatusOutput::clear_has_clusterid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetDatasetStatusOutput::clear_clusterid() {
  clusterid_ = GOOGLE_ULONGLONG(0);
  clear_has_clusterid();
}
inline ::google::protobuf::uint64 GetDatasetStatusOutput::clusterid() const {
  return clusterid_;
}
inline void GetDatasetStatusOutput::set_clusterid(::google::protobuf::uint64 value) {
  set_has_clusterid();
  clusterid_ = value;
}

// optional fixed64 primaryStorageId = 3;
inline bool GetDatasetStatusOutput::has_primarystorageid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetDatasetStatusOutput::set_has_primarystorageid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetDatasetStatusOutput::clear_has_primarystorageid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetDatasetStatusOutput::clear_primarystorageid() {
  primarystorageid_ = GOOGLE_ULONGLONG(0);
  clear_has_primarystorageid();
}
inline ::google::protobuf::uint64 GetDatasetStatusOutput::primarystorageid() const {
  return primarystorageid_;
}
inline void GetDatasetStatusOutput::set_primarystorageid(::google::protobuf::uint64 value) {
  set_has_primarystorageid();
  primarystorageid_ = value;
}

// optional fixed64 primaryDatasetSize = 4;
inline bool GetDatasetStatusOutput::has_primarydatasetsize() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetDatasetStatusOutput::set_has_primarydatasetsize() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetDatasetStatusOutput::clear_has_primarydatasetsize() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetDatasetStatusOutput::clear_primarydatasetsize() {
  primarydatasetsize_ = GOOGLE_ULONGLONG(0);
  clear_has_primarydatasetsize();
}
inline ::google::protobuf::uint64 GetDatasetStatusOutput::primarydatasetsize() const {
  return primarydatasetsize_;
}
inline void GetDatasetStatusOutput::set_primarydatasetsize(::google::protobuf::uint64 value) {
  set_has_primarydatasetsize();
  primarydatasetsize_ = value;
}

// optional fixed64 primaryDatasetVersion = 5;
inline bool GetDatasetStatusOutput::has_primarydatasetversion() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetDatasetStatusOutput::set_has_primarydatasetversion() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetDatasetStatusOutput::clear_has_primarydatasetversion() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetDatasetStatusOutput::clear_primarydatasetversion() {
  primarydatasetversion_ = GOOGLE_ULONGLONG(0);
  clear_has_primarydatasetversion();
}
inline ::google::protobuf::uint64 GetDatasetStatusOutput::primarydatasetversion() const {
  return primarydatasetversion_;
}
inline void GetDatasetStatusOutput::set_primarydatasetversion(::google::protobuf::uint64 value) {
  set_has_primarydatasetversion();
  primarydatasetversion_ = value;
}

// optional fixed64 secondaryStorageId = 6;
inline bool GetDatasetStatusOutput::has_secondarystorageid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GetDatasetStatusOutput::set_has_secondarystorageid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GetDatasetStatusOutput::clear_has_secondarystorageid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GetDatasetStatusOutput::clear_secondarystorageid() {
  secondarystorageid_ = GOOGLE_ULONGLONG(0);
  clear_has_secondarystorageid();
}
inline ::google::protobuf::uint64 GetDatasetStatusOutput::secondarystorageid() const {
  return secondarystorageid_;
}
inline void GetDatasetStatusOutput::set_secondarystorageid(::google::protobuf::uint64 value) {
  set_has_secondarystorageid();
  secondarystorageid_ = value;
}

// optional fixed64 secondaryDatasetSize = 7;
inline bool GetDatasetStatusOutput::has_secondarydatasetsize() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GetDatasetStatusOutput::set_has_secondarydatasetsize() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GetDatasetStatusOutput::clear_has_secondarydatasetsize() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GetDatasetStatusOutput::clear_secondarydatasetsize() {
  secondarydatasetsize_ = GOOGLE_ULONGLONG(0);
  clear_has_secondarydatasetsize();
}
inline ::google::protobuf::uint64 GetDatasetStatusOutput::secondarydatasetsize() const {
  return secondarydatasetsize_;
}
inline void GetDatasetStatusOutput::set_secondarydatasetsize(::google::protobuf::uint64 value) {
  set_has_secondarydatasetsize();
  secondarydatasetsize_ = value;
}

// optional fixed64 secondaryDatasetVersion = 8;
inline bool GetDatasetStatusOutput::has_secondarydatasetversion() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GetDatasetStatusOutput::set_has_secondarydatasetversion() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GetDatasetStatusOutput::clear_has_secondarydatasetversion() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GetDatasetStatusOutput::clear_secondarydatasetversion() {
  secondarydatasetversion_ = GOOGLE_ULONGLONG(0);
  clear_has_secondarydatasetversion();
}
inline ::google::protobuf::uint64 GetDatasetStatusOutput::secondarydatasetversion() const {
  return secondarydatasetversion_;
}
inline void GetDatasetStatusOutput::set_secondarydatasetversion(::google::protobuf::uint64 value) {
  set_has_secondarydatasetversion();
  secondarydatasetversion_ = value;
}

// optional fixed64 backupStorageId = 9;
inline bool GetDatasetStatusOutput::has_backupstorageid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GetDatasetStatusOutput::set_has_backupstorageid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GetDatasetStatusOutput::clear_has_backupstorageid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GetDatasetStatusOutput::clear_backupstorageid() {
  backupstorageid_ = GOOGLE_ULONGLONG(0);
  clear_has_backupstorageid();
}
inline ::google::protobuf::uint64 GetDatasetStatusOutput::backupstorageid() const {
  return backupstorageid_;
}
inline void GetDatasetStatusOutput::set_backupstorageid(::google::protobuf::uint64 value) {
  set_has_backupstorageid();
  backupstorageid_ = value;
}

// optional .vplex.vsDirectory.DatasetType datasetType = 10;
inline bool GetDatasetStatusOutput::has_datasettype() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GetDatasetStatusOutput::set_has_datasettype() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GetDatasetStatusOutput::clear_has_datasettype() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GetDatasetStatusOutput::clear_datasettype() {
  datasettype_ = 1;
  clear_has_datasettype();
}
inline vplex::vsDirectory::DatasetType GetDatasetStatusOutput::datasettype() const {
  return static_cast< vplex::vsDirectory::DatasetType >(datasettype_);
}
inline void GetDatasetStatusOutput::set_datasettype(vplex::vsDirectory::DatasetType value) {
  GOOGLE_DCHECK(vplex::vsDirectory::DatasetType_IsValid(value));
  set_has_datasettype();
  datasettype_ = value;
}

// optional fixed64 deleteDataAfter = 11;
inline bool GetDatasetStatusOutput::has_deletedataafter() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GetDatasetStatusOutput::set_has_deletedataafter() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GetDatasetStatusOutput::clear_has_deletedataafter() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GetDatasetStatusOutput::clear_deletedataafter() {
  deletedataafter_ = GOOGLE_ULONGLONG(0);
  clear_has_deletedataafter();
}
inline ::google::protobuf::uint64 GetDatasetStatusOutput::deletedataafter() const {
  return deletedataafter_;
}
inline void GetDatasetStatusOutput::set_deletedataafter(::google::protobuf::uint64 value) {
  set_has_deletedataafter();
  deletedataafter_ = value;
}

// optional fixed64 backupDatasetVersion = 12;
inline bool GetDatasetStatusOutput::has_backupdatasetversion() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GetDatasetStatusOutput::set_has_backupdatasetversion() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GetDatasetStatusOutput::clear_has_backupdatasetversion() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GetDatasetStatusOutput::clear_backupdatasetversion() {
  backupdatasetversion_ = GOOGLE_ULONGLONG(0);
  clear_has_backupdatasetversion();
}
inline ::google::protobuf::uint64 GetDatasetStatusOutput::backupdatasetversion() const {
  return backupdatasetversion_;
}
inline void GetDatasetStatusOutput::set_backupdatasetversion(::google::protobuf::uint64 value) {
  set_has_backupdatasetversion();
  backupdatasetversion_ = value;
}

// optional fixed64 archiveDatasetVersion = 13;
inline bool GetDatasetStatusOutput::has_archivedatasetversion() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GetDatasetStatusOutput::set_has_archivedatasetversion() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GetDatasetStatusOutput::clear_has_archivedatasetversion() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GetDatasetStatusOutput::clear_archivedatasetversion() {
  archivedatasetversion_ = GOOGLE_ULONGLONG(0);
  clear_has_archivedatasetversion();
}
inline ::google::protobuf::uint64 GetDatasetStatusOutput::archivedatasetversion() const {
  return archivedatasetversion_;
}
inline void GetDatasetStatusOutput::set_archivedatasetversion(::google::protobuf::uint64 value) {
  set_has_archivedatasetversion();
  archivedatasetversion_ = value;
}

// optional bool suspendedFlag = 14;
inline bool GetDatasetStatusOutput::has_suspendedflag() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GetDatasetStatusOutput::set_has_suspendedflag() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GetDatasetStatusOutput::clear_has_suspendedflag() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GetDatasetStatusOutput::clear_suspendedflag() {
  suspendedflag_ = false;
  clear_has_suspendedflag();
}
inline bool GetDatasetStatusOutput::suspendedflag() const {
  return suspendedflag_;
}
inline void GetDatasetStatusOutput::set_suspendedflag(bool value) {
  set_has_suspendedflag();
  suspendedflag_ = value;
}

// -------------------------------------------------------------------

// StoreDeviceEventInput

// required .vplex.vsDirectory.SessionInfo session = 1;
inline bool StoreDeviceEventInput::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StoreDeviceEventInput::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StoreDeviceEventInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StoreDeviceEventInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& StoreDeviceEventInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* StoreDeviceEventInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* StoreDeviceEventInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 userId = 2;
inline bool StoreDeviceEventInput::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StoreDeviceEventInput::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StoreDeviceEventInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StoreDeviceEventInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 StoreDeviceEventInput::userid() const {
  return userid_;
}
inline void StoreDeviceEventInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required fixed64 deviceId = 3;
inline bool StoreDeviceEventInput::has_deviceid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StoreDeviceEventInput::set_has_deviceid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StoreDeviceEventInput::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StoreDeviceEventInput::clear_deviceid() {
  deviceid_ = GOOGLE_ULONGLONG(0);
  clear_has_deviceid();
}
inline ::google::protobuf::uint64 StoreDeviceEventInput::deviceid() const {
  return deviceid_;
}
inline void StoreDeviceEventInput::set_deviceid(::google::protobuf::uint64 value) {
  set_has_deviceid();
  deviceid_ = value;
}

// repeated .vplex.vsDirectory.EventInfo eventInfos = 4;
inline int StoreDeviceEventInput::eventinfos_size() const {
  return eventinfos_.size();
}
inline void StoreDeviceEventInput::clear_eventinfos() {
  eventinfos_.Clear();
}
inline const ::vplex::vsDirectory::EventInfo& StoreDeviceEventInput::eventinfos(int index) const {
  return eventinfos_.Get(index);
}
inline ::vplex::vsDirectory::EventInfo* StoreDeviceEventInput::mutable_eventinfos(int index) {
  return eventinfos_.Mutable(index);
}
inline ::vplex::vsDirectory::EventInfo* StoreDeviceEventInput::add_eventinfos() {
  return eventinfos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::EventInfo >&
StoreDeviceEventInput::eventinfos() const {
  return eventinfos_;
}
inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::EventInfo >*
StoreDeviceEventInput::mutable_eventinfos() {
  return &eventinfos_;
}

// optional string version = 5;
inline bool StoreDeviceEventInput::has_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StoreDeviceEventInput::set_has_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StoreDeviceEventInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StoreDeviceEventInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& StoreDeviceEventInput::version() const {
  return *version_;
}
inline void StoreDeviceEventInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void StoreDeviceEventInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void StoreDeviceEventInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreDeviceEventInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* StoreDeviceEventInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// StoreDeviceEventOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool StoreDeviceEventOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StoreDeviceEventOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StoreDeviceEventOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StoreDeviceEventOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& StoreDeviceEventOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* StoreDeviceEventOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* StoreDeviceEventOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// optional fixed32 successCount = 2;
inline bool StoreDeviceEventOutput::has_successcount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StoreDeviceEventOutput::set_has_successcount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StoreDeviceEventOutput::clear_has_successcount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StoreDeviceEventOutput::clear_successcount() {
  successcount_ = 0u;
  clear_has_successcount();
}
inline ::google::protobuf::uint32 StoreDeviceEventOutput::successcount() const {
  return successcount_;
}
inline void StoreDeviceEventOutput::set_successcount(::google::protobuf::uint32 value) {
  set_has_successcount();
  successcount_ = value;
}

// optional fixed32 errorCount = 3;
inline bool StoreDeviceEventOutput::has_errorcount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StoreDeviceEventOutput::set_has_errorcount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StoreDeviceEventOutput::clear_has_errorcount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StoreDeviceEventOutput::clear_errorcount() {
  errorcount_ = 0u;
  clear_has_errorcount();
}
inline ::google::protobuf::uint32 StoreDeviceEventOutput::errorcount() const {
  return errorcount_;
}
inline void StoreDeviceEventOutput::set_errorcount(::google::protobuf::uint32 value) {
  set_has_errorcount();
  errorcount_ = value;
}

// optional fixed32 nextReportTime = 4;
inline bool StoreDeviceEventOutput::has_nextreporttime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StoreDeviceEventOutput::set_has_nextreporttime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StoreDeviceEventOutput::clear_has_nextreporttime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StoreDeviceEventOutput::clear_nextreporttime() {
  nextreporttime_ = 0u;
  clear_has_nextreporttime();
}
inline ::google::protobuf::uint32 StoreDeviceEventOutput::nextreporttime() const {
  return nextreporttime_;
}
inline void StoreDeviceEventOutput::set_nextreporttime(::google::protobuf::uint32 value) {
  set_has_nextreporttime();
  nextreporttime_ = value;
}

// -------------------------------------------------------------------

// EventInfo

// required string appId = 1;
inline bool EventInfo::has_appid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EventInfo::set_has_appid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EventInfo::clear_has_appid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EventInfo::clear_appid() {
  if (appid_ != &::google::protobuf::internal::kEmptyString) {
    appid_->clear();
  }
  clear_has_appid();
}
inline const ::std::string& EventInfo::appid() const {
  return *appid_;
}
inline void EventInfo::set_appid(const ::std::string& value) {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  appid_->assign(value);
}
inline void EventInfo::set_appid(const char* value) {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  appid_->assign(value);
}
inline void EventInfo::set_appid(const char* value, size_t size) {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  appid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EventInfo::mutable_appid() {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  return appid_;
}
inline ::std::string* EventInfo::release_appid() {
  clear_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = appid_;
    appid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string eventId = 2;
inline bool EventInfo::has_eventid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EventInfo::set_has_eventid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EventInfo::clear_has_eventid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EventInfo::clear_eventid() {
  if (eventid_ != &::google::protobuf::internal::kEmptyString) {
    eventid_->clear();
  }
  clear_has_eventid();
}
inline const ::std::string& EventInfo::eventid() const {
  return *eventid_;
}
inline void EventInfo::set_eventid(const ::std::string& value) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(value);
}
inline void EventInfo::set_eventid(const char* value) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(value);
}
inline void EventInfo::set_eventid(const char* value, size_t size) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EventInfo::mutable_eventid() {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  return eventid_;
}
inline ::std::string* EventInfo::release_eventid() {
  clear_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = eventid_;
    eventid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required fixed64 startTime = 3;
inline bool EventInfo::has_starttime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EventInfo::set_has_starttime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EventInfo::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EventInfo::clear_starttime() {
  starttime_ = GOOGLE_ULONGLONG(0);
  clear_has_starttime();
}
inline ::google::protobuf::uint64 EventInfo::starttime() const {
  return starttime_;
}
inline void EventInfo::set_starttime(::google::protobuf::uint64 value) {
  set_has_starttime();
  starttime_ = value;
}

// optional fixed64 endTime = 4;
inline bool EventInfo::has_endtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EventInfo::set_has_endtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EventInfo::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EventInfo::clear_endtime() {
  endtime_ = GOOGLE_ULONGLONG(0);
  clear_has_endtime();
}
inline ::google::protobuf::uint64 EventInfo::endtime() const {
  return endtime_;
}
inline void EventInfo::set_endtime(::google::protobuf::uint64 value) {
  set_has_endtime();
  endtime_ = value;
}

// optional fixed32 eventCount = 5;
inline bool EventInfo::has_eventcount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EventInfo::set_has_eventcount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EventInfo::clear_has_eventcount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EventInfo::clear_eventcount() {
  eventcount_ = 0u;
  clear_has_eventcount();
}
inline ::google::protobuf::uint32 EventInfo::eventcount() const {
  return eventcount_;
}
inline void EventInfo::set_eventcount(::google::protobuf::uint32 value) {
  set_has_eventcount();
  eventcount_ = value;
}

// optional bool limitReached = 6;
inline bool EventInfo::has_limitreached() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EventInfo::set_has_limitreached() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EventInfo::clear_has_limitreached() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EventInfo::clear_limitreached() {
  limitreached_ = false;
  clear_has_limitreached();
}
inline bool EventInfo::limitreached() const {
  return limitreached_;
}
inline void EventInfo::set_limitreached(bool value) {
  set_has_limitreached();
  limitreached_ = value;
}

// optional string eventInfo = 7;
inline bool EventInfo::has_eventinfo() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EventInfo::set_has_eventinfo() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EventInfo::clear_has_eventinfo() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EventInfo::clear_eventinfo() {
  if (eventinfo_ != &::google::protobuf::internal::kEmptyString) {
    eventinfo_->clear();
  }
  clear_has_eventinfo();
}
inline const ::std::string& EventInfo::eventinfo() const {
  return *eventinfo_;
}
inline void EventInfo::set_eventinfo(const ::std::string& value) {
  set_has_eventinfo();
  if (eventinfo_ == &::google::protobuf::internal::kEmptyString) {
    eventinfo_ = new ::std::string;
  }
  eventinfo_->assign(value);
}
inline void EventInfo::set_eventinfo(const char* value) {
  set_has_eventinfo();
  if (eventinfo_ == &::google::protobuf::internal::kEmptyString) {
    eventinfo_ = new ::std::string;
  }
  eventinfo_->assign(value);
}
inline void EventInfo::set_eventinfo(const char* value, size_t size) {
  set_has_eventinfo();
  if (eventinfo_ == &::google::protobuf::internal::kEmptyString) {
    eventinfo_ = new ::std::string;
  }
  eventinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EventInfo::mutable_eventinfo() {
  set_has_eventinfo();
  if (eventinfo_ == &::google::protobuf::internal::kEmptyString) {
    eventinfo_ = new ::std::string;
  }
  return eventinfo_;
}
inline ::std::string* EventInfo::release_eventinfo() {
  clear_has_eventinfo();
  if (eventinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = eventinfo_;
    eventinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetLinkedDatasetStatusInput

// required fixed64 userId = 1;
inline bool GetLinkedDatasetStatusInput::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetLinkedDatasetStatusInput::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetLinkedDatasetStatusInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetLinkedDatasetStatusInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 GetLinkedDatasetStatusInput::userid() const {
  return userid_;
}
inline void GetLinkedDatasetStatusInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required fixed64 datasetId = 2;
inline bool GetLinkedDatasetStatusInput::has_datasetid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetLinkedDatasetStatusInput::set_has_datasetid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetLinkedDatasetStatusInput::clear_has_datasetid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetLinkedDatasetStatusInput::clear_datasetid() {
  datasetid_ = GOOGLE_ULONGLONG(0);
  clear_has_datasetid();
}
inline ::google::protobuf::uint64 GetLinkedDatasetStatusInput::datasetid() const {
  return datasetid_;
}
inline void GetLinkedDatasetStatusInput::set_datasetid(::google::protobuf::uint64 value) {
  set_has_datasetid();
  datasetid_ = value;
}

// optional string version = 3;
inline bool GetLinkedDatasetStatusInput::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetLinkedDatasetStatusInput::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetLinkedDatasetStatusInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetLinkedDatasetStatusInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& GetLinkedDatasetStatusInput::version() const {
  return *version_;
}
inline void GetLinkedDatasetStatusInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetLinkedDatasetStatusInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetLinkedDatasetStatusInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetLinkedDatasetStatusInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* GetLinkedDatasetStatusInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetLinkedDatasetStatusOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool GetLinkedDatasetStatusOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetLinkedDatasetStatusOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetLinkedDatasetStatusOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetLinkedDatasetStatusOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& GetLinkedDatasetStatusOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* GetLinkedDatasetStatusOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* GetLinkedDatasetStatusOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// optional fixed64 linkedDatasetId = 2;
inline bool GetLinkedDatasetStatusOutput::has_linkeddatasetid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetLinkedDatasetStatusOutput::set_has_linkeddatasetid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetLinkedDatasetStatusOutput::clear_has_linkeddatasetid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetLinkedDatasetStatusOutput::clear_linkeddatasetid() {
  linkeddatasetid_ = GOOGLE_ULONGLONG(0);
  clear_has_linkeddatasetid();
}
inline ::google::protobuf::uint64 GetLinkedDatasetStatusOutput::linkeddatasetid() const {
  return linkeddatasetid_;
}
inline void GetLinkedDatasetStatusOutput::set_linkeddatasetid(::google::protobuf::uint64 value) {
  set_has_linkeddatasetid();
  linkeddatasetid_ = value;
}

// optional fixed64 clusterId = 3;
inline bool GetLinkedDatasetStatusOutput::has_clusterid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetLinkedDatasetStatusOutput::set_has_clusterid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetLinkedDatasetStatusOutput::clear_has_clusterid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetLinkedDatasetStatusOutput::clear_clusterid() {
  clusterid_ = GOOGLE_ULONGLONG(0);
  clear_has_clusterid();
}
inline ::google::protobuf::uint64 GetLinkedDatasetStatusOutput::clusterid() const {
  return clusterid_;
}
inline void GetLinkedDatasetStatusOutput::set_clusterid(::google::protobuf::uint64 value) {
  set_has_clusterid();
  clusterid_ = value;
}

// optional fixed64 primaryStorageId = 4;
inline bool GetLinkedDatasetStatusOutput::has_primarystorageid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetLinkedDatasetStatusOutput::set_has_primarystorageid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetLinkedDatasetStatusOutput::clear_has_primarystorageid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetLinkedDatasetStatusOutput::clear_primarystorageid() {
  primarystorageid_ = GOOGLE_ULONGLONG(0);
  clear_has_primarystorageid();
}
inline ::google::protobuf::uint64 GetLinkedDatasetStatusOutput::primarystorageid() const {
  return primarystorageid_;
}
inline void GetLinkedDatasetStatusOutput::set_primarystorageid(::google::protobuf::uint64 value) {
  set_has_primarystorageid();
  primarystorageid_ = value;
}

// optional fixed64 primaryDatasetSize = 5;
inline bool GetLinkedDatasetStatusOutput::has_primarydatasetsize() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetLinkedDatasetStatusOutput::set_has_primarydatasetsize() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetLinkedDatasetStatusOutput::clear_has_primarydatasetsize() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetLinkedDatasetStatusOutput::clear_primarydatasetsize() {
  primarydatasetsize_ = GOOGLE_ULONGLONG(0);
  clear_has_primarydatasetsize();
}
inline ::google::protobuf::uint64 GetLinkedDatasetStatusOutput::primarydatasetsize() const {
  return primarydatasetsize_;
}
inline void GetLinkedDatasetStatusOutput::set_primarydatasetsize(::google::protobuf::uint64 value) {
  set_has_primarydatasetsize();
  primarydatasetsize_ = value;
}

// optional fixed64 primaryDatasetVersion = 6;
inline bool GetLinkedDatasetStatusOutput::has_primarydatasetversion() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GetLinkedDatasetStatusOutput::set_has_primarydatasetversion() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GetLinkedDatasetStatusOutput::clear_has_primarydatasetversion() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GetLinkedDatasetStatusOutput::clear_primarydatasetversion() {
  primarydatasetversion_ = GOOGLE_ULONGLONG(0);
  clear_has_primarydatasetversion();
}
inline ::google::protobuf::uint64 GetLinkedDatasetStatusOutput::primarydatasetversion() const {
  return primarydatasetversion_;
}
inline void GetLinkedDatasetStatusOutput::set_primarydatasetversion(::google::protobuf::uint64 value) {
  set_has_primarydatasetversion();
  primarydatasetversion_ = value;
}

// optional fixed64 secondaryStorageId = 7;
inline bool GetLinkedDatasetStatusOutput::has_secondarystorageid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GetLinkedDatasetStatusOutput::set_has_secondarystorageid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GetLinkedDatasetStatusOutput::clear_has_secondarystorageid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GetLinkedDatasetStatusOutput::clear_secondarystorageid() {
  secondarystorageid_ = GOOGLE_ULONGLONG(0);
  clear_has_secondarystorageid();
}
inline ::google::protobuf::uint64 GetLinkedDatasetStatusOutput::secondarystorageid() const {
  return secondarystorageid_;
}
inline void GetLinkedDatasetStatusOutput::set_secondarystorageid(::google::protobuf::uint64 value) {
  set_has_secondarystorageid();
  secondarystorageid_ = value;
}

// optional fixed64 secondaryDatasetSize = 8;
inline bool GetLinkedDatasetStatusOutput::has_secondarydatasetsize() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GetLinkedDatasetStatusOutput::set_has_secondarydatasetsize() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GetLinkedDatasetStatusOutput::clear_has_secondarydatasetsize() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GetLinkedDatasetStatusOutput::clear_secondarydatasetsize() {
  secondarydatasetsize_ = GOOGLE_ULONGLONG(0);
  clear_has_secondarydatasetsize();
}
inline ::google::protobuf::uint64 GetLinkedDatasetStatusOutput::secondarydatasetsize() const {
  return secondarydatasetsize_;
}
inline void GetLinkedDatasetStatusOutput::set_secondarydatasetsize(::google::protobuf::uint64 value) {
  set_has_secondarydatasetsize();
  secondarydatasetsize_ = value;
}

// optional fixed64 secondaryDatasetVersion = 9;
inline bool GetLinkedDatasetStatusOutput::has_secondarydatasetversion() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GetLinkedDatasetStatusOutput::set_has_secondarydatasetversion() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GetLinkedDatasetStatusOutput::clear_has_secondarydatasetversion() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GetLinkedDatasetStatusOutput::clear_secondarydatasetversion() {
  secondarydatasetversion_ = GOOGLE_ULONGLONG(0);
  clear_has_secondarydatasetversion();
}
inline ::google::protobuf::uint64 GetLinkedDatasetStatusOutput::secondarydatasetversion() const {
  return secondarydatasetversion_;
}
inline void GetLinkedDatasetStatusOutput::set_secondarydatasetversion(::google::protobuf::uint64 value) {
  set_has_secondarydatasetversion();
  secondarydatasetversion_ = value;
}

// optional fixed64 backupStorageId = 10;
inline bool GetLinkedDatasetStatusOutput::has_backupstorageid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GetLinkedDatasetStatusOutput::set_has_backupstorageid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GetLinkedDatasetStatusOutput::clear_has_backupstorageid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GetLinkedDatasetStatusOutput::clear_backupstorageid() {
  backupstorageid_ = GOOGLE_ULONGLONG(0);
  clear_has_backupstorageid();
}
inline ::google::protobuf::uint64 GetLinkedDatasetStatusOutput::backupstorageid() const {
  return backupstorageid_;
}
inline void GetLinkedDatasetStatusOutput::set_backupstorageid(::google::protobuf::uint64 value) {
  set_has_backupstorageid();
  backupstorageid_ = value;
}

// optional .vplex.vsDirectory.DatasetType datasetType = 11;
inline bool GetLinkedDatasetStatusOutput::has_datasettype() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GetLinkedDatasetStatusOutput::set_has_datasettype() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GetLinkedDatasetStatusOutput::clear_has_datasettype() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GetLinkedDatasetStatusOutput::clear_datasettype() {
  datasettype_ = 1;
  clear_has_datasettype();
}
inline vplex::vsDirectory::DatasetType GetLinkedDatasetStatusOutput::datasettype() const {
  return static_cast< vplex::vsDirectory::DatasetType >(datasettype_);
}
inline void GetLinkedDatasetStatusOutput::set_datasettype(vplex::vsDirectory::DatasetType value) {
  GOOGLE_DCHECK(vplex::vsDirectory::DatasetType_IsValid(value));
  set_has_datasettype();
  datasettype_ = value;
}

// optional bool suspendedFlag = 12;
inline bool GetLinkedDatasetStatusOutput::has_suspendedflag() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GetLinkedDatasetStatusOutput::set_has_suspendedflag() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GetLinkedDatasetStatusOutput::clear_has_suspendedflag() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GetLinkedDatasetStatusOutput::clear_suspendedflag() {
  suspendedflag_ = false;
  clear_has_suspendedflag();
}
inline bool GetLinkedDatasetStatusOutput::suspendedflag() const {
  return suspendedflag_;
}
inline void GetLinkedDatasetStatusOutput::set_suspendedflag(bool value) {
  set_has_suspendedflag();
  suspendedflag_ = value;
}

// -------------------------------------------------------------------

// GetUserQuotaStatusInput

// required fixed64 userId = 1;
inline bool GetUserQuotaStatusInput::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetUserQuotaStatusInput::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetUserQuotaStatusInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetUserQuotaStatusInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 GetUserQuotaStatusInput::userid() const {
  return userid_;
}
inline void GetUserQuotaStatusInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required fixed64 clusterId = 2;
inline bool GetUserQuotaStatusInput::has_clusterid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetUserQuotaStatusInput::set_has_clusterid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetUserQuotaStatusInput::clear_has_clusterid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetUserQuotaStatusInput::clear_clusterid() {
  clusterid_ = GOOGLE_ULONGLONG(0);
  clear_has_clusterid();
}
inline ::google::protobuf::uint64 GetUserQuotaStatusInput::clusterid() const {
  return clusterid_;
}
inline void GetUserQuotaStatusInput::set_clusterid(::google::protobuf::uint64 value) {
  set_has_clusterid();
  clusterid_ = value;
}

// optional string version = 3;
inline bool GetUserQuotaStatusInput::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetUserQuotaStatusInput::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetUserQuotaStatusInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetUserQuotaStatusInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& GetUserQuotaStatusInput::version() const {
  return *version_;
}
inline void GetUserQuotaStatusInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetUserQuotaStatusInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetUserQuotaStatusInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetUserQuotaStatusInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* GetUserQuotaStatusInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetUserQuotaStatusOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool GetUserQuotaStatusOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetUserQuotaStatusOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetUserQuotaStatusOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetUserQuotaStatusOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& GetUserQuotaStatusOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* GetUserQuotaStatusOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* GetUserQuotaStatusOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// optional fixed64 quotaLimit = 2;
inline bool GetUserQuotaStatusOutput::has_quotalimit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetUserQuotaStatusOutput::set_has_quotalimit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetUserQuotaStatusOutput::clear_has_quotalimit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetUserQuotaStatusOutput::clear_quotalimit() {
  quotalimit_ = GOOGLE_ULONGLONG(0);
  clear_has_quotalimit();
}
inline ::google::protobuf::uint64 GetUserQuotaStatusOutput::quotalimit() const {
  return quotalimit_;
}
inline void GetUserQuotaStatusOutput::set_quotalimit(::google::protobuf::uint64 value) {
  set_has_quotalimit();
  quotalimit_ = value;
}

// optional fixed64 currentUsage = 3;
inline bool GetUserQuotaStatusOutput::has_currentusage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetUserQuotaStatusOutput::set_has_currentusage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetUserQuotaStatusOutput::clear_has_currentusage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetUserQuotaStatusOutput::clear_currentusage() {
  currentusage_ = GOOGLE_ULONGLONG(0);
  clear_has_currentusage();
}
inline ::google::protobuf::uint64 GetUserQuotaStatusOutput::currentusage() const {
  return currentusage_;
}
inline void GetUserQuotaStatusOutput::set_currentusage(::google::protobuf::uint64 value) {
  set_has_currentusage();
  currentusage_ = value;
}

// -------------------------------------------------------------------

// GetDatasetsToBackupInput

// required fixed64 backupStorageId = 1;
inline bool GetDatasetsToBackupInput::has_backupstorageid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetDatasetsToBackupInput::set_has_backupstorageid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetDatasetsToBackupInput::clear_has_backupstorageid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetDatasetsToBackupInput::clear_backupstorageid() {
  backupstorageid_ = GOOGLE_ULONGLONG(0);
  clear_has_backupstorageid();
}
inline ::google::protobuf::uint64 GetDatasetsToBackupInput::backupstorageid() const {
  return backupstorageid_;
}
inline void GetDatasetsToBackupInput::set_backupstorageid(::google::protobuf::uint64 value) {
  set_has_backupstorageid();
  backupstorageid_ = value;
}

// required fixed64 userId = 2;
inline bool GetDatasetsToBackupInput::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetDatasetsToBackupInput::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetDatasetsToBackupInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetDatasetsToBackupInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 GetDatasetsToBackupInput::userid() const {
  return userid_;
}
inline void GetDatasetsToBackupInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required fixed64 datasetId = 3;
inline bool GetDatasetsToBackupInput::has_datasetid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetDatasetsToBackupInput::set_has_datasetid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetDatasetsToBackupInput::clear_has_datasetid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetDatasetsToBackupInput::clear_datasetid() {
  datasetid_ = GOOGLE_ULONGLONG(0);
  clear_has_datasetid();
}
inline ::google::protobuf::uint64 GetDatasetsToBackupInput::datasetid() const {
  return datasetid_;
}
inline void GetDatasetsToBackupInput::set_datasetid(::google::protobuf::uint64 value) {
  set_has_datasetid();
  datasetid_ = value;
}

// required fixed32 count = 4;
inline bool GetDatasetsToBackupInput::has_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetDatasetsToBackupInput::set_has_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetDatasetsToBackupInput::clear_has_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetDatasetsToBackupInput::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 GetDatasetsToBackupInput::count() const {
  return count_;
}
inline void GetDatasetsToBackupInput::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// optional fixed64 clusterId = 5;
inline bool GetDatasetsToBackupInput::has_clusterid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetDatasetsToBackupInput::set_has_clusterid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetDatasetsToBackupInput::clear_has_clusterid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetDatasetsToBackupInput::clear_clusterid() {
  clusterid_ = GOOGLE_ULONGLONG(0);
  clear_has_clusterid();
}
inline ::google::protobuf::uint64 GetDatasetsToBackupInput::clusterid() const {
  return clusterid_;
}
inline void GetDatasetsToBackupInput::set_clusterid(::google::protobuf::uint64 value) {
  set_has_clusterid();
  clusterid_ = value;
}

// optional string version = 6;
inline bool GetDatasetsToBackupInput::has_version() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GetDatasetsToBackupInput::set_has_version() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GetDatasetsToBackupInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GetDatasetsToBackupInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& GetDatasetsToBackupInput::version() const {
  return *version_;
}
inline void GetDatasetsToBackupInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetDatasetsToBackupInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetDatasetsToBackupInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetDatasetsToBackupInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* GetDatasetsToBackupInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetDatasetsToBackupOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool GetDatasetsToBackupOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetDatasetsToBackupOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetDatasetsToBackupOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetDatasetsToBackupOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& GetDatasetsToBackupOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* GetDatasetsToBackupOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* GetDatasetsToBackupOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// repeated .vplex.vsDirectory.BackupStatus datasetsToBackup = 2;
inline int GetDatasetsToBackupOutput::datasetstobackup_size() const {
  return datasetstobackup_.size();
}
inline void GetDatasetsToBackupOutput::clear_datasetstobackup() {
  datasetstobackup_.Clear();
}
inline const ::vplex::vsDirectory::BackupStatus& GetDatasetsToBackupOutput::datasetstobackup(int index) const {
  return datasetstobackup_.Get(index);
}
inline ::vplex::vsDirectory::BackupStatus* GetDatasetsToBackupOutput::mutable_datasetstobackup(int index) {
  return datasetstobackup_.Mutable(index);
}
inline ::vplex::vsDirectory::BackupStatus* GetDatasetsToBackupOutput::add_datasetstobackup() {
  return datasetstobackup_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::BackupStatus >&
GetDatasetsToBackupOutput::datasetstobackup() const {
  return datasetstobackup_;
}
inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::BackupStatus >*
GetDatasetsToBackupOutput::mutable_datasetstobackup() {
  return &datasetstobackup_;
}

// -------------------------------------------------------------------

// GetBRSHostNameInput

// required fixed64 clusterId = 1;
inline bool GetBRSHostNameInput::has_clusterid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetBRSHostNameInput::set_has_clusterid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetBRSHostNameInput::clear_has_clusterid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetBRSHostNameInput::clear_clusterid() {
  clusterid_ = GOOGLE_ULONGLONG(0);
  clear_has_clusterid();
}
inline ::google::protobuf::uint64 GetBRSHostNameInput::clusterid() const {
  return clusterid_;
}
inline void GetBRSHostNameInput::set_clusterid(::google::protobuf::uint64 value) {
  set_has_clusterid();
  clusterid_ = value;
}

// required fixed64 backupStorageId = 2;
inline bool GetBRSHostNameInput::has_backupstorageid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetBRSHostNameInput::set_has_backupstorageid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetBRSHostNameInput::clear_has_backupstorageid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetBRSHostNameInput::clear_backupstorageid() {
  backupstorageid_ = GOOGLE_ULONGLONG(0);
  clear_has_backupstorageid();
}
inline ::google::protobuf::uint64 GetBRSHostNameInput::backupstorageid() const {
  return backupstorageid_;
}
inline void GetBRSHostNameInput::set_backupstorageid(::google::protobuf::uint64 value) {
  set_has_backupstorageid();
  backupstorageid_ = value;
}

// optional string version = 3;
inline bool GetBRSHostNameInput::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetBRSHostNameInput::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetBRSHostNameInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetBRSHostNameInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& GetBRSHostNameInput::version() const {
  return *version_;
}
inline void GetBRSHostNameInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetBRSHostNameInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetBRSHostNameInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetBRSHostNameInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* GetBRSHostNameInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetBRSHostNameOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool GetBRSHostNameOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetBRSHostNameOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetBRSHostNameOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetBRSHostNameOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& GetBRSHostNameOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* GetBRSHostNameOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* GetBRSHostNameOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// optional string hostName = 2;
inline bool GetBRSHostNameOutput::has_hostname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetBRSHostNameOutput::set_has_hostname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetBRSHostNameOutput::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetBRSHostNameOutput::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& GetBRSHostNameOutput::hostname() const {
  return *hostname_;
}
inline void GetBRSHostNameOutput::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void GetBRSHostNameOutput::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void GetBRSHostNameOutput::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetBRSHostNameOutput::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* GetBRSHostNameOutput::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetBackupStorageUnitsForBrsInput

// required fixed64 clusterId = 1;
inline bool GetBackupStorageUnitsForBrsInput::has_clusterid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetBackupStorageUnitsForBrsInput::set_has_clusterid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetBackupStorageUnitsForBrsInput::clear_has_clusterid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetBackupStorageUnitsForBrsInput::clear_clusterid() {
  clusterid_ = GOOGLE_ULONGLONG(0);
  clear_has_clusterid();
}
inline ::google::protobuf::uint64 GetBackupStorageUnitsForBrsInput::clusterid() const {
  return clusterid_;
}
inline void GetBackupStorageUnitsForBrsInput::set_clusterid(::google::protobuf::uint64 value) {
  set_has_clusterid();
  clusterid_ = value;
}

// required fixed64 brsId = 2;
inline bool GetBackupStorageUnitsForBrsInput::has_brsid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetBackupStorageUnitsForBrsInput::set_has_brsid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetBackupStorageUnitsForBrsInput::clear_has_brsid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetBackupStorageUnitsForBrsInput::clear_brsid() {
  brsid_ = GOOGLE_ULONGLONG(0);
  clear_has_brsid();
}
inline ::google::protobuf::uint64 GetBackupStorageUnitsForBrsInput::brsid() const {
  return brsid_;
}
inline void GetBackupStorageUnitsForBrsInput::set_brsid(::google::protobuf::uint64 value) {
  set_has_brsid();
  brsid_ = value;
}

// optional string version = 3;
inline bool GetBackupStorageUnitsForBrsInput::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetBackupStorageUnitsForBrsInput::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetBackupStorageUnitsForBrsInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetBackupStorageUnitsForBrsInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& GetBackupStorageUnitsForBrsInput::version() const {
  return *version_;
}
inline void GetBackupStorageUnitsForBrsInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetBackupStorageUnitsForBrsInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetBackupStorageUnitsForBrsInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetBackupStorageUnitsForBrsInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* GetBackupStorageUnitsForBrsInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetBackupStorageUnitsForBrsOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool GetBackupStorageUnitsForBrsOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetBackupStorageUnitsForBrsOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetBackupStorageUnitsForBrsOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetBackupStorageUnitsForBrsOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& GetBackupStorageUnitsForBrsOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* GetBackupStorageUnitsForBrsOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* GetBackupStorageUnitsForBrsOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// repeated fixed64 backupStorageIds = 2;
inline int GetBackupStorageUnitsForBrsOutput::backupstorageids_size() const {
  return backupstorageids_.size();
}
inline void GetBackupStorageUnitsForBrsOutput::clear_backupstorageids() {
  backupstorageids_.Clear();
}
inline ::google::protobuf::uint64 GetBackupStorageUnitsForBrsOutput::backupstorageids(int index) const {
  return backupstorageids_.Get(index);
}
inline void GetBackupStorageUnitsForBrsOutput::set_backupstorageids(int index, ::google::protobuf::uint64 value) {
  backupstorageids_.Set(index, value);
}
inline void GetBackupStorageUnitsForBrsOutput::add_backupstorageids(::google::protobuf::uint64 value) {
  backupstorageids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
GetBackupStorageUnitsForBrsOutput::backupstorageids() const {
  return backupstorageids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
GetBackupStorageUnitsForBrsOutput::mutable_backupstorageids() {
  return &backupstorageids_;
}

// -------------------------------------------------------------------

// GetUpdatedDatasetsInput

// required string version = 1;
inline bool GetUpdatedDatasetsInput::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetUpdatedDatasetsInput::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetUpdatedDatasetsInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetUpdatedDatasetsInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& GetUpdatedDatasetsInput::version() const {
  return *version_;
}
inline void GetUpdatedDatasetsInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetUpdatedDatasetsInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GetUpdatedDatasetsInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetUpdatedDatasetsInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* GetUpdatedDatasetsInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required fixed64 clusterId = 2;
inline bool GetUpdatedDatasetsInput::has_clusterid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetUpdatedDatasetsInput::set_has_clusterid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetUpdatedDatasetsInput::clear_has_clusterid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetUpdatedDatasetsInput::clear_clusterid() {
  clusterid_ = GOOGLE_ULONGLONG(0);
  clear_has_clusterid();
}
inline ::google::protobuf::uint64 GetUpdatedDatasetsInput::clusterid() const {
  return clusterid_;
}
inline void GetUpdatedDatasetsInput::set_clusterid(::google::protobuf::uint64 value) {
  set_has_clusterid();
  clusterid_ = value;
}

// required fixed64 startTime = 3;
inline bool GetUpdatedDatasetsInput::has_starttime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetUpdatedDatasetsInput::set_has_starttime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetUpdatedDatasetsInput::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetUpdatedDatasetsInput::clear_starttime() {
  starttime_ = GOOGLE_ULONGLONG(0);
  clear_has_starttime();
}
inline ::google::protobuf::uint64 GetUpdatedDatasetsInput::starttime() const {
  return starttime_;
}
inline void GetUpdatedDatasetsInput::set_starttime(::google::protobuf::uint64 value) {
  set_has_starttime();
  starttime_ = value;
}

// required fixed64 endTime = 4;
inline bool GetUpdatedDatasetsInput::has_endtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetUpdatedDatasetsInput::set_has_endtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetUpdatedDatasetsInput::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetUpdatedDatasetsInput::clear_endtime() {
  endtime_ = GOOGLE_ULONGLONG(0);
  clear_has_endtime();
}
inline ::google::protobuf::uint64 GetUpdatedDatasetsInput::endtime() const {
  return endtime_;
}
inline void GetUpdatedDatasetsInput::set_endtime(::google::protobuf::uint64 value) {
  set_has_endtime();
  endtime_ = value;
}

// required fixed32 count = 5;
inline bool GetUpdatedDatasetsInput::has_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetUpdatedDatasetsInput::set_has_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetUpdatedDatasetsInput::clear_has_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetUpdatedDatasetsInput::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 GetUpdatedDatasetsInput::count() const {
  return count_;
}
inline void GetUpdatedDatasetsInput::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// repeated .vplex.vsDirectory.DatasetFilter filters = 6;
inline int GetUpdatedDatasetsInput::filters_size() const {
  return filters_.size();
}
inline void GetUpdatedDatasetsInput::clear_filters() {
  filters_.Clear();
}
inline const ::vplex::vsDirectory::DatasetFilter& GetUpdatedDatasetsInput::filters(int index) const {
  return filters_.Get(index);
}
inline ::vplex::vsDirectory::DatasetFilter* GetUpdatedDatasetsInput::mutable_filters(int index) {
  return filters_.Mutable(index);
}
inline ::vplex::vsDirectory::DatasetFilter* GetUpdatedDatasetsInput::add_filters() {
  return filters_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::DatasetFilter >&
GetUpdatedDatasetsInput::filters() const {
  return filters_;
}
inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::DatasetFilter >*
GetUpdatedDatasetsInput::mutable_filters() {
  return &filters_;
}

// -------------------------------------------------------------------

// GetUpdatedDatasetsOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool GetUpdatedDatasetsOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetUpdatedDatasetsOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetUpdatedDatasetsOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetUpdatedDatasetsOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& GetUpdatedDatasetsOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* GetUpdatedDatasetsOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* GetUpdatedDatasetsOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// repeated .vplex.vsDirectory.UpdatedDataset datasets = 2;
inline int GetUpdatedDatasetsOutput::datasets_size() const {
  return datasets_.size();
}
inline void GetUpdatedDatasetsOutput::clear_datasets() {
  datasets_.Clear();
}
inline const ::vplex::vsDirectory::UpdatedDataset& GetUpdatedDatasetsOutput::datasets(int index) const {
  return datasets_.Get(index);
}
inline ::vplex::vsDirectory::UpdatedDataset* GetUpdatedDatasetsOutput::mutable_datasets(int index) {
  return datasets_.Mutable(index);
}
inline ::vplex::vsDirectory::UpdatedDataset* GetUpdatedDatasetsOutput::add_datasets() {
  return datasets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::UpdatedDataset >&
GetUpdatedDatasetsOutput::datasets() const {
  return datasets_;
}
inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::UpdatedDataset >*
GetUpdatedDatasetsOutput::mutable_datasets() {
  return &datasets_;
}

// -------------------------------------------------------------------

// AddDatasetArchiveStorageDeviceInput

// required fixed64 datasetId = 1;
inline bool AddDatasetArchiveStorageDeviceInput::has_datasetid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddDatasetArchiveStorageDeviceInput::set_has_datasetid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddDatasetArchiveStorageDeviceInput::clear_has_datasetid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddDatasetArchiveStorageDeviceInput::clear_datasetid() {
  datasetid_ = GOOGLE_ULONGLONG(0);
  clear_has_datasetid();
}
inline ::google::protobuf::uint64 AddDatasetArchiveStorageDeviceInput::datasetid() const {
  return datasetid_;
}
inline void AddDatasetArchiveStorageDeviceInput::set_datasetid(::google::protobuf::uint64 value) {
  set_has_datasetid();
  datasetid_ = value;
}

// repeated fixed64 archiveStorageDeviceId = 2;
inline int AddDatasetArchiveStorageDeviceInput::archivestoragedeviceid_size() const {
  return archivestoragedeviceid_.size();
}
inline void AddDatasetArchiveStorageDeviceInput::clear_archivestoragedeviceid() {
  archivestoragedeviceid_.Clear();
}
inline ::google::protobuf::uint64 AddDatasetArchiveStorageDeviceInput::archivestoragedeviceid(int index) const {
  return archivestoragedeviceid_.Get(index);
}
inline void AddDatasetArchiveStorageDeviceInput::set_archivestoragedeviceid(int index, ::google::protobuf::uint64 value) {
  archivestoragedeviceid_.Set(index, value);
}
inline void AddDatasetArchiveStorageDeviceInput::add_archivestoragedeviceid(::google::protobuf::uint64 value) {
  archivestoragedeviceid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
AddDatasetArchiveStorageDeviceInput::archivestoragedeviceid() const {
  return archivestoragedeviceid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
AddDatasetArchiveStorageDeviceInput::mutable_archivestoragedeviceid() {
  return &archivestoragedeviceid_;
}

// required .vplex.vsDirectory.SessionInfo session = 3;
inline bool AddDatasetArchiveStorageDeviceInput::has_session() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AddDatasetArchiveStorageDeviceInput::set_has_session() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AddDatasetArchiveStorageDeviceInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AddDatasetArchiveStorageDeviceInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& AddDatasetArchiveStorageDeviceInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* AddDatasetArchiveStorageDeviceInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* AddDatasetArchiveStorageDeviceInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 userId = 4;
inline bool AddDatasetArchiveStorageDeviceInput::has_userid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AddDatasetArchiveStorageDeviceInput::set_has_userid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AddDatasetArchiveStorageDeviceInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AddDatasetArchiveStorageDeviceInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 AddDatasetArchiveStorageDeviceInput::userid() const {
  return userid_;
}
inline void AddDatasetArchiveStorageDeviceInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// optional string version = 5;
inline bool AddDatasetArchiveStorageDeviceInput::has_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AddDatasetArchiveStorageDeviceInput::set_has_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AddDatasetArchiveStorageDeviceInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AddDatasetArchiveStorageDeviceInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& AddDatasetArchiveStorageDeviceInput::version() const {
  return *version_;
}
inline void AddDatasetArchiveStorageDeviceInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void AddDatasetArchiveStorageDeviceInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void AddDatasetArchiveStorageDeviceInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddDatasetArchiveStorageDeviceInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* AddDatasetArchiveStorageDeviceInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AddDatasetArchiveStorageDeviceOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool AddDatasetArchiveStorageDeviceOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddDatasetArchiveStorageDeviceOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddDatasetArchiveStorageDeviceOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddDatasetArchiveStorageDeviceOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& AddDatasetArchiveStorageDeviceOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* AddDatasetArchiveStorageDeviceOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* AddDatasetArchiveStorageDeviceOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// RemoveDatasetArchiveStorageDeviceInput

// required fixed64 datasetId = 1;
inline bool RemoveDatasetArchiveStorageDeviceInput::has_datasetid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoveDatasetArchiveStorageDeviceInput::set_has_datasetid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoveDatasetArchiveStorageDeviceInput::clear_has_datasetid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoveDatasetArchiveStorageDeviceInput::clear_datasetid() {
  datasetid_ = GOOGLE_ULONGLONG(0);
  clear_has_datasetid();
}
inline ::google::protobuf::uint64 RemoveDatasetArchiveStorageDeviceInput::datasetid() const {
  return datasetid_;
}
inline void RemoveDatasetArchiveStorageDeviceInput::set_datasetid(::google::protobuf::uint64 value) {
  set_has_datasetid();
  datasetid_ = value;
}

// repeated fixed64 archiveStorageDeviceId = 2;
inline int RemoveDatasetArchiveStorageDeviceInput::archivestoragedeviceid_size() const {
  return archivestoragedeviceid_.size();
}
inline void RemoveDatasetArchiveStorageDeviceInput::clear_archivestoragedeviceid() {
  archivestoragedeviceid_.Clear();
}
inline ::google::protobuf::uint64 RemoveDatasetArchiveStorageDeviceInput::archivestoragedeviceid(int index) const {
  return archivestoragedeviceid_.Get(index);
}
inline void RemoveDatasetArchiveStorageDeviceInput::set_archivestoragedeviceid(int index, ::google::protobuf::uint64 value) {
  archivestoragedeviceid_.Set(index, value);
}
inline void RemoveDatasetArchiveStorageDeviceInput::add_archivestoragedeviceid(::google::protobuf::uint64 value) {
  archivestoragedeviceid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
RemoveDatasetArchiveStorageDeviceInput::archivestoragedeviceid() const {
  return archivestoragedeviceid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
RemoveDatasetArchiveStorageDeviceInput::mutable_archivestoragedeviceid() {
  return &archivestoragedeviceid_;
}

// required .vplex.vsDirectory.SessionInfo session = 3;
inline bool RemoveDatasetArchiveStorageDeviceInput::has_session() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RemoveDatasetArchiveStorageDeviceInput::set_has_session() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RemoveDatasetArchiveStorageDeviceInput::clear_has_session() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RemoveDatasetArchiveStorageDeviceInput::clear_session() {
  if (session_ != NULL) session_->::vplex::vsDirectory::SessionInfo::Clear();
  clear_has_session();
}
inline const ::vplex::vsDirectory::SessionInfo& RemoveDatasetArchiveStorageDeviceInput::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::vplex::vsDirectory::SessionInfo* RemoveDatasetArchiveStorageDeviceInput::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::vplex::vsDirectory::SessionInfo;
  return session_;
}
inline ::vplex::vsDirectory::SessionInfo* RemoveDatasetArchiveStorageDeviceInput::release_session() {
  clear_has_session();
  ::vplex::vsDirectory::SessionInfo* temp = session_;
  session_ = NULL;
  return temp;
}

// required fixed64 userId = 4;
inline bool RemoveDatasetArchiveStorageDeviceInput::has_userid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RemoveDatasetArchiveStorageDeviceInput::set_has_userid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RemoveDatasetArchiveStorageDeviceInput::clear_has_userid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RemoveDatasetArchiveStorageDeviceInput::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 RemoveDatasetArchiveStorageDeviceInput::userid() const {
  return userid_;
}
inline void RemoveDatasetArchiveStorageDeviceInput::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// optional string version = 5;
inline bool RemoveDatasetArchiveStorageDeviceInput::has_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RemoveDatasetArchiveStorageDeviceInput::set_has_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RemoveDatasetArchiveStorageDeviceInput::clear_has_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RemoveDatasetArchiveStorageDeviceInput::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& RemoveDatasetArchiveStorageDeviceInput::version() const {
  return *version_;
}
inline void RemoveDatasetArchiveStorageDeviceInput::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void RemoveDatasetArchiveStorageDeviceInput::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void RemoveDatasetArchiveStorageDeviceInput::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoveDatasetArchiveStorageDeviceInput::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* RemoveDatasetArchiveStorageDeviceInput::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RemoveDatasetArchiveStorageDeviceOutput

// required .vplex.vsDirectory.Error error = 1;
inline bool RemoveDatasetArchiveStorageDeviceOutput::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoveDatasetArchiveStorageDeviceOutput::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoveDatasetArchiveStorageDeviceOutput::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoveDatasetArchiveStorageDeviceOutput::clear_error() {
  if (error_ != NULL) error_->::vplex::vsDirectory::Error::Clear();
  clear_has_error();
}
inline const ::vplex::vsDirectory::Error& RemoveDatasetArchiveStorageDeviceOutput::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::vplex::vsDirectory::Error* RemoveDatasetArchiveStorageDeviceOutput::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::vplex::vsDirectory::Error;
  return error_;
}
inline ::vplex::vsDirectory::Error* RemoveDatasetArchiveStorageDeviceOutput::release_error() {
  clear_has_error();
  ::vplex::vsDirectory::Error* temp = error_;
  error_ = NULL;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace vsDirectory
}  // namespace vplex

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< vplex::vsDirectory::DatasetType>() {
  return vplex::vsDirectory::DatasetType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< vplex::vsDirectory::RouteType>() {
  return vplex::vsDirectory::RouteType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< vplex::vsDirectory::ProtocolType>() {
  return vplex::vsDirectory::ProtocolType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< vplex::vsDirectory::PortType>() {
  return vplex::vsDirectory::PortType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< vplex::vsDirectory::SubscriptionRole>() {
  return vplex::vsDirectory::SubscriptionRole_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_vplex_5fvs_5fdirectory_5fservice_5ftypes_2eproto__INCLUDED
