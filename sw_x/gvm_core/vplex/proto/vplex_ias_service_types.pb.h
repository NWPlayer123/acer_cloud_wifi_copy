// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vplex_ias_service_types.proto

#ifndef PROTOBUF_vplex_5fias_5fservice_5ftypes_2eproto__INCLUDED
#define PROTOBUF_vplex_5fias_5fservice_5ftypes_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace vplex {
namespace ias {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_vplex_5fias_5fservice_5ftypes_2eproto();
void protobuf_AssignDesc_vplex_5fias_5fservice_5ftypes_2eproto();
void protobuf_ShutdownFile_vplex_5fias_5fservice_5ftypes_2eproto();

class AbstractRequestType;
class AbstractResponseType;
class CheckVirtualDeviceCredentialsRenewalRequestType;
class CheckVirtualDeviceCredentialsRenewalResponseType;
class StrAttributeType;
class GetSessionKeyRequestType;
class GetSessionKeyResponseType;
class LoginRequestType;
class LoginResponseType;
class LogoutRequestType;
class LogoutResponseType;
class RegisterVirtualDeviceRequestType;
class RegisterVirtualDeviceResponseType;
class RenewVirtualDeviceCredentialsRequestType;
class RenewVirtualDeviceCredentialsResponseType;
class GetServerKeyRequestType;
class GetServerKeyResponseType;
class RequestPairingRequestType;
class RequestPairingResponseType;
class RespondToPairingRequestRequestType;
class RespondToPairingRequestResponseType;
class RequestPairingPinRequestType;
class RequestPairingPinResponseType;
class GetPairingStatusRequestType;
class GetPairingStatusResponseType;

// ===================================================================

class AbstractRequestType : public ::google::protobuf::Message {
 public:
  AbstractRequestType();
  virtual ~AbstractRequestType();
  
  AbstractRequestType(const AbstractRequestType& from);
  
  inline AbstractRequestType& operator=(const AbstractRequestType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AbstractRequestType& default_instance();
  
  void Swap(AbstractRequestType* other);
  
  // implements Message ----------------------------------------------
  
  AbstractRequestType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AbstractRequestType& from);
  void MergeFrom(const AbstractRequestType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string Version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // required string MessageId = 2;
  inline bool has_messageid() const;
  inline void clear_messageid();
  static const int kMessageIdFieldNumber = 2;
  inline const ::std::string& messageid() const;
  inline void set_messageid(const ::std::string& value);
  inline void set_messageid(const char* value);
  inline void set_messageid(const char* value, size_t size);
  inline ::std::string* mutable_messageid();
  inline ::std::string* release_messageid();
  
  // optional fixed64 DeviceId = 3;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIdFieldNumber = 3;
  inline ::google::protobuf::uint64 deviceid() const;
  inline void set_deviceid(::google::protobuf::uint64 value);
  
  // optional string Region = 7;
  inline bool has_region() const;
  inline void clear_region();
  static const int kRegionFieldNumber = 7;
  inline const ::std::string& region() const;
  inline void set_region(const ::std::string& value);
  inline void set_region(const char* value);
  inline void set_region(const char* value, size_t size);
  inline ::std::string* mutable_region();
  inline ::std::string* release_region();
  
  // optional string Country = 8;
  inline bool has_country() const;
  inline void clear_country();
  static const int kCountryFieldNumber = 8;
  inline const ::std::string& country() const;
  inline void set_country(const ::std::string& value);
  inline void set_country(const char* value);
  inline void set_country(const char* value, size_t size);
  inline ::std::string* mutable_country();
  inline ::std::string* release_country();
  
  // optional string Language = 9;
  inline bool has_language() const;
  inline void clear_language();
  static const int kLanguageFieldNumber = 9;
  inline const ::std::string& language() const;
  inline void set_language(const ::std::string& value);
  inline void set_language(const char* value);
  inline void set_language(const char* value, size_t size);
  inline ::std::string* mutable_language();
  inline ::std::string* release_language();
  
  // optional fixed64 SessionHandle = 10;
  inline bool has_sessionhandle() const;
  inline void clear_sessionhandle();
  static const int kSessionHandleFieldNumber = 10;
  inline ::google::protobuf::uint64 sessionhandle() const;
  inline void set_sessionhandle(::google::protobuf::uint64 value);
  
  // optional bytes ServiceTicket = 11;
  inline bool has_serviceticket() const;
  inline void clear_serviceticket();
  static const int kServiceTicketFieldNumber = 11;
  inline const ::std::string& serviceticket() const;
  inline void set_serviceticket(const ::std::string& value);
  inline void set_serviceticket(const char* value);
  inline void set_serviceticket(const void* value, size_t size);
  inline ::std::string* mutable_serviceticket();
  inline ::std::string* release_serviceticket();
  
  // optional string ServiceId = 12;
  inline bool has_serviceid() const;
  inline void clear_serviceid();
  static const int kServiceIdFieldNumber = 12;
  inline const ::std::string& serviceid() const;
  inline void set_serviceid(const ::std::string& value);
  inline void set_serviceid(const char* value);
  inline void set_serviceid(const char* value, size_t size);
  inline ::std::string* mutable_serviceid();
  inline ::std::string* release_serviceid();
  
  // @@protoc_insertion_point(class_scope:vplex.ias.AbstractRequestType)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_messageid();
  inline void clear_has_messageid();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_region();
  inline void clear_has_region();
  inline void set_has_country();
  inline void clear_has_country();
  inline void set_has_language();
  inline void clear_has_language();
  inline void set_has_sessionhandle();
  inline void clear_has_sessionhandle();
  inline void set_has_serviceticket();
  inline void clear_has_serviceticket();
  inline void set_has_serviceid();
  inline void clear_has_serviceid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* version_;
  ::std::string* messageid_;
  ::google::protobuf::uint64 deviceid_;
  ::std::string* region_;
  ::std::string* country_;
  ::std::string* language_;
  ::google::protobuf::uint64 sessionhandle_;
  ::std::string* serviceticket_;
  ::std::string* serviceid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fias_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static AbstractRequestType* default_instance_;
};
// -------------------------------------------------------------------

class AbstractResponseType : public ::google::protobuf::Message {
 public:
  AbstractResponseType();
  virtual ~AbstractResponseType();
  
  AbstractResponseType(const AbstractResponseType& from);
  
  inline AbstractResponseType& operator=(const AbstractResponseType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AbstractResponseType& default_instance();
  
  void Swap(AbstractResponseType* other);
  
  // implements Message ----------------------------------------------
  
  AbstractResponseType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AbstractResponseType& from);
  void MergeFrom(const AbstractResponseType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string Version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // optional fixed64 DeviceId = 2;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIdFieldNumber = 2;
  inline ::google::protobuf::uint64 deviceid() const;
  inline void set_deviceid(::google::protobuf::uint64 value);
  
  // required string MessageId = 3;
  inline bool has_messageid() const;
  inline void clear_messageid();
  static const int kMessageIdFieldNumber = 3;
  inline const ::std::string& messageid() const;
  inline void set_messageid(const ::std::string& value);
  inline void set_messageid(const char* value);
  inline void set_messageid(const char* value, size_t size);
  inline ::std::string* mutable_messageid();
  inline ::std::string* release_messageid();
  
  // required fixed64 TimeStamp = 4;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimeStampFieldNumber = 4;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);
  
  // required sint32 ErrorCode = 5;
  inline bool has_errorcode() const;
  inline void clear_errorcode();
  static const int kErrorCodeFieldNumber = 5;
  inline ::google::protobuf::int32 errorcode() const;
  inline void set_errorcode(::google::protobuf::int32 value);
  
  // optional string ErrorMessage = 6;
  inline bool has_errormessage() const;
  inline void clear_errormessage();
  static const int kErrorMessageFieldNumber = 6;
  inline const ::std::string& errormessage() const;
  inline void set_errormessage(const ::std::string& value);
  inline void set_errormessage(const char* value);
  inline void set_errormessage(const char* value, size_t size);
  inline ::std::string* mutable_errormessage();
  inline ::std::string* release_errormessage();
  
  // optional bool ServiceStandbyMode = 7;
  inline bool has_servicestandbymode() const;
  inline void clear_servicestandbymode();
  static const int kServiceStandbyModeFieldNumber = 7;
  inline bool servicestandbymode() const;
  inline void set_servicestandbymode(bool value);
  
  // @@protoc_insertion_point(class_scope:vplex.ias.AbstractResponseType)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_messageid();
  inline void clear_has_messageid();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_errormessage();
  inline void clear_has_errormessage();
  inline void set_has_servicestandbymode();
  inline void clear_has_servicestandbymode();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* version_;
  ::google::protobuf::uint64 deviceid_;
  ::std::string* messageid_;
  ::google::protobuf::uint64 timestamp_;
  ::std::string* errormessage_;
  ::google::protobuf::int32 errorcode_;
  bool servicestandbymode_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fias_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static AbstractResponseType* default_instance_;
};
// -------------------------------------------------------------------

class CheckVirtualDeviceCredentialsRenewalRequestType : public ::google::protobuf::Message {
 public:
  CheckVirtualDeviceCredentialsRenewalRequestType();
  virtual ~CheckVirtualDeviceCredentialsRenewalRequestType();
  
  CheckVirtualDeviceCredentialsRenewalRequestType(const CheckVirtualDeviceCredentialsRenewalRequestType& from);
  
  inline CheckVirtualDeviceCredentialsRenewalRequestType& operator=(const CheckVirtualDeviceCredentialsRenewalRequestType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckVirtualDeviceCredentialsRenewalRequestType& default_instance();
  
  void Swap(CheckVirtualDeviceCredentialsRenewalRequestType* other);
  
  // implements Message ----------------------------------------------
  
  CheckVirtualDeviceCredentialsRenewalRequestType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CheckVirtualDeviceCredentialsRenewalRequestType& from);
  void MergeFrom(const CheckVirtualDeviceCredentialsRenewalRequestType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.ias.AbstractRequestType _inherited = 1;
  inline bool has__inherited() const;
  inline void clear__inherited();
  static const int kInheritedFieldNumber = 1;
  inline const ::vplex::ias::AbstractRequestType& _inherited() const;
  inline ::vplex::ias::AbstractRequestType* mutable__inherited();
  inline ::vplex::ias::AbstractRequestType* release__inherited();
  
  // required fixed64 IssueDate = 2;
  inline bool has_issuedate() const;
  inline void clear_issuedate();
  static const int kIssueDateFieldNumber = 2;
  inline ::google::protobuf::uint64 issuedate() const;
  inline void set_issuedate(::google::protobuf::uint64 value);
  
  // required fixed64 SerialNumber = 3;
  inline bool has_serialnumber() const;
  inline void clear_serialnumber();
  static const int kSerialNumberFieldNumber = 3;
  inline ::google::protobuf::uint64 serialnumber() const;
  inline void set_serialnumber(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:vplex.ias.CheckVirtualDeviceCredentialsRenewalRequestType)
 private:
  inline void set_has__inherited();
  inline void clear_has__inherited();
  inline void set_has_issuedate();
  inline void clear_has_issuedate();
  inline void set_has_serialnumber();
  inline void clear_has_serialnumber();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::ias::AbstractRequestType* _inherited_;
  ::google::protobuf::uint64 issuedate_;
  ::google::protobuf::uint64 serialnumber_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fias_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static CheckVirtualDeviceCredentialsRenewalRequestType* default_instance_;
};
// -------------------------------------------------------------------

class CheckVirtualDeviceCredentialsRenewalResponseType : public ::google::protobuf::Message {
 public:
  CheckVirtualDeviceCredentialsRenewalResponseType();
  virtual ~CheckVirtualDeviceCredentialsRenewalResponseType();
  
  CheckVirtualDeviceCredentialsRenewalResponseType(const CheckVirtualDeviceCredentialsRenewalResponseType& from);
  
  inline CheckVirtualDeviceCredentialsRenewalResponseType& operator=(const CheckVirtualDeviceCredentialsRenewalResponseType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckVirtualDeviceCredentialsRenewalResponseType& default_instance();
  
  void Swap(CheckVirtualDeviceCredentialsRenewalResponseType* other);
  
  // implements Message ----------------------------------------------
  
  CheckVirtualDeviceCredentialsRenewalResponseType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CheckVirtualDeviceCredentialsRenewalResponseType& from);
  void MergeFrom(const CheckVirtualDeviceCredentialsRenewalResponseType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.ias.AbstractResponseType _inherited = 1;
  inline bool has__inherited() const;
  inline void clear__inherited();
  static const int kInheritedFieldNumber = 1;
  inline const ::vplex::ias::AbstractResponseType& _inherited() const;
  inline ::vplex::ias::AbstractResponseType* mutable__inherited();
  inline ::vplex::ias::AbstractResponseType* release__inherited();
  
  // required fixed64 ExpectedSerialNumber = 2;
  inline bool has_expectedserialnumber() const;
  inline void clear_expectedserialnumber();
  static const int kExpectedSerialNumberFieldNumber = 2;
  inline ::google::protobuf::uint64 expectedserialnumber() const;
  inline void set_expectedserialnumber(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:vplex.ias.CheckVirtualDeviceCredentialsRenewalResponseType)
 private:
  inline void set_has__inherited();
  inline void clear_has__inherited();
  inline void set_has_expectedserialnumber();
  inline void clear_has_expectedserialnumber();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::ias::AbstractResponseType* _inherited_;
  ::google::protobuf::uint64 expectedserialnumber_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fias_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static CheckVirtualDeviceCredentialsRenewalResponseType* default_instance_;
};
// -------------------------------------------------------------------

class StrAttributeType : public ::google::protobuf::Message {
 public:
  StrAttributeType();
  virtual ~StrAttributeType();
  
  StrAttributeType(const StrAttributeType& from);
  
  inline StrAttributeType& operator=(const StrAttributeType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StrAttributeType& default_instance();
  
  void Swap(StrAttributeType* other);
  
  // implements Message ----------------------------------------------
  
  StrAttributeType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StrAttributeType& from);
  void MergeFrom(const StrAttributeType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string AttributeName = 1;
  inline bool has_attributename() const;
  inline void clear_attributename();
  static const int kAttributeNameFieldNumber = 1;
  inline const ::std::string& attributename() const;
  inline void set_attributename(const ::std::string& value);
  inline void set_attributename(const char* value);
  inline void set_attributename(const char* value, size_t size);
  inline ::std::string* mutable_attributename();
  inline ::std::string* release_attributename();
  
  // required string AttributeValue = 2;
  inline bool has_attributevalue() const;
  inline void clear_attributevalue();
  static const int kAttributeValueFieldNumber = 2;
  inline const ::std::string& attributevalue() const;
  inline void set_attributevalue(const ::std::string& value);
  inline void set_attributevalue(const char* value);
  inline void set_attributevalue(const char* value, size_t size);
  inline ::std::string* mutable_attributevalue();
  inline ::std::string* release_attributevalue();
  
  // @@protoc_insertion_point(class_scope:vplex.ias.StrAttributeType)
 private:
  inline void set_has_attributename();
  inline void clear_has_attributename();
  inline void set_has_attributevalue();
  inline void clear_has_attributevalue();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* attributename_;
  ::std::string* attributevalue_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fias_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static StrAttributeType* default_instance_;
};
// -------------------------------------------------------------------

class GetSessionKeyRequestType : public ::google::protobuf::Message {
 public:
  GetSessionKeyRequestType();
  virtual ~GetSessionKeyRequestType();
  
  GetSessionKeyRequestType(const GetSessionKeyRequestType& from);
  
  inline GetSessionKeyRequestType& operator=(const GetSessionKeyRequestType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSessionKeyRequestType& default_instance();
  
  void Swap(GetSessionKeyRequestType* other);
  
  // implements Message ----------------------------------------------
  
  GetSessionKeyRequestType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetSessionKeyRequestType& from);
  void MergeFrom(const GetSessionKeyRequestType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.ias.AbstractRequestType _inherited = 1;
  inline bool has__inherited() const;
  inline void clear__inherited();
  static const int kInheritedFieldNumber = 1;
  inline const ::vplex::ias::AbstractRequestType& _inherited() const;
  inline ::vplex::ias::AbstractRequestType* mutable__inherited();
  inline ::vplex::ias::AbstractRequestType* release__inherited();
  
  // required string Type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  
  // repeated .vplex.ias.StrAttributeType KeyAttributes = 3;
  inline int keyattributes_size() const;
  inline void clear_keyattributes();
  static const int kKeyAttributesFieldNumber = 3;
  inline const ::vplex::ias::StrAttributeType& keyattributes(int index) const;
  inline ::vplex::ias::StrAttributeType* mutable_keyattributes(int index);
  inline ::vplex::ias::StrAttributeType* add_keyattributes();
  inline const ::google::protobuf::RepeatedPtrField< ::vplex::ias::StrAttributeType >&
      keyattributes() const;
  inline ::google::protobuf::RepeatedPtrField< ::vplex::ias::StrAttributeType >*
      mutable_keyattributes();
  
  // optional bytes EncryptedSessionKey = 4;
  inline bool has_encryptedsessionkey() const;
  inline void clear_encryptedsessionkey();
  static const int kEncryptedSessionKeyFieldNumber = 4;
  inline const ::std::string& encryptedsessionkey() const;
  inline void set_encryptedsessionkey(const ::std::string& value);
  inline void set_encryptedsessionkey(const char* value);
  inline void set_encryptedsessionkey(const void* value, size_t size);
  inline ::std::string* mutable_encryptedsessionkey();
  inline ::std::string* release_encryptedsessionkey();
  
  // @@protoc_insertion_point(class_scope:vplex.ias.GetSessionKeyRequestType)
 private:
  inline void set_has__inherited();
  inline void clear_has__inherited();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_encryptedsessionkey();
  inline void clear_has_encryptedsessionkey();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::ias::AbstractRequestType* _inherited_;
  ::std::string* type_;
  ::google::protobuf::RepeatedPtrField< ::vplex::ias::StrAttributeType > keyattributes_;
  ::std::string* encryptedsessionkey_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fias_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetSessionKeyRequestType* default_instance_;
};
// -------------------------------------------------------------------

class GetSessionKeyResponseType : public ::google::protobuf::Message {
 public:
  GetSessionKeyResponseType();
  virtual ~GetSessionKeyResponseType();
  
  GetSessionKeyResponseType(const GetSessionKeyResponseType& from);
  
  inline GetSessionKeyResponseType& operator=(const GetSessionKeyResponseType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSessionKeyResponseType& default_instance();
  
  void Swap(GetSessionKeyResponseType* other);
  
  // implements Message ----------------------------------------------
  
  GetSessionKeyResponseType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetSessionKeyResponseType& from);
  void MergeFrom(const GetSessionKeyResponseType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.ias.AbstractResponseType _inherited = 1;
  inline bool has__inherited() const;
  inline void clear__inherited();
  static const int kInheritedFieldNumber = 1;
  inline const ::vplex::ias::AbstractResponseType& _inherited() const;
  inline ::vplex::ias::AbstractResponseType* mutable__inherited();
  inline ::vplex::ias::AbstractResponseType* release__inherited();
  
  // optional bytes SessionKey = 2;
  inline bool has_sessionkey() const;
  inline void clear_sessionkey();
  static const int kSessionKeyFieldNumber = 2;
  inline const ::std::string& sessionkey() const;
  inline void set_sessionkey(const ::std::string& value);
  inline void set_sessionkey(const char* value);
  inline void set_sessionkey(const void* value, size_t size);
  inline ::std::string* mutable_sessionkey();
  inline ::std::string* release_sessionkey();
  
  // optional bytes EncryptedSessionKey = 3;
  inline bool has_encryptedsessionkey() const;
  inline void clear_encryptedsessionkey();
  static const int kEncryptedSessionKeyFieldNumber = 3;
  inline const ::std::string& encryptedsessionkey() const;
  inline void set_encryptedsessionkey(const ::std::string& value);
  inline void set_encryptedsessionkey(const char* value);
  inline void set_encryptedsessionkey(const void* value, size_t size);
  inline ::std::string* mutable_encryptedsessionkey();
  inline ::std::string* release_encryptedsessionkey();
  
  // optional uint32 InstanceId = 4;
  inline bool has_instanceid() const;
  inline void clear_instanceid();
  static const int kInstanceIdFieldNumber = 4;
  inline ::google::protobuf::uint32 instanceid() const;
  inline void set_instanceid(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:vplex.ias.GetSessionKeyResponseType)
 private:
  inline void set_has__inherited();
  inline void clear_has__inherited();
  inline void set_has_sessionkey();
  inline void clear_has_sessionkey();
  inline void set_has_encryptedsessionkey();
  inline void clear_has_encryptedsessionkey();
  inline void set_has_instanceid();
  inline void clear_has_instanceid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::ias::AbstractResponseType* _inherited_;
  ::std::string* sessionkey_;
  ::std::string* encryptedsessionkey_;
  ::google::protobuf::uint32 instanceid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fias_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetSessionKeyResponseType* default_instance_;
};
// -------------------------------------------------------------------

class LoginRequestType : public ::google::protobuf::Message {
 public:
  LoginRequestType();
  virtual ~LoginRequestType();
  
  LoginRequestType(const LoginRequestType& from);
  
  inline LoginRequestType& operator=(const LoginRequestType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginRequestType& default_instance();
  
  void Swap(LoginRequestType* other);
  
  // implements Message ----------------------------------------------
  
  LoginRequestType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginRequestType& from);
  void MergeFrom(const LoginRequestType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.ias.AbstractRequestType _inherited = 1;
  inline bool has__inherited() const;
  inline void clear__inherited();
  static const int kInheritedFieldNumber = 1;
  inline const ::vplex::ias::AbstractRequestType& _inherited() const;
  inline ::vplex::ias::AbstractRequestType* mutable__inherited();
  inline ::vplex::ias::AbstractRequestType* release__inherited();
  
  // optional string Username = 2;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 2;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // required string Namespace = 3;
  inline bool has_namespace_() const;
  inline void clear_namespace_();
  static const int kNamespaceFieldNumber = 3;
  inline const ::std::string& namespace_() const;
  inline void set_namespace_(const ::std::string& value);
  inline void set_namespace_(const char* value);
  inline void set_namespace_(const char* value, size_t size);
  inline ::std::string* mutable_namespace_();
  inline ::std::string* release_namespace_();
  
  // optional string Password = 4;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 4;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  
  // optional string WeakToken = 5;
  inline bool has_weaktoken() const;
  inline void clear_weaktoken();
  static const int kWeakTokenFieldNumber = 5;
  inline const ::std::string& weaktoken() const;
  inline void set_weaktoken(const ::std::string& value);
  inline void set_weaktoken(const char* value);
  inline void set_weaktoken(const char* value, size_t size);
  inline ::std::string* mutable_weaktoken();
  inline ::std::string* release_weaktoken();
  
  // optional string PairingToken = 11;
  inline bool has_pairingtoken() const;
  inline void clear_pairingtoken();
  static const int kPairingTokenFieldNumber = 11;
  inline const ::std::string& pairingtoken() const;
  inline void set_pairingtoken(const ::std::string& value);
  inline void set_pairingtoken(const char* value);
  inline void set_pairingtoken(const char* value, size_t size);
  inline ::std::string* mutable_pairingtoken();
  inline ::std::string* release_pairingtoken();
  
  // optional bool ACEulaAgreed = 10;
  inline bool has_aceulaagreed() const;
  inline void clear_aceulaagreed();
  static const int kACEulaAgreedFieldNumber = 10;
  inline bool aceulaagreed() const;
  inline void set_aceulaagreed(bool value);
  
  // @@protoc_insertion_point(class_scope:vplex.ias.LoginRequestType)
 private:
  inline void set_has__inherited();
  inline void clear_has__inherited();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_namespace_();
  inline void clear_has_namespace_();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_weaktoken();
  inline void clear_has_weaktoken();
  inline void set_has_pairingtoken();
  inline void clear_has_pairingtoken();
  inline void set_has_aceulaagreed();
  inline void clear_has_aceulaagreed();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::ias::AbstractRequestType* _inherited_;
  ::std::string* username_;
  ::std::string* namespace__;
  ::std::string* password_;
  ::std::string* weaktoken_;
  ::std::string* pairingtoken_;
  bool aceulaagreed_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fias_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static LoginRequestType* default_instance_;
};
// -------------------------------------------------------------------

class LoginResponseType : public ::google::protobuf::Message {
 public:
  LoginResponseType();
  virtual ~LoginResponseType();
  
  LoginResponseType(const LoginResponseType& from);
  
  inline LoginResponseType& operator=(const LoginResponseType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginResponseType& default_instance();
  
  void Swap(LoginResponseType* other);
  
  // implements Message ----------------------------------------------
  
  LoginResponseType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginResponseType& from);
  void MergeFrom(const LoginResponseType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.ias.AbstractResponseType _inherited = 1;
  inline bool has__inherited() const;
  inline void clear__inherited();
  static const int kInheritedFieldNumber = 1;
  inline const ::vplex::ias::AbstractResponseType& _inherited() const;
  inline ::vplex::ias::AbstractResponseType* mutable__inherited();
  inline ::vplex::ias::AbstractResponseType* release__inherited();
  
  // required fixed64 SessionHandle = 2;
  inline bool has_sessionhandle() const;
  inline void clear_sessionhandle();
  static const int kSessionHandleFieldNumber = 2;
  inline ::google::protobuf::uint64 sessionhandle() const;
  inline void set_sessionhandle(::google::protobuf::uint64 value);
  
  // required bytes SessionSecret = 3;
  inline bool has_sessionsecret() const;
  inline void clear_sessionsecret();
  static const int kSessionSecretFieldNumber = 3;
  inline const ::std::string& sessionsecret() const;
  inline void set_sessionsecret(const ::std::string& value);
  inline void set_sessionsecret(const char* value);
  inline void set_sessionsecret(const void* value, size_t size);
  inline ::std::string* mutable_sessionsecret();
  inline ::std::string* release_sessionsecret();
  
  // optional string AccountId = 4;
  inline bool has_accountid() const;
  inline void clear_accountid();
  static const int kAccountIdFieldNumber = 4;
  inline const ::std::string& accountid() const;
  inline void set_accountid(const ::std::string& value);
  inline void set_accountid(const char* value);
  inline void set_accountid(const char* value, size_t size);
  inline ::std::string* mutable_accountid();
  inline ::std::string* release_accountid();
  
  // required fixed64 UserId = 5;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 5;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // optional string DisplayName = 6;
  inline bool has_displayname() const;
  inline void clear_displayname();
  static const int kDisplayNameFieldNumber = 6;
  inline const ::std::string& displayname() const;
  inline void set_displayname(const ::std::string& value);
  inline void set_displayname(const char* value);
  inline void set_displayname(const char* value, size_t size);
  inline ::std::string* mutable_displayname();
  inline ::std::string* release_displayname();
  
  // optional string WeakToken = 7;
  inline bool has_weaktoken() const;
  inline void clear_weaktoken();
  static const int kWeakTokenFieldNumber = 7;
  inline const ::std::string& weaktoken() const;
  inline void set_weaktoken(const ::std::string& value);
  inline void set_weaktoken(const char* value);
  inline void set_weaktoken(const char* value, size_t size);
  inline ::std::string* mutable_weaktoken();
  inline ::std::string* release_weaktoken();
  
  // optional fixed64 OldFgSessionHandle = 8;
  inline bool has_oldfgsessionhandle() const;
  inline void clear_oldfgsessionhandle();
  static const int kOldFgSessionHandleFieldNumber = 8;
  inline ::google::protobuf::uint64 oldfgsessionhandle() const;
  inline void set_oldfgsessionhandle(::google::protobuf::uint64 value);
  
  // optional string StorageRegion = 9;
  inline bool has_storageregion() const;
  inline void clear_storageregion();
  static const int kStorageRegionFieldNumber = 9;
  inline const ::std::string& storageregion() const;
  inline void set_storageregion(const ::std::string& value);
  inline void set_storageregion(const char* value);
  inline void set_storageregion(const char* value, size_t size);
  inline ::std::string* mutable_storageregion();
  inline ::std::string* release_storageregion();
  
  // optional int64 StorageClusterId = 10;
  inline bool has_storageclusterid() const;
  inline void clear_storageclusterid();
  static const int kStorageClusterIdFieldNumber = 10;
  inline ::google::protobuf::int64 storageclusterid() const;
  inline void set_storageclusterid(::google::protobuf::int64 value);
  
  // optional string persistentCredentials = 11;
  inline bool has_persistentcredentials() const;
  inline void clear_persistentcredentials();
  static const int kPersistentCredentialsFieldNumber = 11;
  inline const ::std::string& persistentcredentials() const;
  inline void set_persistentcredentials(const ::std::string& value);
  inline void set_persistentcredentials(const char* value);
  inline void set_persistentcredentials(const char* value, size_t size);
  inline ::std::string* mutable_persistentcredentials();
  inline ::std::string* release_persistentcredentials();
  
  // @@protoc_insertion_point(class_scope:vplex.ias.LoginResponseType)
 private:
  inline void set_has__inherited();
  inline void clear_has__inherited();
  inline void set_has_sessionhandle();
  inline void clear_has_sessionhandle();
  inline void set_has_sessionsecret();
  inline void clear_has_sessionsecret();
  inline void set_has_accountid();
  inline void clear_has_accountid();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_displayname();
  inline void clear_has_displayname();
  inline void set_has_weaktoken();
  inline void clear_has_weaktoken();
  inline void set_has_oldfgsessionhandle();
  inline void clear_has_oldfgsessionhandle();
  inline void set_has_storageregion();
  inline void clear_has_storageregion();
  inline void set_has_storageclusterid();
  inline void clear_has_storageclusterid();
  inline void set_has_persistentcredentials();
  inline void clear_has_persistentcredentials();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::ias::AbstractResponseType* _inherited_;
  ::google::protobuf::uint64 sessionhandle_;
  ::std::string* sessionsecret_;
  ::std::string* accountid_;
  ::google::protobuf::uint64 userid_;
  ::std::string* displayname_;
  ::std::string* weaktoken_;
  ::google::protobuf::uint64 oldfgsessionhandle_;
  ::std::string* storageregion_;
  ::google::protobuf::int64 storageclusterid_;
  ::std::string* persistentcredentials_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fias_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static LoginResponseType* default_instance_;
};
// -------------------------------------------------------------------

class LogoutRequestType : public ::google::protobuf::Message {
 public:
  LogoutRequestType();
  virtual ~LogoutRequestType();
  
  LogoutRequestType(const LogoutRequestType& from);
  
  inline LogoutRequestType& operator=(const LogoutRequestType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LogoutRequestType& default_instance();
  
  void Swap(LogoutRequestType* other);
  
  // implements Message ----------------------------------------------
  
  LogoutRequestType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogoutRequestType& from);
  void MergeFrom(const LogoutRequestType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.ias.AbstractRequestType _inherited = 1;
  inline bool has__inherited() const;
  inline void clear__inherited();
  static const int kInheritedFieldNumber = 1;
  inline const ::vplex::ias::AbstractRequestType& _inherited() const;
  inline ::vplex::ias::AbstractRequestType* mutable__inherited();
  inline ::vplex::ias::AbstractRequestType* release__inherited();
  
  // @@protoc_insertion_point(class_scope:vplex.ias.LogoutRequestType)
 private:
  inline void set_has__inherited();
  inline void clear_has__inherited();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::ias::AbstractRequestType* _inherited_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fias_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static LogoutRequestType* default_instance_;
};
// -------------------------------------------------------------------

class LogoutResponseType : public ::google::protobuf::Message {
 public:
  LogoutResponseType();
  virtual ~LogoutResponseType();
  
  LogoutResponseType(const LogoutResponseType& from);
  
  inline LogoutResponseType& operator=(const LogoutResponseType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LogoutResponseType& default_instance();
  
  void Swap(LogoutResponseType* other);
  
  // implements Message ----------------------------------------------
  
  LogoutResponseType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogoutResponseType& from);
  void MergeFrom(const LogoutResponseType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.ias.AbstractResponseType _inherited = 1;
  inline bool has__inherited() const;
  inline void clear__inherited();
  static const int kInheritedFieldNumber = 1;
  inline const ::vplex::ias::AbstractResponseType& _inherited() const;
  inline ::vplex::ias::AbstractResponseType* mutable__inherited();
  inline ::vplex::ias::AbstractResponseType* release__inherited();
  
  // @@protoc_insertion_point(class_scope:vplex.ias.LogoutResponseType)
 private:
  inline void set_has__inherited();
  inline void clear_has__inherited();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::ias::AbstractResponseType* _inherited_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fias_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static LogoutResponseType* default_instance_;
};
// -------------------------------------------------------------------

class RegisterVirtualDeviceRequestType : public ::google::protobuf::Message {
 public:
  RegisterVirtualDeviceRequestType();
  virtual ~RegisterVirtualDeviceRequestType();
  
  RegisterVirtualDeviceRequestType(const RegisterVirtualDeviceRequestType& from);
  
  inline RegisterVirtualDeviceRequestType& operator=(const RegisterVirtualDeviceRequestType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterVirtualDeviceRequestType& default_instance();
  
  void Swap(RegisterVirtualDeviceRequestType* other);
  
  // implements Message ----------------------------------------------
  
  RegisterVirtualDeviceRequestType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterVirtualDeviceRequestType& from);
  void MergeFrom(const RegisterVirtualDeviceRequestType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.ias.AbstractRequestType _inherited = 1;
  inline bool has__inherited() const;
  inline void clear__inherited();
  static const int kInheritedFieldNumber = 1;
  inline const ::vplex::ias::AbstractRequestType& _inherited() const;
  inline ::vplex::ias::AbstractRequestType* mutable__inherited();
  inline ::vplex::ias::AbstractRequestType* release__inherited();
  
  // required string Username = 2;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 2;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // optional string Password = 3;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  
  // required bytes HardwareInfo = 4;
  inline bool has_hardwareinfo() const;
  inline void clear_hardwareinfo();
  static const int kHardwareInfoFieldNumber = 4;
  inline const ::std::string& hardwareinfo() const;
  inline void set_hardwareinfo(const ::std::string& value);
  inline void set_hardwareinfo(const char* value);
  inline void set_hardwareinfo(const void* value, size_t size);
  inline ::std::string* mutable_hardwareinfo();
  inline ::std::string* release_hardwareinfo();
  
  // required string DeviceName = 5;
  inline bool has_devicename() const;
  inline void clear_devicename();
  static const int kDeviceNameFieldNumber = 5;
  inline const ::std::string& devicename() const;
  inline void set_devicename(const ::std::string& value);
  inline void set_devicename(const char* value);
  inline void set_devicename(const char* value, size_t size);
  inline ::std::string* mutable_devicename();
  inline ::std::string* release_devicename();
  
  // optional string Namespace = 6;
  inline bool has_namespace_() const;
  inline void clear_namespace_();
  static const int kNamespaceFieldNumber = 6;
  inline const ::std::string& namespace_() const;
  inline void set_namespace_(const ::std::string& value);
  inline void set_namespace_(const char* value);
  inline void set_namespace_(const char* value, size_t size);
  inline ::std::string* mutable_namespace_();
  inline ::std::string* release_namespace_();
  
  // optional string WeakToken = 7;
  inline bool has_weaktoken() const;
  inline void clear_weaktoken();
  static const int kWeakTokenFieldNumber = 7;
  inline const ::std::string& weaktoken() const;
  inline void set_weaktoken(const ::std::string& value);
  inline void set_weaktoken(const char* value);
  inline void set_weaktoken(const char* value, size_t size);
  inline ::std::string* mutable_weaktoken();
  inline ::std::string* release_weaktoken();
  
  // optional string PairingToken = 8;
  inline bool has_pairingtoken() const;
  inline void clear_pairingtoken();
  static const int kPairingTokenFieldNumber = 8;
  inline const ::std::string& pairingtoken() const;
  inline void set_pairingtoken(const ::std::string& value);
  inline void set_pairingtoken(const char* value);
  inline void set_pairingtoken(const char* value, size_t size);
  inline ::std::string* mutable_pairingtoken();
  inline ::std::string* release_pairingtoken();
  
  // @@protoc_insertion_point(class_scope:vplex.ias.RegisterVirtualDeviceRequestType)
 private:
  inline void set_has__inherited();
  inline void clear_has__inherited();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_hardwareinfo();
  inline void clear_has_hardwareinfo();
  inline void set_has_devicename();
  inline void clear_has_devicename();
  inline void set_has_namespace_();
  inline void clear_has_namespace_();
  inline void set_has_weaktoken();
  inline void clear_has_weaktoken();
  inline void set_has_pairingtoken();
  inline void clear_has_pairingtoken();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::ias::AbstractRequestType* _inherited_;
  ::std::string* username_;
  ::std::string* password_;
  ::std::string* hardwareinfo_;
  ::std::string* devicename_;
  ::std::string* namespace__;
  ::std::string* weaktoken_;
  ::std::string* pairingtoken_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fias_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static RegisterVirtualDeviceRequestType* default_instance_;
};
// -------------------------------------------------------------------

class RegisterVirtualDeviceResponseType : public ::google::protobuf::Message {
 public:
  RegisterVirtualDeviceResponseType();
  virtual ~RegisterVirtualDeviceResponseType();
  
  RegisterVirtualDeviceResponseType(const RegisterVirtualDeviceResponseType& from);
  
  inline RegisterVirtualDeviceResponseType& operator=(const RegisterVirtualDeviceResponseType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterVirtualDeviceResponseType& default_instance();
  
  void Swap(RegisterVirtualDeviceResponseType* other);
  
  // implements Message ----------------------------------------------
  
  RegisterVirtualDeviceResponseType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterVirtualDeviceResponseType& from);
  void MergeFrom(const RegisterVirtualDeviceResponseType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.ias.AbstractResponseType _inherited = 1;
  inline bool has__inherited() const;
  inline void clear__inherited();
  static const int kInheritedFieldNumber = 1;
  inline const ::vplex::ias::AbstractResponseType& _inherited() const;
  inline ::vplex::ias::AbstractResponseType* mutable__inherited();
  inline ::vplex::ias::AbstractResponseType* release__inherited();
  
  // optional bytes RenewalToken = 2;
  inline bool has_renewaltoken() const;
  inline void clear_renewaltoken();
  static const int kRenewalTokenFieldNumber = 2;
  inline const ::std::string& renewaltoken() const;
  inline void set_renewaltoken(const ::std::string& value);
  inline void set_renewaltoken(const char* value);
  inline void set_renewaltoken(const void* value, size_t size);
  inline ::std::string* mutable_renewaltoken();
  inline ::std::string* release_renewaltoken();
  
  // @@protoc_insertion_point(class_scope:vplex.ias.RegisterVirtualDeviceResponseType)
 private:
  inline void set_has__inherited();
  inline void clear_has__inherited();
  inline void set_has_renewaltoken();
  inline void clear_has_renewaltoken();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::ias::AbstractResponseType* _inherited_;
  ::std::string* renewaltoken_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fias_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static RegisterVirtualDeviceResponseType* default_instance_;
};
// -------------------------------------------------------------------

class RenewVirtualDeviceCredentialsRequestType : public ::google::protobuf::Message {
 public:
  RenewVirtualDeviceCredentialsRequestType();
  virtual ~RenewVirtualDeviceCredentialsRequestType();
  
  RenewVirtualDeviceCredentialsRequestType(const RenewVirtualDeviceCredentialsRequestType& from);
  
  inline RenewVirtualDeviceCredentialsRequestType& operator=(const RenewVirtualDeviceCredentialsRequestType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RenewVirtualDeviceCredentialsRequestType& default_instance();
  
  void Swap(RenewVirtualDeviceCredentialsRequestType* other);
  
  // implements Message ----------------------------------------------
  
  RenewVirtualDeviceCredentialsRequestType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RenewVirtualDeviceCredentialsRequestType& from);
  void MergeFrom(const RenewVirtualDeviceCredentialsRequestType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.ias.AbstractRequestType _inherited = 1;
  inline bool has__inherited() const;
  inline void clear__inherited();
  static const int kInheritedFieldNumber = 1;
  inline const ::vplex::ias::AbstractRequestType& _inherited() const;
  inline ::vplex::ias::AbstractRequestType* mutable__inherited();
  inline ::vplex::ias::AbstractRequestType* release__inherited();
  
  // required fixed64 SerialNumber = 2;
  inline bool has_serialnumber() const;
  inline void clear_serialnumber();
  static const int kSerialNumberFieldNumber = 2;
  inline ::google::protobuf::uint64 serialnumber() const;
  inline void set_serialnumber(::google::protobuf::uint64 value);
  
  // required fixed64 IssueDate = 3;
  inline bool has_issuedate() const;
  inline void clear_issuedate();
  static const int kIssueDateFieldNumber = 3;
  inline ::google::protobuf::uint64 issuedate() const;
  inline void set_issuedate(::google::protobuf::uint64 value);
  
  // required bytes RenewalToken = 4;
  inline bool has_renewaltoken() const;
  inline void clear_renewaltoken();
  static const int kRenewalTokenFieldNumber = 4;
  inline const ::std::string& renewaltoken() const;
  inline void set_renewaltoken(const ::std::string& value);
  inline void set_renewaltoken(const char* value);
  inline void set_renewaltoken(const void* value, size_t size);
  inline ::std::string* mutable_renewaltoken();
  inline ::std::string* release_renewaltoken();
  
  // @@protoc_insertion_point(class_scope:vplex.ias.RenewVirtualDeviceCredentialsRequestType)
 private:
  inline void set_has__inherited();
  inline void clear_has__inherited();
  inline void set_has_serialnumber();
  inline void clear_has_serialnumber();
  inline void set_has_issuedate();
  inline void clear_has_issuedate();
  inline void set_has_renewaltoken();
  inline void clear_has_renewaltoken();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::ias::AbstractRequestType* _inherited_;
  ::google::protobuf::uint64 serialnumber_;
  ::google::protobuf::uint64 issuedate_;
  ::std::string* renewaltoken_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fias_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static RenewVirtualDeviceCredentialsRequestType* default_instance_;
};
// -------------------------------------------------------------------

class RenewVirtualDeviceCredentialsResponseType : public ::google::protobuf::Message {
 public:
  RenewVirtualDeviceCredentialsResponseType();
  virtual ~RenewVirtualDeviceCredentialsResponseType();
  
  RenewVirtualDeviceCredentialsResponseType(const RenewVirtualDeviceCredentialsResponseType& from);
  
  inline RenewVirtualDeviceCredentialsResponseType& operator=(const RenewVirtualDeviceCredentialsResponseType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RenewVirtualDeviceCredentialsResponseType& default_instance();
  
  void Swap(RenewVirtualDeviceCredentialsResponseType* other);
  
  // implements Message ----------------------------------------------
  
  RenewVirtualDeviceCredentialsResponseType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RenewVirtualDeviceCredentialsResponseType& from);
  void MergeFrom(const RenewVirtualDeviceCredentialsResponseType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.ias.AbstractResponseType _inherited = 1;
  inline bool has__inherited() const;
  inline void clear__inherited();
  static const int kInheritedFieldNumber = 1;
  inline const ::vplex::ias::AbstractResponseType& _inherited() const;
  inline ::vplex::ias::AbstractResponseType* mutable__inherited();
  inline ::vplex::ias::AbstractResponseType* release__inherited();
  
  // optional bytes SecretDeviceCredentials = 2;
  inline bool has_secretdevicecredentials() const;
  inline void clear_secretdevicecredentials();
  static const int kSecretDeviceCredentialsFieldNumber = 2;
  inline const ::std::string& secretdevicecredentials() const;
  inline void set_secretdevicecredentials(const ::std::string& value);
  inline void set_secretdevicecredentials(const char* value);
  inline void set_secretdevicecredentials(const void* value, size_t size);
  inline ::std::string* mutable_secretdevicecredentials();
  inline ::std::string* release_secretdevicecredentials();
  
  // optional bytes ClearDeviceCredentials = 3;
  inline bool has_cleardevicecredentials() const;
  inline void clear_cleardevicecredentials();
  static const int kClearDeviceCredentialsFieldNumber = 3;
  inline const ::std::string& cleardevicecredentials() const;
  inline void set_cleardevicecredentials(const ::std::string& value);
  inline void set_cleardevicecredentials(const char* value);
  inline void set_cleardevicecredentials(const void* value, size_t size);
  inline ::std::string* mutable_cleardevicecredentials();
  inline ::std::string* release_cleardevicecredentials();
  
  // optional bytes RenewalToken = 4;
  inline bool has_renewaltoken() const;
  inline void clear_renewaltoken();
  static const int kRenewalTokenFieldNumber = 4;
  inline const ::std::string& renewaltoken() const;
  inline void set_renewaltoken(const ::std::string& value);
  inline void set_renewaltoken(const char* value);
  inline void set_renewaltoken(const void* value, size_t size);
  inline ::std::string* mutable_renewaltoken();
  inline ::std::string* release_renewaltoken();
  
  // optional bytes AttestProgram = 5;
  inline bool has_attestprogram() const;
  inline void clear_attestprogram();
  static const int kAttestProgramFieldNumber = 5;
  inline const ::std::string& attestprogram() const;
  inline void set_attestprogram(const ::std::string& value);
  inline void set_attestprogram(const char* value);
  inline void set_attestprogram(const void* value, size_t size);
  inline ::std::string* mutable_attestprogram();
  inline ::std::string* release_attestprogram();
  
  // required fixed64 IssueDate = 6;
  inline bool has_issuedate() const;
  inline void clear_issuedate();
  static const int kIssueDateFieldNumber = 6;
  inline ::google::protobuf::uint64 issuedate() const;
  inline void set_issuedate(::google::protobuf::uint64 value);
  
  // required fixed64 SerialNumber = 7;
  inline bool has_serialnumber() const;
  inline void clear_serialnumber();
  static const int kSerialNumberFieldNumber = 7;
  inline ::google::protobuf::uint64 serialnumber() const;
  inline void set_serialnumber(::google::protobuf::uint64 value);
  
  // optional bytes AttestTMD = 8;
  inline bool has_attesttmd() const;
  inline void clear_attesttmd();
  static const int kAttestTMDFieldNumber = 8;
  inline const ::std::string& attesttmd() const;
  inline void set_attesttmd(const ::std::string& value);
  inline void set_attesttmd(const char* value);
  inline void set_attesttmd(const void* value, size_t size);
  inline ::std::string* mutable_attesttmd();
  inline ::std::string* release_attesttmd();
  
  // optional bytes DeviceCert = 9;
  inline bool has_devicecert() const;
  inline void clear_devicecert();
  static const int kDeviceCertFieldNumber = 9;
  inline const ::std::string& devicecert() const;
  inline void set_devicecert(const ::std::string& value);
  inline void set_devicecert(const char* value);
  inline void set_devicecert(const void* value, size_t size);
  inline ::std::string* mutable_devicecert();
  inline ::std::string* release_devicecert();
  
  // optional bytes PlatformKey = 10;
  inline bool has_platformkey() const;
  inline void clear_platformkey();
  static const int kPlatformKeyFieldNumber = 10;
  inline const ::std::string& platformkey() const;
  inline void set_platformkey(const ::std::string& value);
  inline void set_platformkey(const char* value);
  inline void set_platformkey(const void* value, size_t size);
  inline ::std::string* mutable_platformkey();
  inline ::std::string* release_platformkey();
  
  // @@protoc_insertion_point(class_scope:vplex.ias.RenewVirtualDeviceCredentialsResponseType)
 private:
  inline void set_has__inherited();
  inline void clear_has__inherited();
  inline void set_has_secretdevicecredentials();
  inline void clear_has_secretdevicecredentials();
  inline void set_has_cleardevicecredentials();
  inline void clear_has_cleardevicecredentials();
  inline void set_has_renewaltoken();
  inline void clear_has_renewaltoken();
  inline void set_has_attestprogram();
  inline void clear_has_attestprogram();
  inline void set_has_issuedate();
  inline void clear_has_issuedate();
  inline void set_has_serialnumber();
  inline void clear_has_serialnumber();
  inline void set_has_attesttmd();
  inline void clear_has_attesttmd();
  inline void set_has_devicecert();
  inline void clear_has_devicecert();
  inline void set_has_platformkey();
  inline void clear_has_platformkey();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::ias::AbstractResponseType* _inherited_;
  ::std::string* secretdevicecredentials_;
  ::std::string* cleardevicecredentials_;
  ::std::string* renewaltoken_;
  ::std::string* attestprogram_;
  ::google::protobuf::uint64 issuedate_;
  ::google::protobuf::uint64 serialnumber_;
  ::std::string* attesttmd_;
  ::std::string* devicecert_;
  ::std::string* platformkey_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fias_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static RenewVirtualDeviceCredentialsResponseType* default_instance_;
};
// -------------------------------------------------------------------

class GetServerKeyRequestType : public ::google::protobuf::Message {
 public:
  GetServerKeyRequestType();
  virtual ~GetServerKeyRequestType();
  
  GetServerKeyRequestType(const GetServerKeyRequestType& from);
  
  inline GetServerKeyRequestType& operator=(const GetServerKeyRequestType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetServerKeyRequestType& default_instance();
  
  void Swap(GetServerKeyRequestType* other);
  
  // implements Message ----------------------------------------------
  
  GetServerKeyRequestType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetServerKeyRequestType& from);
  void MergeFrom(const GetServerKeyRequestType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.ias.AbstractRequestType _inherited = 1;
  inline bool has__inherited() const;
  inline void clear__inherited();
  static const int kInheritedFieldNumber = 1;
  inline const ::vplex::ias::AbstractRequestType& _inherited() const;
  inline ::vplex::ias::AbstractRequestType* mutable__inherited();
  inline ::vplex::ias::AbstractRequestType* release__inherited();
  
  // required fixed64 UserId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:vplex.ias.GetServerKeyRequestType)
 private:
  inline void set_has__inherited();
  inline void clear_has__inherited();
  inline void set_has_userid();
  inline void clear_has_userid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::ias::AbstractRequestType* _inherited_;
  ::google::protobuf::uint64 userid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fias_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetServerKeyRequestType* default_instance_;
};
// -------------------------------------------------------------------

class GetServerKeyResponseType : public ::google::protobuf::Message {
 public:
  GetServerKeyResponseType();
  virtual ~GetServerKeyResponseType();
  
  GetServerKeyResponseType(const GetServerKeyResponseType& from);
  
  inline GetServerKeyResponseType& operator=(const GetServerKeyResponseType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetServerKeyResponseType& default_instance();
  
  void Swap(GetServerKeyResponseType* other);
  
  // implements Message ----------------------------------------------
  
  GetServerKeyResponseType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetServerKeyResponseType& from);
  void MergeFrom(const GetServerKeyResponseType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.ias.AbstractResponseType _inherited = 1;
  inline bool has__inherited() const;
  inline void clear__inherited();
  static const int kInheritedFieldNumber = 1;
  inline const ::vplex::ias::AbstractResponseType& _inherited() const;
  inline ::vplex::ias::AbstractResponseType* mutable__inherited();
  inline ::vplex::ias::AbstractResponseType* release__inherited();
  
  // optional bytes ServerKey = 2;
  inline bool has_serverkey() const;
  inline void clear_serverkey();
  static const int kServerKeyFieldNumber = 2;
  inline const ::std::string& serverkey() const;
  inline void set_serverkey(const ::std::string& value);
  inline void set_serverkey(const char* value);
  inline void set_serverkey(const void* value, size_t size);
  inline ::std::string* mutable_serverkey();
  inline ::std::string* release_serverkey();
  
  // @@protoc_insertion_point(class_scope:vplex.ias.GetServerKeyResponseType)
 private:
  inline void set_has__inherited();
  inline void clear_has__inherited();
  inline void set_has_serverkey();
  inline void clear_has_serverkey();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::ias::AbstractResponseType* _inherited_;
  ::std::string* serverkey_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fias_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetServerKeyResponseType* default_instance_;
};
// -------------------------------------------------------------------

class RequestPairingRequestType : public ::google::protobuf::Message {
 public:
  RequestPairingRequestType();
  virtual ~RequestPairingRequestType();
  
  RequestPairingRequestType(const RequestPairingRequestType& from);
  
  inline RequestPairingRequestType& operator=(const RequestPairingRequestType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestPairingRequestType& default_instance();
  
  void Swap(RequestPairingRequestType* other);
  
  // implements Message ----------------------------------------------
  
  RequestPairingRequestType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestPairingRequestType& from);
  void MergeFrom(const RequestPairingRequestType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.ias.AbstractRequestType _inherited = 1;
  inline bool has__inherited() const;
  inline void clear__inherited();
  static const int kInheritedFieldNumber = 1;
  inline const ::vplex::ias::AbstractRequestType& _inherited() const;
  inline ::vplex::ias::AbstractRequestType* mutable__inherited();
  inline ::vplex::ias::AbstractRequestType* release__inherited();
  
  // optional bytes HostHardwareId = 2;
  inline bool has_hosthardwareid() const;
  inline void clear_hosthardwareid();
  static const int kHostHardwareIdFieldNumber = 2;
  inline const ::std::string& hosthardwareid() const;
  inline void set_hosthardwareid(const ::std::string& value);
  inline void set_hosthardwareid(const char* value);
  inline void set_hosthardwareid(const void* value, size_t size);
  inline ::std::string* mutable_hosthardwareid();
  inline ::std::string* release_hosthardwareid();
  
  // optional fixed64 HostDeviceId = 3;
  inline bool has_hostdeviceid() const;
  inline void clear_hostdeviceid();
  static const int kHostDeviceIdFieldNumber = 3;
  inline ::google::protobuf::uint64 hostdeviceid() const;
  inline void set_hostdeviceid(::google::protobuf::uint64 value);
  
  // required bytes DeviceHardwareId = 4;
  inline bool has_devicehardwareid() const;
  inline void clear_devicehardwareid();
  static const int kDeviceHardwareIdFieldNumber = 4;
  inline const ::std::string& devicehardwareid() const;
  inline void set_devicehardwareid(const ::std::string& value);
  inline void set_devicehardwareid(const char* value);
  inline void set_devicehardwareid(const void* value, size_t size);
  inline ::std::string* mutable_devicehardwareid();
  inline ::std::string* release_devicehardwareid();
  
  // optional string PIN = 5;
  inline bool has_pin() const;
  inline void clear_pin();
  static const int kPINFieldNumber = 5;
  inline const ::std::string& pin() const;
  inline void set_pin(const ::std::string& value);
  inline void set_pin(const char* value);
  inline void set_pin(const char* value, size_t size);
  inline ::std::string* mutable_pin();
  inline ::std::string* release_pin();
  
  // repeated .vplex.ias.StrAttributeType PairingAttributes = 6;
  inline int pairingattributes_size() const;
  inline void clear_pairingattributes();
  static const int kPairingAttributesFieldNumber = 6;
  inline const ::vplex::ias::StrAttributeType& pairingattributes(int index) const;
  inline ::vplex::ias::StrAttributeType* mutable_pairingattributes(int index);
  inline ::vplex::ias::StrAttributeType* add_pairingattributes();
  inline const ::google::protobuf::RepeatedPtrField< ::vplex::ias::StrAttributeType >&
      pairingattributes() const;
  inline ::google::protobuf::RepeatedPtrField< ::vplex::ias::StrAttributeType >*
      mutable_pairingattributes();
  
  // @@protoc_insertion_point(class_scope:vplex.ias.RequestPairingRequestType)
 private:
  inline void set_has__inherited();
  inline void clear_has__inherited();
  inline void set_has_hosthardwareid();
  inline void clear_has_hosthardwareid();
  inline void set_has_hostdeviceid();
  inline void clear_has_hostdeviceid();
  inline void set_has_devicehardwareid();
  inline void clear_has_devicehardwareid();
  inline void set_has_pin();
  inline void clear_has_pin();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::ias::AbstractRequestType* _inherited_;
  ::std::string* hosthardwareid_;
  ::google::protobuf::uint64 hostdeviceid_;
  ::std::string* devicehardwareid_;
  ::std::string* pin_;
  ::google::protobuf::RepeatedPtrField< ::vplex::ias::StrAttributeType > pairingattributes_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fias_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static RequestPairingRequestType* default_instance_;
};
// -------------------------------------------------------------------

class RequestPairingResponseType : public ::google::protobuf::Message {
 public:
  RequestPairingResponseType();
  virtual ~RequestPairingResponseType();
  
  RequestPairingResponseType(const RequestPairingResponseType& from);
  
  inline RequestPairingResponseType& operator=(const RequestPairingResponseType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestPairingResponseType& default_instance();
  
  void Swap(RequestPairingResponseType* other);
  
  // implements Message ----------------------------------------------
  
  RequestPairingResponseType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestPairingResponseType& from);
  void MergeFrom(const RequestPairingResponseType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.ias.AbstractResponseType _inherited = 1;
  inline bool has__inherited() const;
  inline void clear__inherited();
  static const int kInheritedFieldNumber = 1;
  inline const ::vplex::ias::AbstractResponseType& _inherited() const;
  inline ::vplex::ias::AbstractResponseType* mutable__inherited();
  inline ::vplex::ias::AbstractResponseType* release__inherited();
  
  // required string PairingToken = 2;
  inline bool has_pairingtoken() const;
  inline void clear_pairingtoken();
  static const int kPairingTokenFieldNumber = 2;
  inline const ::std::string& pairingtoken() const;
  inline void set_pairingtoken(const ::std::string& value);
  inline void set_pairingtoken(const char* value);
  inline void set_pairingtoken(const char* value, size_t size);
  inline ::std::string* mutable_pairingtoken();
  inline ::std::string* release_pairingtoken();
  
  // @@protoc_insertion_point(class_scope:vplex.ias.RequestPairingResponseType)
 private:
  inline void set_has__inherited();
  inline void clear_has__inherited();
  inline void set_has_pairingtoken();
  inline void clear_has_pairingtoken();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::ias::AbstractResponseType* _inherited_;
  ::std::string* pairingtoken_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fias_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static RequestPairingResponseType* default_instance_;
};
// -------------------------------------------------------------------

class RespondToPairingRequestRequestType : public ::google::protobuf::Message {
 public:
  RespondToPairingRequestRequestType();
  virtual ~RespondToPairingRequestRequestType();
  
  RespondToPairingRequestRequestType(const RespondToPairingRequestRequestType& from);
  
  inline RespondToPairingRequestRequestType& operator=(const RespondToPairingRequestRequestType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RespondToPairingRequestRequestType& default_instance();
  
  void Swap(RespondToPairingRequestRequestType* other);
  
  // implements Message ----------------------------------------------
  
  RespondToPairingRequestRequestType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RespondToPairingRequestRequestType& from);
  void MergeFrom(const RespondToPairingRequestRequestType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.ias.AbstractRequestType _inherited = 1;
  inline bool has__inherited() const;
  inline void clear__inherited();
  static const int kInheritedFieldNumber = 1;
  inline const ::vplex::ias::AbstractRequestType& _inherited() const;
  inline ::vplex::ias::AbstractRequestType* mutable__inherited();
  inline ::vplex::ias::AbstractRequestType* release__inherited();
  
  // required string TransactionId = 2;
  inline bool has_transactionid() const;
  inline void clear_transactionid();
  static const int kTransactionIdFieldNumber = 2;
  inline const ::std::string& transactionid() const;
  inline void set_transactionid(const ::std::string& value);
  inline void set_transactionid(const char* value);
  inline void set_transactionid(const char* value, size_t size);
  inline ::std::string* mutable_transactionid();
  inline ::std::string* release_transactionid();
  
  // required bool AcceptedPairing = 3;
  inline bool has_acceptedpairing() const;
  inline void clear_acceptedpairing();
  static const int kAcceptedPairingFieldNumber = 3;
  inline bool acceptedpairing() const;
  inline void set_acceptedpairing(bool value);
  
  // @@protoc_insertion_point(class_scope:vplex.ias.RespondToPairingRequestRequestType)
 private:
  inline void set_has__inherited();
  inline void clear_has__inherited();
  inline void set_has_transactionid();
  inline void clear_has_transactionid();
  inline void set_has_acceptedpairing();
  inline void clear_has_acceptedpairing();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::ias::AbstractRequestType* _inherited_;
  ::std::string* transactionid_;
  bool acceptedpairing_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fias_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static RespondToPairingRequestRequestType* default_instance_;
};
// -------------------------------------------------------------------

class RespondToPairingRequestResponseType : public ::google::protobuf::Message {
 public:
  RespondToPairingRequestResponseType();
  virtual ~RespondToPairingRequestResponseType();
  
  RespondToPairingRequestResponseType(const RespondToPairingRequestResponseType& from);
  
  inline RespondToPairingRequestResponseType& operator=(const RespondToPairingRequestResponseType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RespondToPairingRequestResponseType& default_instance();
  
  void Swap(RespondToPairingRequestResponseType* other);
  
  // implements Message ----------------------------------------------
  
  RespondToPairingRequestResponseType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RespondToPairingRequestResponseType& from);
  void MergeFrom(const RespondToPairingRequestResponseType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.ias.AbstractResponseType _inherited = 1;
  inline bool has__inherited() const;
  inline void clear__inherited();
  static const int kInheritedFieldNumber = 1;
  inline const ::vplex::ias::AbstractResponseType& _inherited() const;
  inline ::vplex::ias::AbstractResponseType* mutable__inherited();
  inline ::vplex::ias::AbstractResponseType* release__inherited();
  
  // @@protoc_insertion_point(class_scope:vplex.ias.RespondToPairingRequestResponseType)
 private:
  inline void set_has__inherited();
  inline void clear_has__inherited();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::ias::AbstractResponseType* _inherited_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fias_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static RespondToPairingRequestResponseType* default_instance_;
};
// -------------------------------------------------------------------

class RequestPairingPinRequestType : public ::google::protobuf::Message {
 public:
  RequestPairingPinRequestType();
  virtual ~RequestPairingPinRequestType();
  
  RequestPairingPinRequestType(const RequestPairingPinRequestType& from);
  
  inline RequestPairingPinRequestType& operator=(const RequestPairingPinRequestType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestPairingPinRequestType& default_instance();
  
  void Swap(RequestPairingPinRequestType* other);
  
  // implements Message ----------------------------------------------
  
  RequestPairingPinRequestType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestPairingPinRequestType& from);
  void MergeFrom(const RequestPairingPinRequestType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.ias.AbstractRequestType _inherited = 1;
  inline bool has__inherited() const;
  inline void clear__inherited();
  static const int kInheritedFieldNumber = 1;
  inline const ::vplex::ias::AbstractRequestType& _inherited() const;
  inline ::vplex::ias::AbstractRequestType* mutable__inherited();
  inline ::vplex::ias::AbstractRequestType* release__inherited();
  
  // @@protoc_insertion_point(class_scope:vplex.ias.RequestPairingPinRequestType)
 private:
  inline void set_has__inherited();
  inline void clear_has__inherited();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::ias::AbstractRequestType* _inherited_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fias_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static RequestPairingPinRequestType* default_instance_;
};
// -------------------------------------------------------------------

class RequestPairingPinResponseType : public ::google::protobuf::Message {
 public:
  RequestPairingPinResponseType();
  virtual ~RequestPairingPinResponseType();
  
  RequestPairingPinResponseType(const RequestPairingPinResponseType& from);
  
  inline RequestPairingPinResponseType& operator=(const RequestPairingPinResponseType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestPairingPinResponseType& default_instance();
  
  void Swap(RequestPairingPinResponseType* other);
  
  // implements Message ----------------------------------------------
  
  RequestPairingPinResponseType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestPairingPinResponseType& from);
  void MergeFrom(const RequestPairingPinResponseType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.ias.AbstractResponseType _inherited = 1;
  inline bool has__inherited() const;
  inline void clear__inherited();
  static const int kInheritedFieldNumber = 1;
  inline const ::vplex::ias::AbstractResponseType& _inherited() const;
  inline ::vplex::ias::AbstractResponseType* mutable__inherited();
  inline ::vplex::ias::AbstractResponseType* release__inherited();
  
  // required string PairingPin = 2;
  inline bool has_pairingpin() const;
  inline void clear_pairingpin();
  static const int kPairingPinFieldNumber = 2;
  inline const ::std::string& pairingpin() const;
  inline void set_pairingpin(const ::std::string& value);
  inline void set_pairingpin(const char* value);
  inline void set_pairingpin(const char* value, size_t size);
  inline ::std::string* mutable_pairingpin();
  inline ::std::string* release_pairingpin();
  
  // @@protoc_insertion_point(class_scope:vplex.ias.RequestPairingPinResponseType)
 private:
  inline void set_has__inherited();
  inline void clear_has__inherited();
  inline void set_has_pairingpin();
  inline void clear_has_pairingpin();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::ias::AbstractResponseType* _inherited_;
  ::std::string* pairingpin_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fias_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static RequestPairingPinResponseType* default_instance_;
};
// -------------------------------------------------------------------

class GetPairingStatusRequestType : public ::google::protobuf::Message {
 public:
  GetPairingStatusRequestType();
  virtual ~GetPairingStatusRequestType();
  
  GetPairingStatusRequestType(const GetPairingStatusRequestType& from);
  
  inline GetPairingStatusRequestType& operator=(const GetPairingStatusRequestType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetPairingStatusRequestType& default_instance();
  
  void Swap(GetPairingStatusRequestType* other);
  
  // implements Message ----------------------------------------------
  
  GetPairingStatusRequestType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetPairingStatusRequestType& from);
  void MergeFrom(const GetPairingStatusRequestType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.ias.AbstractRequestType _inherited = 1;
  inline bool has__inherited() const;
  inline void clear__inherited();
  static const int kInheritedFieldNumber = 1;
  inline const ::vplex::ias::AbstractRequestType& _inherited() const;
  inline ::vplex::ias::AbstractRequestType* mutable__inherited();
  inline ::vplex::ias::AbstractRequestType* release__inherited();
  
  // required string PairingToken = 2;
  inline bool has_pairingtoken() const;
  inline void clear_pairingtoken();
  static const int kPairingTokenFieldNumber = 2;
  inline const ::std::string& pairingtoken() const;
  inline void set_pairingtoken(const ::std::string& value);
  inline void set_pairingtoken(const char* value);
  inline void set_pairingtoken(const char* value, size_t size);
  inline ::std::string* mutable_pairingtoken();
  inline ::std::string* release_pairingtoken();
  
  // @@protoc_insertion_point(class_scope:vplex.ias.GetPairingStatusRequestType)
 private:
  inline void set_has__inherited();
  inline void clear_has__inherited();
  inline void set_has_pairingtoken();
  inline void clear_has_pairingtoken();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::ias::AbstractRequestType* _inherited_;
  ::std::string* pairingtoken_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fias_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetPairingStatusRequestType* default_instance_;
};
// -------------------------------------------------------------------

class GetPairingStatusResponseType : public ::google::protobuf::Message {
 public:
  GetPairingStatusResponseType();
  virtual ~GetPairingStatusResponseType();
  
  GetPairingStatusResponseType(const GetPairingStatusResponseType& from);
  
  inline GetPairingStatusResponseType& operator=(const GetPairingStatusResponseType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetPairingStatusResponseType& default_instance();
  
  void Swap(GetPairingStatusResponseType* other);
  
  // implements Message ----------------------------------------------
  
  GetPairingStatusResponseType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetPairingStatusResponseType& from);
  void MergeFrom(const GetPairingStatusResponseType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.ias.AbstractResponseType _inherited = 1;
  inline bool has__inherited() const;
  inline void clear__inherited();
  static const int kInheritedFieldNumber = 1;
  inline const ::vplex::ias::AbstractResponseType& _inherited() const;
  inline ::vplex::ias::AbstractResponseType* mutable__inherited();
  inline ::vplex::ias::AbstractResponseType* release__inherited();
  
  // required string Status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline const ::std::string& status() const;
  inline void set_status(const ::std::string& value);
  inline void set_status(const char* value);
  inline void set_status(const char* value, size_t size);
  inline ::std::string* mutable_status();
  inline ::std::string* release_status();
  
  // optional string Username = 3;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 3;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // @@protoc_insertion_point(class_scope:vplex.ias.GetPairingStatusResponseType)
 private:
  inline void set_has__inherited();
  inline void clear_has__inherited();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_username();
  inline void clear_has_username();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::ias::AbstractResponseType* _inherited_;
  ::std::string* status_;
  ::std::string* username_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_AssignDesc_vplex_5fias_5fservice_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_vplex_5fias_5fservice_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GetPairingStatusResponseType* default_instance_;
};
// ===================================================================


// ===================================================================

// AbstractRequestType

// required string Version = 1;
inline bool AbstractRequestType::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AbstractRequestType::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AbstractRequestType::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AbstractRequestType::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& AbstractRequestType::version() const {
  return *version_;
}
inline void AbstractRequestType::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void AbstractRequestType::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void AbstractRequestType::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AbstractRequestType::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* AbstractRequestType::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string MessageId = 2;
inline bool AbstractRequestType::has_messageid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AbstractRequestType::set_has_messageid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AbstractRequestType::clear_has_messageid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AbstractRequestType::clear_messageid() {
  if (messageid_ != &::google::protobuf::internal::kEmptyString) {
    messageid_->clear();
  }
  clear_has_messageid();
}
inline const ::std::string& AbstractRequestType::messageid() const {
  return *messageid_;
}
inline void AbstractRequestType::set_messageid(const ::std::string& value) {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    messageid_ = new ::std::string;
  }
  messageid_->assign(value);
}
inline void AbstractRequestType::set_messageid(const char* value) {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    messageid_ = new ::std::string;
  }
  messageid_->assign(value);
}
inline void AbstractRequestType::set_messageid(const char* value, size_t size) {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    messageid_ = new ::std::string;
  }
  messageid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AbstractRequestType::mutable_messageid() {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    messageid_ = new ::std::string;
  }
  return messageid_;
}
inline ::std::string* AbstractRequestType::release_messageid() {
  clear_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = messageid_;
    messageid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional fixed64 DeviceId = 3;
inline bool AbstractRequestType::has_deviceid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AbstractRequestType::set_has_deviceid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AbstractRequestType::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AbstractRequestType::clear_deviceid() {
  deviceid_ = GOOGLE_ULONGLONG(0);
  clear_has_deviceid();
}
inline ::google::protobuf::uint64 AbstractRequestType::deviceid() const {
  return deviceid_;
}
inline void AbstractRequestType::set_deviceid(::google::protobuf::uint64 value) {
  set_has_deviceid();
  deviceid_ = value;
}

// optional string Region = 7;
inline bool AbstractRequestType::has_region() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AbstractRequestType::set_has_region() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AbstractRequestType::clear_has_region() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AbstractRequestType::clear_region() {
  if (region_ != &::google::protobuf::internal::kEmptyString) {
    region_->clear();
  }
  clear_has_region();
}
inline const ::std::string& AbstractRequestType::region() const {
  return *region_;
}
inline void AbstractRequestType::set_region(const ::std::string& value) {
  set_has_region();
  if (region_ == &::google::protobuf::internal::kEmptyString) {
    region_ = new ::std::string;
  }
  region_->assign(value);
}
inline void AbstractRequestType::set_region(const char* value) {
  set_has_region();
  if (region_ == &::google::protobuf::internal::kEmptyString) {
    region_ = new ::std::string;
  }
  region_->assign(value);
}
inline void AbstractRequestType::set_region(const char* value, size_t size) {
  set_has_region();
  if (region_ == &::google::protobuf::internal::kEmptyString) {
    region_ = new ::std::string;
  }
  region_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AbstractRequestType::mutable_region() {
  set_has_region();
  if (region_ == &::google::protobuf::internal::kEmptyString) {
    region_ = new ::std::string;
  }
  return region_;
}
inline ::std::string* AbstractRequestType::release_region() {
  clear_has_region();
  if (region_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = region_;
    region_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Country = 8;
inline bool AbstractRequestType::has_country() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AbstractRequestType::set_has_country() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AbstractRequestType::clear_has_country() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AbstractRequestType::clear_country() {
  if (country_ != &::google::protobuf::internal::kEmptyString) {
    country_->clear();
  }
  clear_has_country();
}
inline const ::std::string& AbstractRequestType::country() const {
  return *country_;
}
inline void AbstractRequestType::set_country(const ::std::string& value) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    country_ = new ::std::string;
  }
  country_->assign(value);
}
inline void AbstractRequestType::set_country(const char* value) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    country_ = new ::std::string;
  }
  country_->assign(value);
}
inline void AbstractRequestType::set_country(const char* value, size_t size) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    country_ = new ::std::string;
  }
  country_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AbstractRequestType::mutable_country() {
  set_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    country_ = new ::std::string;
  }
  return country_;
}
inline ::std::string* AbstractRequestType::release_country() {
  clear_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = country_;
    country_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Language = 9;
inline bool AbstractRequestType::has_language() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AbstractRequestType::set_has_language() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AbstractRequestType::clear_has_language() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AbstractRequestType::clear_language() {
  if (language_ != &::google::protobuf::internal::kEmptyString) {
    language_->clear();
  }
  clear_has_language();
}
inline const ::std::string& AbstractRequestType::language() const {
  return *language_;
}
inline void AbstractRequestType::set_language(const ::std::string& value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(value);
}
inline void AbstractRequestType::set_language(const char* value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(value);
}
inline void AbstractRequestType::set_language(const char* value, size_t size) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AbstractRequestType::mutable_language() {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  return language_;
}
inline ::std::string* AbstractRequestType::release_language() {
  clear_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = language_;
    language_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional fixed64 SessionHandle = 10;
inline bool AbstractRequestType::has_sessionhandle() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AbstractRequestType::set_has_sessionhandle() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AbstractRequestType::clear_has_sessionhandle() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AbstractRequestType::clear_sessionhandle() {
  sessionhandle_ = GOOGLE_ULONGLONG(0);
  clear_has_sessionhandle();
}
inline ::google::protobuf::uint64 AbstractRequestType::sessionhandle() const {
  return sessionhandle_;
}
inline void AbstractRequestType::set_sessionhandle(::google::protobuf::uint64 value) {
  set_has_sessionhandle();
  sessionhandle_ = value;
}

// optional bytes ServiceTicket = 11;
inline bool AbstractRequestType::has_serviceticket() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AbstractRequestType::set_has_serviceticket() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AbstractRequestType::clear_has_serviceticket() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AbstractRequestType::clear_serviceticket() {
  if (serviceticket_ != &::google::protobuf::internal::kEmptyString) {
    serviceticket_->clear();
  }
  clear_has_serviceticket();
}
inline const ::std::string& AbstractRequestType::serviceticket() const {
  return *serviceticket_;
}
inline void AbstractRequestType::set_serviceticket(const ::std::string& value) {
  set_has_serviceticket();
  if (serviceticket_ == &::google::protobuf::internal::kEmptyString) {
    serviceticket_ = new ::std::string;
  }
  serviceticket_->assign(value);
}
inline void AbstractRequestType::set_serviceticket(const char* value) {
  set_has_serviceticket();
  if (serviceticket_ == &::google::protobuf::internal::kEmptyString) {
    serviceticket_ = new ::std::string;
  }
  serviceticket_->assign(value);
}
inline void AbstractRequestType::set_serviceticket(const void* value, size_t size) {
  set_has_serviceticket();
  if (serviceticket_ == &::google::protobuf::internal::kEmptyString) {
    serviceticket_ = new ::std::string;
  }
  serviceticket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AbstractRequestType::mutable_serviceticket() {
  set_has_serviceticket();
  if (serviceticket_ == &::google::protobuf::internal::kEmptyString) {
    serviceticket_ = new ::std::string;
  }
  return serviceticket_;
}
inline ::std::string* AbstractRequestType::release_serviceticket() {
  clear_has_serviceticket();
  if (serviceticket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serviceticket_;
    serviceticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ServiceId = 12;
inline bool AbstractRequestType::has_serviceid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AbstractRequestType::set_has_serviceid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AbstractRequestType::clear_has_serviceid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AbstractRequestType::clear_serviceid() {
  if (serviceid_ != &::google::protobuf::internal::kEmptyString) {
    serviceid_->clear();
  }
  clear_has_serviceid();
}
inline const ::std::string& AbstractRequestType::serviceid() const {
  return *serviceid_;
}
inline void AbstractRequestType::set_serviceid(const ::std::string& value) {
  set_has_serviceid();
  if (serviceid_ == &::google::protobuf::internal::kEmptyString) {
    serviceid_ = new ::std::string;
  }
  serviceid_->assign(value);
}
inline void AbstractRequestType::set_serviceid(const char* value) {
  set_has_serviceid();
  if (serviceid_ == &::google::protobuf::internal::kEmptyString) {
    serviceid_ = new ::std::string;
  }
  serviceid_->assign(value);
}
inline void AbstractRequestType::set_serviceid(const char* value, size_t size) {
  set_has_serviceid();
  if (serviceid_ == &::google::protobuf::internal::kEmptyString) {
    serviceid_ = new ::std::string;
  }
  serviceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AbstractRequestType::mutable_serviceid() {
  set_has_serviceid();
  if (serviceid_ == &::google::protobuf::internal::kEmptyString) {
    serviceid_ = new ::std::string;
  }
  return serviceid_;
}
inline ::std::string* AbstractRequestType::release_serviceid() {
  clear_has_serviceid();
  if (serviceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serviceid_;
    serviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AbstractResponseType

// required string Version = 1;
inline bool AbstractResponseType::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AbstractResponseType::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AbstractResponseType::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AbstractResponseType::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& AbstractResponseType::version() const {
  return *version_;
}
inline void AbstractResponseType::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void AbstractResponseType::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void AbstractResponseType::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AbstractResponseType::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* AbstractResponseType::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional fixed64 DeviceId = 2;
inline bool AbstractResponseType::has_deviceid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AbstractResponseType::set_has_deviceid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AbstractResponseType::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AbstractResponseType::clear_deviceid() {
  deviceid_ = GOOGLE_ULONGLONG(0);
  clear_has_deviceid();
}
inline ::google::protobuf::uint64 AbstractResponseType::deviceid() const {
  return deviceid_;
}
inline void AbstractResponseType::set_deviceid(::google::protobuf::uint64 value) {
  set_has_deviceid();
  deviceid_ = value;
}

// required string MessageId = 3;
inline bool AbstractResponseType::has_messageid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AbstractResponseType::set_has_messageid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AbstractResponseType::clear_has_messageid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AbstractResponseType::clear_messageid() {
  if (messageid_ != &::google::protobuf::internal::kEmptyString) {
    messageid_->clear();
  }
  clear_has_messageid();
}
inline const ::std::string& AbstractResponseType::messageid() const {
  return *messageid_;
}
inline void AbstractResponseType::set_messageid(const ::std::string& value) {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    messageid_ = new ::std::string;
  }
  messageid_->assign(value);
}
inline void AbstractResponseType::set_messageid(const char* value) {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    messageid_ = new ::std::string;
  }
  messageid_->assign(value);
}
inline void AbstractResponseType::set_messageid(const char* value, size_t size) {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    messageid_ = new ::std::string;
  }
  messageid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AbstractResponseType::mutable_messageid() {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    messageid_ = new ::std::string;
  }
  return messageid_;
}
inline ::std::string* AbstractResponseType::release_messageid() {
  clear_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = messageid_;
    messageid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required fixed64 TimeStamp = 4;
inline bool AbstractResponseType::has_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AbstractResponseType::set_has_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AbstractResponseType::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AbstractResponseType::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 AbstractResponseType::timestamp() const {
  return timestamp_;
}
inline void AbstractResponseType::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// required sint32 ErrorCode = 5;
inline bool AbstractResponseType::has_errorcode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AbstractResponseType::set_has_errorcode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AbstractResponseType::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AbstractResponseType::clear_errorcode() {
  errorcode_ = 0;
  clear_has_errorcode();
}
inline ::google::protobuf::int32 AbstractResponseType::errorcode() const {
  return errorcode_;
}
inline void AbstractResponseType::set_errorcode(::google::protobuf::int32 value) {
  set_has_errorcode();
  errorcode_ = value;
}

// optional string ErrorMessage = 6;
inline bool AbstractResponseType::has_errormessage() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AbstractResponseType::set_has_errormessage() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AbstractResponseType::clear_has_errormessage() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AbstractResponseType::clear_errormessage() {
  if (errormessage_ != &::google::protobuf::internal::kEmptyString) {
    errormessage_->clear();
  }
  clear_has_errormessage();
}
inline const ::std::string& AbstractResponseType::errormessage() const {
  return *errormessage_;
}
inline void AbstractResponseType::set_errormessage(const ::std::string& value) {
  set_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    errormessage_ = new ::std::string;
  }
  errormessage_->assign(value);
}
inline void AbstractResponseType::set_errormessage(const char* value) {
  set_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    errormessage_ = new ::std::string;
  }
  errormessage_->assign(value);
}
inline void AbstractResponseType::set_errormessage(const char* value, size_t size) {
  set_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    errormessage_ = new ::std::string;
  }
  errormessage_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AbstractResponseType::mutable_errormessage() {
  set_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    errormessage_ = new ::std::string;
  }
  return errormessage_;
}
inline ::std::string* AbstractResponseType::release_errormessage() {
  clear_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = errormessage_;
    errormessage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool ServiceStandbyMode = 7;
inline bool AbstractResponseType::has_servicestandbymode() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AbstractResponseType::set_has_servicestandbymode() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AbstractResponseType::clear_has_servicestandbymode() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AbstractResponseType::clear_servicestandbymode() {
  servicestandbymode_ = false;
  clear_has_servicestandbymode();
}
inline bool AbstractResponseType::servicestandbymode() const {
  return servicestandbymode_;
}
inline void AbstractResponseType::set_servicestandbymode(bool value) {
  set_has_servicestandbymode();
  servicestandbymode_ = value;
}

// -------------------------------------------------------------------

// CheckVirtualDeviceCredentialsRenewalRequestType

// required .vplex.ias.AbstractRequestType _inherited = 1;
inline bool CheckVirtualDeviceCredentialsRenewalRequestType::has__inherited() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckVirtualDeviceCredentialsRenewalRequestType::set_has__inherited() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckVirtualDeviceCredentialsRenewalRequestType::clear_has__inherited() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckVirtualDeviceCredentialsRenewalRequestType::clear__inherited() {
  if (_inherited_ != NULL) _inherited_->::vplex::ias::AbstractRequestType::Clear();
  clear_has__inherited();
}
inline const ::vplex::ias::AbstractRequestType& CheckVirtualDeviceCredentialsRenewalRequestType::_inherited() const {
  return _inherited_ != NULL ? *_inherited_ : *default_instance_->_inherited_;
}
inline ::vplex::ias::AbstractRequestType* CheckVirtualDeviceCredentialsRenewalRequestType::mutable__inherited() {
  set_has__inherited();
  if (_inherited_ == NULL) _inherited_ = new ::vplex::ias::AbstractRequestType;
  return _inherited_;
}
inline ::vplex::ias::AbstractRequestType* CheckVirtualDeviceCredentialsRenewalRequestType::release__inherited() {
  clear_has__inherited();
  ::vplex::ias::AbstractRequestType* temp = _inherited_;
  _inherited_ = NULL;
  return temp;
}

// required fixed64 IssueDate = 2;
inline bool CheckVirtualDeviceCredentialsRenewalRequestType::has_issuedate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CheckVirtualDeviceCredentialsRenewalRequestType::set_has_issuedate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CheckVirtualDeviceCredentialsRenewalRequestType::clear_has_issuedate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CheckVirtualDeviceCredentialsRenewalRequestType::clear_issuedate() {
  issuedate_ = GOOGLE_ULONGLONG(0);
  clear_has_issuedate();
}
inline ::google::protobuf::uint64 CheckVirtualDeviceCredentialsRenewalRequestType::issuedate() const {
  return issuedate_;
}
inline void CheckVirtualDeviceCredentialsRenewalRequestType::set_issuedate(::google::protobuf::uint64 value) {
  set_has_issuedate();
  issuedate_ = value;
}

// required fixed64 SerialNumber = 3;
inline bool CheckVirtualDeviceCredentialsRenewalRequestType::has_serialnumber() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CheckVirtualDeviceCredentialsRenewalRequestType::set_has_serialnumber() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CheckVirtualDeviceCredentialsRenewalRequestType::clear_has_serialnumber() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CheckVirtualDeviceCredentialsRenewalRequestType::clear_serialnumber() {
  serialnumber_ = GOOGLE_ULONGLONG(0);
  clear_has_serialnumber();
}
inline ::google::protobuf::uint64 CheckVirtualDeviceCredentialsRenewalRequestType::serialnumber() const {
  return serialnumber_;
}
inline void CheckVirtualDeviceCredentialsRenewalRequestType::set_serialnumber(::google::protobuf::uint64 value) {
  set_has_serialnumber();
  serialnumber_ = value;
}

// -------------------------------------------------------------------

// CheckVirtualDeviceCredentialsRenewalResponseType

// required .vplex.ias.AbstractResponseType _inherited = 1;
inline bool CheckVirtualDeviceCredentialsRenewalResponseType::has__inherited() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckVirtualDeviceCredentialsRenewalResponseType::set_has__inherited() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckVirtualDeviceCredentialsRenewalResponseType::clear_has__inherited() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckVirtualDeviceCredentialsRenewalResponseType::clear__inherited() {
  if (_inherited_ != NULL) _inherited_->::vplex::ias::AbstractResponseType::Clear();
  clear_has__inherited();
}
inline const ::vplex::ias::AbstractResponseType& CheckVirtualDeviceCredentialsRenewalResponseType::_inherited() const {
  return _inherited_ != NULL ? *_inherited_ : *default_instance_->_inherited_;
}
inline ::vplex::ias::AbstractResponseType* CheckVirtualDeviceCredentialsRenewalResponseType::mutable__inherited() {
  set_has__inherited();
  if (_inherited_ == NULL) _inherited_ = new ::vplex::ias::AbstractResponseType;
  return _inherited_;
}
inline ::vplex::ias::AbstractResponseType* CheckVirtualDeviceCredentialsRenewalResponseType::release__inherited() {
  clear_has__inherited();
  ::vplex::ias::AbstractResponseType* temp = _inherited_;
  _inherited_ = NULL;
  return temp;
}

// required fixed64 ExpectedSerialNumber = 2;
inline bool CheckVirtualDeviceCredentialsRenewalResponseType::has_expectedserialnumber() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CheckVirtualDeviceCredentialsRenewalResponseType::set_has_expectedserialnumber() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CheckVirtualDeviceCredentialsRenewalResponseType::clear_has_expectedserialnumber() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CheckVirtualDeviceCredentialsRenewalResponseType::clear_expectedserialnumber() {
  expectedserialnumber_ = GOOGLE_ULONGLONG(0);
  clear_has_expectedserialnumber();
}
inline ::google::protobuf::uint64 CheckVirtualDeviceCredentialsRenewalResponseType::expectedserialnumber() const {
  return expectedserialnumber_;
}
inline void CheckVirtualDeviceCredentialsRenewalResponseType::set_expectedserialnumber(::google::protobuf::uint64 value) {
  set_has_expectedserialnumber();
  expectedserialnumber_ = value;
}

// -------------------------------------------------------------------

// StrAttributeType

// required string AttributeName = 1;
inline bool StrAttributeType::has_attributename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StrAttributeType::set_has_attributename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StrAttributeType::clear_has_attributename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StrAttributeType::clear_attributename() {
  if (attributename_ != &::google::protobuf::internal::kEmptyString) {
    attributename_->clear();
  }
  clear_has_attributename();
}
inline const ::std::string& StrAttributeType::attributename() const {
  return *attributename_;
}
inline void StrAttributeType::set_attributename(const ::std::string& value) {
  set_has_attributename();
  if (attributename_ == &::google::protobuf::internal::kEmptyString) {
    attributename_ = new ::std::string;
  }
  attributename_->assign(value);
}
inline void StrAttributeType::set_attributename(const char* value) {
  set_has_attributename();
  if (attributename_ == &::google::protobuf::internal::kEmptyString) {
    attributename_ = new ::std::string;
  }
  attributename_->assign(value);
}
inline void StrAttributeType::set_attributename(const char* value, size_t size) {
  set_has_attributename();
  if (attributename_ == &::google::protobuf::internal::kEmptyString) {
    attributename_ = new ::std::string;
  }
  attributename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StrAttributeType::mutable_attributename() {
  set_has_attributename();
  if (attributename_ == &::google::protobuf::internal::kEmptyString) {
    attributename_ = new ::std::string;
  }
  return attributename_;
}
inline ::std::string* StrAttributeType::release_attributename() {
  clear_has_attributename();
  if (attributename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attributename_;
    attributename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string AttributeValue = 2;
inline bool StrAttributeType::has_attributevalue() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StrAttributeType::set_has_attributevalue() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StrAttributeType::clear_has_attributevalue() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StrAttributeType::clear_attributevalue() {
  if (attributevalue_ != &::google::protobuf::internal::kEmptyString) {
    attributevalue_->clear();
  }
  clear_has_attributevalue();
}
inline const ::std::string& StrAttributeType::attributevalue() const {
  return *attributevalue_;
}
inline void StrAttributeType::set_attributevalue(const ::std::string& value) {
  set_has_attributevalue();
  if (attributevalue_ == &::google::protobuf::internal::kEmptyString) {
    attributevalue_ = new ::std::string;
  }
  attributevalue_->assign(value);
}
inline void StrAttributeType::set_attributevalue(const char* value) {
  set_has_attributevalue();
  if (attributevalue_ == &::google::protobuf::internal::kEmptyString) {
    attributevalue_ = new ::std::string;
  }
  attributevalue_->assign(value);
}
inline void StrAttributeType::set_attributevalue(const char* value, size_t size) {
  set_has_attributevalue();
  if (attributevalue_ == &::google::protobuf::internal::kEmptyString) {
    attributevalue_ = new ::std::string;
  }
  attributevalue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StrAttributeType::mutable_attributevalue() {
  set_has_attributevalue();
  if (attributevalue_ == &::google::protobuf::internal::kEmptyString) {
    attributevalue_ = new ::std::string;
  }
  return attributevalue_;
}
inline ::std::string* StrAttributeType::release_attributevalue() {
  clear_has_attributevalue();
  if (attributevalue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attributevalue_;
    attributevalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetSessionKeyRequestType

// required .vplex.ias.AbstractRequestType _inherited = 1;
inline bool GetSessionKeyRequestType::has__inherited() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetSessionKeyRequestType::set_has__inherited() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetSessionKeyRequestType::clear_has__inherited() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetSessionKeyRequestType::clear__inherited() {
  if (_inherited_ != NULL) _inherited_->::vplex::ias::AbstractRequestType::Clear();
  clear_has__inherited();
}
inline const ::vplex::ias::AbstractRequestType& GetSessionKeyRequestType::_inherited() const {
  return _inherited_ != NULL ? *_inherited_ : *default_instance_->_inherited_;
}
inline ::vplex::ias::AbstractRequestType* GetSessionKeyRequestType::mutable__inherited() {
  set_has__inherited();
  if (_inherited_ == NULL) _inherited_ = new ::vplex::ias::AbstractRequestType;
  return _inherited_;
}
inline ::vplex::ias::AbstractRequestType* GetSessionKeyRequestType::release__inherited() {
  clear_has__inherited();
  ::vplex::ias::AbstractRequestType* temp = _inherited_;
  _inherited_ = NULL;
  return temp;
}

// required string Type = 2;
inline bool GetSessionKeyRequestType::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetSessionKeyRequestType::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetSessionKeyRequestType::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetSessionKeyRequestType::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& GetSessionKeyRequestType::type() const {
  return *type_;
}
inline void GetSessionKeyRequestType::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void GetSessionKeyRequestType::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void GetSessionKeyRequestType::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetSessionKeyRequestType::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* GetSessionKeyRequestType::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .vplex.ias.StrAttributeType KeyAttributes = 3;
inline int GetSessionKeyRequestType::keyattributes_size() const {
  return keyattributes_.size();
}
inline void GetSessionKeyRequestType::clear_keyattributes() {
  keyattributes_.Clear();
}
inline const ::vplex::ias::StrAttributeType& GetSessionKeyRequestType::keyattributes(int index) const {
  return keyattributes_.Get(index);
}
inline ::vplex::ias::StrAttributeType* GetSessionKeyRequestType::mutable_keyattributes(int index) {
  return keyattributes_.Mutable(index);
}
inline ::vplex::ias::StrAttributeType* GetSessionKeyRequestType::add_keyattributes() {
  return keyattributes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vplex::ias::StrAttributeType >&
GetSessionKeyRequestType::keyattributes() const {
  return keyattributes_;
}
inline ::google::protobuf::RepeatedPtrField< ::vplex::ias::StrAttributeType >*
GetSessionKeyRequestType::mutable_keyattributes() {
  return &keyattributes_;
}

// optional bytes EncryptedSessionKey = 4;
inline bool GetSessionKeyRequestType::has_encryptedsessionkey() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetSessionKeyRequestType::set_has_encryptedsessionkey() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetSessionKeyRequestType::clear_has_encryptedsessionkey() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetSessionKeyRequestType::clear_encryptedsessionkey() {
  if (encryptedsessionkey_ != &::google::protobuf::internal::kEmptyString) {
    encryptedsessionkey_->clear();
  }
  clear_has_encryptedsessionkey();
}
inline const ::std::string& GetSessionKeyRequestType::encryptedsessionkey() const {
  return *encryptedsessionkey_;
}
inline void GetSessionKeyRequestType::set_encryptedsessionkey(const ::std::string& value) {
  set_has_encryptedsessionkey();
  if (encryptedsessionkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedsessionkey_ = new ::std::string;
  }
  encryptedsessionkey_->assign(value);
}
inline void GetSessionKeyRequestType::set_encryptedsessionkey(const char* value) {
  set_has_encryptedsessionkey();
  if (encryptedsessionkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedsessionkey_ = new ::std::string;
  }
  encryptedsessionkey_->assign(value);
}
inline void GetSessionKeyRequestType::set_encryptedsessionkey(const void* value, size_t size) {
  set_has_encryptedsessionkey();
  if (encryptedsessionkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedsessionkey_ = new ::std::string;
  }
  encryptedsessionkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetSessionKeyRequestType::mutable_encryptedsessionkey() {
  set_has_encryptedsessionkey();
  if (encryptedsessionkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedsessionkey_ = new ::std::string;
  }
  return encryptedsessionkey_;
}
inline ::std::string* GetSessionKeyRequestType::release_encryptedsessionkey() {
  clear_has_encryptedsessionkey();
  if (encryptedsessionkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encryptedsessionkey_;
    encryptedsessionkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetSessionKeyResponseType

// required .vplex.ias.AbstractResponseType _inherited = 1;
inline bool GetSessionKeyResponseType::has__inherited() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetSessionKeyResponseType::set_has__inherited() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetSessionKeyResponseType::clear_has__inherited() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetSessionKeyResponseType::clear__inherited() {
  if (_inherited_ != NULL) _inherited_->::vplex::ias::AbstractResponseType::Clear();
  clear_has__inherited();
}
inline const ::vplex::ias::AbstractResponseType& GetSessionKeyResponseType::_inherited() const {
  return _inherited_ != NULL ? *_inherited_ : *default_instance_->_inherited_;
}
inline ::vplex::ias::AbstractResponseType* GetSessionKeyResponseType::mutable__inherited() {
  set_has__inherited();
  if (_inherited_ == NULL) _inherited_ = new ::vplex::ias::AbstractResponseType;
  return _inherited_;
}
inline ::vplex::ias::AbstractResponseType* GetSessionKeyResponseType::release__inherited() {
  clear_has__inherited();
  ::vplex::ias::AbstractResponseType* temp = _inherited_;
  _inherited_ = NULL;
  return temp;
}

// optional bytes SessionKey = 2;
inline bool GetSessionKeyResponseType::has_sessionkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetSessionKeyResponseType::set_has_sessionkey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetSessionKeyResponseType::clear_has_sessionkey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetSessionKeyResponseType::clear_sessionkey() {
  if (sessionkey_ != &::google::protobuf::internal::kEmptyString) {
    sessionkey_->clear();
  }
  clear_has_sessionkey();
}
inline const ::std::string& GetSessionKeyResponseType::sessionkey() const {
  return *sessionkey_;
}
inline void GetSessionKeyResponseType::set_sessionkey(const ::std::string& value) {
  set_has_sessionkey();
  if (sessionkey_ == &::google::protobuf::internal::kEmptyString) {
    sessionkey_ = new ::std::string;
  }
  sessionkey_->assign(value);
}
inline void GetSessionKeyResponseType::set_sessionkey(const char* value) {
  set_has_sessionkey();
  if (sessionkey_ == &::google::protobuf::internal::kEmptyString) {
    sessionkey_ = new ::std::string;
  }
  sessionkey_->assign(value);
}
inline void GetSessionKeyResponseType::set_sessionkey(const void* value, size_t size) {
  set_has_sessionkey();
  if (sessionkey_ == &::google::protobuf::internal::kEmptyString) {
    sessionkey_ = new ::std::string;
  }
  sessionkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetSessionKeyResponseType::mutable_sessionkey() {
  set_has_sessionkey();
  if (sessionkey_ == &::google::protobuf::internal::kEmptyString) {
    sessionkey_ = new ::std::string;
  }
  return sessionkey_;
}
inline ::std::string* GetSessionKeyResponseType::release_sessionkey() {
  clear_has_sessionkey();
  if (sessionkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sessionkey_;
    sessionkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes EncryptedSessionKey = 3;
inline bool GetSessionKeyResponseType::has_encryptedsessionkey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetSessionKeyResponseType::set_has_encryptedsessionkey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetSessionKeyResponseType::clear_has_encryptedsessionkey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetSessionKeyResponseType::clear_encryptedsessionkey() {
  if (encryptedsessionkey_ != &::google::protobuf::internal::kEmptyString) {
    encryptedsessionkey_->clear();
  }
  clear_has_encryptedsessionkey();
}
inline const ::std::string& GetSessionKeyResponseType::encryptedsessionkey() const {
  return *encryptedsessionkey_;
}
inline void GetSessionKeyResponseType::set_encryptedsessionkey(const ::std::string& value) {
  set_has_encryptedsessionkey();
  if (encryptedsessionkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedsessionkey_ = new ::std::string;
  }
  encryptedsessionkey_->assign(value);
}
inline void GetSessionKeyResponseType::set_encryptedsessionkey(const char* value) {
  set_has_encryptedsessionkey();
  if (encryptedsessionkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedsessionkey_ = new ::std::string;
  }
  encryptedsessionkey_->assign(value);
}
inline void GetSessionKeyResponseType::set_encryptedsessionkey(const void* value, size_t size) {
  set_has_encryptedsessionkey();
  if (encryptedsessionkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedsessionkey_ = new ::std::string;
  }
  encryptedsessionkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetSessionKeyResponseType::mutable_encryptedsessionkey() {
  set_has_encryptedsessionkey();
  if (encryptedsessionkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptedsessionkey_ = new ::std::string;
  }
  return encryptedsessionkey_;
}
inline ::std::string* GetSessionKeyResponseType::release_encryptedsessionkey() {
  clear_has_encryptedsessionkey();
  if (encryptedsessionkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encryptedsessionkey_;
    encryptedsessionkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 InstanceId = 4;
inline bool GetSessionKeyResponseType::has_instanceid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetSessionKeyResponseType::set_has_instanceid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetSessionKeyResponseType::clear_has_instanceid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetSessionKeyResponseType::clear_instanceid() {
  instanceid_ = 0u;
  clear_has_instanceid();
}
inline ::google::protobuf::uint32 GetSessionKeyResponseType::instanceid() const {
  return instanceid_;
}
inline void GetSessionKeyResponseType::set_instanceid(::google::protobuf::uint32 value) {
  set_has_instanceid();
  instanceid_ = value;
}

// -------------------------------------------------------------------

// LoginRequestType

// required .vplex.ias.AbstractRequestType _inherited = 1;
inline bool LoginRequestType::has__inherited() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginRequestType::set_has__inherited() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginRequestType::clear_has__inherited() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginRequestType::clear__inherited() {
  if (_inherited_ != NULL) _inherited_->::vplex::ias::AbstractRequestType::Clear();
  clear_has__inherited();
}
inline const ::vplex::ias::AbstractRequestType& LoginRequestType::_inherited() const {
  return _inherited_ != NULL ? *_inherited_ : *default_instance_->_inherited_;
}
inline ::vplex::ias::AbstractRequestType* LoginRequestType::mutable__inherited() {
  set_has__inherited();
  if (_inherited_ == NULL) _inherited_ = new ::vplex::ias::AbstractRequestType;
  return _inherited_;
}
inline ::vplex::ias::AbstractRequestType* LoginRequestType::release__inherited() {
  clear_has__inherited();
  ::vplex::ias::AbstractRequestType* temp = _inherited_;
  _inherited_ = NULL;
  return temp;
}

// optional string Username = 2;
inline bool LoginRequestType::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginRequestType::set_has_username() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginRequestType::clear_has_username() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginRequestType::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& LoginRequestType::username() const {
  return *username_;
}
inline void LoginRequestType::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void LoginRequestType::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void LoginRequestType::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequestType::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* LoginRequestType::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string Namespace = 3;
inline bool LoginRequestType::has_namespace_() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginRequestType::set_has_namespace_() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginRequestType::clear_has_namespace_() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginRequestType::clear_namespace_() {
  if (namespace__ != &::google::protobuf::internal::kEmptyString) {
    namespace__->clear();
  }
  clear_has_namespace_();
}
inline const ::std::string& LoginRequestType::namespace_() const {
  return *namespace__;
}
inline void LoginRequestType::set_namespace_(const ::std::string& value) {
  set_has_namespace_();
  if (namespace__ == &::google::protobuf::internal::kEmptyString) {
    namespace__ = new ::std::string;
  }
  namespace__->assign(value);
}
inline void LoginRequestType::set_namespace_(const char* value) {
  set_has_namespace_();
  if (namespace__ == &::google::protobuf::internal::kEmptyString) {
    namespace__ = new ::std::string;
  }
  namespace__->assign(value);
}
inline void LoginRequestType::set_namespace_(const char* value, size_t size) {
  set_has_namespace_();
  if (namespace__ == &::google::protobuf::internal::kEmptyString) {
    namespace__ = new ::std::string;
  }
  namespace__->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequestType::mutable_namespace_() {
  set_has_namespace_();
  if (namespace__ == &::google::protobuf::internal::kEmptyString) {
    namespace__ = new ::std::string;
  }
  return namespace__;
}
inline ::std::string* LoginRequestType::release_namespace_() {
  clear_has_namespace_();
  if (namespace__ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = namespace__;
    namespace__ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Password = 4;
inline bool LoginRequestType::has_password() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginRequestType::set_has_password() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginRequestType::clear_has_password() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginRequestType::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& LoginRequestType::password() const {
  return *password_;
}
inline void LoginRequestType::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginRequestType::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginRequestType::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequestType::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* LoginRequestType::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string WeakToken = 5;
inline bool LoginRequestType::has_weaktoken() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginRequestType::set_has_weaktoken() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginRequestType::clear_has_weaktoken() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginRequestType::clear_weaktoken() {
  if (weaktoken_ != &::google::protobuf::internal::kEmptyString) {
    weaktoken_->clear();
  }
  clear_has_weaktoken();
}
inline const ::std::string& LoginRequestType::weaktoken() const {
  return *weaktoken_;
}
inline void LoginRequestType::set_weaktoken(const ::std::string& value) {
  set_has_weaktoken();
  if (weaktoken_ == &::google::protobuf::internal::kEmptyString) {
    weaktoken_ = new ::std::string;
  }
  weaktoken_->assign(value);
}
inline void LoginRequestType::set_weaktoken(const char* value) {
  set_has_weaktoken();
  if (weaktoken_ == &::google::protobuf::internal::kEmptyString) {
    weaktoken_ = new ::std::string;
  }
  weaktoken_->assign(value);
}
inline void LoginRequestType::set_weaktoken(const char* value, size_t size) {
  set_has_weaktoken();
  if (weaktoken_ == &::google::protobuf::internal::kEmptyString) {
    weaktoken_ = new ::std::string;
  }
  weaktoken_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequestType::mutable_weaktoken() {
  set_has_weaktoken();
  if (weaktoken_ == &::google::protobuf::internal::kEmptyString) {
    weaktoken_ = new ::std::string;
  }
  return weaktoken_;
}
inline ::std::string* LoginRequestType::release_weaktoken() {
  clear_has_weaktoken();
  if (weaktoken_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = weaktoken_;
    weaktoken_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string PairingToken = 11;
inline bool LoginRequestType::has_pairingtoken() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoginRequestType::set_has_pairingtoken() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LoginRequestType::clear_has_pairingtoken() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LoginRequestType::clear_pairingtoken() {
  if (pairingtoken_ != &::google::protobuf::internal::kEmptyString) {
    pairingtoken_->clear();
  }
  clear_has_pairingtoken();
}
inline const ::std::string& LoginRequestType::pairingtoken() const {
  return *pairingtoken_;
}
inline void LoginRequestType::set_pairingtoken(const ::std::string& value) {
  set_has_pairingtoken();
  if (pairingtoken_ == &::google::protobuf::internal::kEmptyString) {
    pairingtoken_ = new ::std::string;
  }
  pairingtoken_->assign(value);
}
inline void LoginRequestType::set_pairingtoken(const char* value) {
  set_has_pairingtoken();
  if (pairingtoken_ == &::google::protobuf::internal::kEmptyString) {
    pairingtoken_ = new ::std::string;
  }
  pairingtoken_->assign(value);
}
inline void LoginRequestType::set_pairingtoken(const char* value, size_t size) {
  set_has_pairingtoken();
  if (pairingtoken_ == &::google::protobuf::internal::kEmptyString) {
    pairingtoken_ = new ::std::string;
  }
  pairingtoken_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequestType::mutable_pairingtoken() {
  set_has_pairingtoken();
  if (pairingtoken_ == &::google::protobuf::internal::kEmptyString) {
    pairingtoken_ = new ::std::string;
  }
  return pairingtoken_;
}
inline ::std::string* LoginRequestType::release_pairingtoken() {
  clear_has_pairingtoken();
  if (pairingtoken_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pairingtoken_;
    pairingtoken_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool ACEulaAgreed = 10;
inline bool LoginRequestType::has_aceulaagreed() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LoginRequestType::set_has_aceulaagreed() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LoginRequestType::clear_has_aceulaagreed() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LoginRequestType::clear_aceulaagreed() {
  aceulaagreed_ = false;
  clear_has_aceulaagreed();
}
inline bool LoginRequestType::aceulaagreed() const {
  return aceulaagreed_;
}
inline void LoginRequestType::set_aceulaagreed(bool value) {
  set_has_aceulaagreed();
  aceulaagreed_ = value;
}

// -------------------------------------------------------------------

// LoginResponseType

// required .vplex.ias.AbstractResponseType _inherited = 1;
inline bool LoginResponseType::has__inherited() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginResponseType::set_has__inherited() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginResponseType::clear_has__inherited() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginResponseType::clear__inherited() {
  if (_inherited_ != NULL) _inherited_->::vplex::ias::AbstractResponseType::Clear();
  clear_has__inherited();
}
inline const ::vplex::ias::AbstractResponseType& LoginResponseType::_inherited() const {
  return _inherited_ != NULL ? *_inherited_ : *default_instance_->_inherited_;
}
inline ::vplex::ias::AbstractResponseType* LoginResponseType::mutable__inherited() {
  set_has__inherited();
  if (_inherited_ == NULL) _inherited_ = new ::vplex::ias::AbstractResponseType;
  return _inherited_;
}
inline ::vplex::ias::AbstractResponseType* LoginResponseType::release__inherited() {
  clear_has__inherited();
  ::vplex::ias::AbstractResponseType* temp = _inherited_;
  _inherited_ = NULL;
  return temp;
}

// required fixed64 SessionHandle = 2;
inline bool LoginResponseType::has_sessionhandle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginResponseType::set_has_sessionhandle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginResponseType::clear_has_sessionhandle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginResponseType::clear_sessionhandle() {
  sessionhandle_ = GOOGLE_ULONGLONG(0);
  clear_has_sessionhandle();
}
inline ::google::protobuf::uint64 LoginResponseType::sessionhandle() const {
  return sessionhandle_;
}
inline void LoginResponseType::set_sessionhandle(::google::protobuf::uint64 value) {
  set_has_sessionhandle();
  sessionhandle_ = value;
}

// required bytes SessionSecret = 3;
inline bool LoginResponseType::has_sessionsecret() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginResponseType::set_has_sessionsecret() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginResponseType::clear_has_sessionsecret() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginResponseType::clear_sessionsecret() {
  if (sessionsecret_ != &::google::protobuf::internal::kEmptyString) {
    sessionsecret_->clear();
  }
  clear_has_sessionsecret();
}
inline const ::std::string& LoginResponseType::sessionsecret() const {
  return *sessionsecret_;
}
inline void LoginResponseType::set_sessionsecret(const ::std::string& value) {
  set_has_sessionsecret();
  if (sessionsecret_ == &::google::protobuf::internal::kEmptyString) {
    sessionsecret_ = new ::std::string;
  }
  sessionsecret_->assign(value);
}
inline void LoginResponseType::set_sessionsecret(const char* value) {
  set_has_sessionsecret();
  if (sessionsecret_ == &::google::protobuf::internal::kEmptyString) {
    sessionsecret_ = new ::std::string;
  }
  sessionsecret_->assign(value);
}
inline void LoginResponseType::set_sessionsecret(const void* value, size_t size) {
  set_has_sessionsecret();
  if (sessionsecret_ == &::google::protobuf::internal::kEmptyString) {
    sessionsecret_ = new ::std::string;
  }
  sessionsecret_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResponseType::mutable_sessionsecret() {
  set_has_sessionsecret();
  if (sessionsecret_ == &::google::protobuf::internal::kEmptyString) {
    sessionsecret_ = new ::std::string;
  }
  return sessionsecret_;
}
inline ::std::string* LoginResponseType::release_sessionsecret() {
  clear_has_sessionsecret();
  if (sessionsecret_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sessionsecret_;
    sessionsecret_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string AccountId = 4;
inline bool LoginResponseType::has_accountid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginResponseType::set_has_accountid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginResponseType::clear_has_accountid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginResponseType::clear_accountid() {
  if (accountid_ != &::google::protobuf::internal::kEmptyString) {
    accountid_->clear();
  }
  clear_has_accountid();
}
inline const ::std::string& LoginResponseType::accountid() const {
  return *accountid_;
}
inline void LoginResponseType::set_accountid(const ::std::string& value) {
  set_has_accountid();
  if (accountid_ == &::google::protobuf::internal::kEmptyString) {
    accountid_ = new ::std::string;
  }
  accountid_->assign(value);
}
inline void LoginResponseType::set_accountid(const char* value) {
  set_has_accountid();
  if (accountid_ == &::google::protobuf::internal::kEmptyString) {
    accountid_ = new ::std::string;
  }
  accountid_->assign(value);
}
inline void LoginResponseType::set_accountid(const char* value, size_t size) {
  set_has_accountid();
  if (accountid_ == &::google::protobuf::internal::kEmptyString) {
    accountid_ = new ::std::string;
  }
  accountid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResponseType::mutable_accountid() {
  set_has_accountid();
  if (accountid_ == &::google::protobuf::internal::kEmptyString) {
    accountid_ = new ::std::string;
  }
  return accountid_;
}
inline ::std::string* LoginResponseType::release_accountid() {
  clear_has_accountid();
  if (accountid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = accountid_;
    accountid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required fixed64 UserId = 5;
inline bool LoginResponseType::has_userid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginResponseType::set_has_userid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginResponseType::clear_has_userid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginResponseType::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 LoginResponseType::userid() const {
  return userid_;
}
inline void LoginResponseType::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// optional string DisplayName = 6;
inline bool LoginResponseType::has_displayname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoginResponseType::set_has_displayname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LoginResponseType::clear_has_displayname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LoginResponseType::clear_displayname() {
  if (displayname_ != &::google::protobuf::internal::kEmptyString) {
    displayname_->clear();
  }
  clear_has_displayname();
}
inline const ::std::string& LoginResponseType::displayname() const {
  return *displayname_;
}
inline void LoginResponseType::set_displayname(const ::std::string& value) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(value);
}
inline void LoginResponseType::set_displayname(const char* value) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(value);
}
inline void LoginResponseType::set_displayname(const char* value, size_t size) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResponseType::mutable_displayname() {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  return displayname_;
}
inline ::std::string* LoginResponseType::release_displayname() {
  clear_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = displayname_;
    displayname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string WeakToken = 7;
inline bool LoginResponseType::has_weaktoken() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LoginResponseType::set_has_weaktoken() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LoginResponseType::clear_has_weaktoken() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LoginResponseType::clear_weaktoken() {
  if (weaktoken_ != &::google::protobuf::internal::kEmptyString) {
    weaktoken_->clear();
  }
  clear_has_weaktoken();
}
inline const ::std::string& LoginResponseType::weaktoken() const {
  return *weaktoken_;
}
inline void LoginResponseType::set_weaktoken(const ::std::string& value) {
  set_has_weaktoken();
  if (weaktoken_ == &::google::protobuf::internal::kEmptyString) {
    weaktoken_ = new ::std::string;
  }
  weaktoken_->assign(value);
}
inline void LoginResponseType::set_weaktoken(const char* value) {
  set_has_weaktoken();
  if (weaktoken_ == &::google::protobuf::internal::kEmptyString) {
    weaktoken_ = new ::std::string;
  }
  weaktoken_->assign(value);
}
inline void LoginResponseType::set_weaktoken(const char* value, size_t size) {
  set_has_weaktoken();
  if (weaktoken_ == &::google::protobuf::internal::kEmptyString) {
    weaktoken_ = new ::std::string;
  }
  weaktoken_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResponseType::mutable_weaktoken() {
  set_has_weaktoken();
  if (weaktoken_ == &::google::protobuf::internal::kEmptyString) {
    weaktoken_ = new ::std::string;
  }
  return weaktoken_;
}
inline ::std::string* LoginResponseType::release_weaktoken() {
  clear_has_weaktoken();
  if (weaktoken_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = weaktoken_;
    weaktoken_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional fixed64 OldFgSessionHandle = 8;
inline bool LoginResponseType::has_oldfgsessionhandle() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LoginResponseType::set_has_oldfgsessionhandle() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LoginResponseType::clear_has_oldfgsessionhandle() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LoginResponseType::clear_oldfgsessionhandle() {
  oldfgsessionhandle_ = GOOGLE_ULONGLONG(0);
  clear_has_oldfgsessionhandle();
}
inline ::google::protobuf::uint64 LoginResponseType::oldfgsessionhandle() const {
  return oldfgsessionhandle_;
}
inline void LoginResponseType::set_oldfgsessionhandle(::google::protobuf::uint64 value) {
  set_has_oldfgsessionhandle();
  oldfgsessionhandle_ = value;
}

// optional string StorageRegion = 9;
inline bool LoginResponseType::has_storageregion() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LoginResponseType::set_has_storageregion() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LoginResponseType::clear_has_storageregion() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LoginResponseType::clear_storageregion() {
  if (storageregion_ != &::google::protobuf::internal::kEmptyString) {
    storageregion_->clear();
  }
  clear_has_storageregion();
}
inline const ::std::string& LoginResponseType::storageregion() const {
  return *storageregion_;
}
inline void LoginResponseType::set_storageregion(const ::std::string& value) {
  set_has_storageregion();
  if (storageregion_ == &::google::protobuf::internal::kEmptyString) {
    storageregion_ = new ::std::string;
  }
  storageregion_->assign(value);
}
inline void LoginResponseType::set_storageregion(const char* value) {
  set_has_storageregion();
  if (storageregion_ == &::google::protobuf::internal::kEmptyString) {
    storageregion_ = new ::std::string;
  }
  storageregion_->assign(value);
}
inline void LoginResponseType::set_storageregion(const char* value, size_t size) {
  set_has_storageregion();
  if (storageregion_ == &::google::protobuf::internal::kEmptyString) {
    storageregion_ = new ::std::string;
  }
  storageregion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResponseType::mutable_storageregion() {
  set_has_storageregion();
  if (storageregion_ == &::google::protobuf::internal::kEmptyString) {
    storageregion_ = new ::std::string;
  }
  return storageregion_;
}
inline ::std::string* LoginResponseType::release_storageregion() {
  clear_has_storageregion();
  if (storageregion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = storageregion_;
    storageregion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int64 StorageClusterId = 10;
inline bool LoginResponseType::has_storageclusterid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LoginResponseType::set_has_storageclusterid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LoginResponseType::clear_has_storageclusterid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LoginResponseType::clear_storageclusterid() {
  storageclusterid_ = GOOGLE_LONGLONG(0);
  clear_has_storageclusterid();
}
inline ::google::protobuf::int64 LoginResponseType::storageclusterid() const {
  return storageclusterid_;
}
inline void LoginResponseType::set_storageclusterid(::google::protobuf::int64 value) {
  set_has_storageclusterid();
  storageclusterid_ = value;
}

// optional string persistentCredentials = 11;
inline bool LoginResponseType::has_persistentcredentials() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LoginResponseType::set_has_persistentcredentials() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LoginResponseType::clear_has_persistentcredentials() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LoginResponseType::clear_persistentcredentials() {
  if (persistentcredentials_ != &::google::protobuf::internal::kEmptyString) {
    persistentcredentials_->clear();
  }
  clear_has_persistentcredentials();
}
inline const ::std::string& LoginResponseType::persistentcredentials() const {
  return *persistentcredentials_;
}
inline void LoginResponseType::set_persistentcredentials(const ::std::string& value) {
  set_has_persistentcredentials();
  if (persistentcredentials_ == &::google::protobuf::internal::kEmptyString) {
    persistentcredentials_ = new ::std::string;
  }
  persistentcredentials_->assign(value);
}
inline void LoginResponseType::set_persistentcredentials(const char* value) {
  set_has_persistentcredentials();
  if (persistentcredentials_ == &::google::protobuf::internal::kEmptyString) {
    persistentcredentials_ = new ::std::string;
  }
  persistentcredentials_->assign(value);
}
inline void LoginResponseType::set_persistentcredentials(const char* value, size_t size) {
  set_has_persistentcredentials();
  if (persistentcredentials_ == &::google::protobuf::internal::kEmptyString) {
    persistentcredentials_ = new ::std::string;
  }
  persistentcredentials_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResponseType::mutable_persistentcredentials() {
  set_has_persistentcredentials();
  if (persistentcredentials_ == &::google::protobuf::internal::kEmptyString) {
    persistentcredentials_ = new ::std::string;
  }
  return persistentcredentials_;
}
inline ::std::string* LoginResponseType::release_persistentcredentials() {
  clear_has_persistentcredentials();
  if (persistentcredentials_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = persistentcredentials_;
    persistentcredentials_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LogoutRequestType

// required .vplex.ias.AbstractRequestType _inherited = 1;
inline bool LogoutRequestType::has__inherited() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogoutRequestType::set_has__inherited() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogoutRequestType::clear_has__inherited() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogoutRequestType::clear__inherited() {
  if (_inherited_ != NULL) _inherited_->::vplex::ias::AbstractRequestType::Clear();
  clear_has__inherited();
}
inline const ::vplex::ias::AbstractRequestType& LogoutRequestType::_inherited() const {
  return _inherited_ != NULL ? *_inherited_ : *default_instance_->_inherited_;
}
inline ::vplex::ias::AbstractRequestType* LogoutRequestType::mutable__inherited() {
  set_has__inherited();
  if (_inherited_ == NULL) _inherited_ = new ::vplex::ias::AbstractRequestType;
  return _inherited_;
}
inline ::vplex::ias::AbstractRequestType* LogoutRequestType::release__inherited() {
  clear_has__inherited();
  ::vplex::ias::AbstractRequestType* temp = _inherited_;
  _inherited_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// LogoutResponseType

// required .vplex.ias.AbstractResponseType _inherited = 1;
inline bool LogoutResponseType::has__inherited() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogoutResponseType::set_has__inherited() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogoutResponseType::clear_has__inherited() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogoutResponseType::clear__inherited() {
  if (_inherited_ != NULL) _inherited_->::vplex::ias::AbstractResponseType::Clear();
  clear_has__inherited();
}
inline const ::vplex::ias::AbstractResponseType& LogoutResponseType::_inherited() const {
  return _inherited_ != NULL ? *_inherited_ : *default_instance_->_inherited_;
}
inline ::vplex::ias::AbstractResponseType* LogoutResponseType::mutable__inherited() {
  set_has__inherited();
  if (_inherited_ == NULL) _inherited_ = new ::vplex::ias::AbstractResponseType;
  return _inherited_;
}
inline ::vplex::ias::AbstractResponseType* LogoutResponseType::release__inherited() {
  clear_has__inherited();
  ::vplex::ias::AbstractResponseType* temp = _inherited_;
  _inherited_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// RegisterVirtualDeviceRequestType

// required .vplex.ias.AbstractRequestType _inherited = 1;
inline bool RegisterVirtualDeviceRequestType::has__inherited() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterVirtualDeviceRequestType::set_has__inherited() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterVirtualDeviceRequestType::clear_has__inherited() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterVirtualDeviceRequestType::clear__inherited() {
  if (_inherited_ != NULL) _inherited_->::vplex::ias::AbstractRequestType::Clear();
  clear_has__inherited();
}
inline const ::vplex::ias::AbstractRequestType& RegisterVirtualDeviceRequestType::_inherited() const {
  return _inherited_ != NULL ? *_inherited_ : *default_instance_->_inherited_;
}
inline ::vplex::ias::AbstractRequestType* RegisterVirtualDeviceRequestType::mutable__inherited() {
  set_has__inherited();
  if (_inherited_ == NULL) _inherited_ = new ::vplex::ias::AbstractRequestType;
  return _inherited_;
}
inline ::vplex::ias::AbstractRequestType* RegisterVirtualDeviceRequestType::release__inherited() {
  clear_has__inherited();
  ::vplex::ias::AbstractRequestType* temp = _inherited_;
  _inherited_ = NULL;
  return temp;
}

// required string Username = 2;
inline bool RegisterVirtualDeviceRequestType::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterVirtualDeviceRequestType::set_has_username() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterVirtualDeviceRequestType::clear_has_username() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterVirtualDeviceRequestType::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& RegisterVirtualDeviceRequestType::username() const {
  return *username_;
}
inline void RegisterVirtualDeviceRequestType::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void RegisterVirtualDeviceRequestType::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void RegisterVirtualDeviceRequestType::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterVirtualDeviceRequestType::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* RegisterVirtualDeviceRequestType::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Password = 3;
inline bool RegisterVirtualDeviceRequestType::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegisterVirtualDeviceRequestType::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegisterVirtualDeviceRequestType::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegisterVirtualDeviceRequestType::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& RegisterVirtualDeviceRequestType::password() const {
  return *password_;
}
inline void RegisterVirtualDeviceRequestType::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void RegisterVirtualDeviceRequestType::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void RegisterVirtualDeviceRequestType::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterVirtualDeviceRequestType::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* RegisterVirtualDeviceRequestType::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes HardwareInfo = 4;
inline bool RegisterVirtualDeviceRequestType::has_hardwareinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RegisterVirtualDeviceRequestType::set_has_hardwareinfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RegisterVirtualDeviceRequestType::clear_has_hardwareinfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RegisterVirtualDeviceRequestType::clear_hardwareinfo() {
  if (hardwareinfo_ != &::google::protobuf::internal::kEmptyString) {
    hardwareinfo_->clear();
  }
  clear_has_hardwareinfo();
}
inline const ::std::string& RegisterVirtualDeviceRequestType::hardwareinfo() const {
  return *hardwareinfo_;
}
inline void RegisterVirtualDeviceRequestType::set_hardwareinfo(const ::std::string& value) {
  set_has_hardwareinfo();
  if (hardwareinfo_ == &::google::protobuf::internal::kEmptyString) {
    hardwareinfo_ = new ::std::string;
  }
  hardwareinfo_->assign(value);
}
inline void RegisterVirtualDeviceRequestType::set_hardwareinfo(const char* value) {
  set_has_hardwareinfo();
  if (hardwareinfo_ == &::google::protobuf::internal::kEmptyString) {
    hardwareinfo_ = new ::std::string;
  }
  hardwareinfo_->assign(value);
}
inline void RegisterVirtualDeviceRequestType::set_hardwareinfo(const void* value, size_t size) {
  set_has_hardwareinfo();
  if (hardwareinfo_ == &::google::protobuf::internal::kEmptyString) {
    hardwareinfo_ = new ::std::string;
  }
  hardwareinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterVirtualDeviceRequestType::mutable_hardwareinfo() {
  set_has_hardwareinfo();
  if (hardwareinfo_ == &::google::protobuf::internal::kEmptyString) {
    hardwareinfo_ = new ::std::string;
  }
  return hardwareinfo_;
}
inline ::std::string* RegisterVirtualDeviceRequestType::release_hardwareinfo() {
  clear_has_hardwareinfo();
  if (hardwareinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hardwareinfo_;
    hardwareinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string DeviceName = 5;
inline bool RegisterVirtualDeviceRequestType::has_devicename() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RegisterVirtualDeviceRequestType::set_has_devicename() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RegisterVirtualDeviceRequestType::clear_has_devicename() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RegisterVirtualDeviceRequestType::clear_devicename() {
  if (devicename_ != &::google::protobuf::internal::kEmptyString) {
    devicename_->clear();
  }
  clear_has_devicename();
}
inline const ::std::string& RegisterVirtualDeviceRequestType::devicename() const {
  return *devicename_;
}
inline void RegisterVirtualDeviceRequestType::set_devicename(const ::std::string& value) {
  set_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    devicename_ = new ::std::string;
  }
  devicename_->assign(value);
}
inline void RegisterVirtualDeviceRequestType::set_devicename(const char* value) {
  set_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    devicename_ = new ::std::string;
  }
  devicename_->assign(value);
}
inline void RegisterVirtualDeviceRequestType::set_devicename(const char* value, size_t size) {
  set_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    devicename_ = new ::std::string;
  }
  devicename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterVirtualDeviceRequestType::mutable_devicename() {
  set_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    devicename_ = new ::std::string;
  }
  return devicename_;
}
inline ::std::string* RegisterVirtualDeviceRequestType::release_devicename() {
  clear_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devicename_;
    devicename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Namespace = 6;
inline bool RegisterVirtualDeviceRequestType::has_namespace_() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RegisterVirtualDeviceRequestType::set_has_namespace_() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RegisterVirtualDeviceRequestType::clear_has_namespace_() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RegisterVirtualDeviceRequestType::clear_namespace_() {
  if (namespace__ != &::google::protobuf::internal::kEmptyString) {
    namespace__->clear();
  }
  clear_has_namespace_();
}
inline const ::std::string& RegisterVirtualDeviceRequestType::namespace_() const {
  return *namespace__;
}
inline void RegisterVirtualDeviceRequestType::set_namespace_(const ::std::string& value) {
  set_has_namespace_();
  if (namespace__ == &::google::protobuf::internal::kEmptyString) {
    namespace__ = new ::std::string;
  }
  namespace__->assign(value);
}
inline void RegisterVirtualDeviceRequestType::set_namespace_(const char* value) {
  set_has_namespace_();
  if (namespace__ == &::google::protobuf::internal::kEmptyString) {
    namespace__ = new ::std::string;
  }
  namespace__->assign(value);
}
inline void RegisterVirtualDeviceRequestType::set_namespace_(const char* value, size_t size) {
  set_has_namespace_();
  if (namespace__ == &::google::protobuf::internal::kEmptyString) {
    namespace__ = new ::std::string;
  }
  namespace__->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterVirtualDeviceRequestType::mutable_namespace_() {
  set_has_namespace_();
  if (namespace__ == &::google::protobuf::internal::kEmptyString) {
    namespace__ = new ::std::string;
  }
  return namespace__;
}
inline ::std::string* RegisterVirtualDeviceRequestType::release_namespace_() {
  clear_has_namespace_();
  if (namespace__ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = namespace__;
    namespace__ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string WeakToken = 7;
inline bool RegisterVirtualDeviceRequestType::has_weaktoken() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RegisterVirtualDeviceRequestType::set_has_weaktoken() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RegisterVirtualDeviceRequestType::clear_has_weaktoken() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RegisterVirtualDeviceRequestType::clear_weaktoken() {
  if (weaktoken_ != &::google::protobuf::internal::kEmptyString) {
    weaktoken_->clear();
  }
  clear_has_weaktoken();
}
inline const ::std::string& RegisterVirtualDeviceRequestType::weaktoken() const {
  return *weaktoken_;
}
inline void RegisterVirtualDeviceRequestType::set_weaktoken(const ::std::string& value) {
  set_has_weaktoken();
  if (weaktoken_ == &::google::protobuf::internal::kEmptyString) {
    weaktoken_ = new ::std::string;
  }
  weaktoken_->assign(value);
}
inline void RegisterVirtualDeviceRequestType::set_weaktoken(const char* value) {
  set_has_weaktoken();
  if (weaktoken_ == &::google::protobuf::internal::kEmptyString) {
    weaktoken_ = new ::std::string;
  }
  weaktoken_->assign(value);
}
inline void RegisterVirtualDeviceRequestType::set_weaktoken(const char* value, size_t size) {
  set_has_weaktoken();
  if (weaktoken_ == &::google::protobuf::internal::kEmptyString) {
    weaktoken_ = new ::std::string;
  }
  weaktoken_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterVirtualDeviceRequestType::mutable_weaktoken() {
  set_has_weaktoken();
  if (weaktoken_ == &::google::protobuf::internal::kEmptyString) {
    weaktoken_ = new ::std::string;
  }
  return weaktoken_;
}
inline ::std::string* RegisterVirtualDeviceRequestType::release_weaktoken() {
  clear_has_weaktoken();
  if (weaktoken_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = weaktoken_;
    weaktoken_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string PairingToken = 8;
inline bool RegisterVirtualDeviceRequestType::has_pairingtoken() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RegisterVirtualDeviceRequestType::set_has_pairingtoken() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RegisterVirtualDeviceRequestType::clear_has_pairingtoken() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RegisterVirtualDeviceRequestType::clear_pairingtoken() {
  if (pairingtoken_ != &::google::protobuf::internal::kEmptyString) {
    pairingtoken_->clear();
  }
  clear_has_pairingtoken();
}
inline const ::std::string& RegisterVirtualDeviceRequestType::pairingtoken() const {
  return *pairingtoken_;
}
inline void RegisterVirtualDeviceRequestType::set_pairingtoken(const ::std::string& value) {
  set_has_pairingtoken();
  if (pairingtoken_ == &::google::protobuf::internal::kEmptyString) {
    pairingtoken_ = new ::std::string;
  }
  pairingtoken_->assign(value);
}
inline void RegisterVirtualDeviceRequestType::set_pairingtoken(const char* value) {
  set_has_pairingtoken();
  if (pairingtoken_ == &::google::protobuf::internal::kEmptyString) {
    pairingtoken_ = new ::std::string;
  }
  pairingtoken_->assign(value);
}
inline void RegisterVirtualDeviceRequestType::set_pairingtoken(const char* value, size_t size) {
  set_has_pairingtoken();
  if (pairingtoken_ == &::google::protobuf::internal::kEmptyString) {
    pairingtoken_ = new ::std::string;
  }
  pairingtoken_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterVirtualDeviceRequestType::mutable_pairingtoken() {
  set_has_pairingtoken();
  if (pairingtoken_ == &::google::protobuf::internal::kEmptyString) {
    pairingtoken_ = new ::std::string;
  }
  return pairingtoken_;
}
inline ::std::string* RegisterVirtualDeviceRequestType::release_pairingtoken() {
  clear_has_pairingtoken();
  if (pairingtoken_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pairingtoken_;
    pairingtoken_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RegisterVirtualDeviceResponseType

// required .vplex.ias.AbstractResponseType _inherited = 1;
inline bool RegisterVirtualDeviceResponseType::has__inherited() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterVirtualDeviceResponseType::set_has__inherited() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterVirtualDeviceResponseType::clear_has__inherited() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterVirtualDeviceResponseType::clear__inherited() {
  if (_inherited_ != NULL) _inherited_->::vplex::ias::AbstractResponseType::Clear();
  clear_has__inherited();
}
inline const ::vplex::ias::AbstractResponseType& RegisterVirtualDeviceResponseType::_inherited() const {
  return _inherited_ != NULL ? *_inherited_ : *default_instance_->_inherited_;
}
inline ::vplex::ias::AbstractResponseType* RegisterVirtualDeviceResponseType::mutable__inherited() {
  set_has__inherited();
  if (_inherited_ == NULL) _inherited_ = new ::vplex::ias::AbstractResponseType;
  return _inherited_;
}
inline ::vplex::ias::AbstractResponseType* RegisterVirtualDeviceResponseType::release__inherited() {
  clear_has__inherited();
  ::vplex::ias::AbstractResponseType* temp = _inherited_;
  _inherited_ = NULL;
  return temp;
}

// optional bytes RenewalToken = 2;
inline bool RegisterVirtualDeviceResponseType::has_renewaltoken() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterVirtualDeviceResponseType::set_has_renewaltoken() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterVirtualDeviceResponseType::clear_has_renewaltoken() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterVirtualDeviceResponseType::clear_renewaltoken() {
  if (renewaltoken_ != &::google::protobuf::internal::kEmptyString) {
    renewaltoken_->clear();
  }
  clear_has_renewaltoken();
}
inline const ::std::string& RegisterVirtualDeviceResponseType::renewaltoken() const {
  return *renewaltoken_;
}
inline void RegisterVirtualDeviceResponseType::set_renewaltoken(const ::std::string& value) {
  set_has_renewaltoken();
  if (renewaltoken_ == &::google::protobuf::internal::kEmptyString) {
    renewaltoken_ = new ::std::string;
  }
  renewaltoken_->assign(value);
}
inline void RegisterVirtualDeviceResponseType::set_renewaltoken(const char* value) {
  set_has_renewaltoken();
  if (renewaltoken_ == &::google::protobuf::internal::kEmptyString) {
    renewaltoken_ = new ::std::string;
  }
  renewaltoken_->assign(value);
}
inline void RegisterVirtualDeviceResponseType::set_renewaltoken(const void* value, size_t size) {
  set_has_renewaltoken();
  if (renewaltoken_ == &::google::protobuf::internal::kEmptyString) {
    renewaltoken_ = new ::std::string;
  }
  renewaltoken_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterVirtualDeviceResponseType::mutable_renewaltoken() {
  set_has_renewaltoken();
  if (renewaltoken_ == &::google::protobuf::internal::kEmptyString) {
    renewaltoken_ = new ::std::string;
  }
  return renewaltoken_;
}
inline ::std::string* RegisterVirtualDeviceResponseType::release_renewaltoken() {
  clear_has_renewaltoken();
  if (renewaltoken_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = renewaltoken_;
    renewaltoken_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RenewVirtualDeviceCredentialsRequestType

// required .vplex.ias.AbstractRequestType _inherited = 1;
inline bool RenewVirtualDeviceCredentialsRequestType::has__inherited() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RenewVirtualDeviceCredentialsRequestType::set_has__inherited() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RenewVirtualDeviceCredentialsRequestType::clear_has__inherited() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RenewVirtualDeviceCredentialsRequestType::clear__inherited() {
  if (_inherited_ != NULL) _inherited_->::vplex::ias::AbstractRequestType::Clear();
  clear_has__inherited();
}
inline const ::vplex::ias::AbstractRequestType& RenewVirtualDeviceCredentialsRequestType::_inherited() const {
  return _inherited_ != NULL ? *_inherited_ : *default_instance_->_inherited_;
}
inline ::vplex::ias::AbstractRequestType* RenewVirtualDeviceCredentialsRequestType::mutable__inherited() {
  set_has__inherited();
  if (_inherited_ == NULL) _inherited_ = new ::vplex::ias::AbstractRequestType;
  return _inherited_;
}
inline ::vplex::ias::AbstractRequestType* RenewVirtualDeviceCredentialsRequestType::release__inherited() {
  clear_has__inherited();
  ::vplex::ias::AbstractRequestType* temp = _inherited_;
  _inherited_ = NULL;
  return temp;
}

// required fixed64 SerialNumber = 2;
inline bool RenewVirtualDeviceCredentialsRequestType::has_serialnumber() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RenewVirtualDeviceCredentialsRequestType::set_has_serialnumber() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RenewVirtualDeviceCredentialsRequestType::clear_has_serialnumber() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RenewVirtualDeviceCredentialsRequestType::clear_serialnumber() {
  serialnumber_ = GOOGLE_ULONGLONG(0);
  clear_has_serialnumber();
}
inline ::google::protobuf::uint64 RenewVirtualDeviceCredentialsRequestType::serialnumber() const {
  return serialnumber_;
}
inline void RenewVirtualDeviceCredentialsRequestType::set_serialnumber(::google::protobuf::uint64 value) {
  set_has_serialnumber();
  serialnumber_ = value;
}

// required fixed64 IssueDate = 3;
inline bool RenewVirtualDeviceCredentialsRequestType::has_issuedate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RenewVirtualDeviceCredentialsRequestType::set_has_issuedate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RenewVirtualDeviceCredentialsRequestType::clear_has_issuedate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RenewVirtualDeviceCredentialsRequestType::clear_issuedate() {
  issuedate_ = GOOGLE_ULONGLONG(0);
  clear_has_issuedate();
}
inline ::google::protobuf::uint64 RenewVirtualDeviceCredentialsRequestType::issuedate() const {
  return issuedate_;
}
inline void RenewVirtualDeviceCredentialsRequestType::set_issuedate(::google::protobuf::uint64 value) {
  set_has_issuedate();
  issuedate_ = value;
}

// required bytes RenewalToken = 4;
inline bool RenewVirtualDeviceCredentialsRequestType::has_renewaltoken() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RenewVirtualDeviceCredentialsRequestType::set_has_renewaltoken() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RenewVirtualDeviceCredentialsRequestType::clear_has_renewaltoken() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RenewVirtualDeviceCredentialsRequestType::clear_renewaltoken() {
  if (renewaltoken_ != &::google::protobuf::internal::kEmptyString) {
    renewaltoken_->clear();
  }
  clear_has_renewaltoken();
}
inline const ::std::string& RenewVirtualDeviceCredentialsRequestType::renewaltoken() const {
  return *renewaltoken_;
}
inline void RenewVirtualDeviceCredentialsRequestType::set_renewaltoken(const ::std::string& value) {
  set_has_renewaltoken();
  if (renewaltoken_ == &::google::protobuf::internal::kEmptyString) {
    renewaltoken_ = new ::std::string;
  }
  renewaltoken_->assign(value);
}
inline void RenewVirtualDeviceCredentialsRequestType::set_renewaltoken(const char* value) {
  set_has_renewaltoken();
  if (renewaltoken_ == &::google::protobuf::internal::kEmptyString) {
    renewaltoken_ = new ::std::string;
  }
  renewaltoken_->assign(value);
}
inline void RenewVirtualDeviceCredentialsRequestType::set_renewaltoken(const void* value, size_t size) {
  set_has_renewaltoken();
  if (renewaltoken_ == &::google::protobuf::internal::kEmptyString) {
    renewaltoken_ = new ::std::string;
  }
  renewaltoken_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RenewVirtualDeviceCredentialsRequestType::mutable_renewaltoken() {
  set_has_renewaltoken();
  if (renewaltoken_ == &::google::protobuf::internal::kEmptyString) {
    renewaltoken_ = new ::std::string;
  }
  return renewaltoken_;
}
inline ::std::string* RenewVirtualDeviceCredentialsRequestType::release_renewaltoken() {
  clear_has_renewaltoken();
  if (renewaltoken_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = renewaltoken_;
    renewaltoken_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RenewVirtualDeviceCredentialsResponseType

// required .vplex.ias.AbstractResponseType _inherited = 1;
inline bool RenewVirtualDeviceCredentialsResponseType::has__inherited() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RenewVirtualDeviceCredentialsResponseType::set_has__inherited() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RenewVirtualDeviceCredentialsResponseType::clear_has__inherited() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RenewVirtualDeviceCredentialsResponseType::clear__inherited() {
  if (_inherited_ != NULL) _inherited_->::vplex::ias::AbstractResponseType::Clear();
  clear_has__inherited();
}
inline const ::vplex::ias::AbstractResponseType& RenewVirtualDeviceCredentialsResponseType::_inherited() const {
  return _inherited_ != NULL ? *_inherited_ : *default_instance_->_inherited_;
}
inline ::vplex::ias::AbstractResponseType* RenewVirtualDeviceCredentialsResponseType::mutable__inherited() {
  set_has__inherited();
  if (_inherited_ == NULL) _inherited_ = new ::vplex::ias::AbstractResponseType;
  return _inherited_;
}
inline ::vplex::ias::AbstractResponseType* RenewVirtualDeviceCredentialsResponseType::release__inherited() {
  clear_has__inherited();
  ::vplex::ias::AbstractResponseType* temp = _inherited_;
  _inherited_ = NULL;
  return temp;
}

// optional bytes SecretDeviceCredentials = 2;
inline bool RenewVirtualDeviceCredentialsResponseType::has_secretdevicecredentials() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RenewVirtualDeviceCredentialsResponseType::set_has_secretdevicecredentials() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RenewVirtualDeviceCredentialsResponseType::clear_has_secretdevicecredentials() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RenewVirtualDeviceCredentialsResponseType::clear_secretdevicecredentials() {
  if (secretdevicecredentials_ != &::google::protobuf::internal::kEmptyString) {
    secretdevicecredentials_->clear();
  }
  clear_has_secretdevicecredentials();
}
inline const ::std::string& RenewVirtualDeviceCredentialsResponseType::secretdevicecredentials() const {
  return *secretdevicecredentials_;
}
inline void RenewVirtualDeviceCredentialsResponseType::set_secretdevicecredentials(const ::std::string& value) {
  set_has_secretdevicecredentials();
  if (secretdevicecredentials_ == &::google::protobuf::internal::kEmptyString) {
    secretdevicecredentials_ = new ::std::string;
  }
  secretdevicecredentials_->assign(value);
}
inline void RenewVirtualDeviceCredentialsResponseType::set_secretdevicecredentials(const char* value) {
  set_has_secretdevicecredentials();
  if (secretdevicecredentials_ == &::google::protobuf::internal::kEmptyString) {
    secretdevicecredentials_ = new ::std::string;
  }
  secretdevicecredentials_->assign(value);
}
inline void RenewVirtualDeviceCredentialsResponseType::set_secretdevicecredentials(const void* value, size_t size) {
  set_has_secretdevicecredentials();
  if (secretdevicecredentials_ == &::google::protobuf::internal::kEmptyString) {
    secretdevicecredentials_ = new ::std::string;
  }
  secretdevicecredentials_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RenewVirtualDeviceCredentialsResponseType::mutable_secretdevicecredentials() {
  set_has_secretdevicecredentials();
  if (secretdevicecredentials_ == &::google::protobuf::internal::kEmptyString) {
    secretdevicecredentials_ = new ::std::string;
  }
  return secretdevicecredentials_;
}
inline ::std::string* RenewVirtualDeviceCredentialsResponseType::release_secretdevicecredentials() {
  clear_has_secretdevicecredentials();
  if (secretdevicecredentials_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = secretdevicecredentials_;
    secretdevicecredentials_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes ClearDeviceCredentials = 3;
inline bool RenewVirtualDeviceCredentialsResponseType::has_cleardevicecredentials() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RenewVirtualDeviceCredentialsResponseType::set_has_cleardevicecredentials() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RenewVirtualDeviceCredentialsResponseType::clear_has_cleardevicecredentials() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RenewVirtualDeviceCredentialsResponseType::clear_cleardevicecredentials() {
  if (cleardevicecredentials_ != &::google::protobuf::internal::kEmptyString) {
    cleardevicecredentials_->clear();
  }
  clear_has_cleardevicecredentials();
}
inline const ::std::string& RenewVirtualDeviceCredentialsResponseType::cleardevicecredentials() const {
  return *cleardevicecredentials_;
}
inline void RenewVirtualDeviceCredentialsResponseType::set_cleardevicecredentials(const ::std::string& value) {
  set_has_cleardevicecredentials();
  if (cleardevicecredentials_ == &::google::protobuf::internal::kEmptyString) {
    cleardevicecredentials_ = new ::std::string;
  }
  cleardevicecredentials_->assign(value);
}
inline void RenewVirtualDeviceCredentialsResponseType::set_cleardevicecredentials(const char* value) {
  set_has_cleardevicecredentials();
  if (cleardevicecredentials_ == &::google::protobuf::internal::kEmptyString) {
    cleardevicecredentials_ = new ::std::string;
  }
  cleardevicecredentials_->assign(value);
}
inline void RenewVirtualDeviceCredentialsResponseType::set_cleardevicecredentials(const void* value, size_t size) {
  set_has_cleardevicecredentials();
  if (cleardevicecredentials_ == &::google::protobuf::internal::kEmptyString) {
    cleardevicecredentials_ = new ::std::string;
  }
  cleardevicecredentials_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RenewVirtualDeviceCredentialsResponseType::mutable_cleardevicecredentials() {
  set_has_cleardevicecredentials();
  if (cleardevicecredentials_ == &::google::protobuf::internal::kEmptyString) {
    cleardevicecredentials_ = new ::std::string;
  }
  return cleardevicecredentials_;
}
inline ::std::string* RenewVirtualDeviceCredentialsResponseType::release_cleardevicecredentials() {
  clear_has_cleardevicecredentials();
  if (cleardevicecredentials_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cleardevicecredentials_;
    cleardevicecredentials_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes RenewalToken = 4;
inline bool RenewVirtualDeviceCredentialsResponseType::has_renewaltoken() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RenewVirtualDeviceCredentialsResponseType::set_has_renewaltoken() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RenewVirtualDeviceCredentialsResponseType::clear_has_renewaltoken() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RenewVirtualDeviceCredentialsResponseType::clear_renewaltoken() {
  if (renewaltoken_ != &::google::protobuf::internal::kEmptyString) {
    renewaltoken_->clear();
  }
  clear_has_renewaltoken();
}
inline const ::std::string& RenewVirtualDeviceCredentialsResponseType::renewaltoken() const {
  return *renewaltoken_;
}
inline void RenewVirtualDeviceCredentialsResponseType::set_renewaltoken(const ::std::string& value) {
  set_has_renewaltoken();
  if (renewaltoken_ == &::google::protobuf::internal::kEmptyString) {
    renewaltoken_ = new ::std::string;
  }
  renewaltoken_->assign(value);
}
inline void RenewVirtualDeviceCredentialsResponseType::set_renewaltoken(const char* value) {
  set_has_renewaltoken();
  if (renewaltoken_ == &::google::protobuf::internal::kEmptyString) {
    renewaltoken_ = new ::std::string;
  }
  renewaltoken_->assign(value);
}
inline void RenewVirtualDeviceCredentialsResponseType::set_renewaltoken(const void* value, size_t size) {
  set_has_renewaltoken();
  if (renewaltoken_ == &::google::protobuf::internal::kEmptyString) {
    renewaltoken_ = new ::std::string;
  }
  renewaltoken_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RenewVirtualDeviceCredentialsResponseType::mutable_renewaltoken() {
  set_has_renewaltoken();
  if (renewaltoken_ == &::google::protobuf::internal::kEmptyString) {
    renewaltoken_ = new ::std::string;
  }
  return renewaltoken_;
}
inline ::std::string* RenewVirtualDeviceCredentialsResponseType::release_renewaltoken() {
  clear_has_renewaltoken();
  if (renewaltoken_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = renewaltoken_;
    renewaltoken_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes AttestProgram = 5;
inline bool RenewVirtualDeviceCredentialsResponseType::has_attestprogram() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RenewVirtualDeviceCredentialsResponseType::set_has_attestprogram() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RenewVirtualDeviceCredentialsResponseType::clear_has_attestprogram() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RenewVirtualDeviceCredentialsResponseType::clear_attestprogram() {
  if (attestprogram_ != &::google::protobuf::internal::kEmptyString) {
    attestprogram_->clear();
  }
  clear_has_attestprogram();
}
inline const ::std::string& RenewVirtualDeviceCredentialsResponseType::attestprogram() const {
  return *attestprogram_;
}
inline void RenewVirtualDeviceCredentialsResponseType::set_attestprogram(const ::std::string& value) {
  set_has_attestprogram();
  if (attestprogram_ == &::google::protobuf::internal::kEmptyString) {
    attestprogram_ = new ::std::string;
  }
  attestprogram_->assign(value);
}
inline void RenewVirtualDeviceCredentialsResponseType::set_attestprogram(const char* value) {
  set_has_attestprogram();
  if (attestprogram_ == &::google::protobuf::internal::kEmptyString) {
    attestprogram_ = new ::std::string;
  }
  attestprogram_->assign(value);
}
inline void RenewVirtualDeviceCredentialsResponseType::set_attestprogram(const void* value, size_t size) {
  set_has_attestprogram();
  if (attestprogram_ == &::google::protobuf::internal::kEmptyString) {
    attestprogram_ = new ::std::string;
  }
  attestprogram_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RenewVirtualDeviceCredentialsResponseType::mutable_attestprogram() {
  set_has_attestprogram();
  if (attestprogram_ == &::google::protobuf::internal::kEmptyString) {
    attestprogram_ = new ::std::string;
  }
  return attestprogram_;
}
inline ::std::string* RenewVirtualDeviceCredentialsResponseType::release_attestprogram() {
  clear_has_attestprogram();
  if (attestprogram_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attestprogram_;
    attestprogram_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required fixed64 IssueDate = 6;
inline bool RenewVirtualDeviceCredentialsResponseType::has_issuedate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RenewVirtualDeviceCredentialsResponseType::set_has_issuedate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RenewVirtualDeviceCredentialsResponseType::clear_has_issuedate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RenewVirtualDeviceCredentialsResponseType::clear_issuedate() {
  issuedate_ = GOOGLE_ULONGLONG(0);
  clear_has_issuedate();
}
inline ::google::protobuf::uint64 RenewVirtualDeviceCredentialsResponseType::issuedate() const {
  return issuedate_;
}
inline void RenewVirtualDeviceCredentialsResponseType::set_issuedate(::google::protobuf::uint64 value) {
  set_has_issuedate();
  issuedate_ = value;
}

// required fixed64 SerialNumber = 7;
inline bool RenewVirtualDeviceCredentialsResponseType::has_serialnumber() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RenewVirtualDeviceCredentialsResponseType::set_has_serialnumber() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RenewVirtualDeviceCredentialsResponseType::clear_has_serialnumber() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RenewVirtualDeviceCredentialsResponseType::clear_serialnumber() {
  serialnumber_ = GOOGLE_ULONGLONG(0);
  clear_has_serialnumber();
}
inline ::google::protobuf::uint64 RenewVirtualDeviceCredentialsResponseType::serialnumber() const {
  return serialnumber_;
}
inline void RenewVirtualDeviceCredentialsResponseType::set_serialnumber(::google::protobuf::uint64 value) {
  set_has_serialnumber();
  serialnumber_ = value;
}

// optional bytes AttestTMD = 8;
inline bool RenewVirtualDeviceCredentialsResponseType::has_attesttmd() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RenewVirtualDeviceCredentialsResponseType::set_has_attesttmd() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RenewVirtualDeviceCredentialsResponseType::clear_has_attesttmd() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RenewVirtualDeviceCredentialsResponseType::clear_attesttmd() {
  if (attesttmd_ != &::google::protobuf::internal::kEmptyString) {
    attesttmd_->clear();
  }
  clear_has_attesttmd();
}
inline const ::std::string& RenewVirtualDeviceCredentialsResponseType::attesttmd() const {
  return *attesttmd_;
}
inline void RenewVirtualDeviceCredentialsResponseType::set_attesttmd(const ::std::string& value) {
  set_has_attesttmd();
  if (attesttmd_ == &::google::protobuf::internal::kEmptyString) {
    attesttmd_ = new ::std::string;
  }
  attesttmd_->assign(value);
}
inline void RenewVirtualDeviceCredentialsResponseType::set_attesttmd(const char* value) {
  set_has_attesttmd();
  if (attesttmd_ == &::google::protobuf::internal::kEmptyString) {
    attesttmd_ = new ::std::string;
  }
  attesttmd_->assign(value);
}
inline void RenewVirtualDeviceCredentialsResponseType::set_attesttmd(const void* value, size_t size) {
  set_has_attesttmd();
  if (attesttmd_ == &::google::protobuf::internal::kEmptyString) {
    attesttmd_ = new ::std::string;
  }
  attesttmd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RenewVirtualDeviceCredentialsResponseType::mutable_attesttmd() {
  set_has_attesttmd();
  if (attesttmd_ == &::google::protobuf::internal::kEmptyString) {
    attesttmd_ = new ::std::string;
  }
  return attesttmd_;
}
inline ::std::string* RenewVirtualDeviceCredentialsResponseType::release_attesttmd() {
  clear_has_attesttmd();
  if (attesttmd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attesttmd_;
    attesttmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes DeviceCert = 9;
inline bool RenewVirtualDeviceCredentialsResponseType::has_devicecert() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RenewVirtualDeviceCredentialsResponseType::set_has_devicecert() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RenewVirtualDeviceCredentialsResponseType::clear_has_devicecert() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RenewVirtualDeviceCredentialsResponseType::clear_devicecert() {
  if (devicecert_ != &::google::protobuf::internal::kEmptyString) {
    devicecert_->clear();
  }
  clear_has_devicecert();
}
inline const ::std::string& RenewVirtualDeviceCredentialsResponseType::devicecert() const {
  return *devicecert_;
}
inline void RenewVirtualDeviceCredentialsResponseType::set_devicecert(const ::std::string& value) {
  set_has_devicecert();
  if (devicecert_ == &::google::protobuf::internal::kEmptyString) {
    devicecert_ = new ::std::string;
  }
  devicecert_->assign(value);
}
inline void RenewVirtualDeviceCredentialsResponseType::set_devicecert(const char* value) {
  set_has_devicecert();
  if (devicecert_ == &::google::protobuf::internal::kEmptyString) {
    devicecert_ = new ::std::string;
  }
  devicecert_->assign(value);
}
inline void RenewVirtualDeviceCredentialsResponseType::set_devicecert(const void* value, size_t size) {
  set_has_devicecert();
  if (devicecert_ == &::google::protobuf::internal::kEmptyString) {
    devicecert_ = new ::std::string;
  }
  devicecert_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RenewVirtualDeviceCredentialsResponseType::mutable_devicecert() {
  set_has_devicecert();
  if (devicecert_ == &::google::protobuf::internal::kEmptyString) {
    devicecert_ = new ::std::string;
  }
  return devicecert_;
}
inline ::std::string* RenewVirtualDeviceCredentialsResponseType::release_devicecert() {
  clear_has_devicecert();
  if (devicecert_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devicecert_;
    devicecert_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes PlatformKey = 10;
inline bool RenewVirtualDeviceCredentialsResponseType::has_platformkey() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RenewVirtualDeviceCredentialsResponseType::set_has_platformkey() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RenewVirtualDeviceCredentialsResponseType::clear_has_platformkey() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RenewVirtualDeviceCredentialsResponseType::clear_platformkey() {
  if (platformkey_ != &::google::protobuf::internal::kEmptyString) {
    platformkey_->clear();
  }
  clear_has_platformkey();
}
inline const ::std::string& RenewVirtualDeviceCredentialsResponseType::platformkey() const {
  return *platformkey_;
}
inline void RenewVirtualDeviceCredentialsResponseType::set_platformkey(const ::std::string& value) {
  set_has_platformkey();
  if (platformkey_ == &::google::protobuf::internal::kEmptyString) {
    platformkey_ = new ::std::string;
  }
  platformkey_->assign(value);
}
inline void RenewVirtualDeviceCredentialsResponseType::set_platformkey(const char* value) {
  set_has_platformkey();
  if (platformkey_ == &::google::protobuf::internal::kEmptyString) {
    platformkey_ = new ::std::string;
  }
  platformkey_->assign(value);
}
inline void RenewVirtualDeviceCredentialsResponseType::set_platformkey(const void* value, size_t size) {
  set_has_platformkey();
  if (platformkey_ == &::google::protobuf::internal::kEmptyString) {
    platformkey_ = new ::std::string;
  }
  platformkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RenewVirtualDeviceCredentialsResponseType::mutable_platformkey() {
  set_has_platformkey();
  if (platformkey_ == &::google::protobuf::internal::kEmptyString) {
    platformkey_ = new ::std::string;
  }
  return platformkey_;
}
inline ::std::string* RenewVirtualDeviceCredentialsResponseType::release_platformkey() {
  clear_has_platformkey();
  if (platformkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = platformkey_;
    platformkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetServerKeyRequestType

// required .vplex.ias.AbstractRequestType _inherited = 1;
inline bool GetServerKeyRequestType::has__inherited() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetServerKeyRequestType::set_has__inherited() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetServerKeyRequestType::clear_has__inherited() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetServerKeyRequestType::clear__inherited() {
  if (_inherited_ != NULL) _inherited_->::vplex::ias::AbstractRequestType::Clear();
  clear_has__inherited();
}
inline const ::vplex::ias::AbstractRequestType& GetServerKeyRequestType::_inherited() const {
  return _inherited_ != NULL ? *_inherited_ : *default_instance_->_inherited_;
}
inline ::vplex::ias::AbstractRequestType* GetServerKeyRequestType::mutable__inherited() {
  set_has__inherited();
  if (_inherited_ == NULL) _inherited_ = new ::vplex::ias::AbstractRequestType;
  return _inherited_;
}
inline ::vplex::ias::AbstractRequestType* GetServerKeyRequestType::release__inherited() {
  clear_has__inherited();
  ::vplex::ias::AbstractRequestType* temp = _inherited_;
  _inherited_ = NULL;
  return temp;
}

// required fixed64 UserId = 2;
inline bool GetServerKeyRequestType::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetServerKeyRequestType::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetServerKeyRequestType::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetServerKeyRequestType::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 GetServerKeyRequestType::userid() const {
  return userid_;
}
inline void GetServerKeyRequestType::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// -------------------------------------------------------------------

// GetServerKeyResponseType

// required .vplex.ias.AbstractResponseType _inherited = 1;
inline bool GetServerKeyResponseType::has__inherited() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetServerKeyResponseType::set_has__inherited() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetServerKeyResponseType::clear_has__inherited() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetServerKeyResponseType::clear__inherited() {
  if (_inherited_ != NULL) _inherited_->::vplex::ias::AbstractResponseType::Clear();
  clear_has__inherited();
}
inline const ::vplex::ias::AbstractResponseType& GetServerKeyResponseType::_inherited() const {
  return _inherited_ != NULL ? *_inherited_ : *default_instance_->_inherited_;
}
inline ::vplex::ias::AbstractResponseType* GetServerKeyResponseType::mutable__inherited() {
  set_has__inherited();
  if (_inherited_ == NULL) _inherited_ = new ::vplex::ias::AbstractResponseType;
  return _inherited_;
}
inline ::vplex::ias::AbstractResponseType* GetServerKeyResponseType::release__inherited() {
  clear_has__inherited();
  ::vplex::ias::AbstractResponseType* temp = _inherited_;
  _inherited_ = NULL;
  return temp;
}

// optional bytes ServerKey = 2;
inline bool GetServerKeyResponseType::has_serverkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetServerKeyResponseType::set_has_serverkey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetServerKeyResponseType::clear_has_serverkey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetServerKeyResponseType::clear_serverkey() {
  if (serverkey_ != &::google::protobuf::internal::kEmptyString) {
    serverkey_->clear();
  }
  clear_has_serverkey();
}
inline const ::std::string& GetServerKeyResponseType::serverkey() const {
  return *serverkey_;
}
inline void GetServerKeyResponseType::set_serverkey(const ::std::string& value) {
  set_has_serverkey();
  if (serverkey_ == &::google::protobuf::internal::kEmptyString) {
    serverkey_ = new ::std::string;
  }
  serverkey_->assign(value);
}
inline void GetServerKeyResponseType::set_serverkey(const char* value) {
  set_has_serverkey();
  if (serverkey_ == &::google::protobuf::internal::kEmptyString) {
    serverkey_ = new ::std::string;
  }
  serverkey_->assign(value);
}
inline void GetServerKeyResponseType::set_serverkey(const void* value, size_t size) {
  set_has_serverkey();
  if (serverkey_ == &::google::protobuf::internal::kEmptyString) {
    serverkey_ = new ::std::string;
  }
  serverkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetServerKeyResponseType::mutable_serverkey() {
  set_has_serverkey();
  if (serverkey_ == &::google::protobuf::internal::kEmptyString) {
    serverkey_ = new ::std::string;
  }
  return serverkey_;
}
inline ::std::string* GetServerKeyResponseType::release_serverkey() {
  clear_has_serverkey();
  if (serverkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serverkey_;
    serverkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RequestPairingRequestType

// required .vplex.ias.AbstractRequestType _inherited = 1;
inline bool RequestPairingRequestType::has__inherited() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestPairingRequestType::set_has__inherited() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestPairingRequestType::clear_has__inherited() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestPairingRequestType::clear__inherited() {
  if (_inherited_ != NULL) _inherited_->::vplex::ias::AbstractRequestType::Clear();
  clear_has__inherited();
}
inline const ::vplex::ias::AbstractRequestType& RequestPairingRequestType::_inherited() const {
  return _inherited_ != NULL ? *_inherited_ : *default_instance_->_inherited_;
}
inline ::vplex::ias::AbstractRequestType* RequestPairingRequestType::mutable__inherited() {
  set_has__inherited();
  if (_inherited_ == NULL) _inherited_ = new ::vplex::ias::AbstractRequestType;
  return _inherited_;
}
inline ::vplex::ias::AbstractRequestType* RequestPairingRequestType::release__inherited() {
  clear_has__inherited();
  ::vplex::ias::AbstractRequestType* temp = _inherited_;
  _inherited_ = NULL;
  return temp;
}

// optional bytes HostHardwareId = 2;
inline bool RequestPairingRequestType::has_hosthardwareid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestPairingRequestType::set_has_hosthardwareid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestPairingRequestType::clear_has_hosthardwareid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestPairingRequestType::clear_hosthardwareid() {
  if (hosthardwareid_ != &::google::protobuf::internal::kEmptyString) {
    hosthardwareid_->clear();
  }
  clear_has_hosthardwareid();
}
inline const ::std::string& RequestPairingRequestType::hosthardwareid() const {
  return *hosthardwareid_;
}
inline void RequestPairingRequestType::set_hosthardwareid(const ::std::string& value) {
  set_has_hosthardwareid();
  if (hosthardwareid_ == &::google::protobuf::internal::kEmptyString) {
    hosthardwareid_ = new ::std::string;
  }
  hosthardwareid_->assign(value);
}
inline void RequestPairingRequestType::set_hosthardwareid(const char* value) {
  set_has_hosthardwareid();
  if (hosthardwareid_ == &::google::protobuf::internal::kEmptyString) {
    hosthardwareid_ = new ::std::string;
  }
  hosthardwareid_->assign(value);
}
inline void RequestPairingRequestType::set_hosthardwareid(const void* value, size_t size) {
  set_has_hosthardwareid();
  if (hosthardwareid_ == &::google::protobuf::internal::kEmptyString) {
    hosthardwareid_ = new ::std::string;
  }
  hosthardwareid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestPairingRequestType::mutable_hosthardwareid() {
  set_has_hosthardwareid();
  if (hosthardwareid_ == &::google::protobuf::internal::kEmptyString) {
    hosthardwareid_ = new ::std::string;
  }
  return hosthardwareid_;
}
inline ::std::string* RequestPairingRequestType::release_hosthardwareid() {
  clear_has_hosthardwareid();
  if (hosthardwareid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hosthardwareid_;
    hosthardwareid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional fixed64 HostDeviceId = 3;
inline bool RequestPairingRequestType::has_hostdeviceid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestPairingRequestType::set_has_hostdeviceid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestPairingRequestType::clear_has_hostdeviceid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestPairingRequestType::clear_hostdeviceid() {
  hostdeviceid_ = GOOGLE_ULONGLONG(0);
  clear_has_hostdeviceid();
}
inline ::google::protobuf::uint64 RequestPairingRequestType::hostdeviceid() const {
  return hostdeviceid_;
}
inline void RequestPairingRequestType::set_hostdeviceid(::google::protobuf::uint64 value) {
  set_has_hostdeviceid();
  hostdeviceid_ = value;
}

// required bytes DeviceHardwareId = 4;
inline bool RequestPairingRequestType::has_devicehardwareid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestPairingRequestType::set_has_devicehardwareid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestPairingRequestType::clear_has_devicehardwareid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestPairingRequestType::clear_devicehardwareid() {
  if (devicehardwareid_ != &::google::protobuf::internal::kEmptyString) {
    devicehardwareid_->clear();
  }
  clear_has_devicehardwareid();
}
inline const ::std::string& RequestPairingRequestType::devicehardwareid() const {
  return *devicehardwareid_;
}
inline void RequestPairingRequestType::set_devicehardwareid(const ::std::string& value) {
  set_has_devicehardwareid();
  if (devicehardwareid_ == &::google::protobuf::internal::kEmptyString) {
    devicehardwareid_ = new ::std::string;
  }
  devicehardwareid_->assign(value);
}
inline void RequestPairingRequestType::set_devicehardwareid(const char* value) {
  set_has_devicehardwareid();
  if (devicehardwareid_ == &::google::protobuf::internal::kEmptyString) {
    devicehardwareid_ = new ::std::string;
  }
  devicehardwareid_->assign(value);
}
inline void RequestPairingRequestType::set_devicehardwareid(const void* value, size_t size) {
  set_has_devicehardwareid();
  if (devicehardwareid_ == &::google::protobuf::internal::kEmptyString) {
    devicehardwareid_ = new ::std::string;
  }
  devicehardwareid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestPairingRequestType::mutable_devicehardwareid() {
  set_has_devicehardwareid();
  if (devicehardwareid_ == &::google::protobuf::internal::kEmptyString) {
    devicehardwareid_ = new ::std::string;
  }
  return devicehardwareid_;
}
inline ::std::string* RequestPairingRequestType::release_devicehardwareid() {
  clear_has_devicehardwareid();
  if (devicehardwareid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devicehardwareid_;
    devicehardwareid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string PIN = 5;
inline bool RequestPairingRequestType::has_pin() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestPairingRequestType::set_has_pin() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestPairingRequestType::clear_has_pin() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestPairingRequestType::clear_pin() {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    pin_->clear();
  }
  clear_has_pin();
}
inline const ::std::string& RequestPairingRequestType::pin() const {
  return *pin_;
}
inline void RequestPairingRequestType::set_pin(const ::std::string& value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void RequestPairingRequestType::set_pin(const char* value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void RequestPairingRequestType::set_pin(const char* value, size_t size) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestPairingRequestType::mutable_pin() {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  return pin_;
}
inline ::std::string* RequestPairingRequestType::release_pin() {
  clear_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pin_;
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .vplex.ias.StrAttributeType PairingAttributes = 6;
inline int RequestPairingRequestType::pairingattributes_size() const {
  return pairingattributes_.size();
}
inline void RequestPairingRequestType::clear_pairingattributes() {
  pairingattributes_.Clear();
}
inline const ::vplex::ias::StrAttributeType& RequestPairingRequestType::pairingattributes(int index) const {
  return pairingattributes_.Get(index);
}
inline ::vplex::ias::StrAttributeType* RequestPairingRequestType::mutable_pairingattributes(int index) {
  return pairingattributes_.Mutable(index);
}
inline ::vplex::ias::StrAttributeType* RequestPairingRequestType::add_pairingattributes() {
  return pairingattributes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vplex::ias::StrAttributeType >&
RequestPairingRequestType::pairingattributes() const {
  return pairingattributes_;
}
inline ::google::protobuf::RepeatedPtrField< ::vplex::ias::StrAttributeType >*
RequestPairingRequestType::mutable_pairingattributes() {
  return &pairingattributes_;
}

// -------------------------------------------------------------------

// RequestPairingResponseType

// required .vplex.ias.AbstractResponseType _inherited = 1;
inline bool RequestPairingResponseType::has__inherited() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestPairingResponseType::set_has__inherited() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestPairingResponseType::clear_has__inherited() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestPairingResponseType::clear__inherited() {
  if (_inherited_ != NULL) _inherited_->::vplex::ias::AbstractResponseType::Clear();
  clear_has__inherited();
}
inline const ::vplex::ias::AbstractResponseType& RequestPairingResponseType::_inherited() const {
  return _inherited_ != NULL ? *_inherited_ : *default_instance_->_inherited_;
}
inline ::vplex::ias::AbstractResponseType* RequestPairingResponseType::mutable__inherited() {
  set_has__inherited();
  if (_inherited_ == NULL) _inherited_ = new ::vplex::ias::AbstractResponseType;
  return _inherited_;
}
inline ::vplex::ias::AbstractResponseType* RequestPairingResponseType::release__inherited() {
  clear_has__inherited();
  ::vplex::ias::AbstractResponseType* temp = _inherited_;
  _inherited_ = NULL;
  return temp;
}

// required string PairingToken = 2;
inline bool RequestPairingResponseType::has_pairingtoken() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestPairingResponseType::set_has_pairingtoken() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestPairingResponseType::clear_has_pairingtoken() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestPairingResponseType::clear_pairingtoken() {
  if (pairingtoken_ != &::google::protobuf::internal::kEmptyString) {
    pairingtoken_->clear();
  }
  clear_has_pairingtoken();
}
inline const ::std::string& RequestPairingResponseType::pairingtoken() const {
  return *pairingtoken_;
}
inline void RequestPairingResponseType::set_pairingtoken(const ::std::string& value) {
  set_has_pairingtoken();
  if (pairingtoken_ == &::google::protobuf::internal::kEmptyString) {
    pairingtoken_ = new ::std::string;
  }
  pairingtoken_->assign(value);
}
inline void RequestPairingResponseType::set_pairingtoken(const char* value) {
  set_has_pairingtoken();
  if (pairingtoken_ == &::google::protobuf::internal::kEmptyString) {
    pairingtoken_ = new ::std::string;
  }
  pairingtoken_->assign(value);
}
inline void RequestPairingResponseType::set_pairingtoken(const char* value, size_t size) {
  set_has_pairingtoken();
  if (pairingtoken_ == &::google::protobuf::internal::kEmptyString) {
    pairingtoken_ = new ::std::string;
  }
  pairingtoken_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestPairingResponseType::mutable_pairingtoken() {
  set_has_pairingtoken();
  if (pairingtoken_ == &::google::protobuf::internal::kEmptyString) {
    pairingtoken_ = new ::std::string;
  }
  return pairingtoken_;
}
inline ::std::string* RequestPairingResponseType::release_pairingtoken() {
  clear_has_pairingtoken();
  if (pairingtoken_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pairingtoken_;
    pairingtoken_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RespondToPairingRequestRequestType

// required .vplex.ias.AbstractRequestType _inherited = 1;
inline bool RespondToPairingRequestRequestType::has__inherited() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RespondToPairingRequestRequestType::set_has__inherited() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RespondToPairingRequestRequestType::clear_has__inherited() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RespondToPairingRequestRequestType::clear__inherited() {
  if (_inherited_ != NULL) _inherited_->::vplex::ias::AbstractRequestType::Clear();
  clear_has__inherited();
}
inline const ::vplex::ias::AbstractRequestType& RespondToPairingRequestRequestType::_inherited() const {
  return _inherited_ != NULL ? *_inherited_ : *default_instance_->_inherited_;
}
inline ::vplex::ias::AbstractRequestType* RespondToPairingRequestRequestType::mutable__inherited() {
  set_has__inherited();
  if (_inherited_ == NULL) _inherited_ = new ::vplex::ias::AbstractRequestType;
  return _inherited_;
}
inline ::vplex::ias::AbstractRequestType* RespondToPairingRequestRequestType::release__inherited() {
  clear_has__inherited();
  ::vplex::ias::AbstractRequestType* temp = _inherited_;
  _inherited_ = NULL;
  return temp;
}

// required string TransactionId = 2;
inline bool RespondToPairingRequestRequestType::has_transactionid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RespondToPairingRequestRequestType::set_has_transactionid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RespondToPairingRequestRequestType::clear_has_transactionid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RespondToPairingRequestRequestType::clear_transactionid() {
  if (transactionid_ != &::google::protobuf::internal::kEmptyString) {
    transactionid_->clear();
  }
  clear_has_transactionid();
}
inline const ::std::string& RespondToPairingRequestRequestType::transactionid() const {
  return *transactionid_;
}
inline void RespondToPairingRequestRequestType::set_transactionid(const ::std::string& value) {
  set_has_transactionid();
  if (transactionid_ == &::google::protobuf::internal::kEmptyString) {
    transactionid_ = new ::std::string;
  }
  transactionid_->assign(value);
}
inline void RespondToPairingRequestRequestType::set_transactionid(const char* value) {
  set_has_transactionid();
  if (transactionid_ == &::google::protobuf::internal::kEmptyString) {
    transactionid_ = new ::std::string;
  }
  transactionid_->assign(value);
}
inline void RespondToPairingRequestRequestType::set_transactionid(const char* value, size_t size) {
  set_has_transactionid();
  if (transactionid_ == &::google::protobuf::internal::kEmptyString) {
    transactionid_ = new ::std::string;
  }
  transactionid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RespondToPairingRequestRequestType::mutable_transactionid() {
  set_has_transactionid();
  if (transactionid_ == &::google::protobuf::internal::kEmptyString) {
    transactionid_ = new ::std::string;
  }
  return transactionid_;
}
inline ::std::string* RespondToPairingRequestRequestType::release_transactionid() {
  clear_has_transactionid();
  if (transactionid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = transactionid_;
    transactionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bool AcceptedPairing = 3;
inline bool RespondToPairingRequestRequestType::has_acceptedpairing() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RespondToPairingRequestRequestType::set_has_acceptedpairing() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RespondToPairingRequestRequestType::clear_has_acceptedpairing() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RespondToPairingRequestRequestType::clear_acceptedpairing() {
  acceptedpairing_ = false;
  clear_has_acceptedpairing();
}
inline bool RespondToPairingRequestRequestType::acceptedpairing() const {
  return acceptedpairing_;
}
inline void RespondToPairingRequestRequestType::set_acceptedpairing(bool value) {
  set_has_acceptedpairing();
  acceptedpairing_ = value;
}

// -------------------------------------------------------------------

// RespondToPairingRequestResponseType

// required .vplex.ias.AbstractResponseType _inherited = 1;
inline bool RespondToPairingRequestResponseType::has__inherited() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RespondToPairingRequestResponseType::set_has__inherited() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RespondToPairingRequestResponseType::clear_has__inherited() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RespondToPairingRequestResponseType::clear__inherited() {
  if (_inherited_ != NULL) _inherited_->::vplex::ias::AbstractResponseType::Clear();
  clear_has__inherited();
}
inline const ::vplex::ias::AbstractResponseType& RespondToPairingRequestResponseType::_inherited() const {
  return _inherited_ != NULL ? *_inherited_ : *default_instance_->_inherited_;
}
inline ::vplex::ias::AbstractResponseType* RespondToPairingRequestResponseType::mutable__inherited() {
  set_has__inherited();
  if (_inherited_ == NULL) _inherited_ = new ::vplex::ias::AbstractResponseType;
  return _inherited_;
}
inline ::vplex::ias::AbstractResponseType* RespondToPairingRequestResponseType::release__inherited() {
  clear_has__inherited();
  ::vplex::ias::AbstractResponseType* temp = _inherited_;
  _inherited_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// RequestPairingPinRequestType

// required .vplex.ias.AbstractRequestType _inherited = 1;
inline bool RequestPairingPinRequestType::has__inherited() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestPairingPinRequestType::set_has__inherited() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestPairingPinRequestType::clear_has__inherited() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestPairingPinRequestType::clear__inherited() {
  if (_inherited_ != NULL) _inherited_->::vplex::ias::AbstractRequestType::Clear();
  clear_has__inherited();
}
inline const ::vplex::ias::AbstractRequestType& RequestPairingPinRequestType::_inherited() const {
  return _inherited_ != NULL ? *_inherited_ : *default_instance_->_inherited_;
}
inline ::vplex::ias::AbstractRequestType* RequestPairingPinRequestType::mutable__inherited() {
  set_has__inherited();
  if (_inherited_ == NULL) _inherited_ = new ::vplex::ias::AbstractRequestType;
  return _inherited_;
}
inline ::vplex::ias::AbstractRequestType* RequestPairingPinRequestType::release__inherited() {
  clear_has__inherited();
  ::vplex::ias::AbstractRequestType* temp = _inherited_;
  _inherited_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// RequestPairingPinResponseType

// required .vplex.ias.AbstractResponseType _inherited = 1;
inline bool RequestPairingPinResponseType::has__inherited() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestPairingPinResponseType::set_has__inherited() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestPairingPinResponseType::clear_has__inherited() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestPairingPinResponseType::clear__inherited() {
  if (_inherited_ != NULL) _inherited_->::vplex::ias::AbstractResponseType::Clear();
  clear_has__inherited();
}
inline const ::vplex::ias::AbstractResponseType& RequestPairingPinResponseType::_inherited() const {
  return _inherited_ != NULL ? *_inherited_ : *default_instance_->_inherited_;
}
inline ::vplex::ias::AbstractResponseType* RequestPairingPinResponseType::mutable__inherited() {
  set_has__inherited();
  if (_inherited_ == NULL) _inherited_ = new ::vplex::ias::AbstractResponseType;
  return _inherited_;
}
inline ::vplex::ias::AbstractResponseType* RequestPairingPinResponseType::release__inherited() {
  clear_has__inherited();
  ::vplex::ias::AbstractResponseType* temp = _inherited_;
  _inherited_ = NULL;
  return temp;
}

// required string PairingPin = 2;
inline bool RequestPairingPinResponseType::has_pairingpin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestPairingPinResponseType::set_has_pairingpin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestPairingPinResponseType::clear_has_pairingpin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestPairingPinResponseType::clear_pairingpin() {
  if (pairingpin_ != &::google::protobuf::internal::kEmptyString) {
    pairingpin_->clear();
  }
  clear_has_pairingpin();
}
inline const ::std::string& RequestPairingPinResponseType::pairingpin() const {
  return *pairingpin_;
}
inline void RequestPairingPinResponseType::set_pairingpin(const ::std::string& value) {
  set_has_pairingpin();
  if (pairingpin_ == &::google::protobuf::internal::kEmptyString) {
    pairingpin_ = new ::std::string;
  }
  pairingpin_->assign(value);
}
inline void RequestPairingPinResponseType::set_pairingpin(const char* value) {
  set_has_pairingpin();
  if (pairingpin_ == &::google::protobuf::internal::kEmptyString) {
    pairingpin_ = new ::std::string;
  }
  pairingpin_->assign(value);
}
inline void RequestPairingPinResponseType::set_pairingpin(const char* value, size_t size) {
  set_has_pairingpin();
  if (pairingpin_ == &::google::protobuf::internal::kEmptyString) {
    pairingpin_ = new ::std::string;
  }
  pairingpin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestPairingPinResponseType::mutable_pairingpin() {
  set_has_pairingpin();
  if (pairingpin_ == &::google::protobuf::internal::kEmptyString) {
    pairingpin_ = new ::std::string;
  }
  return pairingpin_;
}
inline ::std::string* RequestPairingPinResponseType::release_pairingpin() {
  clear_has_pairingpin();
  if (pairingpin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pairingpin_;
    pairingpin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetPairingStatusRequestType

// required .vplex.ias.AbstractRequestType _inherited = 1;
inline bool GetPairingStatusRequestType::has__inherited() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetPairingStatusRequestType::set_has__inherited() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetPairingStatusRequestType::clear_has__inherited() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetPairingStatusRequestType::clear__inherited() {
  if (_inherited_ != NULL) _inherited_->::vplex::ias::AbstractRequestType::Clear();
  clear_has__inherited();
}
inline const ::vplex::ias::AbstractRequestType& GetPairingStatusRequestType::_inherited() const {
  return _inherited_ != NULL ? *_inherited_ : *default_instance_->_inherited_;
}
inline ::vplex::ias::AbstractRequestType* GetPairingStatusRequestType::mutable__inherited() {
  set_has__inherited();
  if (_inherited_ == NULL) _inherited_ = new ::vplex::ias::AbstractRequestType;
  return _inherited_;
}
inline ::vplex::ias::AbstractRequestType* GetPairingStatusRequestType::release__inherited() {
  clear_has__inherited();
  ::vplex::ias::AbstractRequestType* temp = _inherited_;
  _inherited_ = NULL;
  return temp;
}

// required string PairingToken = 2;
inline bool GetPairingStatusRequestType::has_pairingtoken() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetPairingStatusRequestType::set_has_pairingtoken() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetPairingStatusRequestType::clear_has_pairingtoken() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetPairingStatusRequestType::clear_pairingtoken() {
  if (pairingtoken_ != &::google::protobuf::internal::kEmptyString) {
    pairingtoken_->clear();
  }
  clear_has_pairingtoken();
}
inline const ::std::string& GetPairingStatusRequestType::pairingtoken() const {
  return *pairingtoken_;
}
inline void GetPairingStatusRequestType::set_pairingtoken(const ::std::string& value) {
  set_has_pairingtoken();
  if (pairingtoken_ == &::google::protobuf::internal::kEmptyString) {
    pairingtoken_ = new ::std::string;
  }
  pairingtoken_->assign(value);
}
inline void GetPairingStatusRequestType::set_pairingtoken(const char* value) {
  set_has_pairingtoken();
  if (pairingtoken_ == &::google::protobuf::internal::kEmptyString) {
    pairingtoken_ = new ::std::string;
  }
  pairingtoken_->assign(value);
}
inline void GetPairingStatusRequestType::set_pairingtoken(const char* value, size_t size) {
  set_has_pairingtoken();
  if (pairingtoken_ == &::google::protobuf::internal::kEmptyString) {
    pairingtoken_ = new ::std::string;
  }
  pairingtoken_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetPairingStatusRequestType::mutable_pairingtoken() {
  set_has_pairingtoken();
  if (pairingtoken_ == &::google::protobuf::internal::kEmptyString) {
    pairingtoken_ = new ::std::string;
  }
  return pairingtoken_;
}
inline ::std::string* GetPairingStatusRequestType::release_pairingtoken() {
  clear_has_pairingtoken();
  if (pairingtoken_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pairingtoken_;
    pairingtoken_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetPairingStatusResponseType

// required .vplex.ias.AbstractResponseType _inherited = 1;
inline bool GetPairingStatusResponseType::has__inherited() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetPairingStatusResponseType::set_has__inherited() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetPairingStatusResponseType::clear_has__inherited() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetPairingStatusResponseType::clear__inherited() {
  if (_inherited_ != NULL) _inherited_->::vplex::ias::AbstractResponseType::Clear();
  clear_has__inherited();
}
inline const ::vplex::ias::AbstractResponseType& GetPairingStatusResponseType::_inherited() const {
  return _inherited_ != NULL ? *_inherited_ : *default_instance_->_inherited_;
}
inline ::vplex::ias::AbstractResponseType* GetPairingStatusResponseType::mutable__inherited() {
  set_has__inherited();
  if (_inherited_ == NULL) _inherited_ = new ::vplex::ias::AbstractResponseType;
  return _inherited_;
}
inline ::vplex::ias::AbstractResponseType* GetPairingStatusResponseType::release__inherited() {
  clear_has__inherited();
  ::vplex::ias::AbstractResponseType* temp = _inherited_;
  _inherited_ = NULL;
  return temp;
}

// required string Status = 2;
inline bool GetPairingStatusResponseType::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetPairingStatusResponseType::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetPairingStatusResponseType::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetPairingStatusResponseType::clear_status() {
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    status_->clear();
  }
  clear_has_status();
}
inline const ::std::string& GetPairingStatusResponseType::status() const {
  return *status_;
}
inline void GetPairingStatusResponseType::set_status(const ::std::string& value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void GetPairingStatusResponseType::set_status(const char* value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void GetPairingStatusResponseType::set_status(const char* value, size_t size) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetPairingStatusResponseType::mutable_status() {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  return status_;
}
inline ::std::string* GetPairingStatusResponseType::release_status() {
  clear_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = status_;
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Username = 3;
inline bool GetPairingStatusResponseType::has_username() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetPairingStatusResponseType::set_has_username() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetPairingStatusResponseType::clear_has_username() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetPairingStatusResponseType::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& GetPairingStatusResponseType::username() const {
  return *username_;
}
inline void GetPairingStatusResponseType::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void GetPairingStatusResponseType::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void GetPairingStatusResponseType::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetPairingStatusResponseType::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* GetPairingStatusResponseType::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ias
}  // namespace vplex

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_vplex_5fias_5fservice_5ftypes_2eproto__INCLUDED
