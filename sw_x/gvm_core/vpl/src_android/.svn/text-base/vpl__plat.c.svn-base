//
//  Copyright 2011 iGware Inc.
//  All Rights Reserved.
//
//  THIS SOFTWARE CONTAINS CONFIDENTIAL INFORMATION AND
//  TRADE SECRETS OF IGWARE INC.
//  USE, DISCLOSURE OR REPRODUCTION IS PROHIBITED WITHOUT
//  THE PRIOR EXPRESS WRITTEN PERMISSION OF IGWARE INC.
//

#include "vpl_plat.h"

#include "vplu.h"

#include <sys/system_properties.h>

static VPL_BOOL gInitialized = VPL_FALSE;

static u8 randHardwareInfo[33] = "RAND";

int VPL_Init(void)
{
    if (gInitialized) {
        return VPL_ERR_IS_INIT;
    }
    {
        // Random value, to use as a fallback.
        srand((unsigned int)VPLTime_GetTime());
        size_t i;
        for (i = 4; i < ARRAY_SIZE_IN_BYTES(randHardwareInfo); i++) {
            randHardwareInfo[i] = (char)(50 + (rand() % 64)); // ensure a string of printable ASCII characters
        }
        randHardwareInfo[ARRAY_SIZE_IN_BYTES(randHardwareInfo) - 1] = '\0';
    }
    gInitialized = VPL_TRUE;
    return VPL_OK;
}

VPL_BOOL VPL_IsInit()
{
    if (gInitialized) {
        return VPL_TRUE;
    } else {
        return VPL_FALSE;
    }
}

int VPL_Quit(void)
{
    if (!gInitialized) {
        return VPL_ERR_NOT_INIT;
    }
    gInitialized = VPL_FALSE;
    return VPL_OK;
}

int VPL_GetHwUuid(char** hwUuid_out)
{
    int rv = VPL_OK;

    if (hwUuid_out == NULL) {
        return VPL_ERR_INVALID;
    }

    *hwUuid_out = NULL;

    if (!gInitialized) {
        return VPL_ERR_NOT_INIT;
    }
    {
        // The documentation is ambiguous if the +1 is needed or not; better safe than sorry.
        char* buf = malloc(PROP_VALUE_MAX + 1);
        if (buf == NULL) {
            return VPL_ERR_NOMEM;
        }
        int len;
        len = __system_property_get("ro.aceruuid", buf);
        if (len > 0) {
            // It has an Acer UUID; use it.
            *hwUuid_out = buf;
            // buf will be freed when the client calls VPL_ReleaseHwUuid.
            goto out;
        }
        // Not an Acer Device; fall back to the next technique.
        len = __system_property_get( "ro.serialno", buf );
        if (len > 0) {
            // It has a serial # that was generated by the manufacturer.
            *hwUuid_out = buf;
            // buf will be freed when the client calls VPL_ReleaseHwUuid.
            goto out;
        }
        // buf will not be used; free it now.
        free( buf );
    }
    // Just provide a random id.
    {
        char* buf = malloc(ARRAY_SIZE_IN_BYTES(randHardwareInfo));
        if (buf == NULL) {
            return VPL_ERR_NOMEM;
        }
        memcpy(buf, randHardwareInfo, ARRAY_SIZE_IN_BYTES(randHardwareInfo));
        *hwUuid_out = buf;
        goto out;
    }

out:
    return rv;
}

void VPL_ReleaseHwUuid(char* hwUuid)
{
    if (hwUuid != NULL) {
        free(hwUuid);
    }
}

int VPL_GetOSUserName(char** osUserName_out)
{
    if (osUserName_out == NULL) {
        return VPL_ERR_INVALID;
    }
    *osUserName_out = NULL;
    if (!gInitialized) {
        return VPL_ERR_NOT_INIT;
    }
    // It should be fine for this to return an empty string for our current purposes, since
    // Android doesn't have a concept of multiple users on the same hardware.
    *osUserName_out = malloc(1);
    if (*osUserName_out == NULL) {
        return VPL_ERR_NOMEM;
    }
    (*osUserName_out)[0] = '\0';
    return VPL_OK;
}

void VPL_ReleaseOSUserName(char* osUserName)
{
    if (osUserName != NULL) {
        free(osUserName);
    }
}

int VPL_GetOSUserId(char** osUserId_out)
{
    if (osUserId_out == NULL) {
        return VPL_ERR_INVALID;
    }
    *osUserId_out = NULL;
    if (!gInitialized) {
        return VPL_ERR_NOT_INIT;
    }
    // TODO: Bug 12925: This is no longer true, since Android supports multiple OS users now:
    // It should be fine for this to return an empty string for our current purposes, since
    // Android doesn't have a concept of multiple users on the same hardware.
    *osUserId_out = malloc(1);
    if (*osUserId_out == NULL) {
        return VPL_ERR_NOMEM;
    }
    (*osUserId_out)[0] = '\0';
    return VPL_OK;
}

void VPL_ReleaseOSUserId(char* osUserId)
{
    if (osUserId != NULL) {
        free(osUserId);
    }
}

int VPL_GetDeviceInfo(char** manufacturer_out, char **model_out)
{
    int rv = VPL_OK;

    if (manufacturer_out == NULL) {
        return VPL_ERR_INVALID;
    }
    if (model_out == NULL) {
        return VPL_ERR_INVALID;
    }

    *manufacturer_out = NULL;
    *model_out = NULL;

    if (!gInitialized) {
        return VPL_ERR_NOT_INIT;
    }

    char* buf = NULL;
    char* buf2 = NULL;
    {
        // The documentation is ambiguous if the +1 is needed or not; better safe than sorry.
        buf = malloc(PROP_VALUE_MAX + 1);
        if (buf == NULL) {
            rv = VPL_ERR_NOMEM;
            goto out;
        }
        int len;
        len = __system_property_get("ro.product.manufacturer", buf);
        if (len > 0) {
            // It has manufacturer; use it.
            *manufacturer_out = buf;
            // buf will be freed when the client calls VPL_ReleaseHwUuid.
        } else {
            rv = VPL_ERR_FAIL;
            goto out;
        }

        buf2 = malloc(PROP_VALUE_MAX + 1);
        if (buf2 == NULL) {
            rv = VPL_ERR_NOMEM;
            goto out;
        }
        len = __system_property_get("ro.product.model", buf2);
        if (len > 0) {
            // It has model ; use it.
            *model_out = buf2;
            // buf will be freed when the client calls VPL_ReleaseHwUuid.
        } else {
            rv = VPL_ERR_FAIL;
            goto out;
        }
    }

out:
    if(buf != NULL && rv != VPL_OK){
        free(buf);
        buf = NULL;
        *manufacturer_out = NULL;
    }
    if(buf2 != NULL && rv != VPL_OK){
        free(buf2);
        buf2 = NULL;
        *model_out = NULL;
    }

    return rv;
}

void VPL_ReleaseDeviceInfo(char* manufacturer, char* model)
{
    if (manufacturer != NULL) {
        // should have been allocated via malloc
        free(manufacturer);
        manufacturer = NULL;
    }

    if (model != NULL) {
        // should have been allocated via malloc
        free(model);
        model = NULL;
    }
}

int VPL_GetOSVersion(char** osVersion_out)
{
    int rv = VPL_OK;

    if (osVersion_out == NULL) {
        return VPL_ERR_INVALID;
    }

    *osVersion_out = NULL;

    if (!gInitialized) {
        return VPL_ERR_NOT_INIT;
    }

    char* buf = NULL;
    char* buf2 = NULL;
    {
        // The documentation is ambiguous if the +1 is needed or not; better safe than sorry.
        buf = malloc(PROP_VALUE_MAX + 1);
        buf2 = malloc(PROP_VALUE_MAX + 10); //"Android build.version.release"
        if (buf == NULL || buf2 == NULL) {
            rv = VPL_ERR_NOMEM;
            goto out;
        }
        int len;
        len = __system_property_get("ro.build.version.release", buf);
        if (len > 0) {
            // It has osVersion; use it.
            sprintf(buf2, "Android %s", buf);
            *osVersion_out = buf2;
            free(buf);
            buf = NULL;
            // buf2 will be freed when the client calls VPL_ReleaseOSVersion.
        } else {
            rv = VPL_ERR_FAIL;
            goto out;
        }

    }

out:
    if(buf != NULL && rv != VPL_OK){
        free(buf);
        buf = NULL;
    }
    if(rv != VPL_OK && buf2 != NULL){
        free(buf2);
        buf2 = NULL;
        *osVersion_out = NULL;
    }

    return rv;
}

void VPL_ReleaseOSVersion(char* osVersion)
{
    if (osVersion != NULL) {
        // should have been allocated via malloc
        free(osVersion);
        osVersion = NULL;
    }

}
