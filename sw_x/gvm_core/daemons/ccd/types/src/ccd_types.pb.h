// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ccd_types.proto

#ifndef PROTOBUF_ccd_5ftypes_2eproto__INCLUDED
#define PROTOBUF_ccd_5ftypes_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "ccdi_rpc.pb.h"
#include "vplex_vs_directory_service_types.pb.h"
// @@protoc_insertion_point(includes)

namespace ccd {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ccd_5ftypes_2eproto();
void protobuf_AssignDesc_ccd_5ftypes_2eproto();
void protobuf_ShutdownFile_ccd_5ftypes_2eproto();

class CameraRollDownloadDirSpecInternal;
class CachedUserSummary;
class CachedUserSummaryList;
class UserSession;
class CCDToCCDCredential;
class CachedDataset;
class CachedSubscription;
class PicstreamDir;
class CachedStatEvent;
class MediaMetadataThumbMigrateInternal;
class SyncBoxSettings;
class CachedUserDetails;
class CachedUserData;
class CCDMainState;

// ===================================================================

class CameraRollDownloadDirSpecInternal : public ::google::protobuf::Message {
 public:
  CameraRollDownloadDirSpecInternal();
  virtual ~CameraRollDownloadDirSpecInternal();
  
  CameraRollDownloadDirSpecInternal(const CameraRollDownloadDirSpecInternal& from);
  
  inline CameraRollDownloadDirSpecInternal& operator=(const CameraRollDownloadDirSpecInternal& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CameraRollDownloadDirSpecInternal& default_instance();
  
  void Swap(CameraRollDownloadDirSpecInternal* other);
  
  // implements Message ----------------------------------------------
  
  CameraRollDownloadDirSpecInternal* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CameraRollDownloadDirSpecInternal& from);
  void MergeFrom(const CameraRollDownloadDirSpecInternal& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string dir = 1;
  inline bool has_dir() const;
  inline void clear_dir();
  static const int kDirFieldNumber = 1;
  inline const ::std::string& dir() const;
  inline void set_dir(const ::std::string& value);
  inline void set_dir(const char* value);
  inline void set_dir(const char* value, size_t size);
  inline ::std::string* mutable_dir();
  inline ::std::string* release_dir();
  
  // optional uint32 max_size = 7 [default = 0];
  inline bool has_max_size() const;
  inline void clear_max_size();
  static const int kMaxSizeFieldNumber = 7;
  inline ::google::protobuf::uint32 max_size() const;
  inline void set_max_size(::google::protobuf::uint32 value);
  
  // optional uint32 max_files = 8 [default = 0];
  inline bool has_max_files() const;
  inline void clear_max_files();
  static const int kMaxFilesFieldNumber = 8;
  inline ::google::protobuf::uint32 max_files() const;
  inline void set_max_files(::google::protobuf::uint32 value);
  
  // optional uint32 preserve_free_disk_percentage = 9 [default = 0];
  inline bool has_preserve_free_disk_percentage() const;
  inline void clear_preserve_free_disk_percentage();
  static const int kPreserveFreeDiskPercentageFieldNumber = 9;
  inline ::google::protobuf::uint32 preserve_free_disk_percentage() const;
  inline void set_preserve_free_disk_percentage(::google::protobuf::uint32 value);
  
  // optional uint64 preserve_free_disk_size_bytes = 10 [default = 0];
  inline bool has_preserve_free_disk_size_bytes() const;
  inline void clear_preserve_free_disk_size_bytes();
  static const int kPreserveFreeDiskSizeBytesFieldNumber = 10;
  inline ::google::protobuf::uint64 preserve_free_disk_size_bytes() const;
  inline void set_preserve_free_disk_size_bytes(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:ccd.CameraRollDownloadDirSpecInternal)
 private:
  inline void set_has_dir();
  inline void clear_has_dir();
  inline void set_has_max_size();
  inline void clear_has_max_size();
  inline void set_has_max_files();
  inline void clear_has_max_files();
  inline void set_has_preserve_free_disk_percentage();
  inline void clear_has_preserve_free_disk_percentage();
  inline void set_has_preserve_free_disk_size_bytes();
  inline void clear_has_preserve_free_disk_size_bytes();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* dir_;
  ::google::protobuf::uint32 max_size_;
  ::google::protobuf::uint32 max_files_;
  ::google::protobuf::uint64 preserve_free_disk_size_bytes_;
  ::google::protobuf::uint32 preserve_free_disk_percentage_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_ccd_5ftypes_2eproto();
  friend void protobuf_AssignDesc_ccd_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_ccd_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static CameraRollDownloadDirSpecInternal* default_instance_;
};
// -------------------------------------------------------------------

class CachedUserSummary : public ::google::protobuf::Message {
 public:
  CachedUserSummary();
  virtual ~CachedUserSummary();
  
  CachedUserSummary(const CachedUserSummary& from);
  
  inline CachedUserSummary& operator=(const CachedUserSummary& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CachedUserSummary& default_instance();
  
  void Swap(CachedUserSummary* other);
  
  // implements Message ----------------------------------------------
  
  CachedUserSummary* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CachedUserSummary& from);
  void MergeFrom(const CachedUserSummary& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed64 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint64 user_id() const;
  inline void set_user_id(::google::protobuf::uint64 value);
  
  // required string username = 2;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 2;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // optional string account_id = 5;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 5;
  inline const ::std::string& account_id() const;
  inline void set_account_id(const ::std::string& value);
  inline void set_account_id(const char* value);
  inline void set_account_id(const char* value, size_t size);
  inline ::std::string* mutable_account_id();
  inline ::std::string* release_account_id();
  
  // optional int64 cluster_id = 7;
  inline bool has_cluster_id() const;
  inline void clear_cluster_id();
  static const int kClusterIdFieldNumber = 7;
  inline ::google::protobuf::int64 cluster_id() const;
  inline void set_cluster_id(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:ccd.CachedUserSummary)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_account_id();
  inline void clear_has_account_id();
  inline void set_has_cluster_id();
  inline void clear_has_cluster_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 user_id_;
  ::std::string* username_;
  ::std::string* account_id_;
  ::google::protobuf::int64 cluster_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_ccd_5ftypes_2eproto();
  friend void protobuf_AssignDesc_ccd_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_ccd_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static CachedUserSummary* default_instance_;
};
// -------------------------------------------------------------------

class CachedUserSummaryList : public ::google::protobuf::Message {
 public:
  CachedUserSummaryList();
  virtual ~CachedUserSummaryList();
  
  CachedUserSummaryList(const CachedUserSummaryList& from);
  
  inline CachedUserSummaryList& operator=(const CachedUserSummaryList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CachedUserSummaryList& default_instance();
  
  void Swap(CachedUserSummaryList* other);
  
  // implements Message ----------------------------------------------
  
  CachedUserSummaryList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CachedUserSummaryList& from);
  void MergeFrom(const CachedUserSummaryList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .ccd.CachedUserSummary users = 1;
  inline int users_size() const;
  inline void clear_users();
  static const int kUsersFieldNumber = 1;
  inline const ::ccd::CachedUserSummary& users(int index) const;
  inline ::ccd::CachedUserSummary* mutable_users(int index);
  inline ::ccd::CachedUserSummary* add_users();
  inline const ::google::protobuf::RepeatedPtrField< ::ccd::CachedUserSummary >&
      users() const;
  inline ::google::protobuf::RepeatedPtrField< ::ccd::CachedUserSummary >*
      mutable_users();
  
  // @@protoc_insertion_point(class_scope:ccd.CachedUserSummaryList)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::ccd::CachedUserSummary > users_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ccd_5ftypes_2eproto();
  friend void protobuf_AssignDesc_ccd_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_ccd_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static CachedUserSummaryList* default_instance_;
};
// -------------------------------------------------------------------

class UserSession : public ::google::protobuf::Message {
 public:
  UserSession();
  virtual ~UserSession();
  
  UserSession(const UserSession& from);
  
  inline UserSession& operator=(const UserSession& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserSession& default_instance();
  
  void Swap(UserSession* other);
  
  // implements Message ----------------------------------------------
  
  UserSession* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserSession& from);
  void MergeFrom(const UserSession& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional fixed64 session_handle = 1;
  inline bool has_session_handle() const;
  inline void clear_session_handle();
  static const int kSessionHandleFieldNumber = 1;
  inline ::google::protobuf::uint64 session_handle() const;
  inline void set_session_handle(::google::protobuf::uint64 value);
  
  // optional bytes session_secret = 2;
  inline bool has_session_secret() const;
  inline void clear_session_secret();
  static const int kSessionSecretFieldNumber = 2;
  inline const ::std::string& session_secret() const;
  inline void set_session_secret(const ::std::string& value);
  inline void set_session_secret(const char* value);
  inline void set_session_secret(const void* value, size_t size);
  inline ::std::string* mutable_session_secret();
  inline ::std::string* release_session_secret();
  
  // optional bytes ias_ticket = 4;
  inline bool has_ias_ticket() const;
  inline void clear_ias_ticket();
  static const int kIasTicketFieldNumber = 4;
  inline const ::std::string& ias_ticket() const;
  inline void set_ias_ticket(const ::std::string& value);
  inline void set_ias_ticket(const char* value);
  inline void set_ias_ticket(const void* value, size_t size);
  inline ::std::string* mutable_ias_ticket();
  inline ::std::string* release_ias_ticket();
  
  // optional bytes ops_ticket = 5;
  inline bool has_ops_ticket() const;
  inline void clear_ops_ticket();
  static const int kOpsTicketFieldNumber = 5;
  inline const ::std::string& ops_ticket() const;
  inline void set_ops_ticket(const ::std::string& value);
  inline void set_ops_ticket(const char* value);
  inline void set_ops_ticket(const void* value, size_t size);
  inline ::std::string* mutable_ops_ticket();
  inline ::std::string* release_ops_ticket();
  
  // optional bytes cs_ticket = 6;
  inline bool has_cs_ticket() const;
  inline void clear_cs_ticket();
  static const int kCsTicketFieldNumber = 6;
  inline const ::std::string& cs_ticket() const;
  inline void set_cs_ticket(const ::std::string& value);
  inline void set_cs_ticket(const char* value);
  inline void set_cs_ticket(const void* value, size_t size);
  inline ::std::string* mutable_cs_ticket();
  inline ::std::string* release_cs_ticket();
  
  // optional bytes vs_ticket = 7;
  inline bool has_vs_ticket() const;
  inline void clear_vs_ticket();
  static const int kVsTicketFieldNumber = 7;
  inline const ::std::string& vs_ticket() const;
  inline void set_vs_ticket(const ::std::string& value);
  inline void set_vs_ticket(const char* value);
  inline void set_vs_ticket(const void* value, size_t size);
  inline ::std::string* mutable_vs_ticket();
  inline ::std::string* release_vs_ticket();
  
  // optional bytes ec_ticket = 8;
  inline bool has_ec_ticket() const;
  inline void clear_ec_ticket();
  static const int kEcTicketFieldNumber = 8;
  inline const ::std::string& ec_ticket() const;
  inline void set_ec_ticket(const ::std::string& value);
  inline void set_ec_ticket(const char* value);
  inline void set_ec_ticket(const void* value, size_t size);
  inline ::std::string* mutable_ec_ticket();
  inline ::std::string* release_ec_ticket();
  
  // optional bytes ans_session_key = 9;
  inline bool has_ans_session_key() const;
  inline void clear_ans_session_key();
  static const int kAnsSessionKeyFieldNumber = 9;
  inline const ::std::string& ans_session_key() const;
  inline void set_ans_session_key(const ::std::string& value);
  inline void set_ans_session_key(const char* value);
  inline void set_ans_session_key(const void* value, size_t size);
  inline ::std::string* mutable_ans_session_key();
  inline ::std::string* release_ans_session_key();
  
  // optional bytes ans_login_blob = 10;
  inline bool has_ans_login_blob() const;
  inline void clear_ans_login_blob();
  static const int kAnsLoginBlobFieldNumber = 10;
  inline const ::std::string& ans_login_blob() const;
  inline void set_ans_login_blob(const ::std::string& value);
  inline void set_ans_login_blob(const char* value);
  inline void set_ans_login_blob(const void* value, size_t size);
  inline ::std::string* mutable_ans_login_blob();
  inline ::std::string* release_ans_login_blob();
  
  // optional bytes rf_ticket = 11;
  inline bool has_rf_ticket() const;
  inline void clear_rf_ticket();
  static const int kRfTicketFieldNumber = 11;
  inline const ::std::string& rf_ticket() const;
  inline void set_rf_ticket(const ::std::string& value);
  inline void set_rf_ticket(const char* value);
  inline void set_rf_ticket(const void* value, size_t size);
  inline ::std::string* mutable_rf_ticket();
  inline ::std::string* release_rf_ticket();
  
  // optional bytes pxd_session_key = 12;
  inline bool has_pxd_session_key() const;
  inline void clear_pxd_session_key();
  static const int kPxdSessionKeyFieldNumber = 12;
  inline const ::std::string& pxd_session_key() const;
  inline void set_pxd_session_key(const ::std::string& value);
  inline void set_pxd_session_key(const char* value);
  inline void set_pxd_session_key(const void* value, size_t size);
  inline ::std::string* mutable_pxd_session_key();
  inline ::std::string* release_pxd_session_key();
  
  // optional bytes pxd_login_blob = 13;
  inline bool has_pxd_login_blob() const;
  inline void clear_pxd_login_blob();
  static const int kPxdLoginBlobFieldNumber = 13;
  inline const ::std::string& pxd_login_blob() const;
  inline void set_pxd_login_blob(const ::std::string& value);
  inline void set_pxd_login_blob(const char* value);
  inline void set_pxd_login_blob(const void* value, size_t size);
  inline ::std::string* mutable_pxd_login_blob();
  inline ::std::string* release_pxd_login_blob();
  
  // optional bytes ccd_server_key = 14;
  inline bool has_ccd_server_key() const;
  inline void clear_ccd_server_key();
  static const int kCcdServerKeyFieldNumber = 14;
  inline const ::std::string& ccd_server_key() const;
  inline void set_ccd_server_key(const ::std::string& value);
  inline void set_ccd_server_key(const char* value);
  inline void set_ccd_server_key(const void* value, size_t size);
  inline ::std::string* mutable_ccd_server_key();
  inline ::std::string* release_ccd_server_key();
  
  // repeated .ccd.CCDToCCDCredential ccd_creds = 15;
  inline int ccd_creds_size() const;
  inline void clear_ccd_creds();
  static const int kCcdCredsFieldNumber = 15;
  inline const ::ccd::CCDToCCDCredential& ccd_creds(int index) const;
  inline ::ccd::CCDToCCDCredential* mutable_ccd_creds(int index);
  inline ::ccd::CCDToCCDCredential* add_ccd_creds();
  inline const ::google::protobuf::RepeatedPtrField< ::ccd::CCDToCCDCredential >&
      ccd_creds() const;
  inline ::google::protobuf::RepeatedPtrField< ::ccd::CCDToCCDCredential >*
      mutable_ccd_creds();
  
  // optional uint32 instance_id = 16;
  inline bool has_instance_id() const;
  inline void clear_instance_id();
  static const int kInstanceIdFieldNumber = 16;
  inline ::google::protobuf::uint32 instance_id() const;
  inline void set_instance_id(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:ccd.UserSession)
 private:
  inline void set_has_session_handle();
  inline void clear_has_session_handle();
  inline void set_has_session_secret();
  inline void clear_has_session_secret();
  inline void set_has_ias_ticket();
  inline void clear_has_ias_ticket();
  inline void set_has_ops_ticket();
  inline void clear_has_ops_ticket();
  inline void set_has_cs_ticket();
  inline void clear_has_cs_ticket();
  inline void set_has_vs_ticket();
  inline void clear_has_vs_ticket();
  inline void set_has_ec_ticket();
  inline void clear_has_ec_ticket();
  inline void set_has_ans_session_key();
  inline void clear_has_ans_session_key();
  inline void set_has_ans_login_blob();
  inline void clear_has_ans_login_blob();
  inline void set_has_rf_ticket();
  inline void clear_has_rf_ticket();
  inline void set_has_pxd_session_key();
  inline void clear_has_pxd_session_key();
  inline void set_has_pxd_login_blob();
  inline void clear_has_pxd_login_blob();
  inline void set_has_ccd_server_key();
  inline void clear_has_ccd_server_key();
  inline void set_has_instance_id();
  inline void clear_has_instance_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 session_handle_;
  ::std::string* session_secret_;
  ::std::string* ias_ticket_;
  ::std::string* ops_ticket_;
  ::std::string* cs_ticket_;
  ::std::string* vs_ticket_;
  ::std::string* ec_ticket_;
  ::std::string* ans_session_key_;
  ::std::string* ans_login_blob_;
  ::std::string* rf_ticket_;
  ::std::string* pxd_session_key_;
  ::std::string* pxd_login_blob_;
  ::std::string* ccd_server_key_;
  ::google::protobuf::RepeatedPtrField< ::ccd::CCDToCCDCredential > ccd_creds_;
  ::google::protobuf::uint32 instance_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];
  
  friend void  protobuf_AddDesc_ccd_5ftypes_2eproto();
  friend void protobuf_AssignDesc_ccd_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_ccd_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static UserSession* default_instance_;
};
// -------------------------------------------------------------------

class CCDToCCDCredential : public ::google::protobuf::Message {
 public:
  CCDToCCDCredential();
  virtual ~CCDToCCDCredential();
  
  CCDToCCDCredential(const CCDToCCDCredential& from);
  
  inline CCDToCCDCredential& operator=(const CCDToCCDCredential& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CCDToCCDCredential& default_instance();
  
  void Swap(CCDToCCDCredential* other);
  
  // implements Message ----------------------------------------------
  
  CCDToCCDCredential* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CCDToCCDCredential& from);
  void MergeFrom(const CCDToCCDCredential& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed64 ccd_svr_user_id = 1;
  inline bool has_ccd_svr_user_id() const;
  inline void clear_ccd_svr_user_id();
  static const int kCcdSvrUserIdFieldNumber = 1;
  inline ::google::protobuf::uint64 ccd_svr_user_id() const;
  inline void set_ccd_svr_user_id(::google::protobuf::uint64 value);
  
  // required fixed64 ccd_svr_device_id = 2;
  inline bool has_ccd_svr_device_id() const;
  inline void clear_ccd_svr_device_id();
  static const int kCcdSvrDeviceIdFieldNumber = 2;
  inline ::google::protobuf::uint64 ccd_svr_device_id() const;
  inline void set_ccd_svr_device_id(::google::protobuf::uint64 value);
  
  // required uint32 ccd_svr_inst_id = 3;
  inline bool has_ccd_svr_inst_id() const;
  inline void clear_ccd_svr_inst_id();
  static const int kCcdSvrInstIdFieldNumber = 3;
  inline ::google::protobuf::uint32 ccd_svr_inst_id() const;
  inline void set_ccd_svr_inst_id(::google::protobuf::uint32 value);
  
  // required bytes ccd_session_key = 4;
  inline bool has_ccd_session_key() const;
  inline void clear_ccd_session_key();
  static const int kCcdSessionKeyFieldNumber = 4;
  inline const ::std::string& ccd_session_key() const;
  inline void set_ccd_session_key(const ::std::string& value);
  inline void set_ccd_session_key(const char* value);
  inline void set_ccd_session_key(const void* value, size_t size);
  inline ::std::string* mutable_ccd_session_key();
  inline ::std::string* release_ccd_session_key();
  
  // required bytes ccd_login_blob = 5;
  inline bool has_ccd_login_blob() const;
  inline void clear_ccd_login_blob();
  static const int kCcdLoginBlobFieldNumber = 5;
  inline const ::std::string& ccd_login_blob() const;
  inline void set_ccd_login_blob(const ::std::string& value);
  inline void set_ccd_login_blob(const char* value);
  inline void set_ccd_login_blob(const void* value, size_t size);
  inline ::std::string* mutable_ccd_login_blob();
  inline ::std::string* release_ccd_login_blob();
  
  // @@protoc_insertion_point(class_scope:ccd.CCDToCCDCredential)
 private:
  inline void set_has_ccd_svr_user_id();
  inline void clear_has_ccd_svr_user_id();
  inline void set_has_ccd_svr_device_id();
  inline void clear_has_ccd_svr_device_id();
  inline void set_has_ccd_svr_inst_id();
  inline void clear_has_ccd_svr_inst_id();
  inline void set_has_ccd_session_key();
  inline void clear_has_ccd_session_key();
  inline void set_has_ccd_login_blob();
  inline void clear_has_ccd_login_blob();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 ccd_svr_user_id_;
  ::google::protobuf::uint64 ccd_svr_device_id_;
  ::std::string* ccd_session_key_;
  ::std::string* ccd_login_blob_;
  ::google::protobuf::uint32 ccd_svr_inst_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_ccd_5ftypes_2eproto();
  friend void protobuf_AssignDesc_ccd_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_ccd_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static CCDToCCDCredential* default_instance_;
};
// -------------------------------------------------------------------

class CachedDataset : public ::google::protobuf::Message {
 public:
  CachedDataset();
  virtual ~CachedDataset();
  
  CachedDataset(const CachedDataset& from);
  
  inline CachedDataset& operator=(const CachedDataset& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CachedDataset& default_instance();
  
  void Swap(CachedDataset* other);
  
  // implements Message ----------------------------------------------
  
  CachedDataset* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CachedDataset& from);
  void MergeFrom(const CachedDataset& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.DatasetDetail details = 1;
  inline bool has_details() const;
  inline void clear_details();
  static const int kDetailsFieldNumber = 1;
  inline const ::vplex::vsDirectory::DatasetDetail& details() const;
  inline ::vplex::vsDirectory::DatasetDetail* mutable_details();
  inline ::vplex::vsDirectory::DatasetDetail* release_details();
  
  // optional string details_hash = 2;
  inline bool has_details_hash() const;
  inline void clear_details_hash();
  static const int kDetailsHashFieldNumber = 2;
  inline const ::std::string& details_hash() const;
  inline void set_details_hash(const ::std::string& value);
  inline void set_details_hash(const char* value);
  inline void set_details_hash(const char* value, size_t size);
  inline ::std::string* mutable_details_hash();
  inline ::std::string* release_details_hash();
  
  // @@protoc_insertion_point(class_scope:ccd.CachedDataset)
 private:
  inline void set_has_details();
  inline void clear_has_details();
  inline void set_has_details_hash();
  inline void clear_has_details_hash();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::DatasetDetail* details_;
  ::std::string* details_hash_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ccd_5ftypes_2eproto();
  friend void protobuf_AssignDesc_ccd_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_ccd_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static CachedDataset* default_instance_;
};
// -------------------------------------------------------------------

class CachedSubscription : public ::google::protobuf::Message {
 public:
  CachedSubscription();
  virtual ~CachedSubscription();
  
  CachedSubscription(const CachedSubscription& from);
  
  inline CachedSubscription& operator=(const CachedSubscription& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CachedSubscription& default_instance();
  
  void Swap(CachedSubscription* other);
  
  // implements Message ----------------------------------------------
  
  CachedSubscription* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CachedSubscription& from);
  void MergeFrom(const CachedSubscription& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .vplex.vsDirectory.Subscription details = 1;
  inline bool has_details() const;
  inline void clear_details();
  static const int kDetailsFieldNumber = 1;
  inline const ::vplex::vsDirectory::Subscription& details() const;
  inline ::vplex::vsDirectory::Subscription* mutable_details();
  inline ::vplex::vsDirectory::Subscription* release_details();
  
  // optional string details_hash = 2;
  inline bool has_details_hash() const;
  inline void clear_details_hash();
  static const int kDetailsHashFieldNumber = 2;
  inline const ::std::string& details_hash() const;
  inline void set_details_hash(const ::std::string& value);
  inline void set_details_hash(const char* value);
  inline void set_details_hash(const char* value, size_t size);
  inline ::std::string* mutable_details_hash();
  inline ::std::string* release_details_hash();
  
  // required string abs_device_root = 3;
  inline bool has_abs_device_root() const;
  inline void clear_abs_device_root();
  static const int kAbsDeviceRootFieldNumber = 3;
  inline const ::std::string& abs_device_root() const;
  inline void set_abs_device_root(const ::std::string& value);
  inline void set_abs_device_root(const char* value);
  inline void set_abs_device_root(const char* value, size_t size);
  inline ::std::string* mutable_abs_device_root();
  inline ::std::string* release_abs_device_root();
  
  // @@protoc_insertion_point(class_scope:ccd.CachedSubscription)
 private:
  inline void set_has_details();
  inline void clear_has_details();
  inline void set_has_details_hash();
  inline void clear_has_details_hash();
  inline void set_has_abs_device_root();
  inline void clear_has_abs_device_root();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::vplex::vsDirectory::Subscription* details_;
  ::std::string* details_hash_;
  ::std::string* abs_device_root_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_ccd_5ftypes_2eproto();
  friend void protobuf_AssignDesc_ccd_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_ccd_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static CachedSubscription* default_instance_;
};
// -------------------------------------------------------------------

class PicstreamDir : public ::google::protobuf::Message {
 public:
  PicstreamDir();
  virtual ~PicstreamDir();
  
  PicstreamDir(const PicstreamDir& from);
  
  inline PicstreamDir& operator=(const PicstreamDir& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PicstreamDir& default_instance();
  
  void Swap(PicstreamDir* other);
  
  // implements Message ----------------------------------------------
  
  PicstreamDir* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PicstreamDir& from);
  void MergeFrom(const PicstreamDir& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string directory = 1;
  inline bool has_directory() const;
  inline void clear_directory();
  static const int kDirectoryFieldNumber = 1;
  inline const ::std::string& directory() const;
  inline void set_directory(const ::std::string& value);
  inline void set_directory(const char* value);
  inline void set_directory(const char* value, size_t size);
  inline ::std::string* mutable_directory();
  inline ::std::string* release_directory();
  
  // required fixed64 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::uint64 index() const;
  inline void set_index(::google::protobuf::uint64 value);
  
  // optional bool never_init = 3;
  inline bool has_never_init() const;
  inline void clear_never_init();
  static const int kNeverInitFieldNumber = 3;
  inline bool never_init() const;
  inline void set_never_init(bool value);
  
  // @@protoc_insertion_point(class_scope:ccd.PicstreamDir)
 private:
  inline void set_has_directory();
  inline void clear_has_directory();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_never_init();
  inline void clear_has_never_init();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* directory_;
  ::google::protobuf::uint64 index_;
  bool never_init_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_ccd_5ftypes_2eproto();
  friend void protobuf_AssignDesc_ccd_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_ccd_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static PicstreamDir* default_instance_;
};
// -------------------------------------------------------------------

class CachedStatEvent : public ::google::protobuf::Message {
 public:
  CachedStatEvent();
  virtual ~CachedStatEvent();
  
  CachedStatEvent(const CachedStatEvent& from);
  
  inline CachedStatEvent& operator=(const CachedStatEvent& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CachedStatEvent& default_instance();
  
  void Swap(CachedStatEvent* other);
  
  // implements Message ----------------------------------------------
  
  CachedStatEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CachedStatEvent& from);
  void MergeFrom(const CachedStatEvent& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline const ::std::string& app_id() const;
  inline void set_app_id(const ::std::string& value);
  inline void set_app_id(const char* value);
  inline void set_app_id(const char* value, size_t size);
  inline ::std::string* mutable_app_id();
  inline ::std::string* release_app_id();
  
  // required string event_id = 2;
  inline bool has_event_id() const;
  inline void clear_event_id();
  static const int kEventIdFieldNumber = 2;
  inline const ::std::string& event_id() const;
  inline void set_event_id(const ::std::string& value);
  inline void set_event_id(const char* value);
  inline void set_event_id(const char* value, size_t size);
  inline ::std::string* mutable_event_id();
  inline ::std::string* release_event_id();
  
  // required uint64 start_time_ms = 3;
  inline bool has_start_time_ms() const;
  inline void clear_start_time_ms();
  static const int kStartTimeMsFieldNumber = 3;
  inline ::google::protobuf::uint64 start_time_ms() const;
  inline void set_start_time_ms(::google::protobuf::uint64 value);
  
  // optional uint64 end_time_ms = 4;
  inline bool has_end_time_ms() const;
  inline void clear_end_time_ms();
  static const int kEndTimeMsFieldNumber = 4;
  inline ::google::protobuf::uint64 end_time_ms() const;
  inline void set_end_time_ms(::google::protobuf::uint64 value);
  
  // required uint32 event_count = 5 [default = 1];
  inline bool has_event_count() const;
  inline void clear_event_count();
  static const int kEventCountFieldNumber = 5;
  inline ::google::protobuf::uint32 event_count() const;
  inline void set_event_count(::google::protobuf::uint32 value);
  
  // optional string event_info = 6;
  inline bool has_event_info() const;
  inline void clear_event_info();
  static const int kEventInfoFieldNumber = 6;
  inline const ::std::string& event_info() const;
  inline void set_event_info(const ::std::string& value);
  inline void set_event_info(const char* value);
  inline void set_event_info(const char* value, size_t size);
  inline ::std::string* mutable_event_info();
  inline ::std::string* release_event_info();
  
  // optional bool limit_reached = 7;
  inline bool has_limit_reached() const;
  inline void clear_limit_reached();
  static const int kLimitReachedFieldNumber = 7;
  inline bool limit_reached() const;
  inline void set_limit_reached(bool value);
  
  // @@protoc_insertion_point(class_scope:ccd.CachedStatEvent)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_event_id();
  inline void clear_has_event_id();
  inline void set_has_start_time_ms();
  inline void clear_has_start_time_ms();
  inline void set_has_end_time_ms();
  inline void clear_has_end_time_ms();
  inline void set_has_event_count();
  inline void clear_has_event_count();
  inline void set_has_event_info();
  inline void clear_has_event_info();
  inline void set_has_limit_reached();
  inline void clear_has_limit_reached();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* app_id_;
  ::std::string* event_id_;
  ::google::protobuf::uint64 start_time_ms_;
  ::google::protobuf::uint64 end_time_ms_;
  ::std::string* event_info_;
  ::google::protobuf::uint32 event_count_;
  bool limit_reached_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_ccd_5ftypes_2eproto();
  friend void protobuf_AssignDesc_ccd_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_ccd_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static CachedStatEvent* default_instance_;
};
// -------------------------------------------------------------------

class MediaMetadataThumbMigrateInternal : public ::google::protobuf::Message {
 public:
  MediaMetadataThumbMigrateInternal();
  virtual ~MediaMetadataThumbMigrateInternal();
  
  MediaMetadataThumbMigrateInternal(const MediaMetadataThumbMigrateInternal& from);
  
  inline MediaMetadataThumbMigrateInternal& operator=(const MediaMetadataThumbMigrateInternal& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MediaMetadataThumbMigrateInternal& default_instance();
  
  void Swap(MediaMetadataThumbMigrateInternal* other);
  
  // implements Message ----------------------------------------------
  
  MediaMetadataThumbMigrateInternal* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MediaMetadataThumbMigrateInternal& from);
  void MergeFrom(const MediaMetadataThumbMigrateInternal& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string mm_thumb_src_dir = 1;
  inline bool has_mm_thumb_src_dir() const;
  inline void clear_mm_thumb_src_dir();
  static const int kMmThumbSrcDirFieldNumber = 1;
  inline const ::std::string& mm_thumb_src_dir() const;
  inline void set_mm_thumb_src_dir(const ::std::string& value);
  inline void set_mm_thumb_src_dir(const char* value);
  inline void set_mm_thumb_src_dir(const char* value, size_t size);
  inline ::std::string* mutable_mm_thumb_src_dir();
  inline ::std::string* release_mm_thumb_src_dir();
  
  // optional string mm_thumb_dest_dir = 2;
  inline bool has_mm_thumb_dest_dir() const;
  inline void clear_mm_thumb_dest_dir();
  static const int kMmThumbDestDirFieldNumber = 2;
  inline const ::std::string& mm_thumb_dest_dir() const;
  inline void set_mm_thumb_dest_dir(const ::std::string& value);
  inline void set_mm_thumb_dest_dir(const char* value);
  inline void set_mm_thumb_dest_dir(const char* value, size_t size);
  inline ::std::string* mutable_mm_thumb_dest_dir();
  inline ::std::string* release_mm_thumb_dest_dir();
  
  // optional bool mm_delete_phase = 3;
  inline bool has_mm_delete_phase() const;
  inline void clear_mm_delete_phase();
  static const int kMmDeletePhaseFieldNumber = 3;
  inline bool mm_delete_phase() const;
  inline void set_mm_delete_phase(bool value);
  
  // @@protoc_insertion_point(class_scope:ccd.MediaMetadataThumbMigrateInternal)
 private:
  inline void set_has_mm_thumb_src_dir();
  inline void clear_has_mm_thumb_src_dir();
  inline void set_has_mm_thumb_dest_dir();
  inline void clear_has_mm_thumb_dest_dir();
  inline void set_has_mm_delete_phase();
  inline void clear_has_mm_delete_phase();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* mm_thumb_src_dir_;
  ::std::string* mm_thumb_dest_dir_;
  bool mm_delete_phase_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_ccd_5ftypes_2eproto();
  friend void protobuf_AssignDesc_ccd_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_ccd_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static MediaMetadataThumbMigrateInternal* default_instance_;
};
// -------------------------------------------------------------------

class SyncBoxSettings : public ::google::protobuf::Message {
 public:
  SyncBoxSettings();
  virtual ~SyncBoxSettings();
  
  SyncBoxSettings(const SyncBoxSettings& from);
  
  inline SyncBoxSettings& operator=(const SyncBoxSettings& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SyncBoxSettings& default_instance();
  
  void Swap(SyncBoxSettings* other);
  
  // implements Message ----------------------------------------------
  
  SyncBoxSettings* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SyncBoxSettings& from);
  void MergeFrom(const SyncBoxSettings& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool enable_sync = 1 [default = false];
  inline bool has_enable_sync() const;
  inline void clear_enable_sync();
  static const int kEnableSyncFieldNumber = 1;
  inline bool enable_sync() const;
  inline void set_enable_sync(bool value);
  
  // optional string sync_feature_path = 2;
  inline bool has_sync_feature_path() const;
  inline void clear_sync_feature_path();
  static const int kSyncFeaturePathFieldNumber = 2;
  inline const ::std::string& sync_feature_path() const;
  inline void set_sync_feature_path(const ::std::string& value);
  inline void set_sync_feature_path(const char* value);
  inline void set_sync_feature_path(const char* value, size_t size);
  inline ::std::string* mutable_sync_feature_path();
  inline ::std::string* release_sync_feature_path();
  
  // optional bool is_archive_storage = 3 [default = false];
  inline bool has_is_archive_storage() const;
  inline void clear_is_archive_storage();
  static const int kIsArchiveStorageFieldNumber = 3;
  inline bool is_archive_storage() const;
  inline void set_is_archive_storage(bool value);
  
  // optional bool coherent = 4 [default = false];
  inline bool has_coherent() const;
  inline void clear_coherent();
  static const int kCoherentFieldNumber = 4;
  inline bool coherent() const;
  inline void set_coherent(bool value);
  
  // optional string syncbox_staging_area_abs_path = 5;
  inline bool has_syncbox_staging_area_abs_path() const;
  inline void clear_syncbox_staging_area_abs_path();
  static const int kSyncboxStagingAreaAbsPathFieldNumber = 5;
  inline const ::std::string& syncbox_staging_area_abs_path() const;
  inline void set_syncbox_staging_area_abs_path(const ::std::string& value);
  inline void set_syncbox_staging_area_abs_path(const char* value);
  inline void set_syncbox_staging_area_abs_path(const char* value, size_t size);
  inline ::std::string* mutable_syncbox_staging_area_abs_path();
  inline ::std::string* release_syncbox_staging_area_abs_path();
  
  // optional fixed64 syncbox_dataset_id = 6;
  inline bool has_syncbox_dataset_id() const;
  inline void clear_syncbox_dataset_id();
  static const int kSyncboxDatasetIdFieldNumber = 6;
  inline ::google::protobuf::uint64 syncbox_dataset_id() const;
  inline void set_syncbox_dataset_id(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:ccd.SyncBoxSettings)
 private:
  inline void set_has_enable_sync();
  inline void clear_has_enable_sync();
  inline void set_has_sync_feature_path();
  inline void clear_has_sync_feature_path();
  inline void set_has_is_archive_storage();
  inline void clear_has_is_archive_storage();
  inline void set_has_coherent();
  inline void clear_has_coherent();
  inline void set_has_syncbox_staging_area_abs_path();
  inline void clear_has_syncbox_staging_area_abs_path();
  inline void set_has_syncbox_dataset_id();
  inline void clear_has_syncbox_dataset_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* sync_feature_path_;
  ::std::string* syncbox_staging_area_abs_path_;
  ::google::protobuf::uint64 syncbox_dataset_id_;
  bool enable_sync_;
  bool is_archive_storage_;
  bool coherent_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_ccd_5ftypes_2eproto();
  friend void protobuf_AssignDesc_ccd_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_ccd_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static SyncBoxSettings* default_instance_;
};
// -------------------------------------------------------------------

class CachedUserDetails : public ::google::protobuf::Message {
 public:
  CachedUserDetails();
  virtual ~CachedUserDetails();
  
  CachedUserDetails(const CachedUserDetails& from);
  
  inline CachedUserDetails& operator=(const CachedUserDetails& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CachedUserDetails& default_instance();
  
  void Swap(CachedUserDetails* other);
  
  // implements Message ----------------------------------------------
  
  CachedUserDetails* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CachedUserDetails& from);
  void MergeFrom(const CachedUserDetails& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .ccd.CachedDataset datasets = 1;
  inline int datasets_size() const;
  inline void clear_datasets();
  static const int kDatasetsFieldNumber = 1;
  inline const ::ccd::CachedDataset& datasets(int index) const;
  inline ::ccd::CachedDataset* mutable_datasets(int index);
  inline ::ccd::CachedDataset* add_datasets();
  inline const ::google::protobuf::RepeatedPtrField< ::ccd::CachedDataset >&
      datasets() const;
  inline ::google::protobuf::RepeatedPtrField< ::ccd::CachedDataset >*
      mutable_datasets();
  
  // repeated .ccd.CachedSubscription subscriptions = 2;
  inline int subscriptions_size() const;
  inline void clear_subscriptions();
  static const int kSubscriptionsFieldNumber = 2;
  inline const ::ccd::CachedSubscription& subscriptions(int index) const;
  inline ::ccd::CachedSubscription* mutable_subscriptions(int index);
  inline ::ccd::CachedSubscription* add_subscriptions();
  inline const ::google::protobuf::RepeatedPtrField< ::ccd::CachedSubscription >&
      subscriptions() const;
  inline ::google::protobuf::RepeatedPtrField< ::ccd::CachedSubscription >*
      mutable_subscriptions();
  
  // repeated .vplex.vsDirectory.DeviceInfo cached_devices = 14;
  inline int cached_devices_size() const;
  inline void clear_cached_devices();
  static const int kCachedDevicesFieldNumber = 14;
  inline const ::vplex::vsDirectory::DeviceInfo& cached_devices(int index) const;
  inline ::vplex::vsDirectory::DeviceInfo* mutable_cached_devices(int index);
  inline ::vplex::vsDirectory::DeviceInfo* add_cached_devices();
  inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::DeviceInfo >&
      cached_devices() const;
  inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::DeviceInfo >*
      mutable_cached_devices();
  
  // required .ccd.UserSession session = 6;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 6;
  inline const ::ccd::UserSession& session() const;
  inline ::ccd::UserSession* mutable_session();
  inline ::ccd::UserSession* release_session();
  
  // repeated .vplex.vsDirectory.UserStorage cached_user_storage = 15;
  inline int cached_user_storage_size() const;
  inline void clear_cached_user_storage();
  static const int kCachedUserStorageFieldNumber = 15;
  inline const ::vplex::vsDirectory::UserStorage& cached_user_storage(int index) const;
  inline ::vplex::vsDirectory::UserStorage* mutable_cached_user_storage(int index);
  inline ::vplex::vsDirectory::UserStorage* add_cached_user_storage();
  inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::UserStorage >&
      cached_user_storage() const;
  inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::UserStorage >*
      mutable_cached_user_storage();
  
  // optional bool disable_background_data = 16;
  inline bool has_disable_background_data() const;
  inline void clear_disable_background_data();
  static const int kDisableBackgroundDataFieldNumber = 16;
  inline bool disable_background_data() const;
  inline void set_disable_background_data(bool value);
  
  // optional bool disable_auto_sync = 17;
  inline bool has_disable_auto_sync() const;
  inline void clear_disable_auto_sync();
  static const int kDisableAutoSyncFieldNumber = 17;
  inline bool disable_auto_sync() const;
  inline void set_disable_auto_sync(bool value);
  
  // optional bool disable_mobile_network_data = 18 [default = true];
  inline bool has_disable_mobile_network_data() const;
  inline void clear_disable_mobile_network_data();
  static const int kDisableMobileNetworkDataFieldNumber = 18;
  inline bool disable_mobile_network_data() const;
  inline void set_disable_mobile_network_data(bool value);
  
  // repeated .ccd.PicstreamDir camera_upload_dirs = 19;
  inline int camera_upload_dirs_size() const;
  inline void clear_camera_upload_dirs();
  static const int kCameraUploadDirsFieldNumber = 19;
  inline const ::ccd::PicstreamDir& camera_upload_dirs(int index) const;
  inline ::ccd::PicstreamDir* mutable_camera_upload_dirs(int index);
  inline ::ccd::PicstreamDir* add_camera_upload_dirs();
  inline const ::google::protobuf::RepeatedPtrField< ::ccd::PicstreamDir >&
      camera_upload_dirs() const;
  inline ::google::protobuf::RepeatedPtrField< ::ccd::PicstreamDir >*
      mutable_camera_upload_dirs();
  
  // optional bool enable_camera_roll_trigger = 20;
  inline bool has_enable_camera_roll_trigger() const;
  inline void clear_enable_camera_roll_trigger();
  static const int kEnableCameraRollTriggerFieldNumber = 20;
  inline bool enable_camera_roll_trigger() const;
  inline void set_enable_camera_roll_trigger(bool value);
  
  // repeated .ccd.CameraRollDownloadDirSpecInternal picstream_download_dirs_full_res = 32;
  inline int picstream_download_dirs_full_res_size() const;
  inline void clear_picstream_download_dirs_full_res();
  static const int kPicstreamDownloadDirsFullResFieldNumber = 32;
  inline const ::ccd::CameraRollDownloadDirSpecInternal& picstream_download_dirs_full_res(int index) const;
  inline ::ccd::CameraRollDownloadDirSpecInternal* mutable_picstream_download_dirs_full_res(int index);
  inline ::ccd::CameraRollDownloadDirSpecInternal* add_picstream_download_dirs_full_res();
  inline const ::google::protobuf::RepeatedPtrField< ::ccd::CameraRollDownloadDirSpecInternal >&
      picstream_download_dirs_full_res() const;
  inline ::google::protobuf::RepeatedPtrField< ::ccd::CameraRollDownloadDirSpecInternal >*
      mutable_picstream_download_dirs_full_res();
  
  // repeated .ccd.CameraRollDownloadDirSpecInternal picstream_download_dirs_low_res = 33;
  inline int picstream_download_dirs_low_res_size() const;
  inline void clear_picstream_download_dirs_low_res();
  static const int kPicstreamDownloadDirsLowResFieldNumber = 33;
  inline const ::ccd::CameraRollDownloadDirSpecInternal& picstream_download_dirs_low_res(int index) const;
  inline ::ccd::CameraRollDownloadDirSpecInternal* mutable_picstream_download_dirs_low_res(int index);
  inline ::ccd::CameraRollDownloadDirSpecInternal* add_picstream_download_dirs_low_res();
  inline const ::google::protobuf::RepeatedPtrField< ::ccd::CameraRollDownloadDirSpecInternal >&
      picstream_download_dirs_low_res() const;
  inline ::google::protobuf::RepeatedPtrField< ::ccd::CameraRollDownloadDirSpecInternal >*
      mutable_picstream_download_dirs_low_res();
  
  // repeated .ccd.CameraRollDownloadDirSpecInternal picstream_download_dirs_thumbnail = 41;
  inline int picstream_download_dirs_thumbnail_size() const;
  inline void clear_picstream_download_dirs_thumbnail();
  static const int kPicstreamDownloadDirsThumbnailFieldNumber = 41;
  inline const ::ccd::CameraRollDownloadDirSpecInternal& picstream_download_dirs_thumbnail(int index) const;
  inline ::ccd::CameraRollDownloadDirSpecInternal* mutable_picstream_download_dirs_thumbnail(int index);
  inline ::ccd::CameraRollDownloadDirSpecInternal* add_picstream_download_dirs_thumbnail();
  inline const ::google::protobuf::RepeatedPtrField< ::ccd::CameraRollDownloadDirSpecInternal >&
      picstream_download_dirs_thumbnail() const;
  inline ::google::protobuf::RepeatedPtrField< ::ccd::CameraRollDownloadDirSpecInternal >*
      mutable_picstream_download_dirs_thumbnail();
  
  // optional bool enable_notes_sync = 23 [default = false];
  inline bool has_enable_notes_sync() const;
  inline void clear_enable_notes_sync();
  static const int kEnableNotesSyncFieldNumber = 23;
  inline bool enable_notes_sync() const;
  inline void set_enable_notes_sync(bool value);
  
  // optional string notes_sync_path = 26;
  inline bool has_notes_sync_path() const;
  inline void clear_notes_sync_path();
  static const int kNotesSyncPathFieldNumber = 26;
  inline const ::std::string& notes_sync_path() const;
  inline void set_notes_sync_path(const ::std::string& value);
  inline void set_notes_sync_path(const char* value);
  inline void set_notes_sync_path(const char* value, size_t size);
  inline ::std::string* mutable_notes_sync_path();
  inline ::std::string* release_notes_sync_path();
  
  // repeated .ccd.CachedStatEvent stat_event_list = 24;
  inline int stat_event_list_size() const;
  inline void clear_stat_event_list();
  static const int kStatEventListFieldNumber = 24;
  inline const ::ccd::CachedStatEvent& stat_event_list(int index) const;
  inline ::ccd::CachedStatEvent* mutable_stat_event_list(int index);
  inline ::ccd::CachedStatEvent* add_stat_event_list();
  inline const ::google::protobuf::RepeatedPtrField< ::ccd::CachedStatEvent >&
      stat_event_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::ccd::CachedStatEvent >*
      mutable_stat_event_list();
  
  // repeated .ccd.CachedStatEvent stat_event_wait_list = 38;
  inline int stat_event_wait_list_size() const;
  inline void clear_stat_event_wait_list();
  static const int kStatEventWaitListFieldNumber = 38;
  inline const ::ccd::CachedStatEvent& stat_event_wait_list(int index) const;
  inline ::ccd::CachedStatEvent* mutable_stat_event_wait_list(int index);
  inline ::ccd::CachedStatEvent* add_stat_event_wait_list();
  inline const ::google::protobuf::RepeatedPtrField< ::ccd::CachedStatEvent >&
      stat_event_wait_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::ccd::CachedStatEvent >*
      mutable_stat_event_wait_list();
  
  // optional bool enable_clouddoc_sync = 25 [default = true];
  inline bool has_enable_clouddoc_sync() const;
  inline void clear_enable_clouddoc_sync();
  static const int kEnableClouddocSyncFieldNumber = 25;
  inline bool enable_clouddoc_sync() const;
  inline void set_enable_clouddoc_sync(bool value);
  
  // optional string mm_thumb_download_path = 34;
  inline bool has_mm_thumb_download_path() const;
  inline void clear_mm_thumb_download_path();
  static const int kMmThumbDownloadPathFieldNumber = 34;
  inline const ::std::string& mm_thumb_download_path() const;
  inline void set_mm_thumb_download_path(const ::std::string& value);
  inline void set_mm_thumb_download_path(const char* value);
  inline void set_mm_thumb_download_path(const char* value, size_t size);
  inline ::std::string* mutable_mm_thumb_download_path();
  inline ::std::string* release_mm_thumb_download_path();
  
  // optional .ccd.MediaMetadataThumbMigrateInternal migrate_mm_thumb_download_path = 35;
  inline bool has_migrate_mm_thumb_download_path() const;
  inline void clear_migrate_mm_thumb_download_path();
  static const int kMigrateMmThumbDownloadPathFieldNumber = 35;
  inline const ::ccd::MediaMetadataThumbMigrateInternal& migrate_mm_thumb_download_path() const;
  inline ::ccd::MediaMetadataThumbMigrateInternal* mutable_migrate_mm_thumb_download_path();
  inline ::ccd::MediaMetadataThumbMigrateInternal* release_migrate_mm_thumb_download_path();
  
  // optional bool mm_thumb_sync_disabled = 36;
  inline bool has_mm_thumb_sync_disabled() const;
  inline void clear_mm_thumb_sync_disabled();
  static const int kMmThumbSyncDisabledFieldNumber = 36;
  inline bool mm_thumb_sync_disabled() const;
  inline void set_mm_thumb_sync_disabled(bool value);
  
  // optional bool picstream_storage_conservation_dropping_mode = 37 [default = false];
  inline bool has_picstream_storage_conservation_dropping_mode() const;
  inline void clear_picstream_storage_conservation_dropping_mode();
  static const int kPicstreamStorageConservationDroppingModeFieldNumber = 37;
  inline bool picstream_storage_conservation_dropping_mode() const;
  inline void set_picstream_storage_conservation_dropping_mode(bool value);
  
  // repeated .ccd.SyncFeature_t mm_thumb_sync_disabled_types = 39;
  inline int mm_thumb_sync_disabled_types_size() const;
  inline void clear_mm_thumb_sync_disabled_types();
  static const int kMmThumbSyncDisabledTypesFieldNumber = 39;
  inline ccd::SyncFeature_t mm_thumb_sync_disabled_types(int index) const;
  inline void set_mm_thumb_sync_disabled_types(int index, ccd::SyncFeature_t value);
  inline void add_mm_thumb_sync_disabled_types(ccd::SyncFeature_t value);
  inline const ::google::protobuf::RepeatedField<int>& mm_thumb_sync_disabled_types() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_mm_thumb_sync_disabled_types();
  
  // optional bool mm_thumb_sync_converted = 40;
  inline bool has_mm_thumb_sync_converted() const;
  inline void clear_mm_thumb_sync_converted();
  static const int kMmThumbSyncConvertedFieldNumber = 40;
  inline bool mm_thumb_sync_converted() const;
  inline void set_mm_thumb_sync_converted(bool value);
  
  // optional .ccd.SyncBoxSettings syncbox_sync_settings = 42;
  inline bool has_syncbox_sync_settings() const;
  inline void clear_syncbox_sync_settings();
  static const int kSyncboxSyncSettingsFieldNumber = 42;
  inline const ::ccd::SyncBoxSettings& syncbox_sync_settings() const;
  inline ::ccd::SyncBoxSettings* mutable_syncbox_sync_settings();
  inline ::ccd::SyncBoxSettings* release_syncbox_sync_settings();
  
  // optional bool allow_syncbox_archive_storage_create_db = 43;
  inline bool has_allow_syncbox_archive_storage_create_db() const;
  inline void clear_allow_syncbox_archive_storage_create_db();
  static const int kAllowSyncboxArchiveStorageCreateDbFieldNumber = 43;
  inline bool allow_syncbox_archive_storage_create_db() const;
  inline void set_allow_syncbox_archive_storage_create_db(bool value);
  
  // optional fixed64 need_to_recreate_syncbox_dataset = 44;
  inline bool has_need_to_recreate_syncbox_dataset() const;
  inline void clear_need_to_recreate_syncbox_dataset();
  static const int kNeedToRecreateSyncboxDatasetFieldNumber = 44;
  inline ::google::protobuf::uint64 need_to_recreate_syncbox_dataset() const;
  inline void set_need_to_recreate_syncbox_dataset(::google::protobuf::uint64 value);
  
  // optional fixed64 local_syncbox_archive_storage_dataset_id = 45;
  inline bool has_local_syncbox_archive_storage_dataset_id() const;
  inline void clear_local_syncbox_archive_storage_dataset_id();
  static const int kLocalSyncboxArchiveStorageDatasetIdFieldNumber = 45;
  inline ::google::protobuf::uint64 local_syncbox_archive_storage_dataset_id() const;
  inline void set_local_syncbox_archive_storage_dataset_id(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:ccd.CachedUserDetails)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_disable_background_data();
  inline void clear_has_disable_background_data();
  inline void set_has_disable_auto_sync();
  inline void clear_has_disable_auto_sync();
  inline void set_has_disable_mobile_network_data();
  inline void clear_has_disable_mobile_network_data();
  inline void set_has_enable_camera_roll_trigger();
  inline void clear_has_enable_camera_roll_trigger();
  inline void set_has_enable_notes_sync();
  inline void clear_has_enable_notes_sync();
  inline void set_has_notes_sync_path();
  inline void clear_has_notes_sync_path();
  inline void set_has_enable_clouddoc_sync();
  inline void clear_has_enable_clouddoc_sync();
  inline void set_has_mm_thumb_download_path();
  inline void clear_has_mm_thumb_download_path();
  inline void set_has_migrate_mm_thumb_download_path();
  inline void clear_has_migrate_mm_thumb_download_path();
  inline void set_has_mm_thumb_sync_disabled();
  inline void clear_has_mm_thumb_sync_disabled();
  inline void set_has_picstream_storage_conservation_dropping_mode();
  inline void clear_has_picstream_storage_conservation_dropping_mode();
  inline void set_has_mm_thumb_sync_converted();
  inline void clear_has_mm_thumb_sync_converted();
  inline void set_has_syncbox_sync_settings();
  inline void clear_has_syncbox_sync_settings();
  inline void set_has_allow_syncbox_archive_storage_create_db();
  inline void clear_has_allow_syncbox_archive_storage_create_db();
  inline void set_has_need_to_recreate_syncbox_dataset();
  inline void clear_has_need_to_recreate_syncbox_dataset();
  inline void set_has_local_syncbox_archive_storage_dataset_id();
  inline void clear_has_local_syncbox_archive_storage_dataset_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::ccd::CachedDataset > datasets_;
  ::google::protobuf::RepeatedPtrField< ::ccd::CachedSubscription > subscriptions_;
  ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::DeviceInfo > cached_devices_;
  ::ccd::UserSession* session_;
  ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::UserStorage > cached_user_storage_;
  ::google::protobuf::RepeatedPtrField< ::ccd::PicstreamDir > camera_upload_dirs_;
  ::google::protobuf::RepeatedPtrField< ::ccd::CameraRollDownloadDirSpecInternal > picstream_download_dirs_full_res_;
  ::google::protobuf::RepeatedPtrField< ::ccd::CameraRollDownloadDirSpecInternal > picstream_download_dirs_low_res_;
  ::google::protobuf::RepeatedPtrField< ::ccd::CameraRollDownloadDirSpecInternal > picstream_download_dirs_thumbnail_;
  bool disable_background_data_;
  bool disable_auto_sync_;
  bool disable_mobile_network_data_;
  bool enable_camera_roll_trigger_;
  bool enable_notes_sync_;
  bool enable_clouddoc_sync_;
  bool mm_thumb_sync_disabled_;
  bool picstream_storage_conservation_dropping_mode_;
  ::std::string* notes_sync_path_;
  ::google::protobuf::RepeatedPtrField< ::ccd::CachedStatEvent > stat_event_list_;
  ::google::protobuf::RepeatedPtrField< ::ccd::CachedStatEvent > stat_event_wait_list_;
  ::std::string* mm_thumb_download_path_;
  ::ccd::MediaMetadataThumbMigrateInternal* migrate_mm_thumb_download_path_;
  ::google::protobuf::RepeatedField<int> mm_thumb_sync_disabled_types_;
  ::ccd::SyncBoxSettings* syncbox_sync_settings_;
  ::google::protobuf::uint64 need_to_recreate_syncbox_dataset_;
  ::google::protobuf::uint64 local_syncbox_archive_storage_dataset_id_;
  bool mm_thumb_sync_converted_;
  bool allow_syncbox_archive_storage_create_db_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(28 + 31) / 32];
  
  friend void  protobuf_AddDesc_ccd_5ftypes_2eproto();
  friend void protobuf_AssignDesc_ccd_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_ccd_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static CachedUserDetails* default_instance_;
};
// -------------------------------------------------------------------

class CachedUserData : public ::google::protobuf::Message {
 public:
  CachedUserData();
  virtual ~CachedUserData();
  
  CachedUserData(const CachedUserData& from);
  
  inline CachedUserData& operator=(const CachedUserData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CachedUserData& default_instance();
  
  void Swap(CachedUserData* other);
  
  // implements Message ----------------------------------------------
  
  CachedUserData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CachedUserData& from);
  void MergeFrom(const CachedUserData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .ccd.CachedUserSummary summary = 1;
  inline bool has_summary() const;
  inline void clear_summary();
  static const int kSummaryFieldNumber = 1;
  inline const ::ccd::CachedUserSummary& summary() const;
  inline ::ccd::CachedUserSummary* mutable_summary();
  inline ::ccd::CachedUserSummary* release_summary();
  
  // required .ccd.CachedUserDetails details = 2;
  inline bool has_details() const;
  inline void clear_details();
  static const int kDetailsFieldNumber = 2;
  inline const ::ccd::CachedUserDetails& details() const;
  inline ::ccd::CachedUserDetails* mutable_details();
  inline ::ccd::CachedUserDetails* release_details();
  
  // @@protoc_insertion_point(class_scope:ccd.CachedUserData)
 private:
  inline void set_has_summary();
  inline void clear_has_summary();
  inline void set_has_details();
  inline void clear_has_details();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::ccd::CachedUserSummary* summary_;
  ::ccd::CachedUserDetails* details_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ccd_5ftypes_2eproto();
  friend void protobuf_AssignDesc_ccd_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_ccd_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static CachedUserData* default_instance_;
};
// -------------------------------------------------------------------

class CCDMainState : public ::google::protobuf::Message {
 public:
  CCDMainState();
  virtual ~CCDMainState();
  
  CCDMainState(const CCDMainState& from);
  
  inline CCDMainState& operator=(const CCDMainState& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CCDMainState& default_instance();
  
  void Swap(CCDMainState* other);
  
  // implements Message ----------------------------------------------
  
  CCDMainState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CCDMainState& from);
  void MergeFrom(const CCDMainState& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional fixed64 logged_in_user = 1 [default = 0];
  inline bool has_logged_in_user() const;
  inline void clear_logged_in_user();
  static const int kLoggedInUserFieldNumber = 1;
  inline ::google::protobuf::uint64 logged_in_user() const;
  inline void set_logged_in_user(::google::protobuf::uint64 value);
  
  // optional int32 background_mode_interval_sec = 4 [default = -1];
  inline bool has_background_mode_interval_sec() const;
  inline void clear_background_mode_interval_sec();
  static const int kBackgroundModeIntervalSecFieldNumber = 4;
  inline ::google::protobuf::int32 background_mode_interval_sec() const;
  inline void set_background_mode_interval_sec(::google::protobuf::int32 value);
  
  // repeated .ccd.LoggedOutUser logged_out_users = 5;
  inline int logged_out_users_size() const;
  inline void clear_logged_out_users();
  static const int kLoggedOutUsersFieldNumber = 5;
  inline const ::ccd::LoggedOutUser& logged_out_users(int index) const;
  inline ::ccd::LoggedOutUser* mutable_logged_out_users(int index);
  inline ::ccd::LoggedOutUser* add_logged_out_users();
  inline const ::google::protobuf::RepeatedPtrField< ::ccd::LoggedOutUser >&
      logged_out_users() const;
  inline ::google::protobuf::RepeatedPtrField< ::ccd::LoggedOutUser >*
      mutable_logged_out_users();
  
  // @@protoc_insertion_point(class_scope:ccd.CCDMainState)
 private:
  inline void set_has_logged_in_user();
  inline void clear_has_logged_in_user();
  inline void set_has_background_mode_interval_sec();
  inline void clear_has_background_mode_interval_sec();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 logged_in_user_;
  ::google::protobuf::RepeatedPtrField< ::ccd::LoggedOutUser > logged_out_users_;
  ::google::protobuf::int32 background_mode_interval_sec_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_ccd_5ftypes_2eproto();
  friend void protobuf_AssignDesc_ccd_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_ccd_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static CCDMainState* default_instance_;
};
// ===================================================================


// ===================================================================

// CameraRollDownloadDirSpecInternal

// required string dir = 1;
inline bool CameraRollDownloadDirSpecInternal::has_dir() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CameraRollDownloadDirSpecInternal::set_has_dir() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CameraRollDownloadDirSpecInternal::clear_has_dir() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CameraRollDownloadDirSpecInternal::clear_dir() {
  if (dir_ != &::google::protobuf::internal::kEmptyString) {
    dir_->clear();
  }
  clear_has_dir();
}
inline const ::std::string& CameraRollDownloadDirSpecInternal::dir() const {
  return *dir_;
}
inline void CameraRollDownloadDirSpecInternal::set_dir(const ::std::string& value) {
  set_has_dir();
  if (dir_ == &::google::protobuf::internal::kEmptyString) {
    dir_ = new ::std::string;
  }
  dir_->assign(value);
}
inline void CameraRollDownloadDirSpecInternal::set_dir(const char* value) {
  set_has_dir();
  if (dir_ == &::google::protobuf::internal::kEmptyString) {
    dir_ = new ::std::string;
  }
  dir_->assign(value);
}
inline void CameraRollDownloadDirSpecInternal::set_dir(const char* value, size_t size) {
  set_has_dir();
  if (dir_ == &::google::protobuf::internal::kEmptyString) {
    dir_ = new ::std::string;
  }
  dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CameraRollDownloadDirSpecInternal::mutable_dir() {
  set_has_dir();
  if (dir_ == &::google::protobuf::internal::kEmptyString) {
    dir_ = new ::std::string;
  }
  return dir_;
}
inline ::std::string* CameraRollDownloadDirSpecInternal::release_dir() {
  clear_has_dir();
  if (dir_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dir_;
    dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 max_size = 7 [default = 0];
inline bool CameraRollDownloadDirSpecInternal::has_max_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CameraRollDownloadDirSpecInternal::set_has_max_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CameraRollDownloadDirSpecInternal::clear_has_max_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CameraRollDownloadDirSpecInternal::clear_max_size() {
  max_size_ = 0u;
  clear_has_max_size();
}
inline ::google::protobuf::uint32 CameraRollDownloadDirSpecInternal::max_size() const {
  return max_size_;
}
inline void CameraRollDownloadDirSpecInternal::set_max_size(::google::protobuf::uint32 value) {
  set_has_max_size();
  max_size_ = value;
}

// optional uint32 max_files = 8 [default = 0];
inline bool CameraRollDownloadDirSpecInternal::has_max_files() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CameraRollDownloadDirSpecInternal::set_has_max_files() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CameraRollDownloadDirSpecInternal::clear_has_max_files() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CameraRollDownloadDirSpecInternal::clear_max_files() {
  max_files_ = 0u;
  clear_has_max_files();
}
inline ::google::protobuf::uint32 CameraRollDownloadDirSpecInternal::max_files() const {
  return max_files_;
}
inline void CameraRollDownloadDirSpecInternal::set_max_files(::google::protobuf::uint32 value) {
  set_has_max_files();
  max_files_ = value;
}

// optional uint32 preserve_free_disk_percentage = 9 [default = 0];
inline bool CameraRollDownloadDirSpecInternal::has_preserve_free_disk_percentage() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CameraRollDownloadDirSpecInternal::set_has_preserve_free_disk_percentage() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CameraRollDownloadDirSpecInternal::clear_has_preserve_free_disk_percentage() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CameraRollDownloadDirSpecInternal::clear_preserve_free_disk_percentage() {
  preserve_free_disk_percentage_ = 0u;
  clear_has_preserve_free_disk_percentage();
}
inline ::google::protobuf::uint32 CameraRollDownloadDirSpecInternal::preserve_free_disk_percentage() const {
  return preserve_free_disk_percentage_;
}
inline void CameraRollDownloadDirSpecInternal::set_preserve_free_disk_percentage(::google::protobuf::uint32 value) {
  set_has_preserve_free_disk_percentage();
  preserve_free_disk_percentage_ = value;
}

// optional uint64 preserve_free_disk_size_bytes = 10 [default = 0];
inline bool CameraRollDownloadDirSpecInternal::has_preserve_free_disk_size_bytes() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CameraRollDownloadDirSpecInternal::set_has_preserve_free_disk_size_bytes() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CameraRollDownloadDirSpecInternal::clear_has_preserve_free_disk_size_bytes() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CameraRollDownloadDirSpecInternal::clear_preserve_free_disk_size_bytes() {
  preserve_free_disk_size_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_preserve_free_disk_size_bytes();
}
inline ::google::protobuf::uint64 CameraRollDownloadDirSpecInternal::preserve_free_disk_size_bytes() const {
  return preserve_free_disk_size_bytes_;
}
inline void CameraRollDownloadDirSpecInternal::set_preserve_free_disk_size_bytes(::google::protobuf::uint64 value) {
  set_has_preserve_free_disk_size_bytes();
  preserve_free_disk_size_bytes_ = value;
}

// -------------------------------------------------------------------

// CachedUserSummary

// required fixed64 user_id = 1;
inline bool CachedUserSummary::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CachedUserSummary::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CachedUserSummary::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CachedUserSummary::clear_user_id() {
  user_id_ = GOOGLE_ULONGLONG(0);
  clear_has_user_id();
}
inline ::google::protobuf::uint64 CachedUserSummary::user_id() const {
  return user_id_;
}
inline void CachedUserSummary::set_user_id(::google::protobuf::uint64 value) {
  set_has_user_id();
  user_id_ = value;
}

// required string username = 2;
inline bool CachedUserSummary::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CachedUserSummary::set_has_username() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CachedUserSummary::clear_has_username() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CachedUserSummary::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& CachedUserSummary::username() const {
  return *username_;
}
inline void CachedUserSummary::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void CachedUserSummary::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void CachedUserSummary::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CachedUserSummary::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* CachedUserSummary::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string account_id = 5;
inline bool CachedUserSummary::has_account_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CachedUserSummary::set_has_account_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CachedUserSummary::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CachedUserSummary::clear_account_id() {
  if (account_id_ != &::google::protobuf::internal::kEmptyString) {
    account_id_->clear();
  }
  clear_has_account_id();
}
inline const ::std::string& CachedUserSummary::account_id() const {
  return *account_id_;
}
inline void CachedUserSummary::set_account_id(const ::std::string& value) {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  account_id_->assign(value);
}
inline void CachedUserSummary::set_account_id(const char* value) {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  account_id_->assign(value);
}
inline void CachedUserSummary::set_account_id(const char* value, size_t size) {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  account_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CachedUserSummary::mutable_account_id() {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  return account_id_;
}
inline ::std::string* CachedUserSummary::release_account_id() {
  clear_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_id_;
    account_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int64 cluster_id = 7;
inline bool CachedUserSummary::has_cluster_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CachedUserSummary::set_has_cluster_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CachedUserSummary::clear_has_cluster_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CachedUserSummary::clear_cluster_id() {
  cluster_id_ = GOOGLE_LONGLONG(0);
  clear_has_cluster_id();
}
inline ::google::protobuf::int64 CachedUserSummary::cluster_id() const {
  return cluster_id_;
}
inline void CachedUserSummary::set_cluster_id(::google::protobuf::int64 value) {
  set_has_cluster_id();
  cluster_id_ = value;
}

// -------------------------------------------------------------------

// CachedUserSummaryList

// repeated .ccd.CachedUserSummary users = 1;
inline int CachedUserSummaryList::users_size() const {
  return users_.size();
}
inline void CachedUserSummaryList::clear_users() {
  users_.Clear();
}
inline const ::ccd::CachedUserSummary& CachedUserSummaryList::users(int index) const {
  return users_.Get(index);
}
inline ::ccd::CachedUserSummary* CachedUserSummaryList::mutable_users(int index) {
  return users_.Mutable(index);
}
inline ::ccd::CachedUserSummary* CachedUserSummaryList::add_users() {
  return users_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ccd::CachedUserSummary >&
CachedUserSummaryList::users() const {
  return users_;
}
inline ::google::protobuf::RepeatedPtrField< ::ccd::CachedUserSummary >*
CachedUserSummaryList::mutable_users() {
  return &users_;
}

// -------------------------------------------------------------------

// UserSession

// optional fixed64 session_handle = 1;
inline bool UserSession::has_session_handle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserSession::set_has_session_handle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserSession::clear_has_session_handle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserSession::clear_session_handle() {
  session_handle_ = GOOGLE_ULONGLONG(0);
  clear_has_session_handle();
}
inline ::google::protobuf::uint64 UserSession::session_handle() const {
  return session_handle_;
}
inline void UserSession::set_session_handle(::google::protobuf::uint64 value) {
  set_has_session_handle();
  session_handle_ = value;
}

// optional bytes session_secret = 2;
inline bool UserSession::has_session_secret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserSession::set_has_session_secret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserSession::clear_has_session_secret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserSession::clear_session_secret() {
  if (session_secret_ != &::google::protobuf::internal::kEmptyString) {
    session_secret_->clear();
  }
  clear_has_session_secret();
}
inline const ::std::string& UserSession::session_secret() const {
  return *session_secret_;
}
inline void UserSession::set_session_secret(const ::std::string& value) {
  set_has_session_secret();
  if (session_secret_ == &::google::protobuf::internal::kEmptyString) {
    session_secret_ = new ::std::string;
  }
  session_secret_->assign(value);
}
inline void UserSession::set_session_secret(const char* value) {
  set_has_session_secret();
  if (session_secret_ == &::google::protobuf::internal::kEmptyString) {
    session_secret_ = new ::std::string;
  }
  session_secret_->assign(value);
}
inline void UserSession::set_session_secret(const void* value, size_t size) {
  set_has_session_secret();
  if (session_secret_ == &::google::protobuf::internal::kEmptyString) {
    session_secret_ = new ::std::string;
  }
  session_secret_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserSession::mutable_session_secret() {
  set_has_session_secret();
  if (session_secret_ == &::google::protobuf::internal::kEmptyString) {
    session_secret_ = new ::std::string;
  }
  return session_secret_;
}
inline ::std::string* UserSession::release_session_secret() {
  clear_has_session_secret();
  if (session_secret_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_secret_;
    session_secret_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes ias_ticket = 4;
inline bool UserSession::has_ias_ticket() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserSession::set_has_ias_ticket() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserSession::clear_has_ias_ticket() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserSession::clear_ias_ticket() {
  if (ias_ticket_ != &::google::protobuf::internal::kEmptyString) {
    ias_ticket_->clear();
  }
  clear_has_ias_ticket();
}
inline const ::std::string& UserSession::ias_ticket() const {
  return *ias_ticket_;
}
inline void UserSession::set_ias_ticket(const ::std::string& value) {
  set_has_ias_ticket();
  if (ias_ticket_ == &::google::protobuf::internal::kEmptyString) {
    ias_ticket_ = new ::std::string;
  }
  ias_ticket_->assign(value);
}
inline void UserSession::set_ias_ticket(const char* value) {
  set_has_ias_ticket();
  if (ias_ticket_ == &::google::protobuf::internal::kEmptyString) {
    ias_ticket_ = new ::std::string;
  }
  ias_ticket_->assign(value);
}
inline void UserSession::set_ias_ticket(const void* value, size_t size) {
  set_has_ias_ticket();
  if (ias_ticket_ == &::google::protobuf::internal::kEmptyString) {
    ias_ticket_ = new ::std::string;
  }
  ias_ticket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserSession::mutable_ias_ticket() {
  set_has_ias_ticket();
  if (ias_ticket_ == &::google::protobuf::internal::kEmptyString) {
    ias_ticket_ = new ::std::string;
  }
  return ias_ticket_;
}
inline ::std::string* UserSession::release_ias_ticket() {
  clear_has_ias_ticket();
  if (ias_ticket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ias_ticket_;
    ias_ticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes ops_ticket = 5;
inline bool UserSession::has_ops_ticket() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserSession::set_has_ops_ticket() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserSession::clear_has_ops_ticket() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserSession::clear_ops_ticket() {
  if (ops_ticket_ != &::google::protobuf::internal::kEmptyString) {
    ops_ticket_->clear();
  }
  clear_has_ops_ticket();
}
inline const ::std::string& UserSession::ops_ticket() const {
  return *ops_ticket_;
}
inline void UserSession::set_ops_ticket(const ::std::string& value) {
  set_has_ops_ticket();
  if (ops_ticket_ == &::google::protobuf::internal::kEmptyString) {
    ops_ticket_ = new ::std::string;
  }
  ops_ticket_->assign(value);
}
inline void UserSession::set_ops_ticket(const char* value) {
  set_has_ops_ticket();
  if (ops_ticket_ == &::google::protobuf::internal::kEmptyString) {
    ops_ticket_ = new ::std::string;
  }
  ops_ticket_->assign(value);
}
inline void UserSession::set_ops_ticket(const void* value, size_t size) {
  set_has_ops_ticket();
  if (ops_ticket_ == &::google::protobuf::internal::kEmptyString) {
    ops_ticket_ = new ::std::string;
  }
  ops_ticket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserSession::mutable_ops_ticket() {
  set_has_ops_ticket();
  if (ops_ticket_ == &::google::protobuf::internal::kEmptyString) {
    ops_ticket_ = new ::std::string;
  }
  return ops_ticket_;
}
inline ::std::string* UserSession::release_ops_ticket() {
  clear_has_ops_ticket();
  if (ops_ticket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ops_ticket_;
    ops_ticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes cs_ticket = 6;
inline bool UserSession::has_cs_ticket() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserSession::set_has_cs_ticket() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserSession::clear_has_cs_ticket() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserSession::clear_cs_ticket() {
  if (cs_ticket_ != &::google::protobuf::internal::kEmptyString) {
    cs_ticket_->clear();
  }
  clear_has_cs_ticket();
}
inline const ::std::string& UserSession::cs_ticket() const {
  return *cs_ticket_;
}
inline void UserSession::set_cs_ticket(const ::std::string& value) {
  set_has_cs_ticket();
  if (cs_ticket_ == &::google::protobuf::internal::kEmptyString) {
    cs_ticket_ = new ::std::string;
  }
  cs_ticket_->assign(value);
}
inline void UserSession::set_cs_ticket(const char* value) {
  set_has_cs_ticket();
  if (cs_ticket_ == &::google::protobuf::internal::kEmptyString) {
    cs_ticket_ = new ::std::string;
  }
  cs_ticket_->assign(value);
}
inline void UserSession::set_cs_ticket(const void* value, size_t size) {
  set_has_cs_ticket();
  if (cs_ticket_ == &::google::protobuf::internal::kEmptyString) {
    cs_ticket_ = new ::std::string;
  }
  cs_ticket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserSession::mutable_cs_ticket() {
  set_has_cs_ticket();
  if (cs_ticket_ == &::google::protobuf::internal::kEmptyString) {
    cs_ticket_ = new ::std::string;
  }
  return cs_ticket_;
}
inline ::std::string* UserSession::release_cs_ticket() {
  clear_has_cs_ticket();
  if (cs_ticket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cs_ticket_;
    cs_ticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes vs_ticket = 7;
inline bool UserSession::has_vs_ticket() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserSession::set_has_vs_ticket() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserSession::clear_has_vs_ticket() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserSession::clear_vs_ticket() {
  if (vs_ticket_ != &::google::protobuf::internal::kEmptyString) {
    vs_ticket_->clear();
  }
  clear_has_vs_ticket();
}
inline const ::std::string& UserSession::vs_ticket() const {
  return *vs_ticket_;
}
inline void UserSession::set_vs_ticket(const ::std::string& value) {
  set_has_vs_ticket();
  if (vs_ticket_ == &::google::protobuf::internal::kEmptyString) {
    vs_ticket_ = new ::std::string;
  }
  vs_ticket_->assign(value);
}
inline void UserSession::set_vs_ticket(const char* value) {
  set_has_vs_ticket();
  if (vs_ticket_ == &::google::protobuf::internal::kEmptyString) {
    vs_ticket_ = new ::std::string;
  }
  vs_ticket_->assign(value);
}
inline void UserSession::set_vs_ticket(const void* value, size_t size) {
  set_has_vs_ticket();
  if (vs_ticket_ == &::google::protobuf::internal::kEmptyString) {
    vs_ticket_ = new ::std::string;
  }
  vs_ticket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserSession::mutable_vs_ticket() {
  set_has_vs_ticket();
  if (vs_ticket_ == &::google::protobuf::internal::kEmptyString) {
    vs_ticket_ = new ::std::string;
  }
  return vs_ticket_;
}
inline ::std::string* UserSession::release_vs_ticket() {
  clear_has_vs_ticket();
  if (vs_ticket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vs_ticket_;
    vs_ticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes ec_ticket = 8;
inline bool UserSession::has_ec_ticket() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserSession::set_has_ec_ticket() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserSession::clear_has_ec_ticket() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserSession::clear_ec_ticket() {
  if (ec_ticket_ != &::google::protobuf::internal::kEmptyString) {
    ec_ticket_->clear();
  }
  clear_has_ec_ticket();
}
inline const ::std::string& UserSession::ec_ticket() const {
  return *ec_ticket_;
}
inline void UserSession::set_ec_ticket(const ::std::string& value) {
  set_has_ec_ticket();
  if (ec_ticket_ == &::google::protobuf::internal::kEmptyString) {
    ec_ticket_ = new ::std::string;
  }
  ec_ticket_->assign(value);
}
inline void UserSession::set_ec_ticket(const char* value) {
  set_has_ec_ticket();
  if (ec_ticket_ == &::google::protobuf::internal::kEmptyString) {
    ec_ticket_ = new ::std::string;
  }
  ec_ticket_->assign(value);
}
inline void UserSession::set_ec_ticket(const void* value, size_t size) {
  set_has_ec_ticket();
  if (ec_ticket_ == &::google::protobuf::internal::kEmptyString) {
    ec_ticket_ = new ::std::string;
  }
  ec_ticket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserSession::mutable_ec_ticket() {
  set_has_ec_ticket();
  if (ec_ticket_ == &::google::protobuf::internal::kEmptyString) {
    ec_ticket_ = new ::std::string;
  }
  return ec_ticket_;
}
inline ::std::string* UserSession::release_ec_ticket() {
  clear_has_ec_ticket();
  if (ec_ticket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ec_ticket_;
    ec_ticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes ans_session_key = 9;
inline bool UserSession::has_ans_session_key() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserSession::set_has_ans_session_key() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserSession::clear_has_ans_session_key() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserSession::clear_ans_session_key() {
  if (ans_session_key_ != &::google::protobuf::internal::kEmptyString) {
    ans_session_key_->clear();
  }
  clear_has_ans_session_key();
}
inline const ::std::string& UserSession::ans_session_key() const {
  return *ans_session_key_;
}
inline void UserSession::set_ans_session_key(const ::std::string& value) {
  set_has_ans_session_key();
  if (ans_session_key_ == &::google::protobuf::internal::kEmptyString) {
    ans_session_key_ = new ::std::string;
  }
  ans_session_key_->assign(value);
}
inline void UserSession::set_ans_session_key(const char* value) {
  set_has_ans_session_key();
  if (ans_session_key_ == &::google::protobuf::internal::kEmptyString) {
    ans_session_key_ = new ::std::string;
  }
  ans_session_key_->assign(value);
}
inline void UserSession::set_ans_session_key(const void* value, size_t size) {
  set_has_ans_session_key();
  if (ans_session_key_ == &::google::protobuf::internal::kEmptyString) {
    ans_session_key_ = new ::std::string;
  }
  ans_session_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserSession::mutable_ans_session_key() {
  set_has_ans_session_key();
  if (ans_session_key_ == &::google::protobuf::internal::kEmptyString) {
    ans_session_key_ = new ::std::string;
  }
  return ans_session_key_;
}
inline ::std::string* UserSession::release_ans_session_key() {
  clear_has_ans_session_key();
  if (ans_session_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ans_session_key_;
    ans_session_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes ans_login_blob = 10;
inline bool UserSession::has_ans_login_blob() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserSession::set_has_ans_login_blob() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserSession::clear_has_ans_login_blob() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserSession::clear_ans_login_blob() {
  if (ans_login_blob_ != &::google::protobuf::internal::kEmptyString) {
    ans_login_blob_->clear();
  }
  clear_has_ans_login_blob();
}
inline const ::std::string& UserSession::ans_login_blob() const {
  return *ans_login_blob_;
}
inline void UserSession::set_ans_login_blob(const ::std::string& value) {
  set_has_ans_login_blob();
  if (ans_login_blob_ == &::google::protobuf::internal::kEmptyString) {
    ans_login_blob_ = new ::std::string;
  }
  ans_login_blob_->assign(value);
}
inline void UserSession::set_ans_login_blob(const char* value) {
  set_has_ans_login_blob();
  if (ans_login_blob_ == &::google::protobuf::internal::kEmptyString) {
    ans_login_blob_ = new ::std::string;
  }
  ans_login_blob_->assign(value);
}
inline void UserSession::set_ans_login_blob(const void* value, size_t size) {
  set_has_ans_login_blob();
  if (ans_login_blob_ == &::google::protobuf::internal::kEmptyString) {
    ans_login_blob_ = new ::std::string;
  }
  ans_login_blob_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserSession::mutable_ans_login_blob() {
  set_has_ans_login_blob();
  if (ans_login_blob_ == &::google::protobuf::internal::kEmptyString) {
    ans_login_blob_ = new ::std::string;
  }
  return ans_login_blob_;
}
inline ::std::string* UserSession::release_ans_login_blob() {
  clear_has_ans_login_blob();
  if (ans_login_blob_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ans_login_blob_;
    ans_login_blob_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes rf_ticket = 11;
inline bool UserSession::has_rf_ticket() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UserSession::set_has_rf_ticket() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UserSession::clear_has_rf_ticket() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UserSession::clear_rf_ticket() {
  if (rf_ticket_ != &::google::protobuf::internal::kEmptyString) {
    rf_ticket_->clear();
  }
  clear_has_rf_ticket();
}
inline const ::std::string& UserSession::rf_ticket() const {
  return *rf_ticket_;
}
inline void UserSession::set_rf_ticket(const ::std::string& value) {
  set_has_rf_ticket();
  if (rf_ticket_ == &::google::protobuf::internal::kEmptyString) {
    rf_ticket_ = new ::std::string;
  }
  rf_ticket_->assign(value);
}
inline void UserSession::set_rf_ticket(const char* value) {
  set_has_rf_ticket();
  if (rf_ticket_ == &::google::protobuf::internal::kEmptyString) {
    rf_ticket_ = new ::std::string;
  }
  rf_ticket_->assign(value);
}
inline void UserSession::set_rf_ticket(const void* value, size_t size) {
  set_has_rf_ticket();
  if (rf_ticket_ == &::google::protobuf::internal::kEmptyString) {
    rf_ticket_ = new ::std::string;
  }
  rf_ticket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserSession::mutable_rf_ticket() {
  set_has_rf_ticket();
  if (rf_ticket_ == &::google::protobuf::internal::kEmptyString) {
    rf_ticket_ = new ::std::string;
  }
  return rf_ticket_;
}
inline ::std::string* UserSession::release_rf_ticket() {
  clear_has_rf_ticket();
  if (rf_ticket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rf_ticket_;
    rf_ticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes pxd_session_key = 12;
inline bool UserSession::has_pxd_session_key() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UserSession::set_has_pxd_session_key() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UserSession::clear_has_pxd_session_key() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UserSession::clear_pxd_session_key() {
  if (pxd_session_key_ != &::google::protobuf::internal::kEmptyString) {
    pxd_session_key_->clear();
  }
  clear_has_pxd_session_key();
}
inline const ::std::string& UserSession::pxd_session_key() const {
  return *pxd_session_key_;
}
inline void UserSession::set_pxd_session_key(const ::std::string& value) {
  set_has_pxd_session_key();
  if (pxd_session_key_ == &::google::protobuf::internal::kEmptyString) {
    pxd_session_key_ = new ::std::string;
  }
  pxd_session_key_->assign(value);
}
inline void UserSession::set_pxd_session_key(const char* value) {
  set_has_pxd_session_key();
  if (pxd_session_key_ == &::google::protobuf::internal::kEmptyString) {
    pxd_session_key_ = new ::std::string;
  }
  pxd_session_key_->assign(value);
}
inline void UserSession::set_pxd_session_key(const void* value, size_t size) {
  set_has_pxd_session_key();
  if (pxd_session_key_ == &::google::protobuf::internal::kEmptyString) {
    pxd_session_key_ = new ::std::string;
  }
  pxd_session_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserSession::mutable_pxd_session_key() {
  set_has_pxd_session_key();
  if (pxd_session_key_ == &::google::protobuf::internal::kEmptyString) {
    pxd_session_key_ = new ::std::string;
  }
  return pxd_session_key_;
}
inline ::std::string* UserSession::release_pxd_session_key() {
  clear_has_pxd_session_key();
  if (pxd_session_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pxd_session_key_;
    pxd_session_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes pxd_login_blob = 13;
inline bool UserSession::has_pxd_login_blob() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UserSession::set_has_pxd_login_blob() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UserSession::clear_has_pxd_login_blob() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UserSession::clear_pxd_login_blob() {
  if (pxd_login_blob_ != &::google::protobuf::internal::kEmptyString) {
    pxd_login_blob_->clear();
  }
  clear_has_pxd_login_blob();
}
inline const ::std::string& UserSession::pxd_login_blob() const {
  return *pxd_login_blob_;
}
inline void UserSession::set_pxd_login_blob(const ::std::string& value) {
  set_has_pxd_login_blob();
  if (pxd_login_blob_ == &::google::protobuf::internal::kEmptyString) {
    pxd_login_blob_ = new ::std::string;
  }
  pxd_login_blob_->assign(value);
}
inline void UserSession::set_pxd_login_blob(const char* value) {
  set_has_pxd_login_blob();
  if (pxd_login_blob_ == &::google::protobuf::internal::kEmptyString) {
    pxd_login_blob_ = new ::std::string;
  }
  pxd_login_blob_->assign(value);
}
inline void UserSession::set_pxd_login_blob(const void* value, size_t size) {
  set_has_pxd_login_blob();
  if (pxd_login_blob_ == &::google::protobuf::internal::kEmptyString) {
    pxd_login_blob_ = new ::std::string;
  }
  pxd_login_blob_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserSession::mutable_pxd_login_blob() {
  set_has_pxd_login_blob();
  if (pxd_login_blob_ == &::google::protobuf::internal::kEmptyString) {
    pxd_login_blob_ = new ::std::string;
  }
  return pxd_login_blob_;
}
inline ::std::string* UserSession::release_pxd_login_blob() {
  clear_has_pxd_login_blob();
  if (pxd_login_blob_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pxd_login_blob_;
    pxd_login_blob_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes ccd_server_key = 14;
inline bool UserSession::has_ccd_server_key() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void UserSession::set_has_ccd_server_key() {
  _has_bits_[0] |= 0x00001000u;
}
inline void UserSession::clear_has_ccd_server_key() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void UserSession::clear_ccd_server_key() {
  if (ccd_server_key_ != &::google::protobuf::internal::kEmptyString) {
    ccd_server_key_->clear();
  }
  clear_has_ccd_server_key();
}
inline const ::std::string& UserSession::ccd_server_key() const {
  return *ccd_server_key_;
}
inline void UserSession::set_ccd_server_key(const ::std::string& value) {
  set_has_ccd_server_key();
  if (ccd_server_key_ == &::google::protobuf::internal::kEmptyString) {
    ccd_server_key_ = new ::std::string;
  }
  ccd_server_key_->assign(value);
}
inline void UserSession::set_ccd_server_key(const char* value) {
  set_has_ccd_server_key();
  if (ccd_server_key_ == &::google::protobuf::internal::kEmptyString) {
    ccd_server_key_ = new ::std::string;
  }
  ccd_server_key_->assign(value);
}
inline void UserSession::set_ccd_server_key(const void* value, size_t size) {
  set_has_ccd_server_key();
  if (ccd_server_key_ == &::google::protobuf::internal::kEmptyString) {
    ccd_server_key_ = new ::std::string;
  }
  ccd_server_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserSession::mutable_ccd_server_key() {
  set_has_ccd_server_key();
  if (ccd_server_key_ == &::google::protobuf::internal::kEmptyString) {
    ccd_server_key_ = new ::std::string;
  }
  return ccd_server_key_;
}
inline ::std::string* UserSession::release_ccd_server_key() {
  clear_has_ccd_server_key();
  if (ccd_server_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ccd_server_key_;
    ccd_server_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .ccd.CCDToCCDCredential ccd_creds = 15;
inline int UserSession::ccd_creds_size() const {
  return ccd_creds_.size();
}
inline void UserSession::clear_ccd_creds() {
  ccd_creds_.Clear();
}
inline const ::ccd::CCDToCCDCredential& UserSession::ccd_creds(int index) const {
  return ccd_creds_.Get(index);
}
inline ::ccd::CCDToCCDCredential* UserSession::mutable_ccd_creds(int index) {
  return ccd_creds_.Mutable(index);
}
inline ::ccd::CCDToCCDCredential* UserSession::add_ccd_creds() {
  return ccd_creds_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ccd::CCDToCCDCredential >&
UserSession::ccd_creds() const {
  return ccd_creds_;
}
inline ::google::protobuf::RepeatedPtrField< ::ccd::CCDToCCDCredential >*
UserSession::mutable_ccd_creds() {
  return &ccd_creds_;
}

// optional uint32 instance_id = 16;
inline bool UserSession::has_instance_id() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void UserSession::set_has_instance_id() {
  _has_bits_[0] |= 0x00004000u;
}
inline void UserSession::clear_has_instance_id() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void UserSession::clear_instance_id() {
  instance_id_ = 0u;
  clear_has_instance_id();
}
inline ::google::protobuf::uint32 UserSession::instance_id() const {
  return instance_id_;
}
inline void UserSession::set_instance_id(::google::protobuf::uint32 value) {
  set_has_instance_id();
  instance_id_ = value;
}

// -------------------------------------------------------------------

// CCDToCCDCredential

// required fixed64 ccd_svr_user_id = 1;
inline bool CCDToCCDCredential::has_ccd_svr_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CCDToCCDCredential::set_has_ccd_svr_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CCDToCCDCredential::clear_has_ccd_svr_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CCDToCCDCredential::clear_ccd_svr_user_id() {
  ccd_svr_user_id_ = GOOGLE_ULONGLONG(0);
  clear_has_ccd_svr_user_id();
}
inline ::google::protobuf::uint64 CCDToCCDCredential::ccd_svr_user_id() const {
  return ccd_svr_user_id_;
}
inline void CCDToCCDCredential::set_ccd_svr_user_id(::google::protobuf::uint64 value) {
  set_has_ccd_svr_user_id();
  ccd_svr_user_id_ = value;
}

// required fixed64 ccd_svr_device_id = 2;
inline bool CCDToCCDCredential::has_ccd_svr_device_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CCDToCCDCredential::set_has_ccd_svr_device_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CCDToCCDCredential::clear_has_ccd_svr_device_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CCDToCCDCredential::clear_ccd_svr_device_id() {
  ccd_svr_device_id_ = GOOGLE_ULONGLONG(0);
  clear_has_ccd_svr_device_id();
}
inline ::google::protobuf::uint64 CCDToCCDCredential::ccd_svr_device_id() const {
  return ccd_svr_device_id_;
}
inline void CCDToCCDCredential::set_ccd_svr_device_id(::google::protobuf::uint64 value) {
  set_has_ccd_svr_device_id();
  ccd_svr_device_id_ = value;
}

// required uint32 ccd_svr_inst_id = 3;
inline bool CCDToCCDCredential::has_ccd_svr_inst_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CCDToCCDCredential::set_has_ccd_svr_inst_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CCDToCCDCredential::clear_has_ccd_svr_inst_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CCDToCCDCredential::clear_ccd_svr_inst_id() {
  ccd_svr_inst_id_ = 0u;
  clear_has_ccd_svr_inst_id();
}
inline ::google::protobuf::uint32 CCDToCCDCredential::ccd_svr_inst_id() const {
  return ccd_svr_inst_id_;
}
inline void CCDToCCDCredential::set_ccd_svr_inst_id(::google::protobuf::uint32 value) {
  set_has_ccd_svr_inst_id();
  ccd_svr_inst_id_ = value;
}

// required bytes ccd_session_key = 4;
inline bool CCDToCCDCredential::has_ccd_session_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CCDToCCDCredential::set_has_ccd_session_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CCDToCCDCredential::clear_has_ccd_session_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CCDToCCDCredential::clear_ccd_session_key() {
  if (ccd_session_key_ != &::google::protobuf::internal::kEmptyString) {
    ccd_session_key_->clear();
  }
  clear_has_ccd_session_key();
}
inline const ::std::string& CCDToCCDCredential::ccd_session_key() const {
  return *ccd_session_key_;
}
inline void CCDToCCDCredential::set_ccd_session_key(const ::std::string& value) {
  set_has_ccd_session_key();
  if (ccd_session_key_ == &::google::protobuf::internal::kEmptyString) {
    ccd_session_key_ = new ::std::string;
  }
  ccd_session_key_->assign(value);
}
inline void CCDToCCDCredential::set_ccd_session_key(const char* value) {
  set_has_ccd_session_key();
  if (ccd_session_key_ == &::google::protobuf::internal::kEmptyString) {
    ccd_session_key_ = new ::std::string;
  }
  ccd_session_key_->assign(value);
}
inline void CCDToCCDCredential::set_ccd_session_key(const void* value, size_t size) {
  set_has_ccd_session_key();
  if (ccd_session_key_ == &::google::protobuf::internal::kEmptyString) {
    ccd_session_key_ = new ::std::string;
  }
  ccd_session_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CCDToCCDCredential::mutable_ccd_session_key() {
  set_has_ccd_session_key();
  if (ccd_session_key_ == &::google::protobuf::internal::kEmptyString) {
    ccd_session_key_ = new ::std::string;
  }
  return ccd_session_key_;
}
inline ::std::string* CCDToCCDCredential::release_ccd_session_key() {
  clear_has_ccd_session_key();
  if (ccd_session_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ccd_session_key_;
    ccd_session_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes ccd_login_blob = 5;
inline bool CCDToCCDCredential::has_ccd_login_blob() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CCDToCCDCredential::set_has_ccd_login_blob() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CCDToCCDCredential::clear_has_ccd_login_blob() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CCDToCCDCredential::clear_ccd_login_blob() {
  if (ccd_login_blob_ != &::google::protobuf::internal::kEmptyString) {
    ccd_login_blob_->clear();
  }
  clear_has_ccd_login_blob();
}
inline const ::std::string& CCDToCCDCredential::ccd_login_blob() const {
  return *ccd_login_blob_;
}
inline void CCDToCCDCredential::set_ccd_login_blob(const ::std::string& value) {
  set_has_ccd_login_blob();
  if (ccd_login_blob_ == &::google::protobuf::internal::kEmptyString) {
    ccd_login_blob_ = new ::std::string;
  }
  ccd_login_blob_->assign(value);
}
inline void CCDToCCDCredential::set_ccd_login_blob(const char* value) {
  set_has_ccd_login_blob();
  if (ccd_login_blob_ == &::google::protobuf::internal::kEmptyString) {
    ccd_login_blob_ = new ::std::string;
  }
  ccd_login_blob_->assign(value);
}
inline void CCDToCCDCredential::set_ccd_login_blob(const void* value, size_t size) {
  set_has_ccd_login_blob();
  if (ccd_login_blob_ == &::google::protobuf::internal::kEmptyString) {
    ccd_login_blob_ = new ::std::string;
  }
  ccd_login_blob_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CCDToCCDCredential::mutable_ccd_login_blob() {
  set_has_ccd_login_blob();
  if (ccd_login_blob_ == &::google::protobuf::internal::kEmptyString) {
    ccd_login_blob_ = new ::std::string;
  }
  return ccd_login_blob_;
}
inline ::std::string* CCDToCCDCredential::release_ccd_login_blob() {
  clear_has_ccd_login_blob();
  if (ccd_login_blob_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ccd_login_blob_;
    ccd_login_blob_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// CachedDataset

// required .vplex.vsDirectory.DatasetDetail details = 1;
inline bool CachedDataset::has_details() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CachedDataset::set_has_details() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CachedDataset::clear_has_details() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CachedDataset::clear_details() {
  if (details_ != NULL) details_->::vplex::vsDirectory::DatasetDetail::Clear();
  clear_has_details();
}
inline const ::vplex::vsDirectory::DatasetDetail& CachedDataset::details() const {
  return details_ != NULL ? *details_ : *default_instance_->details_;
}
inline ::vplex::vsDirectory::DatasetDetail* CachedDataset::mutable_details() {
  set_has_details();
  if (details_ == NULL) details_ = new ::vplex::vsDirectory::DatasetDetail;
  return details_;
}
inline ::vplex::vsDirectory::DatasetDetail* CachedDataset::release_details() {
  clear_has_details();
  ::vplex::vsDirectory::DatasetDetail* temp = details_;
  details_ = NULL;
  return temp;
}

// optional string details_hash = 2;
inline bool CachedDataset::has_details_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CachedDataset::set_has_details_hash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CachedDataset::clear_has_details_hash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CachedDataset::clear_details_hash() {
  if (details_hash_ != &::google::protobuf::internal::kEmptyString) {
    details_hash_->clear();
  }
  clear_has_details_hash();
}
inline const ::std::string& CachedDataset::details_hash() const {
  return *details_hash_;
}
inline void CachedDataset::set_details_hash(const ::std::string& value) {
  set_has_details_hash();
  if (details_hash_ == &::google::protobuf::internal::kEmptyString) {
    details_hash_ = new ::std::string;
  }
  details_hash_->assign(value);
}
inline void CachedDataset::set_details_hash(const char* value) {
  set_has_details_hash();
  if (details_hash_ == &::google::protobuf::internal::kEmptyString) {
    details_hash_ = new ::std::string;
  }
  details_hash_->assign(value);
}
inline void CachedDataset::set_details_hash(const char* value, size_t size) {
  set_has_details_hash();
  if (details_hash_ == &::google::protobuf::internal::kEmptyString) {
    details_hash_ = new ::std::string;
  }
  details_hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CachedDataset::mutable_details_hash() {
  set_has_details_hash();
  if (details_hash_ == &::google::protobuf::internal::kEmptyString) {
    details_hash_ = new ::std::string;
  }
  return details_hash_;
}
inline ::std::string* CachedDataset::release_details_hash() {
  clear_has_details_hash();
  if (details_hash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = details_hash_;
    details_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// CachedSubscription

// required .vplex.vsDirectory.Subscription details = 1;
inline bool CachedSubscription::has_details() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CachedSubscription::set_has_details() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CachedSubscription::clear_has_details() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CachedSubscription::clear_details() {
  if (details_ != NULL) details_->::vplex::vsDirectory::Subscription::Clear();
  clear_has_details();
}
inline const ::vplex::vsDirectory::Subscription& CachedSubscription::details() const {
  return details_ != NULL ? *details_ : *default_instance_->details_;
}
inline ::vplex::vsDirectory::Subscription* CachedSubscription::mutable_details() {
  set_has_details();
  if (details_ == NULL) details_ = new ::vplex::vsDirectory::Subscription;
  return details_;
}
inline ::vplex::vsDirectory::Subscription* CachedSubscription::release_details() {
  clear_has_details();
  ::vplex::vsDirectory::Subscription* temp = details_;
  details_ = NULL;
  return temp;
}

// optional string details_hash = 2;
inline bool CachedSubscription::has_details_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CachedSubscription::set_has_details_hash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CachedSubscription::clear_has_details_hash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CachedSubscription::clear_details_hash() {
  if (details_hash_ != &::google::protobuf::internal::kEmptyString) {
    details_hash_->clear();
  }
  clear_has_details_hash();
}
inline const ::std::string& CachedSubscription::details_hash() const {
  return *details_hash_;
}
inline void CachedSubscription::set_details_hash(const ::std::string& value) {
  set_has_details_hash();
  if (details_hash_ == &::google::protobuf::internal::kEmptyString) {
    details_hash_ = new ::std::string;
  }
  details_hash_->assign(value);
}
inline void CachedSubscription::set_details_hash(const char* value) {
  set_has_details_hash();
  if (details_hash_ == &::google::protobuf::internal::kEmptyString) {
    details_hash_ = new ::std::string;
  }
  details_hash_->assign(value);
}
inline void CachedSubscription::set_details_hash(const char* value, size_t size) {
  set_has_details_hash();
  if (details_hash_ == &::google::protobuf::internal::kEmptyString) {
    details_hash_ = new ::std::string;
  }
  details_hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CachedSubscription::mutable_details_hash() {
  set_has_details_hash();
  if (details_hash_ == &::google::protobuf::internal::kEmptyString) {
    details_hash_ = new ::std::string;
  }
  return details_hash_;
}
inline ::std::string* CachedSubscription::release_details_hash() {
  clear_has_details_hash();
  if (details_hash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = details_hash_;
    details_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string abs_device_root = 3;
inline bool CachedSubscription::has_abs_device_root() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CachedSubscription::set_has_abs_device_root() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CachedSubscription::clear_has_abs_device_root() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CachedSubscription::clear_abs_device_root() {
  if (abs_device_root_ != &::google::protobuf::internal::kEmptyString) {
    abs_device_root_->clear();
  }
  clear_has_abs_device_root();
}
inline const ::std::string& CachedSubscription::abs_device_root() const {
  return *abs_device_root_;
}
inline void CachedSubscription::set_abs_device_root(const ::std::string& value) {
  set_has_abs_device_root();
  if (abs_device_root_ == &::google::protobuf::internal::kEmptyString) {
    abs_device_root_ = new ::std::string;
  }
  abs_device_root_->assign(value);
}
inline void CachedSubscription::set_abs_device_root(const char* value) {
  set_has_abs_device_root();
  if (abs_device_root_ == &::google::protobuf::internal::kEmptyString) {
    abs_device_root_ = new ::std::string;
  }
  abs_device_root_->assign(value);
}
inline void CachedSubscription::set_abs_device_root(const char* value, size_t size) {
  set_has_abs_device_root();
  if (abs_device_root_ == &::google::protobuf::internal::kEmptyString) {
    abs_device_root_ = new ::std::string;
  }
  abs_device_root_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CachedSubscription::mutable_abs_device_root() {
  set_has_abs_device_root();
  if (abs_device_root_ == &::google::protobuf::internal::kEmptyString) {
    abs_device_root_ = new ::std::string;
  }
  return abs_device_root_;
}
inline ::std::string* CachedSubscription::release_abs_device_root() {
  clear_has_abs_device_root();
  if (abs_device_root_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = abs_device_root_;
    abs_device_root_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// PicstreamDir

// required string directory = 1;
inline bool PicstreamDir::has_directory() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PicstreamDir::set_has_directory() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PicstreamDir::clear_has_directory() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PicstreamDir::clear_directory() {
  if (directory_ != &::google::protobuf::internal::kEmptyString) {
    directory_->clear();
  }
  clear_has_directory();
}
inline const ::std::string& PicstreamDir::directory() const {
  return *directory_;
}
inline void PicstreamDir::set_directory(const ::std::string& value) {
  set_has_directory();
  if (directory_ == &::google::protobuf::internal::kEmptyString) {
    directory_ = new ::std::string;
  }
  directory_->assign(value);
}
inline void PicstreamDir::set_directory(const char* value) {
  set_has_directory();
  if (directory_ == &::google::protobuf::internal::kEmptyString) {
    directory_ = new ::std::string;
  }
  directory_->assign(value);
}
inline void PicstreamDir::set_directory(const char* value, size_t size) {
  set_has_directory();
  if (directory_ == &::google::protobuf::internal::kEmptyString) {
    directory_ = new ::std::string;
  }
  directory_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PicstreamDir::mutable_directory() {
  set_has_directory();
  if (directory_ == &::google::protobuf::internal::kEmptyString) {
    directory_ = new ::std::string;
  }
  return directory_;
}
inline ::std::string* PicstreamDir::release_directory() {
  clear_has_directory();
  if (directory_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = directory_;
    directory_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required fixed64 index = 2;
inline bool PicstreamDir::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PicstreamDir::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PicstreamDir::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PicstreamDir::clear_index() {
  index_ = GOOGLE_ULONGLONG(0);
  clear_has_index();
}
inline ::google::protobuf::uint64 PicstreamDir::index() const {
  return index_;
}
inline void PicstreamDir::set_index(::google::protobuf::uint64 value) {
  set_has_index();
  index_ = value;
}

// optional bool never_init = 3;
inline bool PicstreamDir::has_never_init() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PicstreamDir::set_has_never_init() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PicstreamDir::clear_has_never_init() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PicstreamDir::clear_never_init() {
  never_init_ = false;
  clear_has_never_init();
}
inline bool PicstreamDir::never_init() const {
  return never_init_;
}
inline void PicstreamDir::set_never_init(bool value) {
  set_has_never_init();
  never_init_ = value;
}

// -------------------------------------------------------------------

// CachedStatEvent

// required string app_id = 1;
inline bool CachedStatEvent::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CachedStatEvent::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CachedStatEvent::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CachedStatEvent::clear_app_id() {
  if (app_id_ != &::google::protobuf::internal::kEmptyString) {
    app_id_->clear();
  }
  clear_has_app_id();
}
inline const ::std::string& CachedStatEvent::app_id() const {
  return *app_id_;
}
inline void CachedStatEvent::set_app_id(const ::std::string& value) {
  set_has_app_id();
  if (app_id_ == &::google::protobuf::internal::kEmptyString) {
    app_id_ = new ::std::string;
  }
  app_id_->assign(value);
}
inline void CachedStatEvent::set_app_id(const char* value) {
  set_has_app_id();
  if (app_id_ == &::google::protobuf::internal::kEmptyString) {
    app_id_ = new ::std::string;
  }
  app_id_->assign(value);
}
inline void CachedStatEvent::set_app_id(const char* value, size_t size) {
  set_has_app_id();
  if (app_id_ == &::google::protobuf::internal::kEmptyString) {
    app_id_ = new ::std::string;
  }
  app_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CachedStatEvent::mutable_app_id() {
  set_has_app_id();
  if (app_id_ == &::google::protobuf::internal::kEmptyString) {
    app_id_ = new ::std::string;
  }
  return app_id_;
}
inline ::std::string* CachedStatEvent::release_app_id() {
  clear_has_app_id();
  if (app_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = app_id_;
    app_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string event_id = 2;
inline bool CachedStatEvent::has_event_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CachedStatEvent::set_has_event_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CachedStatEvent::clear_has_event_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CachedStatEvent::clear_event_id() {
  if (event_id_ != &::google::protobuf::internal::kEmptyString) {
    event_id_->clear();
  }
  clear_has_event_id();
}
inline const ::std::string& CachedStatEvent::event_id() const {
  return *event_id_;
}
inline void CachedStatEvent::set_event_id(const ::std::string& value) {
  set_has_event_id();
  if (event_id_ == &::google::protobuf::internal::kEmptyString) {
    event_id_ = new ::std::string;
  }
  event_id_->assign(value);
}
inline void CachedStatEvent::set_event_id(const char* value) {
  set_has_event_id();
  if (event_id_ == &::google::protobuf::internal::kEmptyString) {
    event_id_ = new ::std::string;
  }
  event_id_->assign(value);
}
inline void CachedStatEvent::set_event_id(const char* value, size_t size) {
  set_has_event_id();
  if (event_id_ == &::google::protobuf::internal::kEmptyString) {
    event_id_ = new ::std::string;
  }
  event_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CachedStatEvent::mutable_event_id() {
  set_has_event_id();
  if (event_id_ == &::google::protobuf::internal::kEmptyString) {
    event_id_ = new ::std::string;
  }
  return event_id_;
}
inline ::std::string* CachedStatEvent::release_event_id() {
  clear_has_event_id();
  if (event_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = event_id_;
    event_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint64 start_time_ms = 3;
inline bool CachedStatEvent::has_start_time_ms() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CachedStatEvent::set_has_start_time_ms() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CachedStatEvent::clear_has_start_time_ms() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CachedStatEvent::clear_start_time_ms() {
  start_time_ms_ = GOOGLE_ULONGLONG(0);
  clear_has_start_time_ms();
}
inline ::google::protobuf::uint64 CachedStatEvent::start_time_ms() const {
  return start_time_ms_;
}
inline void CachedStatEvent::set_start_time_ms(::google::protobuf::uint64 value) {
  set_has_start_time_ms();
  start_time_ms_ = value;
}

// optional uint64 end_time_ms = 4;
inline bool CachedStatEvent::has_end_time_ms() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CachedStatEvent::set_has_end_time_ms() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CachedStatEvent::clear_has_end_time_ms() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CachedStatEvent::clear_end_time_ms() {
  end_time_ms_ = GOOGLE_ULONGLONG(0);
  clear_has_end_time_ms();
}
inline ::google::protobuf::uint64 CachedStatEvent::end_time_ms() const {
  return end_time_ms_;
}
inline void CachedStatEvent::set_end_time_ms(::google::protobuf::uint64 value) {
  set_has_end_time_ms();
  end_time_ms_ = value;
}

// required uint32 event_count = 5 [default = 1];
inline bool CachedStatEvent::has_event_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CachedStatEvent::set_has_event_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CachedStatEvent::clear_has_event_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CachedStatEvent::clear_event_count() {
  event_count_ = 1u;
  clear_has_event_count();
}
inline ::google::protobuf::uint32 CachedStatEvent::event_count() const {
  return event_count_;
}
inline void CachedStatEvent::set_event_count(::google::protobuf::uint32 value) {
  set_has_event_count();
  event_count_ = value;
}

// optional string event_info = 6;
inline bool CachedStatEvent::has_event_info() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CachedStatEvent::set_has_event_info() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CachedStatEvent::clear_has_event_info() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CachedStatEvent::clear_event_info() {
  if (event_info_ != &::google::protobuf::internal::kEmptyString) {
    event_info_->clear();
  }
  clear_has_event_info();
}
inline const ::std::string& CachedStatEvent::event_info() const {
  return *event_info_;
}
inline void CachedStatEvent::set_event_info(const ::std::string& value) {
  set_has_event_info();
  if (event_info_ == &::google::protobuf::internal::kEmptyString) {
    event_info_ = new ::std::string;
  }
  event_info_->assign(value);
}
inline void CachedStatEvent::set_event_info(const char* value) {
  set_has_event_info();
  if (event_info_ == &::google::protobuf::internal::kEmptyString) {
    event_info_ = new ::std::string;
  }
  event_info_->assign(value);
}
inline void CachedStatEvent::set_event_info(const char* value, size_t size) {
  set_has_event_info();
  if (event_info_ == &::google::protobuf::internal::kEmptyString) {
    event_info_ = new ::std::string;
  }
  event_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CachedStatEvent::mutable_event_info() {
  set_has_event_info();
  if (event_info_ == &::google::protobuf::internal::kEmptyString) {
    event_info_ = new ::std::string;
  }
  return event_info_;
}
inline ::std::string* CachedStatEvent::release_event_info() {
  clear_has_event_info();
  if (event_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = event_info_;
    event_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool limit_reached = 7;
inline bool CachedStatEvent::has_limit_reached() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CachedStatEvent::set_has_limit_reached() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CachedStatEvent::clear_has_limit_reached() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CachedStatEvent::clear_limit_reached() {
  limit_reached_ = false;
  clear_has_limit_reached();
}
inline bool CachedStatEvent::limit_reached() const {
  return limit_reached_;
}
inline void CachedStatEvent::set_limit_reached(bool value) {
  set_has_limit_reached();
  limit_reached_ = value;
}

// -------------------------------------------------------------------

// MediaMetadataThumbMigrateInternal

// optional string mm_thumb_src_dir = 1;
inline bool MediaMetadataThumbMigrateInternal::has_mm_thumb_src_dir() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MediaMetadataThumbMigrateInternal::set_has_mm_thumb_src_dir() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MediaMetadataThumbMigrateInternal::clear_has_mm_thumb_src_dir() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MediaMetadataThumbMigrateInternal::clear_mm_thumb_src_dir() {
  if (mm_thumb_src_dir_ != &::google::protobuf::internal::kEmptyString) {
    mm_thumb_src_dir_->clear();
  }
  clear_has_mm_thumb_src_dir();
}
inline const ::std::string& MediaMetadataThumbMigrateInternal::mm_thumb_src_dir() const {
  return *mm_thumb_src_dir_;
}
inline void MediaMetadataThumbMigrateInternal::set_mm_thumb_src_dir(const ::std::string& value) {
  set_has_mm_thumb_src_dir();
  if (mm_thumb_src_dir_ == &::google::protobuf::internal::kEmptyString) {
    mm_thumb_src_dir_ = new ::std::string;
  }
  mm_thumb_src_dir_->assign(value);
}
inline void MediaMetadataThumbMigrateInternal::set_mm_thumb_src_dir(const char* value) {
  set_has_mm_thumb_src_dir();
  if (mm_thumb_src_dir_ == &::google::protobuf::internal::kEmptyString) {
    mm_thumb_src_dir_ = new ::std::string;
  }
  mm_thumb_src_dir_->assign(value);
}
inline void MediaMetadataThumbMigrateInternal::set_mm_thumb_src_dir(const char* value, size_t size) {
  set_has_mm_thumb_src_dir();
  if (mm_thumb_src_dir_ == &::google::protobuf::internal::kEmptyString) {
    mm_thumb_src_dir_ = new ::std::string;
  }
  mm_thumb_src_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MediaMetadataThumbMigrateInternal::mutable_mm_thumb_src_dir() {
  set_has_mm_thumb_src_dir();
  if (mm_thumb_src_dir_ == &::google::protobuf::internal::kEmptyString) {
    mm_thumb_src_dir_ = new ::std::string;
  }
  return mm_thumb_src_dir_;
}
inline ::std::string* MediaMetadataThumbMigrateInternal::release_mm_thumb_src_dir() {
  clear_has_mm_thumb_src_dir();
  if (mm_thumb_src_dir_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mm_thumb_src_dir_;
    mm_thumb_src_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string mm_thumb_dest_dir = 2;
inline bool MediaMetadataThumbMigrateInternal::has_mm_thumb_dest_dir() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MediaMetadataThumbMigrateInternal::set_has_mm_thumb_dest_dir() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MediaMetadataThumbMigrateInternal::clear_has_mm_thumb_dest_dir() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MediaMetadataThumbMigrateInternal::clear_mm_thumb_dest_dir() {
  if (mm_thumb_dest_dir_ != &::google::protobuf::internal::kEmptyString) {
    mm_thumb_dest_dir_->clear();
  }
  clear_has_mm_thumb_dest_dir();
}
inline const ::std::string& MediaMetadataThumbMigrateInternal::mm_thumb_dest_dir() const {
  return *mm_thumb_dest_dir_;
}
inline void MediaMetadataThumbMigrateInternal::set_mm_thumb_dest_dir(const ::std::string& value) {
  set_has_mm_thumb_dest_dir();
  if (mm_thumb_dest_dir_ == &::google::protobuf::internal::kEmptyString) {
    mm_thumb_dest_dir_ = new ::std::string;
  }
  mm_thumb_dest_dir_->assign(value);
}
inline void MediaMetadataThumbMigrateInternal::set_mm_thumb_dest_dir(const char* value) {
  set_has_mm_thumb_dest_dir();
  if (mm_thumb_dest_dir_ == &::google::protobuf::internal::kEmptyString) {
    mm_thumb_dest_dir_ = new ::std::string;
  }
  mm_thumb_dest_dir_->assign(value);
}
inline void MediaMetadataThumbMigrateInternal::set_mm_thumb_dest_dir(const char* value, size_t size) {
  set_has_mm_thumb_dest_dir();
  if (mm_thumb_dest_dir_ == &::google::protobuf::internal::kEmptyString) {
    mm_thumb_dest_dir_ = new ::std::string;
  }
  mm_thumb_dest_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MediaMetadataThumbMigrateInternal::mutable_mm_thumb_dest_dir() {
  set_has_mm_thumb_dest_dir();
  if (mm_thumb_dest_dir_ == &::google::protobuf::internal::kEmptyString) {
    mm_thumb_dest_dir_ = new ::std::string;
  }
  return mm_thumb_dest_dir_;
}
inline ::std::string* MediaMetadataThumbMigrateInternal::release_mm_thumb_dest_dir() {
  clear_has_mm_thumb_dest_dir();
  if (mm_thumb_dest_dir_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mm_thumb_dest_dir_;
    mm_thumb_dest_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool mm_delete_phase = 3;
inline bool MediaMetadataThumbMigrateInternal::has_mm_delete_phase() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MediaMetadataThumbMigrateInternal::set_has_mm_delete_phase() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MediaMetadataThumbMigrateInternal::clear_has_mm_delete_phase() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MediaMetadataThumbMigrateInternal::clear_mm_delete_phase() {
  mm_delete_phase_ = false;
  clear_has_mm_delete_phase();
}
inline bool MediaMetadataThumbMigrateInternal::mm_delete_phase() const {
  return mm_delete_phase_;
}
inline void MediaMetadataThumbMigrateInternal::set_mm_delete_phase(bool value) {
  set_has_mm_delete_phase();
  mm_delete_phase_ = value;
}

// -------------------------------------------------------------------

// SyncBoxSettings

// optional bool enable_sync = 1 [default = false];
inline bool SyncBoxSettings::has_enable_sync() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SyncBoxSettings::set_has_enable_sync() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SyncBoxSettings::clear_has_enable_sync() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SyncBoxSettings::clear_enable_sync() {
  enable_sync_ = false;
  clear_has_enable_sync();
}
inline bool SyncBoxSettings::enable_sync() const {
  return enable_sync_;
}
inline void SyncBoxSettings::set_enable_sync(bool value) {
  set_has_enable_sync();
  enable_sync_ = value;
}

// optional string sync_feature_path = 2;
inline bool SyncBoxSettings::has_sync_feature_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SyncBoxSettings::set_has_sync_feature_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SyncBoxSettings::clear_has_sync_feature_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SyncBoxSettings::clear_sync_feature_path() {
  if (sync_feature_path_ != &::google::protobuf::internal::kEmptyString) {
    sync_feature_path_->clear();
  }
  clear_has_sync_feature_path();
}
inline const ::std::string& SyncBoxSettings::sync_feature_path() const {
  return *sync_feature_path_;
}
inline void SyncBoxSettings::set_sync_feature_path(const ::std::string& value) {
  set_has_sync_feature_path();
  if (sync_feature_path_ == &::google::protobuf::internal::kEmptyString) {
    sync_feature_path_ = new ::std::string;
  }
  sync_feature_path_->assign(value);
}
inline void SyncBoxSettings::set_sync_feature_path(const char* value) {
  set_has_sync_feature_path();
  if (sync_feature_path_ == &::google::protobuf::internal::kEmptyString) {
    sync_feature_path_ = new ::std::string;
  }
  sync_feature_path_->assign(value);
}
inline void SyncBoxSettings::set_sync_feature_path(const char* value, size_t size) {
  set_has_sync_feature_path();
  if (sync_feature_path_ == &::google::protobuf::internal::kEmptyString) {
    sync_feature_path_ = new ::std::string;
  }
  sync_feature_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SyncBoxSettings::mutable_sync_feature_path() {
  set_has_sync_feature_path();
  if (sync_feature_path_ == &::google::protobuf::internal::kEmptyString) {
    sync_feature_path_ = new ::std::string;
  }
  return sync_feature_path_;
}
inline ::std::string* SyncBoxSettings::release_sync_feature_path() {
  clear_has_sync_feature_path();
  if (sync_feature_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sync_feature_path_;
    sync_feature_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool is_archive_storage = 3 [default = false];
inline bool SyncBoxSettings::has_is_archive_storage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SyncBoxSettings::set_has_is_archive_storage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SyncBoxSettings::clear_has_is_archive_storage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SyncBoxSettings::clear_is_archive_storage() {
  is_archive_storage_ = false;
  clear_has_is_archive_storage();
}
inline bool SyncBoxSettings::is_archive_storage() const {
  return is_archive_storage_;
}
inline void SyncBoxSettings::set_is_archive_storage(bool value) {
  set_has_is_archive_storage();
  is_archive_storage_ = value;
}

// optional bool coherent = 4 [default = false];
inline bool SyncBoxSettings::has_coherent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SyncBoxSettings::set_has_coherent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SyncBoxSettings::clear_has_coherent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SyncBoxSettings::clear_coherent() {
  coherent_ = false;
  clear_has_coherent();
}
inline bool SyncBoxSettings::coherent() const {
  return coherent_;
}
inline void SyncBoxSettings::set_coherent(bool value) {
  set_has_coherent();
  coherent_ = value;
}

// optional string syncbox_staging_area_abs_path = 5;
inline bool SyncBoxSettings::has_syncbox_staging_area_abs_path() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SyncBoxSettings::set_has_syncbox_staging_area_abs_path() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SyncBoxSettings::clear_has_syncbox_staging_area_abs_path() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SyncBoxSettings::clear_syncbox_staging_area_abs_path() {
  if (syncbox_staging_area_abs_path_ != &::google::protobuf::internal::kEmptyString) {
    syncbox_staging_area_abs_path_->clear();
  }
  clear_has_syncbox_staging_area_abs_path();
}
inline const ::std::string& SyncBoxSettings::syncbox_staging_area_abs_path() const {
  return *syncbox_staging_area_abs_path_;
}
inline void SyncBoxSettings::set_syncbox_staging_area_abs_path(const ::std::string& value) {
  set_has_syncbox_staging_area_abs_path();
  if (syncbox_staging_area_abs_path_ == &::google::protobuf::internal::kEmptyString) {
    syncbox_staging_area_abs_path_ = new ::std::string;
  }
  syncbox_staging_area_abs_path_->assign(value);
}
inline void SyncBoxSettings::set_syncbox_staging_area_abs_path(const char* value) {
  set_has_syncbox_staging_area_abs_path();
  if (syncbox_staging_area_abs_path_ == &::google::protobuf::internal::kEmptyString) {
    syncbox_staging_area_abs_path_ = new ::std::string;
  }
  syncbox_staging_area_abs_path_->assign(value);
}
inline void SyncBoxSettings::set_syncbox_staging_area_abs_path(const char* value, size_t size) {
  set_has_syncbox_staging_area_abs_path();
  if (syncbox_staging_area_abs_path_ == &::google::protobuf::internal::kEmptyString) {
    syncbox_staging_area_abs_path_ = new ::std::string;
  }
  syncbox_staging_area_abs_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SyncBoxSettings::mutable_syncbox_staging_area_abs_path() {
  set_has_syncbox_staging_area_abs_path();
  if (syncbox_staging_area_abs_path_ == &::google::protobuf::internal::kEmptyString) {
    syncbox_staging_area_abs_path_ = new ::std::string;
  }
  return syncbox_staging_area_abs_path_;
}
inline ::std::string* SyncBoxSettings::release_syncbox_staging_area_abs_path() {
  clear_has_syncbox_staging_area_abs_path();
  if (syncbox_staging_area_abs_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = syncbox_staging_area_abs_path_;
    syncbox_staging_area_abs_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional fixed64 syncbox_dataset_id = 6;
inline bool SyncBoxSettings::has_syncbox_dataset_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SyncBoxSettings::set_has_syncbox_dataset_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SyncBoxSettings::clear_has_syncbox_dataset_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SyncBoxSettings::clear_syncbox_dataset_id() {
  syncbox_dataset_id_ = GOOGLE_ULONGLONG(0);
  clear_has_syncbox_dataset_id();
}
inline ::google::protobuf::uint64 SyncBoxSettings::syncbox_dataset_id() const {
  return syncbox_dataset_id_;
}
inline void SyncBoxSettings::set_syncbox_dataset_id(::google::protobuf::uint64 value) {
  set_has_syncbox_dataset_id();
  syncbox_dataset_id_ = value;
}

// -------------------------------------------------------------------

// CachedUserDetails

// repeated .ccd.CachedDataset datasets = 1;
inline int CachedUserDetails::datasets_size() const {
  return datasets_.size();
}
inline void CachedUserDetails::clear_datasets() {
  datasets_.Clear();
}
inline const ::ccd::CachedDataset& CachedUserDetails::datasets(int index) const {
  return datasets_.Get(index);
}
inline ::ccd::CachedDataset* CachedUserDetails::mutable_datasets(int index) {
  return datasets_.Mutable(index);
}
inline ::ccd::CachedDataset* CachedUserDetails::add_datasets() {
  return datasets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ccd::CachedDataset >&
CachedUserDetails::datasets() const {
  return datasets_;
}
inline ::google::protobuf::RepeatedPtrField< ::ccd::CachedDataset >*
CachedUserDetails::mutable_datasets() {
  return &datasets_;
}

// repeated .ccd.CachedSubscription subscriptions = 2;
inline int CachedUserDetails::subscriptions_size() const {
  return subscriptions_.size();
}
inline void CachedUserDetails::clear_subscriptions() {
  subscriptions_.Clear();
}
inline const ::ccd::CachedSubscription& CachedUserDetails::subscriptions(int index) const {
  return subscriptions_.Get(index);
}
inline ::ccd::CachedSubscription* CachedUserDetails::mutable_subscriptions(int index) {
  return subscriptions_.Mutable(index);
}
inline ::ccd::CachedSubscription* CachedUserDetails::add_subscriptions() {
  return subscriptions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ccd::CachedSubscription >&
CachedUserDetails::subscriptions() const {
  return subscriptions_;
}
inline ::google::protobuf::RepeatedPtrField< ::ccd::CachedSubscription >*
CachedUserDetails::mutable_subscriptions() {
  return &subscriptions_;
}

// repeated .vplex.vsDirectory.DeviceInfo cached_devices = 14;
inline int CachedUserDetails::cached_devices_size() const {
  return cached_devices_.size();
}
inline void CachedUserDetails::clear_cached_devices() {
  cached_devices_.Clear();
}
inline const ::vplex::vsDirectory::DeviceInfo& CachedUserDetails::cached_devices(int index) const {
  return cached_devices_.Get(index);
}
inline ::vplex::vsDirectory::DeviceInfo* CachedUserDetails::mutable_cached_devices(int index) {
  return cached_devices_.Mutable(index);
}
inline ::vplex::vsDirectory::DeviceInfo* CachedUserDetails::add_cached_devices() {
  return cached_devices_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::DeviceInfo >&
CachedUserDetails::cached_devices() const {
  return cached_devices_;
}
inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::DeviceInfo >*
CachedUserDetails::mutable_cached_devices() {
  return &cached_devices_;
}

// required .ccd.UserSession session = 6;
inline bool CachedUserDetails::has_session() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CachedUserDetails::set_has_session() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CachedUserDetails::clear_has_session() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CachedUserDetails::clear_session() {
  if (session_ != NULL) session_->::ccd::UserSession::Clear();
  clear_has_session();
}
inline const ::ccd::UserSession& CachedUserDetails::session() const {
  return session_ != NULL ? *session_ : *default_instance_->session_;
}
inline ::ccd::UserSession* CachedUserDetails::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::ccd::UserSession;
  return session_;
}
inline ::ccd::UserSession* CachedUserDetails::release_session() {
  clear_has_session();
  ::ccd::UserSession* temp = session_;
  session_ = NULL;
  return temp;
}

// repeated .vplex.vsDirectory.UserStorage cached_user_storage = 15;
inline int CachedUserDetails::cached_user_storage_size() const {
  return cached_user_storage_.size();
}
inline void CachedUserDetails::clear_cached_user_storage() {
  cached_user_storage_.Clear();
}
inline const ::vplex::vsDirectory::UserStorage& CachedUserDetails::cached_user_storage(int index) const {
  return cached_user_storage_.Get(index);
}
inline ::vplex::vsDirectory::UserStorage* CachedUserDetails::mutable_cached_user_storage(int index) {
  return cached_user_storage_.Mutable(index);
}
inline ::vplex::vsDirectory::UserStorage* CachedUserDetails::add_cached_user_storage() {
  return cached_user_storage_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::UserStorage >&
CachedUserDetails::cached_user_storage() const {
  return cached_user_storage_;
}
inline ::google::protobuf::RepeatedPtrField< ::vplex::vsDirectory::UserStorage >*
CachedUserDetails::mutable_cached_user_storage() {
  return &cached_user_storage_;
}

// optional bool disable_background_data = 16;
inline bool CachedUserDetails::has_disable_background_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CachedUserDetails::set_has_disable_background_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CachedUserDetails::clear_has_disable_background_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CachedUserDetails::clear_disable_background_data() {
  disable_background_data_ = false;
  clear_has_disable_background_data();
}
inline bool CachedUserDetails::disable_background_data() const {
  return disable_background_data_;
}
inline void CachedUserDetails::set_disable_background_data(bool value) {
  set_has_disable_background_data();
  disable_background_data_ = value;
}

// optional bool disable_auto_sync = 17;
inline bool CachedUserDetails::has_disable_auto_sync() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CachedUserDetails::set_has_disable_auto_sync() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CachedUserDetails::clear_has_disable_auto_sync() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CachedUserDetails::clear_disable_auto_sync() {
  disable_auto_sync_ = false;
  clear_has_disable_auto_sync();
}
inline bool CachedUserDetails::disable_auto_sync() const {
  return disable_auto_sync_;
}
inline void CachedUserDetails::set_disable_auto_sync(bool value) {
  set_has_disable_auto_sync();
  disable_auto_sync_ = value;
}

// optional bool disable_mobile_network_data = 18 [default = true];
inline bool CachedUserDetails::has_disable_mobile_network_data() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CachedUserDetails::set_has_disable_mobile_network_data() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CachedUserDetails::clear_has_disable_mobile_network_data() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CachedUserDetails::clear_disable_mobile_network_data() {
  disable_mobile_network_data_ = true;
  clear_has_disable_mobile_network_data();
}
inline bool CachedUserDetails::disable_mobile_network_data() const {
  return disable_mobile_network_data_;
}
inline void CachedUserDetails::set_disable_mobile_network_data(bool value) {
  set_has_disable_mobile_network_data();
  disable_mobile_network_data_ = value;
}

// repeated .ccd.PicstreamDir camera_upload_dirs = 19;
inline int CachedUserDetails::camera_upload_dirs_size() const {
  return camera_upload_dirs_.size();
}
inline void CachedUserDetails::clear_camera_upload_dirs() {
  camera_upload_dirs_.Clear();
}
inline const ::ccd::PicstreamDir& CachedUserDetails::camera_upload_dirs(int index) const {
  return camera_upload_dirs_.Get(index);
}
inline ::ccd::PicstreamDir* CachedUserDetails::mutable_camera_upload_dirs(int index) {
  return camera_upload_dirs_.Mutable(index);
}
inline ::ccd::PicstreamDir* CachedUserDetails::add_camera_upload_dirs() {
  return camera_upload_dirs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ccd::PicstreamDir >&
CachedUserDetails::camera_upload_dirs() const {
  return camera_upload_dirs_;
}
inline ::google::protobuf::RepeatedPtrField< ::ccd::PicstreamDir >*
CachedUserDetails::mutable_camera_upload_dirs() {
  return &camera_upload_dirs_;
}

// optional bool enable_camera_roll_trigger = 20;
inline bool CachedUserDetails::has_enable_camera_roll_trigger() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CachedUserDetails::set_has_enable_camera_roll_trigger() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CachedUserDetails::clear_has_enable_camera_roll_trigger() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CachedUserDetails::clear_enable_camera_roll_trigger() {
  enable_camera_roll_trigger_ = false;
  clear_has_enable_camera_roll_trigger();
}
inline bool CachedUserDetails::enable_camera_roll_trigger() const {
  return enable_camera_roll_trigger_;
}
inline void CachedUserDetails::set_enable_camera_roll_trigger(bool value) {
  set_has_enable_camera_roll_trigger();
  enable_camera_roll_trigger_ = value;
}

// repeated .ccd.CameraRollDownloadDirSpecInternal picstream_download_dirs_full_res = 32;
inline int CachedUserDetails::picstream_download_dirs_full_res_size() const {
  return picstream_download_dirs_full_res_.size();
}
inline void CachedUserDetails::clear_picstream_download_dirs_full_res() {
  picstream_download_dirs_full_res_.Clear();
}
inline const ::ccd::CameraRollDownloadDirSpecInternal& CachedUserDetails::picstream_download_dirs_full_res(int index) const {
  return picstream_download_dirs_full_res_.Get(index);
}
inline ::ccd::CameraRollDownloadDirSpecInternal* CachedUserDetails::mutable_picstream_download_dirs_full_res(int index) {
  return picstream_download_dirs_full_res_.Mutable(index);
}
inline ::ccd::CameraRollDownloadDirSpecInternal* CachedUserDetails::add_picstream_download_dirs_full_res() {
  return picstream_download_dirs_full_res_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ccd::CameraRollDownloadDirSpecInternal >&
CachedUserDetails::picstream_download_dirs_full_res() const {
  return picstream_download_dirs_full_res_;
}
inline ::google::protobuf::RepeatedPtrField< ::ccd::CameraRollDownloadDirSpecInternal >*
CachedUserDetails::mutable_picstream_download_dirs_full_res() {
  return &picstream_download_dirs_full_res_;
}

// repeated .ccd.CameraRollDownloadDirSpecInternal picstream_download_dirs_low_res = 33;
inline int CachedUserDetails::picstream_download_dirs_low_res_size() const {
  return picstream_download_dirs_low_res_.size();
}
inline void CachedUserDetails::clear_picstream_download_dirs_low_res() {
  picstream_download_dirs_low_res_.Clear();
}
inline const ::ccd::CameraRollDownloadDirSpecInternal& CachedUserDetails::picstream_download_dirs_low_res(int index) const {
  return picstream_download_dirs_low_res_.Get(index);
}
inline ::ccd::CameraRollDownloadDirSpecInternal* CachedUserDetails::mutable_picstream_download_dirs_low_res(int index) {
  return picstream_download_dirs_low_res_.Mutable(index);
}
inline ::ccd::CameraRollDownloadDirSpecInternal* CachedUserDetails::add_picstream_download_dirs_low_res() {
  return picstream_download_dirs_low_res_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ccd::CameraRollDownloadDirSpecInternal >&
CachedUserDetails::picstream_download_dirs_low_res() const {
  return picstream_download_dirs_low_res_;
}
inline ::google::protobuf::RepeatedPtrField< ::ccd::CameraRollDownloadDirSpecInternal >*
CachedUserDetails::mutable_picstream_download_dirs_low_res() {
  return &picstream_download_dirs_low_res_;
}

// repeated .ccd.CameraRollDownloadDirSpecInternal picstream_download_dirs_thumbnail = 41;
inline int CachedUserDetails::picstream_download_dirs_thumbnail_size() const {
  return picstream_download_dirs_thumbnail_.size();
}
inline void CachedUserDetails::clear_picstream_download_dirs_thumbnail() {
  picstream_download_dirs_thumbnail_.Clear();
}
inline const ::ccd::CameraRollDownloadDirSpecInternal& CachedUserDetails::picstream_download_dirs_thumbnail(int index) const {
  return picstream_download_dirs_thumbnail_.Get(index);
}
inline ::ccd::CameraRollDownloadDirSpecInternal* CachedUserDetails::mutable_picstream_download_dirs_thumbnail(int index) {
  return picstream_download_dirs_thumbnail_.Mutable(index);
}
inline ::ccd::CameraRollDownloadDirSpecInternal* CachedUserDetails::add_picstream_download_dirs_thumbnail() {
  return picstream_download_dirs_thumbnail_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ccd::CameraRollDownloadDirSpecInternal >&
CachedUserDetails::picstream_download_dirs_thumbnail() const {
  return picstream_download_dirs_thumbnail_;
}
inline ::google::protobuf::RepeatedPtrField< ::ccd::CameraRollDownloadDirSpecInternal >*
CachedUserDetails::mutable_picstream_download_dirs_thumbnail() {
  return &picstream_download_dirs_thumbnail_;
}

// optional bool enable_notes_sync = 23 [default = false];
inline bool CachedUserDetails::has_enable_notes_sync() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CachedUserDetails::set_has_enable_notes_sync() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CachedUserDetails::clear_has_enable_notes_sync() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CachedUserDetails::clear_enable_notes_sync() {
  enable_notes_sync_ = false;
  clear_has_enable_notes_sync();
}
inline bool CachedUserDetails::enable_notes_sync() const {
  return enable_notes_sync_;
}
inline void CachedUserDetails::set_enable_notes_sync(bool value) {
  set_has_enable_notes_sync();
  enable_notes_sync_ = value;
}

// optional string notes_sync_path = 26;
inline bool CachedUserDetails::has_notes_sync_path() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CachedUserDetails::set_has_notes_sync_path() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CachedUserDetails::clear_has_notes_sync_path() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CachedUserDetails::clear_notes_sync_path() {
  if (notes_sync_path_ != &::google::protobuf::internal::kEmptyString) {
    notes_sync_path_->clear();
  }
  clear_has_notes_sync_path();
}
inline const ::std::string& CachedUserDetails::notes_sync_path() const {
  return *notes_sync_path_;
}
inline void CachedUserDetails::set_notes_sync_path(const ::std::string& value) {
  set_has_notes_sync_path();
  if (notes_sync_path_ == &::google::protobuf::internal::kEmptyString) {
    notes_sync_path_ = new ::std::string;
  }
  notes_sync_path_->assign(value);
}
inline void CachedUserDetails::set_notes_sync_path(const char* value) {
  set_has_notes_sync_path();
  if (notes_sync_path_ == &::google::protobuf::internal::kEmptyString) {
    notes_sync_path_ = new ::std::string;
  }
  notes_sync_path_->assign(value);
}
inline void CachedUserDetails::set_notes_sync_path(const char* value, size_t size) {
  set_has_notes_sync_path();
  if (notes_sync_path_ == &::google::protobuf::internal::kEmptyString) {
    notes_sync_path_ = new ::std::string;
  }
  notes_sync_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CachedUserDetails::mutable_notes_sync_path() {
  set_has_notes_sync_path();
  if (notes_sync_path_ == &::google::protobuf::internal::kEmptyString) {
    notes_sync_path_ = new ::std::string;
  }
  return notes_sync_path_;
}
inline ::std::string* CachedUserDetails::release_notes_sync_path() {
  clear_has_notes_sync_path();
  if (notes_sync_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = notes_sync_path_;
    notes_sync_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .ccd.CachedStatEvent stat_event_list = 24;
inline int CachedUserDetails::stat_event_list_size() const {
  return stat_event_list_.size();
}
inline void CachedUserDetails::clear_stat_event_list() {
  stat_event_list_.Clear();
}
inline const ::ccd::CachedStatEvent& CachedUserDetails::stat_event_list(int index) const {
  return stat_event_list_.Get(index);
}
inline ::ccd::CachedStatEvent* CachedUserDetails::mutable_stat_event_list(int index) {
  return stat_event_list_.Mutable(index);
}
inline ::ccd::CachedStatEvent* CachedUserDetails::add_stat_event_list() {
  return stat_event_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ccd::CachedStatEvent >&
CachedUserDetails::stat_event_list() const {
  return stat_event_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::ccd::CachedStatEvent >*
CachedUserDetails::mutable_stat_event_list() {
  return &stat_event_list_;
}

// repeated .ccd.CachedStatEvent stat_event_wait_list = 38;
inline int CachedUserDetails::stat_event_wait_list_size() const {
  return stat_event_wait_list_.size();
}
inline void CachedUserDetails::clear_stat_event_wait_list() {
  stat_event_wait_list_.Clear();
}
inline const ::ccd::CachedStatEvent& CachedUserDetails::stat_event_wait_list(int index) const {
  return stat_event_wait_list_.Get(index);
}
inline ::ccd::CachedStatEvent* CachedUserDetails::mutable_stat_event_wait_list(int index) {
  return stat_event_wait_list_.Mutable(index);
}
inline ::ccd::CachedStatEvent* CachedUserDetails::add_stat_event_wait_list() {
  return stat_event_wait_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ccd::CachedStatEvent >&
CachedUserDetails::stat_event_wait_list() const {
  return stat_event_wait_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::ccd::CachedStatEvent >*
CachedUserDetails::mutable_stat_event_wait_list() {
  return &stat_event_wait_list_;
}

// optional bool enable_clouddoc_sync = 25 [default = true];
inline bool CachedUserDetails::has_enable_clouddoc_sync() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void CachedUserDetails::set_has_enable_clouddoc_sync() {
  _has_bits_[0] |= 0x00020000u;
}
inline void CachedUserDetails::clear_has_enable_clouddoc_sync() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void CachedUserDetails::clear_enable_clouddoc_sync() {
  enable_clouddoc_sync_ = true;
  clear_has_enable_clouddoc_sync();
}
inline bool CachedUserDetails::enable_clouddoc_sync() const {
  return enable_clouddoc_sync_;
}
inline void CachedUserDetails::set_enable_clouddoc_sync(bool value) {
  set_has_enable_clouddoc_sync();
  enable_clouddoc_sync_ = value;
}

// optional string mm_thumb_download_path = 34;
inline bool CachedUserDetails::has_mm_thumb_download_path() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void CachedUserDetails::set_has_mm_thumb_download_path() {
  _has_bits_[0] |= 0x00040000u;
}
inline void CachedUserDetails::clear_has_mm_thumb_download_path() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void CachedUserDetails::clear_mm_thumb_download_path() {
  if (mm_thumb_download_path_ != &::google::protobuf::internal::kEmptyString) {
    mm_thumb_download_path_->clear();
  }
  clear_has_mm_thumb_download_path();
}
inline const ::std::string& CachedUserDetails::mm_thumb_download_path() const {
  return *mm_thumb_download_path_;
}
inline void CachedUserDetails::set_mm_thumb_download_path(const ::std::string& value) {
  set_has_mm_thumb_download_path();
  if (mm_thumb_download_path_ == &::google::protobuf::internal::kEmptyString) {
    mm_thumb_download_path_ = new ::std::string;
  }
  mm_thumb_download_path_->assign(value);
}
inline void CachedUserDetails::set_mm_thumb_download_path(const char* value) {
  set_has_mm_thumb_download_path();
  if (mm_thumb_download_path_ == &::google::protobuf::internal::kEmptyString) {
    mm_thumb_download_path_ = new ::std::string;
  }
  mm_thumb_download_path_->assign(value);
}
inline void CachedUserDetails::set_mm_thumb_download_path(const char* value, size_t size) {
  set_has_mm_thumb_download_path();
  if (mm_thumb_download_path_ == &::google::protobuf::internal::kEmptyString) {
    mm_thumb_download_path_ = new ::std::string;
  }
  mm_thumb_download_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CachedUserDetails::mutable_mm_thumb_download_path() {
  set_has_mm_thumb_download_path();
  if (mm_thumb_download_path_ == &::google::protobuf::internal::kEmptyString) {
    mm_thumb_download_path_ = new ::std::string;
  }
  return mm_thumb_download_path_;
}
inline ::std::string* CachedUserDetails::release_mm_thumb_download_path() {
  clear_has_mm_thumb_download_path();
  if (mm_thumb_download_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mm_thumb_download_path_;
    mm_thumb_download_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .ccd.MediaMetadataThumbMigrateInternal migrate_mm_thumb_download_path = 35;
inline bool CachedUserDetails::has_migrate_mm_thumb_download_path() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void CachedUserDetails::set_has_migrate_mm_thumb_download_path() {
  _has_bits_[0] |= 0x00080000u;
}
inline void CachedUserDetails::clear_has_migrate_mm_thumb_download_path() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void CachedUserDetails::clear_migrate_mm_thumb_download_path() {
  if (migrate_mm_thumb_download_path_ != NULL) migrate_mm_thumb_download_path_->::ccd::MediaMetadataThumbMigrateInternal::Clear();
  clear_has_migrate_mm_thumb_download_path();
}
inline const ::ccd::MediaMetadataThumbMigrateInternal& CachedUserDetails::migrate_mm_thumb_download_path() const {
  return migrate_mm_thumb_download_path_ != NULL ? *migrate_mm_thumb_download_path_ : *default_instance_->migrate_mm_thumb_download_path_;
}
inline ::ccd::MediaMetadataThumbMigrateInternal* CachedUserDetails::mutable_migrate_mm_thumb_download_path() {
  set_has_migrate_mm_thumb_download_path();
  if (migrate_mm_thumb_download_path_ == NULL) migrate_mm_thumb_download_path_ = new ::ccd::MediaMetadataThumbMigrateInternal;
  return migrate_mm_thumb_download_path_;
}
inline ::ccd::MediaMetadataThumbMigrateInternal* CachedUserDetails::release_migrate_mm_thumb_download_path() {
  clear_has_migrate_mm_thumb_download_path();
  ::ccd::MediaMetadataThumbMigrateInternal* temp = migrate_mm_thumb_download_path_;
  migrate_mm_thumb_download_path_ = NULL;
  return temp;
}

// optional bool mm_thumb_sync_disabled = 36;
inline bool CachedUserDetails::has_mm_thumb_sync_disabled() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void CachedUserDetails::set_has_mm_thumb_sync_disabled() {
  _has_bits_[0] |= 0x00100000u;
}
inline void CachedUserDetails::clear_has_mm_thumb_sync_disabled() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void CachedUserDetails::clear_mm_thumb_sync_disabled() {
  mm_thumb_sync_disabled_ = false;
  clear_has_mm_thumb_sync_disabled();
}
inline bool CachedUserDetails::mm_thumb_sync_disabled() const {
  return mm_thumb_sync_disabled_;
}
inline void CachedUserDetails::set_mm_thumb_sync_disabled(bool value) {
  set_has_mm_thumb_sync_disabled();
  mm_thumb_sync_disabled_ = value;
}

// optional bool picstream_storage_conservation_dropping_mode = 37 [default = false];
inline bool CachedUserDetails::has_picstream_storage_conservation_dropping_mode() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void CachedUserDetails::set_has_picstream_storage_conservation_dropping_mode() {
  _has_bits_[0] |= 0x00200000u;
}
inline void CachedUserDetails::clear_has_picstream_storage_conservation_dropping_mode() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void CachedUserDetails::clear_picstream_storage_conservation_dropping_mode() {
  picstream_storage_conservation_dropping_mode_ = false;
  clear_has_picstream_storage_conservation_dropping_mode();
}
inline bool CachedUserDetails::picstream_storage_conservation_dropping_mode() const {
  return picstream_storage_conservation_dropping_mode_;
}
inline void CachedUserDetails::set_picstream_storage_conservation_dropping_mode(bool value) {
  set_has_picstream_storage_conservation_dropping_mode();
  picstream_storage_conservation_dropping_mode_ = value;
}

// repeated .ccd.SyncFeature_t mm_thumb_sync_disabled_types = 39;
inline int CachedUserDetails::mm_thumb_sync_disabled_types_size() const {
  return mm_thumb_sync_disabled_types_.size();
}
inline void CachedUserDetails::clear_mm_thumb_sync_disabled_types() {
  mm_thumb_sync_disabled_types_.Clear();
}
inline ccd::SyncFeature_t CachedUserDetails::mm_thumb_sync_disabled_types(int index) const {
  return static_cast< ccd::SyncFeature_t >(mm_thumb_sync_disabled_types_.Get(index));
}
inline void CachedUserDetails::set_mm_thumb_sync_disabled_types(int index, ccd::SyncFeature_t value) {
  GOOGLE_DCHECK(ccd::SyncFeature_t_IsValid(value));
  mm_thumb_sync_disabled_types_.Set(index, value);
}
inline void CachedUserDetails::add_mm_thumb_sync_disabled_types(ccd::SyncFeature_t value) {
  GOOGLE_DCHECK(ccd::SyncFeature_t_IsValid(value));
  mm_thumb_sync_disabled_types_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
CachedUserDetails::mm_thumb_sync_disabled_types() const {
  return mm_thumb_sync_disabled_types_;
}
inline ::google::protobuf::RepeatedField<int>*
CachedUserDetails::mutable_mm_thumb_sync_disabled_types() {
  return &mm_thumb_sync_disabled_types_;
}

// optional bool mm_thumb_sync_converted = 40;
inline bool CachedUserDetails::has_mm_thumb_sync_converted() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void CachedUserDetails::set_has_mm_thumb_sync_converted() {
  _has_bits_[0] |= 0x00800000u;
}
inline void CachedUserDetails::clear_has_mm_thumb_sync_converted() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void CachedUserDetails::clear_mm_thumb_sync_converted() {
  mm_thumb_sync_converted_ = false;
  clear_has_mm_thumb_sync_converted();
}
inline bool CachedUserDetails::mm_thumb_sync_converted() const {
  return mm_thumb_sync_converted_;
}
inline void CachedUserDetails::set_mm_thumb_sync_converted(bool value) {
  set_has_mm_thumb_sync_converted();
  mm_thumb_sync_converted_ = value;
}

// optional .ccd.SyncBoxSettings syncbox_sync_settings = 42;
inline bool CachedUserDetails::has_syncbox_sync_settings() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void CachedUserDetails::set_has_syncbox_sync_settings() {
  _has_bits_[0] |= 0x01000000u;
}
inline void CachedUserDetails::clear_has_syncbox_sync_settings() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void CachedUserDetails::clear_syncbox_sync_settings() {
  if (syncbox_sync_settings_ != NULL) syncbox_sync_settings_->::ccd::SyncBoxSettings::Clear();
  clear_has_syncbox_sync_settings();
}
inline const ::ccd::SyncBoxSettings& CachedUserDetails::syncbox_sync_settings() const {
  return syncbox_sync_settings_ != NULL ? *syncbox_sync_settings_ : *default_instance_->syncbox_sync_settings_;
}
inline ::ccd::SyncBoxSettings* CachedUserDetails::mutable_syncbox_sync_settings() {
  set_has_syncbox_sync_settings();
  if (syncbox_sync_settings_ == NULL) syncbox_sync_settings_ = new ::ccd::SyncBoxSettings;
  return syncbox_sync_settings_;
}
inline ::ccd::SyncBoxSettings* CachedUserDetails::release_syncbox_sync_settings() {
  clear_has_syncbox_sync_settings();
  ::ccd::SyncBoxSettings* temp = syncbox_sync_settings_;
  syncbox_sync_settings_ = NULL;
  return temp;
}

// optional bool allow_syncbox_archive_storage_create_db = 43;
inline bool CachedUserDetails::has_allow_syncbox_archive_storage_create_db() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void CachedUserDetails::set_has_allow_syncbox_archive_storage_create_db() {
  _has_bits_[0] |= 0x02000000u;
}
inline void CachedUserDetails::clear_has_allow_syncbox_archive_storage_create_db() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void CachedUserDetails::clear_allow_syncbox_archive_storage_create_db() {
  allow_syncbox_archive_storage_create_db_ = false;
  clear_has_allow_syncbox_archive_storage_create_db();
}
inline bool CachedUserDetails::allow_syncbox_archive_storage_create_db() const {
  return allow_syncbox_archive_storage_create_db_;
}
inline void CachedUserDetails::set_allow_syncbox_archive_storage_create_db(bool value) {
  set_has_allow_syncbox_archive_storage_create_db();
  allow_syncbox_archive_storage_create_db_ = value;
}

// optional fixed64 need_to_recreate_syncbox_dataset = 44;
inline bool CachedUserDetails::has_need_to_recreate_syncbox_dataset() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void CachedUserDetails::set_has_need_to_recreate_syncbox_dataset() {
  _has_bits_[0] |= 0x04000000u;
}
inline void CachedUserDetails::clear_has_need_to_recreate_syncbox_dataset() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void CachedUserDetails::clear_need_to_recreate_syncbox_dataset() {
  need_to_recreate_syncbox_dataset_ = GOOGLE_ULONGLONG(0);
  clear_has_need_to_recreate_syncbox_dataset();
}
inline ::google::protobuf::uint64 CachedUserDetails::need_to_recreate_syncbox_dataset() const {
  return need_to_recreate_syncbox_dataset_;
}
inline void CachedUserDetails::set_need_to_recreate_syncbox_dataset(::google::protobuf::uint64 value) {
  set_has_need_to_recreate_syncbox_dataset();
  need_to_recreate_syncbox_dataset_ = value;
}

// optional fixed64 local_syncbox_archive_storage_dataset_id = 45;
inline bool CachedUserDetails::has_local_syncbox_archive_storage_dataset_id() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void CachedUserDetails::set_has_local_syncbox_archive_storage_dataset_id() {
  _has_bits_[0] |= 0x08000000u;
}
inline void CachedUserDetails::clear_has_local_syncbox_archive_storage_dataset_id() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void CachedUserDetails::clear_local_syncbox_archive_storage_dataset_id() {
  local_syncbox_archive_storage_dataset_id_ = GOOGLE_ULONGLONG(0);
  clear_has_local_syncbox_archive_storage_dataset_id();
}
inline ::google::protobuf::uint64 CachedUserDetails::local_syncbox_archive_storage_dataset_id() const {
  return local_syncbox_archive_storage_dataset_id_;
}
inline void CachedUserDetails::set_local_syncbox_archive_storage_dataset_id(::google::protobuf::uint64 value) {
  set_has_local_syncbox_archive_storage_dataset_id();
  local_syncbox_archive_storage_dataset_id_ = value;
}

// -------------------------------------------------------------------

// CachedUserData

// required .ccd.CachedUserSummary summary = 1;
inline bool CachedUserData::has_summary() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CachedUserData::set_has_summary() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CachedUserData::clear_has_summary() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CachedUserData::clear_summary() {
  if (summary_ != NULL) summary_->::ccd::CachedUserSummary::Clear();
  clear_has_summary();
}
inline const ::ccd::CachedUserSummary& CachedUserData::summary() const {
  return summary_ != NULL ? *summary_ : *default_instance_->summary_;
}
inline ::ccd::CachedUserSummary* CachedUserData::mutable_summary() {
  set_has_summary();
  if (summary_ == NULL) summary_ = new ::ccd::CachedUserSummary;
  return summary_;
}
inline ::ccd::CachedUserSummary* CachedUserData::release_summary() {
  clear_has_summary();
  ::ccd::CachedUserSummary* temp = summary_;
  summary_ = NULL;
  return temp;
}

// required .ccd.CachedUserDetails details = 2;
inline bool CachedUserData::has_details() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CachedUserData::set_has_details() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CachedUserData::clear_has_details() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CachedUserData::clear_details() {
  if (details_ != NULL) details_->::ccd::CachedUserDetails::Clear();
  clear_has_details();
}
inline const ::ccd::CachedUserDetails& CachedUserData::details() const {
  return details_ != NULL ? *details_ : *default_instance_->details_;
}
inline ::ccd::CachedUserDetails* CachedUserData::mutable_details() {
  set_has_details();
  if (details_ == NULL) details_ = new ::ccd::CachedUserDetails;
  return details_;
}
inline ::ccd::CachedUserDetails* CachedUserData::release_details() {
  clear_has_details();
  ::ccd::CachedUserDetails* temp = details_;
  details_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// CCDMainState

// optional fixed64 logged_in_user = 1 [default = 0];
inline bool CCDMainState::has_logged_in_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CCDMainState::set_has_logged_in_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CCDMainState::clear_has_logged_in_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CCDMainState::clear_logged_in_user() {
  logged_in_user_ = GOOGLE_ULONGLONG(0);
  clear_has_logged_in_user();
}
inline ::google::protobuf::uint64 CCDMainState::logged_in_user() const {
  return logged_in_user_;
}
inline void CCDMainState::set_logged_in_user(::google::protobuf::uint64 value) {
  set_has_logged_in_user();
  logged_in_user_ = value;
}

// optional int32 background_mode_interval_sec = 4 [default = -1];
inline bool CCDMainState::has_background_mode_interval_sec() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CCDMainState::set_has_background_mode_interval_sec() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CCDMainState::clear_has_background_mode_interval_sec() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CCDMainState::clear_background_mode_interval_sec() {
  background_mode_interval_sec_ = -1;
  clear_has_background_mode_interval_sec();
}
inline ::google::protobuf::int32 CCDMainState::background_mode_interval_sec() const {
  return background_mode_interval_sec_;
}
inline void CCDMainState::set_background_mode_interval_sec(::google::protobuf::int32 value) {
  set_has_background_mode_interval_sec();
  background_mode_interval_sec_ = value;
}

// repeated .ccd.LoggedOutUser logged_out_users = 5;
inline int CCDMainState::logged_out_users_size() const {
  return logged_out_users_.size();
}
inline void CCDMainState::clear_logged_out_users() {
  logged_out_users_.Clear();
}
inline const ::ccd::LoggedOutUser& CCDMainState::logged_out_users(int index) const {
  return logged_out_users_.Get(index);
}
inline ::ccd::LoggedOutUser* CCDMainState::mutable_logged_out_users(int index) {
  return logged_out_users_.Mutable(index);
}
inline ::ccd::LoggedOutUser* CCDMainState::add_logged_out_users() {
  return logged_out_users_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ccd::LoggedOutUser >&
CCDMainState::logged_out_users() const {
  return logged_out_users_;
}
inline ::google::protobuf::RepeatedPtrField< ::ccd::LoggedOutUser >*
CCDMainState::mutable_logged_out_users() {
  return &logged_out_users_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ccd

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ccd_5ftypes_2eproto__INCLUDED
