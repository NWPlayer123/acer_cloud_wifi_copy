//
//  Copyright 2010 iGware Inc.
//  All Rights Reserved.
//
//  THIS SOFTWARE CONTAINS CONFIDENTIAL INFORMATION AND
//  TRADE SECRETS OF IGWARE INC.
//  USE, DISCLOSURE OR REPRODUCTION IS PROHIBITED WITHOUT
//  THE PRIOR EXPRESS WRITTEN PERMISSION OF IGWARE INC.
//

//============================================================================
/// @file
/// Implementation of ccdi.hpp (the CCDI APIs that use types generated by Protocol Buffers).
//============================================================================

#include "ccdi.hpp"

#include "escore.h"
#include "log.h"
#include "vpl_fs.h"
#include "vpl_th.h"
#include "vpl_conv.h"
#include "vplex_http2.hpp"
#include "vplex_math.h"
#include "vplex_strings.h"
#include "vplex_protobuf_utils.hpp"
#include "scopeguard.hpp"

#include "ans_connection.hpp"
#include "ccd_core.h"
#include "ccd_core_service.hpp"
#include "ccd_features.h"
#include "ccd_storage.hpp"
#include "config.h"
#include "EventManagerPb.hpp"
#include "ias_query.hpp"
#include "McaThumbMigrate.hpp"
#include "MediaMetadata.hpp"
#include "MediaMetadataCache.hpp"
#include "netman.hpp"
#include "NotificationQ.hpp"
#include "SharedFiles.hpp"
#include "CloudDocMgr.hpp"
#include "picstream.hpp"
#include "query.h"
#include "DeviceStateCache.hpp"
#if CCD_ENABLE_SYNCDOWN
#include "SyncDown.hpp"
#endif
#include "SyncFeatureMgr.hpp"
#if CCD_ENABLE_SYNCUP
#include "SyncUp.hpp"
#endif
#include "system_query.hpp"
#include "virtual_device.hpp"
#include "vsds_query.hpp"
#include "sw_update.hpp"
#include "HttpService.hpp"
#define ts_ns 
#include "ts_server.hpp"
#include "ts_ext_server.hpp"
#include "LanDeviceInfoCache.hpp"
#include "vssi.h"
#include "vssi_error.h"

#if CCD_ENABLE_STORAGE_NODE
#include "vss_server.hpp"
#include "executable_manager.hpp"
#endif

#if CCD_ENABLE_MEDIA_SERVER_AGENT
// bug 9230, to merge MSA APIs to CCDI
#include "MediaMetadataServer.hpp"
#endif 

#if defined(WIN32) && !defined(VPL_PLAT_IS_WINRT)
#include <Sddl.h>
#include "vpl_fs.h"
#endif

#if CCD_USE_SHARED_CREDENTIALS
#include "vplex_shared_object.h"
#include "vplex_shared_credential.hpp"
#endif 
#include "StatManager.hpp"

#include <sstream>
#include <algorithm>
#include <set>
#include "protobuf_file_writer.hpp"

#if CCD_USE_PROTORPC
  // CCDIService::handleRpc will already do the logging.
# define LOG_CCDI_REQUEST(request_)  LOG_FUNC_ENTRY(LOG_LEVEL_DEBUG)
# define LOG_CCDI_RESPONSE(response_, rv)
#else
  // Manually log the CCDI request and response (since there is no RPC layer to do this).
# define LOG_CCDI_REQUEST(request_) \
    CCDProtobufRpcDebugRequestCallback(__func__, true, request_)
# define LOG_CCDI_RESPONSE(response_, rv_) \
    BEGIN_MULTI_STATEMENT_MACRO \
    RpcStatus status; \
    status.set_appstatus(rv_); \
    CCDProtobufRpcDebugResponseCallback(__func__, status, &response_); \
    END_MULTI_STATEMENT_MACRO
#endif

using namespace ccd;
using namespace std;

namespace ccdi {
namespace client {

//----------------------------------------------------------------------------
// Helper functions
//----------------------------------------------------------------------------

#if CCD_USE_SHARED_CREDENTIALS
static CCDIError clearLocalDeviceCredentials()
{
    s32 rv = CCD_OK;
    LOG_INFO("Logging out and clearing local device credentials.");
    int playerindex = 0;
    VPLUser_Id_t userId = VPLUSER_ID_NONE;
    Cache_Logout(playerindex, userId, false, LOGOUT_REASON_SHARED_CREDENTIALS_REMOVED);
    VirtualDevice_ClearLocalDeviceCredentials();
    // TODO: Bug 4571: Need to remove the deviceId from ESCore to avoid contaminating the user's account with the
    //       wrong device.  The best we can do now is crash on purpose...
    LOG_ERROR("Need to reset the deviceId, but that cannot be done currently");
    volatile s32* crash = NULL;
    rv = *crash;
    //ESCore_RemoveCredentials();
    return rv;
}
#endif

//----------------------------------------------------------------------------
// CCDI
//----------------------------------------------------------------------------

static string
getCreatedForDeviceStr(u64 deviceId)
{
    char tempBuf[32];
    snprintf(tempBuf, ARRAY_SIZE_IN_BYTES(tempBuf), "d_"FMTx64, deviceId);
    return string(tempBuf);
}

static CCDIError
addCameraDataset(ServiceSessionInfo_t &session,
                 u64 user_id, const string &dataset_name,
                 u64 &dataset_id)
{
    s32 rv = 0;

    u64 deviceId;
    rv = ESCore_GetDeviceGuid(&deviceId);
    if (rv != 0) {
        LOG_ERROR("ESCore_GetDeviceGuid failed: %d", rv);
        return rv;
    }

    vplex::vsDirectory::AddCameraDatasetInput vsds_request;
    vplex::vsDirectory::AddCameraDatasetOutput vsds_response;
    Query_FillInVsdsSession(vsds_request.mutable_session(), session);
    vsds_request.set_userid(user_id);
    vsds_request.set_datasetname(dataset_name);
    vsds_request.set_createdfor(getCreatedForDeviceStr(deviceId));
    rv = QUERY_VSDS(VPLVsDirectory_AddCameraDataset, vsds_request, vsds_response);
    if (rv != 0) {
        LOG_ERROR("VPLVsDirectory_AddCameraDataset failed: %d, dataset=%s, user="FMT_VPLUser_Id_t,
                  rv, dataset_name.c_str(), user_id);
        return rv;
    }

    dataset_id = vsds_response.datasetid();
    
    return rv;
}

static CCDIError
findFirstStorage(ServiceSessionInfo_t &session, 
                 u64 user_id, s32 storage_type, 
                 u64 &storage_id)
{
    s32 rv = 0;

    vplex::vsDirectory::ListUserStorageInput vsds_request;
    vplex::vsDirectory::ListUserStorageOutput vsds_response;
    Query_FillInVsdsSession(vsds_request.mutable_session(), session);
    vsds_request.set_userid(user_id);
    rv = QUERY_VSDS(VPLVsDirectory_ListUserStorage, vsds_request, vsds_response);
    if (rv != 0) {
        LOG_ERROR("VPLVsDirectory_ListUserStorage failed: %d, uid="FMT_VPLUser_Id_t" type=%d", 
                  rv, user_id, storage_type);
        return rv;
    }

    for (int i = 0; i < vsds_response.storageassignments_size(); i++) {
        if (vsds_response.storageassignments(i).storagetype() == storage_type) {
            storage_id = vsds_response.storageassignments(i).storageclusterid();
            return 0;
        }
    }

    LOG_ERROR("Storage not found: uid="FMT_VPLUser_Id_t" type=%d", 
              user_id, storage_type);
    return CCDI_ERROR_FAIL;
}

static CCDIError
addDatasetToStorage(ServiceSessionInfo_t &session, 
                    u64 user_id, u64 storage_id, const string &dataset_name, vplex::vsDirectory::DatasetType dataset_type, 
                    u64 &dataset_id)
{
    s32 rv = 0;

    vplex::vsDirectory::AddDataSetInput vsds_request;
    vplex::vsDirectory::AddDataSetOutput vsds_response;
    Query_FillInVsdsSession(vsds_request.mutable_session(), session);
    vsds_request.set_userid(user_id);
    vsds_request.set_datasetname(dataset_name);
    vsds_request.set_datasettypeid(dataset_type);
    vsds_request.set_storageclusterid(storage_id);
    rv = QUERY_VSDS(VPLVsDirectory_AddDataSet, vsds_request, vsds_response);
    if (rv != 0) {
        LOG_ERROR("VPLVsDirectory_AddDataSet failed: %d, uid="FMT_VPLUser_Id_t" sid=%"PRIx64" dname=%s dtype=%u",
                  rv, user_id, storage_id, dataset_name.c_str(), dataset_type);
        return rv;
    }

    dataset_id = vsds_response.datasetid();

    return rv;
}

static CCDIError
addSimpleDataset(ServiceSessionInfo_t &session,
                 u64 user_id, s32 storage_type, const string &dataset_name, vplex::vsDirectory::DatasetType dataset_type, 
                 u64 &dataset_id)
{
    s32 rv = 0;

    u64 storage_id = 0;
    rv = findFirstStorage(session, user_id, storage_type, storage_id);
    if (rv == 0) {
        rv = addDatasetToStorage(session, user_id, storage_id, dataset_name, dataset_type, dataset_id);
    }

    return rv;
}

CCDIError CCDIAddDataset(const ccd::AddDatasetInput& request,
                         ccd::AddDatasetOutput& response)
{
    LOG_CCDI_REQUEST(request);
    s32 rv;

    ServiceSessionInfo_t session;
    rv = Cache_GetSessionForVsdsByUser(request.user_id(), session);
    if(rv != 0) {
        LOG_ERROR("Could not get session for user:"FMT_VPLUser_Id_t, request.user_id());
        return rv;
    }

    u64 dataset_id = 0;
    if (request.dataset_type() == NEW_DATASET_TYPE_CAMERA) {
        rv = addCameraDataset(session, request.user_id(), request.dataset_name(), dataset_id);
    } else if (request.dataset_type() == NEW_DATASET_TYPE_MEDIA) {
        rv = addSimpleDataset(session, request.user_id(), /*storage_type=PSN*/1, request.dataset_name(), vplex::vsDirectory::MEDIA, dataset_id);
    } else if (request.dataset_type() == NEW_DATASET_TYPE_USER) {
        rv = addSimpleDataset(session, request.user_id(), /*storage_type=PSN*/1, request.dataset_name(), vplex::vsDirectory::USER, dataset_id);
    } else if (request.dataset_type() == NEW_DATASET_TYPE_CACHE) {
        rv = addSimpleDataset(session, request.user_id(), /*storage_type=DATACENTER*/0, request.dataset_name(), vplex::vsDirectory::CACHE, dataset_id);
    } else if (request.dataset_type() == NEW_DATASET_TYPE_FS) {
        rv = addSimpleDataset(session, request.user_id(), /*storage_type=PSN*/1, request.dataset_name(), vplex::vsDirectory::FS, dataset_id);
    } else {
        LOG_ERROR("Unsupported type: %d", request.dataset_type());
        rv = CCDI_ERROR_PARAMETER;
    }

    if (rv == 0) {
        response.set_dataset_id(dataset_id);
        // TODO: should really be using the activationId instead of user_id, since we released the lock
        CacheMonitor_MarkDatasetsDirty(request.user_id());
    }
    LOG_CCDI_RESPONSE(response, rv);
    return rv;
}

CCDIError CCDIAddSyncSubscription(const ccd::AddSyncSubscriptionInput& request)
{
    LOG_CCDI_REQUEST(request);
    int rv;
    u32 activationId;

    rv = Cache_GetActivationIdForSyncUser(&activationId, request.has_user_id(), request.user_id());
    if (rv != 0) {
        goto out;
    }
    rv = CacheMonitor_UpdateIfNeeded(activationId, CCD_USER_DATA_DATASETS_ONLY);
    if(rv != 0) {
        goto out;
    }
    {
        ServiceSessionInfo_t session;
        rv = Cache_GetSessionForVsdsByUser(request.user_id(), session);
        if(rv != 0) {
            LOG_ERROR("Could not get session for user:"FMT_VPLUser_Id_t, request.user_id());
            goto out;
        }

        u64 deviceId;
        if(request.has_device_id()) {
            deviceId = request.device_id();
        } else {
            rv = ESCore_GetDeviceGuid(&deviceId);
            if(rv != 0) {
                LOG_ERROR("ESCore_GetDeviceGuid failed: %d", rv);
                goto out;
            }
        }

        // Get dataset type from dataset details for requested dataset
        vplex::vsDirectory::DatasetType datasetType;
        {
            // TODO: API to get the dataset details by ID from cache
            CacheAutoLock autoLock;
            rv = autoLock.LockForRead();
            if (rv < 0) {
                LOG_ERROR("Failed to obtain lock");
                goto out;
            }
            CachePlayer* user = cache_getUserByUserId(request.user_id());
            if (user == NULL) {
                LOG_ERROR("user "FMT_VPLUser_Id_t" not signed-in", request.user_id());
                rv = CCD_ERROR_NOT_SIGNED_IN;
                goto out;
            }

            const vplex::vsDirectory::DatasetDetail* datasetDetail =
                    user->getDatasetDetail(request.dataset_id());
            if(datasetDetail == NULL) {
                LOG_ERROR("User "FMT_VPLUser_Id_t" does not have dataset "FMTx64".",
                          request.user_id(), request.dataset_id());
                rv = CCD_ERROR_DATASET_NOT_FOUND;
                goto out;
            }
            datasetType = datasetDetail->datasettype();
        }

        vplex::vsDirectory::AddDatasetSubscriptionInput vsds_request;
        Query_FillInVsdsSession(vsds_request.mutable_session(), session);
        vsds_request.set_userid(request.user_id());
        vsds_request.set_deviceid(deviceId);
        vsds_request.set_datasetid(request.dataset_id());
        vsds_request.set_datasettype(datasetType);
        switch(request.subscription_type()) {
        case SUBSCRIPTION_TYPE_NORMAL:
            vsds_request.set_role(vplex::vsDirectory::GENERAL);
            break;
        case SUBSCRIPTION_TYPE_CAMERA: // deprecated
        case SUBSCRIPTION_TYPE_PRODUCER:
            vsds_request.set_role(vplex::vsDirectory::PRODUCER);
            break;
        case SUBSCRIPTION_TYPE_CONSUMER:
            vsds_request.set_role(vplex::vsDirectory::CONSUMER);
            break;
        case SUBSCRIPTION_TYPE_CLEARFI_SERVER:
            vsds_request.set_role(vplex::vsDirectory::CLEARFI_SERVER);
            break;
        case SUBSCRIPTION_TYPE_CLEARFI_CLIENT:
            vsds_request.set_role(vplex::vsDirectory::CLEARFI_CLIENT);
            break;
        default:
            rv = CCD_ERROR_PARAMETER;
            goto out;
        }
        if(request.has_device_root()) {
            vsds_request.set_deviceroot(request.device_root());
        }
        if(request.has_filter()) {
            vsds_request.set_filter(request.filter());
        }
        if(request.has_max_size()) {
            vsds_request.set_maxsize(request.max_size());
        }
        if(request.has_max_files()) {
            vsds_request.set_maxfiles(request.max_files());
        }
        LOG_INFO("Query_AddDatasetSubscription userId:"FMT_VPLUser_Id_t" deviceId:"FMTx64,
                 request.user_id(), request.device_id());
        vplex::vsDirectory::AddDatasetSubscriptionOutput vsds_response;
        rv = QUERY_VSDS(VPLVsDirectory_AddDatasetSubscription, vsds_request, vsds_response);
        if(rv != 0) {
            goto out;
        }
        CacheMonitor_MarkSubscriptionsDirty(request.user_id());
    }
 out:
    LOG_CCDI_RESPONSE(ccd::NoParamResponse::default_instance(), rv);
    return rv;
}


CCDIError CCDIDeleteDataset(const ccd::DeleteDatasetInput& request)
{
    LOG_CCDI_REQUEST(request);
    s32 rv = 0;
    {
        ServiceSessionInfo_t session;
        rv = Cache_GetSessionForVsdsByUser(request.user_id(), session);
        if(rv != 0) {
            LOG_ERROR("Could not get session for user:"FMT_VPLUser_Id_t, request.user_id());
            goto out;
        }

        vplex::vsDirectory::DeleteDataSetInput vsds_request;
        vplex::vsDirectory::DeleteDataSetOutput vsds_response;
        Query_FillInVsdsSession(vsds_request.mutable_session(), session);
        vsds_request.set_userid(request.user_id());
        vsds_request.set_datasetid(request.dataset_id());
        rv = QUERY_VSDS(VPLVsDirectory_DeleteDataSet, vsds_request, vsds_response);
        if (rv != 0) {
            LOG_ERROR("VPLVsDirectory_DeleteDataSet failed: %d, uid="FMT_VPLUser_Id_t" did=%"PRIx64,
                      rv, request.user_id(), request.dataset_id());
            goto out;
        }

        CacheMonitor_MarkDatasetsDirty(request.user_id());
    }
 out:
    LOG_CCDI_RESPONSE(ccd::NoParamResponse::default_instance(), rv);
    return rv;
}

CCDIError CCDIEventsCreateQueue(
        const ccd::EventsCreateQueueInput& request,
        ccd::EventsCreateQueueOutput& response)
{
    LOG_CCDI_REQUEST(request);
    u64 newHandle;
    int rv = EventManagerPb_CreateQueue(&newHandle);
    if (rv == 0) {
        response.set_queue_handle(newHandle);
    }
    LOG_CCDI_RESPONSE(response, rv);
    return rv;
}

CCDIError CCDIEventsDestroyQueue(
        const ccd::EventsDestroyQueueInput& request)
{
    LOG_CCDI_REQUEST(request);
    CCDIError rv = EventManagerPb_DestroyQueue(request.queue_handle());
    LOG_CCDI_RESPONSE(ccd::NoParamResponse::default_instance(), rv);
    return rv;
}

CCDIError CCDIEventsDequeue(
        const ccd::EventsDequeueInput& request,
        ccd::EventsDequeueOutput& response)
{
    LOG_CCDI_REQUEST(request);
    int rv = EventManagerPb_GetEvents(request.queue_handle(), request.max_count(),
            request.timeout(), response.mutable_events());
    LOG_CCDI_RESPONSE(response, rv);
    return rv;
}

CCDIError CCDIListUserStorage(const ccd::ListUserStorageInput& request,
        ccd::ListUserStorageOutput& response)
{
    LOG_CCDI_REQUEST(request);
    int rv;
    u32 activationId;

    rv = Cache_GetActivationIdForSyncUser(&activationId, request.has_user_id(), request.user_id());
    if (rv != 0) {
        goto out;
    }
    if (!request.only_use_cache()) {
        rv = CacheMonitor_UpdateIfNeeded(activationId, CCD_USER_DATA_UPDATE_DEVICES);
        if (rv != 0) {
            LOG_ERROR("CacheMonitor_UpdateIfNeeded failed: %d", rv);
            goto out;
        }
    }
    // Return the results from the cache.
    {
        CacheAutoLock autoLock;
        rv = autoLock.LockForRead();
        if (rv < 0) {
            LOG_ERROR("Failed to obtain lock");
            goto out;
        }
        CachePlayer* user = cache_getUserByActivationId(activationId);
        if (user == NULL) {
            LOG_INFO("User is no longer logged in");
            rv = CCD_ERROR_NOT_SIGNED_IN;
            goto out;
        }
        const google::protobuf::RepeatedPtrField<vplex::vsDirectory::UserStorage>& userStorage =
                user->_cachedData.details().cached_user_storage();
        *(response.mutable_user_storage()) = userStorage;
    }
out:
    LOG_CCDI_RESPONSE(response, rv);
    return rv;
}


CCDIError CCDISWUpdateCheck(const ccd::SWUpdateCheckInput& request,
                            ccd::SWUpdateCheckOutput& response)
{
    LOG_CCDI_REQUEST(request);
    int rv;
    u64 update_mask;
    u64 app_size;
    string latest_version;
    string latest_ccd_version;
    string change_log;
    bool update_cache = false;
    bool isQA = false;
    bool isAutoUpdateDisabled = false;
    bool isInfraDownload = false;

    if ( request.has_update_cache() ) {
        update_cache = request.update_cache();
    }
    rv = SWUpdateCheck(request.app_guid(), request.app_version(), update_cache,
        update_mask, app_size, latest_version, change_log, latest_ccd_version, isAutoUpdateDisabled, isQA, isInfraDownload, __ccdConfig.userGroup);
    if ( rv ) {
        LOG_ERROR("app_guid %s version %s returned %d",
            request.app_guid().c_str(), request.app_version().c_str(), rv);
        goto done;
    }
    response.set_update_mask(update_mask);
    response.set_app_size(app_size);
    response.set_latest_app_version(latest_version);
    response.set_change_log(change_log);
    response.set_latest_ccd_version(latest_ccd_version);
    response.set_is_qa(isQA);
    response.set_is_auto_update_disabled(isAutoUpdateDisabled);

    // controlled release was rolled back.
    // see https://bugs.ctbg.acer.com/show_bug.cgi?id=18192
    //response.set_is_infra_download(isInfraDownload);

    rv = 0;
done:
    LOG_CCDI_RESPONSE(response, rv);
    return rv;
}

CCDIError CCDISWUpdateBeginDownload(
    const ccd::SWUpdateBeginDownloadInput& request,
    ccd::SWUpdateBeginDownloadOutput& response)
{
    LOG_CCDI_REQUEST(request);
    int rv;
    u64 handle;

    rv = SWUpdateBeginDownload(request.app_guid(), request.app_version(),
        handle);
    if ( rv ) {
        LOG_ERROR("app_guid %s version %s returned %d",
            request.app_guid().c_str(), request.app_version().c_str(), rv);
        goto done;
    }
    response.set_handle(handle);

    rv = 0;
done:
    LOG_CCDI_RESPONSE(response, rv);
    return rv;
}

CCDIError CCDISWUpdateGetDownloadProgress(
    const ccd::SWUpdateGetDownloadProgressInput& request,
    ccd::SWUpdateGetDownloadProgressOutput& response)
{
    LOG_CCDI_REQUEST(request);
    int rv;
    u64 tot_xfer_size;
    u64 tot_xferred;
    ccd::SWUpdateDownloadState_t state;

    rv = SWUpdateGetDownloadProgress(request.handle(), tot_xfer_size,
        tot_xferred, state);
    if ( rv ) {
        LOG_ERROR("handle" FMT0x64 " returned %d", request.handle(), rv);
        goto done;
    }
    response.set_total_transfer_size(tot_xfer_size);
    response.set_bytes_transferred_cnt(tot_xferred);
    response.set_state(state);

    rv = 0;
done:
    LOG_CCDI_RESPONSE(response, rv);
    return rv;
}

CCDIError CCDISWUpdateEndDownload(const ccd::SWUpdateEndDownloadInput& request)
{
    LOG_CCDI_REQUEST(request);
    CCDIError rv = SWUpdateEndDownload(request.handle(), request.file_location());
    LOG_CCDI_RESPONSE(ccd::NoParamResponse::default_instance(), rv);
    return rv;
}

CCDIError CCDISWUpdateCancelDownload(const ccd::SWUpdateCancelDownloadInput& request)
{
    LOG_CCDI_REQUEST(request);
    CCDIError rv = SWUpdateCancelDownload(request.handle());
    LOG_CCDI_RESPONSE(ccd::NoParamResponse::default_instance(), rv);
    return rv;
}


CCDIError CCDISWUpdateSetCcdVersion(const ccd::SWUpdateSetCcdVersionInput& request)
{
    LOG_CCDI_REQUEST(request);
    CCDIError rv = SWUpdateSetCcdVersion(request.ccd_guid(), request.ccd_version());
    LOG_CCDI_RESPONSE(ccd::NoParamResponse::default_instance(), rv);
    return rv;
}

CCDIError CCDIDeleteSyncSubscriptions(const ccd::DeleteSyncSubscriptionsInput& request)
{
    LOG_CCDI_REQUEST(request);
    int rv = 0;
    UserSession session;
    vplex::vsDirectory::DeleteSubscriptionsOutput response;
    u64 deviceId;
    std::vector<u64> datasetIds;

    rv = Cache_GetSessionByUser(request.user_id(), session);
    if(rv != 0) {
        LOG_ERROR("Could not get session for user:"FMT_VPLUser_Id_t, request.user_id());
        goto out;
    }

    if(request.has_device_id()) {
        deviceId = request.device_id();
    }else{
        rv = ESCore_GetDeviceGuid(&deviceId);
        if(rv != 0) {
            LOG_ERROR("ESCore_GetDeviceGuid failed: %d", rv);
            goto out;
        }
    }

    // TODO: Should we stop sync agent first?  Otherwise, we may see errors when SyncAgent attempts
    //   to contact VSS, right?
    
    for(int didIndex = 0; didIndex < request.dataset_ids_size(); didIndex++) {
        datasetIds.push_back(request.dataset_ids(didIndex));
    }

    rv = Query_DeleteSubscriptions(request.user_id(),
                                   session,
                                   deviceId,
                                   datasetIds,
                                   response);
    if(rv!=0) {
        LOG_ERROR("Unsuccessful call to Query_DeleteSubscriptions user "FMT_VPLUser_Id_t,
                  request.user_id());
        goto out;
    }
    CacheMonitor_MarkSubscriptionsDirty(request.user_id());
 out:
    LOG_CCDI_RESPONSE(ccd::NoParamResponse::default_instance(), rv);
    return rv;
}

CCDIError CCDIGetDatasetDirectoryEntries(
            const ccd::GetDatasetDirectoryEntriesInput& request,
            ccd::GetDatasetDirectoryEntriesOutput& response)
{
    LOG_CCDI_REQUEST(request);
    CCDIError rv = CCD_ERROR_NOT_IMPLEMENTED;
    LOG_ERROR("NOT IMPLEMENTED");
    LOG_CCDI_RESPONSE(response, rv);
    return rv;
}

CCDIError CCDIGetInfraHttpInfo(const ccd::GetInfraHttpInfoInput& request, ccd::GetInfraHttpInfoOutput& response)
{
    LOG_CCDI_REQUEST(request);
    s32 rv;

    CacheAutoLock autoLock;
    rv = autoLock.LockForRead();
    if (rv < 0) {
        LOG_ERROR("Failed to obtain lock");
        goto out;
    }
    else {
        CachePlayer* user = NULL;
        if (request.has_user_id()) {
            user = cache_getUserByUserId(request.user_id());
            if (user == NULL) {
                LOG_ERROR("userId "FMT_VPLUser_Id_t" not signed in", request.user_id());
                rv = CCD_ERROR_NOT_SIGNED_IN;
                goto out;
            }

            // Session handle
            {
                std::ostringstream temp1;
                // Infrastructure expects this as a signed value, presumably because Java lacks
                // unsigned types.
                temp1 << static_cast<s64>(user->getSession().session_handle());
                response.set_session_handle(temp1.str());
            }

            // Service ticket
            {
                std::string ticket;
                switch (request.service())
                {
                case INFRA_HTTP_SERVICE_VCS:
                    ticket = user->getSession().vs_ticket();
                    break;
                case INFRA_HTTP_SERVICE_OPS:
                case INFRA_HTTP_SERVICE_OPS_CENTRAL:
                case INFRA_HTTP_SERVICE_OPS_REGIONAL:
                default:
                    ticket = user->getSession().ops_ticket();
                    break;
                }

                // TODO: duplicated in CCDIInfraHttpRequest(), refactor.
                char* ticket64;
                rv = Util_EncodeBase64(ticket.data(), ticket.size(),
                                       &ticket64, NULL, VPL_FALSE, VPL_FALSE);
                if (rv < 0) {
                    LOG_ERROR("error %d when generating service ticket", rv);
                    goto out;
                }
                ON_BLOCK_EXIT(free, ticket64);
                response.set_service_ticket(ticket64);
            }
        }

        std::ostringstream urlPrefix;
        rv = Query_GetUrlPrefix(urlPrefix, request.service(), request.secure(), user);
        if (rv != 0) {
            LOG_ERROR("%s failed: %d", "Query_GetUrlPrefix", rv);
            goto out;
        }
        response.set_url_prefix(urlPrefix.str());
    }
out:
    LOG_CCDI_RESPONSE(response, rv);
    return rv;
}

CCDIError CCDIGetLocalHttpInfo(const ccd::GetLocalHttpInfoInput& request, ccd::GetLocalHttpInfoOutput& response)
{
    LOG_CCDI_REQUEST(request);
    s32 rv;

    CacheAutoLock autoLock;
    rv = autoLock.LockForRead();
    if (rv < 0) {
        LOG_ERROR("Failed to obtain lock");
        goto out;
    }
    else {
        CachePlayer* user = NULL;
        user = cache_getUserByUserId(request.user_id());
        if (user == NULL) {
            LOG_ERROR("userId "FMT_VPLUser_Id_t" not signed in", request.user_id());
            rv = CCD_ERROR_NOT_SIGNED_IN;
            goto out;
        }

        // Session handle
        {
            std::ostringstream temp1;
            // Infrastructure expects this as a signed value, presumably because Java lacks
            // unsigned types.
            temp1 << static_cast<s64>(user->getSession().session_handle());
            response.set_session_handle(temp1.str());
        }

        // Service ticket
        {
            char* ticket64;
            // TODO: service ticket should be dynamic, based on which service type was selected.
            rv = Util_EncodeBase64(user->getSession().vs_ticket().data(), user->getSession().vs_ticket().size(),
                                   &ticket64, NULL, VPL_FALSE, VPL_FALSE);
            if (rv < 0) {
                LOG_ERROR("error %d when generating service ticket", rv);
                goto out;
            }
            ON_BLOCK_EXIT(free, ticket64);
            response.set_service_ticket(ticket64);
        }

        std::ostringstream urlPrefix;
        rv = Query_GetUrlPrefix(urlPrefix, request.service());
        if (rv != 0) {
            LOG_ERROR("%s failed: %d", "Query_GetUrlPrefix", rv);
            goto out;
        }
        response.set_url_prefix(urlPrefix.str());
    }
out:
    LOG_CCDI_RESPONSE(response, rv);
    return rv;
}

CCDIError CCDIGetPersonalCloudState(const ccd::GetPersonalCloudStateInput& request,
        ccd::GetPersonalCloudStateOutput& response)
{
    LOG_CCDI_REQUEST(request);
    s32 rv = CCD_OK;
    // TODO: should really be using the activationId instead of user_id, since we release the lock
    //   between steps
    {
        if (!request.only_use_cache()) {
            if (request.has_list_storage_nodes()) {
                rv = CacheMonitor_UpdateIfNeeded(true, request.user_id(), CCD_USER_DATA_STORAGE_NODES_ONLY);
                if (rv != 0) {
                    LOG_ERROR("%s failed: %d", "CacheMonitor_UpdateIfNeeded", rv);
                    goto out;
                }
            }
            if (request.get_device_connection_status_size() > 0) {
                rv = CacheMonitor_UpdateIfNeeded(true, request.user_id(), CCD_USER_DATA_LINKED_DEVICES_ONLY);
                if (rv != 0) {
                    LOG_ERROR("%s failed: %d", "CacheMonitor_UpdateIfNeeded", rv);
                    goto out;
                }
            }
        }

        ServiceSessionInfo_t session;
        rv = Cache_GetSessionForVsdsByUser(request.user_id(), session);
        if (rv != 0) {
            LOG_ERROR("Could not get session for user:"FMT_VPLUser_Id_t, request.user_id());
            goto out;
        }
        if (request.has_get_infra_storage_quota()) {
            // TODO: implement
            rv = CCD_ERROR_NOT_IMPLEMENTED;
            goto out;
        }
        if (request.has_list_storage_nodes()) {
            DeviceStateCache_GetStorageNodes(request.user_id(), *response.mutable_storage_nodes());
        }
        for (int i = 0; i < request.get_device_connection_status_size(); i++) {
            u64 currDeviceId = request.get_device_connection_status(i);
            *response.add_device_connection_status() = DeviceStateCache_GetDeviceStatus(currDeviceId);
        }
    }
out:
    LOG_CCDI_RESPONSE(response, rv);
    return rv;
}

static CCDIError getPicstreamDatasetId(CachePlayer* user, u64& datasetId)
{
    ASSERT(Cache_ThreadHasLock());
    datasetId = 0;
    const ccd::CachedUserDetails& userDetails = user->_cachedData.details();
    for (int i = 0; i < userDetails.datasets_size(); i++) {
        if (userDetails.datasets(i).details().datasetname() ==  "PicStream") {
            datasetId = userDetails.datasets(i).details().datasetid();
            return 0;
        }
    }
    LOG_ERROR("Picstream dataset not found.");
    return CCD_ERROR_NOT_FOUND;
}

// Dataset sync status is basically here for picstream for legacy.
// Prefer to get state by sync feature.
static void getPicstreamDatasetStatus(CachePlayer* user,
                                      u64 datasetId,
                                      ccd::DatasetSyncStateSummary& summary_out)
{
    summary_out.Clear();
    summary_out.set_status(ccd::CCD_SYNC_STATE_OUT_OF_SYNC);

    bool hasUpload = false;
    bool hasFullResDown = false;
    bool hasLowResDown = false;
    ccd::FeatureSyncStateSummary uploadFeature;
    ccd::FeatureSyncStateSummary fullResDownFeature;
    ccd::FeatureSyncStateSummary lowResDownFeature;
    uploadFeature.set_status(ccd::CCD_FEATURE_STATE_OUT_OF_SYNC);
    fullResDownFeature.set_status(ccd::CCD_FEATURE_STATE_OUT_OF_SYNC);
    lowResDownFeature.set_status(ccd::CCD_FEATURE_STATE_OUT_OF_SYNC);

    int rc;
#if CCD_ENABLE_SYNCUP
    {
        google::protobuf::RepeatedPtrField<ccd::PicstreamDir> cameraUploadDirs;
        user->get_camera_upload_dirs(&cameraUploadDirs);
        if(cameraUploadDirs.size() > 0) {
            hasUpload = true;
            rc = SyncUp_QueryStatus(user->user_id(),
                                    datasetId,
                                    "",
                                    uploadFeature);
            if(rc != 0) {
                LOG_ERROR("SyncUp_QueryStatus:%d", rc);
                summary_out.set_status(ccd::CCD_SYNC_STATE_OUT_OF_SYNC);
            }
        }
    }
#endif // CCD_ENABLE_SYNCUP
#if CCD_ENABLE_SYNCDOWN
    google::protobuf::RepeatedPtrField<ccd::CameraRollDownloadDirSpecInternal> picstream_download_dirs_full_res;
    user->get_camera_download_full_res_dirs(picstream_download_dirs_full_res);
    if(picstream_download_dirs_full_res.size() > 0) {
        hasFullResDown = true;
        rc = SyncDown_QueryStatus(user->user_id(),
                                  datasetId,
                                  picstream_download_dirs_full_res.Get(0).dir(),
                                  fullResDownFeature);
        if(rc != 0) {
            LOG_ERROR("SyncDown_QueryStatus("FMTu64","FMTu64",%s):%d",
                      user->user_id(),
                      datasetId,
                      picstream_download_dirs_full_res.Get(0).dir().c_str(),
                      rc);
        }
    }
    google::protobuf::RepeatedPtrField<ccd::CameraRollDownloadDirSpecInternal> picstream_download_dirs_low_res;
    user->get_camera_download_low_res_dirs(picstream_download_dirs_low_res);
    if(picstream_download_dirs_low_res.size() > 0) {
        hasLowResDown = true;
        rc = SyncDown_QueryStatus(user->user_id(),
                                  datasetId,
                                  picstream_download_dirs_low_res.Get(0).dir(),
                                  lowResDownFeature);
        if(rc != 0) {
            LOG_ERROR("SyncDown_QueryStatus("FMTu64","FMTu64",%s):%d",
                      user->user_id(),
                      datasetId,
                      picstream_download_dirs_low_res.Get(0).dir().c_str(),
                      rc);
        }
    }
#endif // CCD_ENABLE_SYNCDOWN

    if(!hasUpload && !hasFullResDown && !hasLowResDown) {
        // Nothing initialized, leave summary_out as OUT_OF_SYNC
    }else if(
        (!hasUpload ||
         (hasUpload &&
             ccd::CCD_FEATURE_STATE_IN_SYNC == uploadFeature.status())) &&
        (!hasFullResDown ||
         (hasFullResDown &&
             ccd::CCD_FEATURE_STATE_IN_SYNC == fullResDownFeature.status())) &&
        (!hasLowResDown ||
         (hasLowResDown &&
             ccd::CCD_FEATURE_STATE_IN_SYNC == lowResDownFeature.status())))
    { // Combined state of features is IN_SYNC
        summary_out.set_status(ccd::CCD_SYNC_STATE_IN_SYNC);
    }else if(
        (!hasUpload ||
         (hasUpload &&
             (ccd::CCD_FEATURE_STATE_IN_SYNC == uploadFeature.status() ||
              ccd::CCD_FEATURE_STATE_SYNCING == uploadFeature.status()))) &&
        (!hasFullResDown ||
         (hasFullResDown &&
             (ccd::CCD_FEATURE_STATE_IN_SYNC == fullResDownFeature.status() ||
              ccd::CCD_FEATURE_STATE_SYNCING == fullResDownFeature.status()))) &&
        (!hasLowResDown ||
         (hasLowResDown &&
             (ccd::CCD_FEATURE_STATE_IN_SYNC == lowResDownFeature.status() ||
              ccd::CCD_FEATURE_STATE_SYNCING == lowResDownFeature.status()))))
    { // Combined state of features is SYNCING
        summary_out.set_status(ccd::CCD_SYNC_STATE_SYNCING);
    }else{
        // We can assume that the state is OUT_OF_SYNC since it is not IN_SYNC
        // or SYNCING.  Leaving state OUT_OF_SYNC.
    }
}

CCDIError CCDIGetSyncState(const ccd::GetSyncStateInput& request, ccd::GetSyncStateOutput& response)
{
    LOG_CCDI_REQUEST(request);
    int rv;
    UserSession session;
    VPLUser_Id_t userId;
    bool isDeviceLinked;
    u32 activationId;

    rv = Cache_GetActivationIdForSyncUser(&activationId, request.has_user_id(), request.user_id());
    if (rv != 0) {
        goto out;
    }
    if (!request.only_use_cache()) {
        rv = CacheMonitor_UpdateIfNeeded(activationId, CCD_USER_DATA_LINKED_DEVICES_ONLY);
        if(rv != 0) {
            LOG_ERROR("%s failed: %d", "CacheMonitor_UpdateIfNeeded", rv);
            goto out;
        }
    }
    {
        CacheAutoLock autoLock;
        rv = autoLock.LockForRead();
        if (rv < 0) {
            LOG_ERROR("Failed to obtain lock");
            goto out;
        }
        CachePlayer* user = cache_getUserByActivationId(activationId);
        if (user == NULL) {
            LOG_INFO("User is no longer logged in");
            rv = CCD_ERROR_NOT_SIGNED_IN;
            goto out;
        }
        userId = user->user_id();
        isDeviceLinked = user->isLocalDeviceLinked();
        response.set_is_device_linked(isDeviceLinked);
        if (isDeviceLinked && request.get_device_name()) {
            response.set_my_device_name(user->localDeviceName());
        }
        if (request.get_is_camera_roll_upload_enabled()) {
            bool enabled = false;
            int rc = Picstream_GetEnable(enabled);
            if(rc == CCD_ERROR_NOT_INIT) {
                LOG_WARN("Picstream not init, defaulting to trigger state");
                enabled = user->get_enable_camera_roll_trigger();
            } else if(rc != 0) {
                LOG_ERROR("Picstream_GetEnable:%d", rc);
            }
            response.set_is_camera_roll_upload_enabled(enabled);
        }
        if (request.get_is_camera_roll_global_delete_enabled()) {
            bool enabled = false;
            int rc = SyncDown_GetEnableGlobalDelete(enabled);
            if(rc == CCD_ERROR_NOT_INIT) {
                LOG_WARN("SyncDown not init. Global Delete default: false");
            } else if(rc != 0) {
                LOG_ERROR("SyncDown_GetEnableGlobalDelete Error:%d", rc);
            }
            response.set_is_camera_roll_global_delete_enabled(enabled);
        }
        if (request.get_is_network_activity_enabled()) {
            int rc;
            bool networkEnable;
            rc = Cache_GetDeprecatedNetworkEnable(networkEnable);
            if(rc != 0) {
                LOG_ERROR("Cache_GetDeprecatedNetworkEnable:%d", rc);
            }
            response.set_is_network_activity_enabled(networkEnable);
        }
        if (request.get_bandwidth_limits()) {
            // TODO: implement for real
            response.set_max_download_rate_bytes_sec(0);
            response.set_max_upload_rate_bytes_sec(0);
        }
        if (request.get_background_data()) {
            response.set_background_data(user->get_background_data());
        }
        if(request.get_auto_sync()) {
            response.set_auto_sync(user->get_auto_sync());
        }
        if(request.get_mobile_network_data()) {
            response.set_mobile_network_data(user->get_mobile_network_data());
        }
        if(request.get_camera_roll_upload_dirs()) {
            google::protobuf::RepeatedPtrField<ccd::PicstreamDir> camUploadDirs_out;
            user->get_camera_upload_dirs(&camUploadDirs_out);
            int iter;
            for(iter=0; iter<camUploadDirs_out.size(); ++iter) {
                response.add_camera_roll_upload_dirs(
                        camUploadDirs_out.Get(iter).directory());
            }
        }
        for (int i = 0; i < request.get_sync_states_for_paths_size(); i++) {
            SyncConfigStateType_t state;
            u64 dataset_id;
            bool is_sync_folder_root;
            ccd::SyncFeature_t sync_feature;

            ObjectSyncState* syncState = response.add_sync_states_for_paths();
            syncState->set_state(SYNC_STATE_NOT_IN_SYNC_FOLDER);
            std::string abs_path = request.get_sync_states_for_paths(i);
            int rc = SyncFeatureMgr_GetSyncStateForPath(user->user_id(),
                 abs_path, /*out*/state, /*out*/dataset_id,
                 /*out*/sync_feature,/*out*/is_sync_folder_root);
            if (rc == 0) {
                syncState->set_state((ccd::SyncStateType_t)state);
                if (state != SYNC_CONFIG_STATE_NOT_IN_SYNC_FOLDER) {
                    syncState->set_dataset_id(dataset_id);
                    syncState->set_sync_feature(sync_feature);
                    syncState->set_is_sync_folder_root(is_sync_folder_root);
                }
            } else {
                LOG_ERROR("SyncFeatureMgr_GetSyncStateForPath failed: %d", rc);
            }
        }
        for(int index = 0;
            index < request.get_sync_states_for_datasets_size();
            ++index)
        {
            u64 datasetId = request.get_sync_states_for_datasets(index);
            u64 picstreamDid;
            ccd::DatasetSyncStateSummary* summary = response.add_dataset_sync_state_summary();
            int rc = getPicstreamDatasetId(user, picstreamDid);
            if(rc == 0 && datasetId == picstreamDid) {
                getPicstreamDatasetStatus(user, datasetId, *summary);
            }else {
                // NOT SUPPORTED anymore.
                summary->set_status(CCD_SYNC_STATE_OUT_OF_SYNC);
            }
        }
        for(int index_feat = 0;
            index_feat < request.get_sync_states_for_features_size();
            ++index_feat)
        {
            int rc;
            ccd::FeatureSyncStateSummary* summary = response.add_feature_sync_state_summary();
            SyncFeature_t feature = request.get_sync_states_for_features(index_feat);
            switch(feature)
            {
            case SYNC_FEATURE_PICSTREAM_UPLOAD:
#if CCD_ENABLE_SYNCUP
                rc = SyncUp_QueryStatus(user->user_id(),
                                        SYNC_FEATURE_PICSTREAM_UPLOAD,
                                        *summary);
                if(rc == 0) {
                    LOG_INFO("PendingJobCount: %d, FailedJobCount: %d",
                            summary->pending_files(), summary->failed_files());
                } else {
                    LOG_ERROR("SyncUp_QueryStatus:%d", rc);
                }
#else
                summary->set_error(CCD_ERROR_FEATURE_DISABLED);
#endif
                break;
            case SYNC_FEATURE_PICSTREAM_DOWNLOAD_FULL_RES:
#if CCD_ENABLE_SYNCDOWN
                rc = SyncDown_QueryStatus(user->user_id(),
                                          SYNC_FEATURE_PICSTREAM_DOWNLOAD_FULL_RES,
                                          *summary);
                if(rc == 0) {
                    LOG_INFO("PendingJobCount: %d, FailedJobCount: %d",
                            summary->pending_files(), summary->failed_files());
                } else {
                    LOG_ERROR("SyncDown_QueryStatus("FMTu64",SYNC_FEATURE_PICSTREAM_DOWNLOAD_FULL_RES):%d",
                              user->user_id(),
                              rc);
                }
#else
                summary->set_error(CCD_ERROR_FEATURE_DISABLED);
#endif // CCD_ENABLE_SYNCDOWN
                break;
            case SYNC_FEATURE_PICSTREAM_DOWNLOAD_LOW_RES:
#if CCD_ENABLE_SYNCDOWN
                rc = SyncDown_QueryStatus(user->user_id(),
                                          SYNC_FEATURE_PICSTREAM_DOWNLOAD_LOW_RES,
                                          *summary);
                if(rc == 0) {
                    LOG_INFO("PendingJobCount: %d, FailedJobCount: %d",
                            summary->pending_files(), summary->failed_files());
                } else {
                    LOG_ERROR("SyncDown_QueryStatus("FMTu64",SYNC_FEATURE_PICSTREAM_DOWNLOAD_LOW_RES):%d",
                              user->user_id(),
                              rc);
                }
#else
                summary->set_error(CCD_ERROR_FEATURE_DISABLED);
#endif // CCD_ENABLE_SYNCDOWN
                break;
            case SYNC_FEATURE_PICSTREAM_DOWNLOAD_THUMBNAIL:
#if CCD_ENABLE_SYNCDOWN
                rc = SyncDown_QueryStatus(user->user_id(),
                                          SYNC_FEATURE_PICSTREAM_DOWNLOAD_THUMBNAIL,
                                          *summary);
                if(rc == 0) {
                    LOG_INFO("PendingJobCount: %d, FailedJobCount: %d",
                            summary->pending_files(), summary->failed_files());
                } else {
                    LOG_ERROR("SyncDown_QueryStatus("FMTu64",SYNC_FEATURE_PICSTREAM_DOWNLOAD_THUMBNAIL):%d",
                              user->user_id(),
                              rc);
                }
#else
                summary->set_error(CCD_ERROR_FEATURE_DISABLED);
#endif // CCD_ENABLE_SYNCDOWN
                break;
            case SYNC_FEATURE_PICSTREAM_DELETION:
#if CCD_ENABLE_SYNCDOWN
                rc = SyncDown_QueryStatus(user->user_id(),
                                          SYNC_FEATURE_PICSTREAM_DELETION,
                                          *summary);
                if(rc == 0) {
                    LOG_INFO("PendingJobCount: %d, FailedJobCount: %d",
                            summary->pending_files(), summary->failed_files());
                } else {
                    LOG_ERROR("SyncDown_QueryStatus("FMTu64",SYNC_FEATURE_PICSTREAM_DELETION):%d",
                              user->user_id(),
                              rc);
                }
#else
                summary->set_error(CCD_ERROR_FEATURE_DISABLED);
#endif // CCD_ENABLE_SYNCDOWN
                break;
            case SYNC_FEATURE_PHOTO_METADATA:
            case SYNC_FEATURE_PHOTO_THUMBNAILS:
            case SYNC_FEATURE_MUSIC_METADATA:
            case SYNC_FEATURE_MUSIC_THUMBNAILS:
            case SYNC_FEATURE_VIDEO_METADATA:
            case SYNC_FEATURE_VIDEO_THUMBNAILS:
            case SYNC_FEATURE_PLAYLISTS:
            case SYNC_FEATURE_NOTES:
            case SYNC_FEATURE_SYNCBOX:
            case SYNC_FEATURE_MEDIA_METADATA_UPLOAD:
            case SYNC_FEATURE_METADATA_PHOTO_INDEX_UPLOAD:
            case SYNC_FEATURE_METADATA_PHOTO_THUMB_UPLOAD:
            case SYNC_FEATURE_METADATA_MUSIC_INDEX_UPLOAD:
            case SYNC_FEATURE_METADATA_MUSIC_THUMB_UPLOAD:
            case SYNC_FEATURE_METADATA_VIDEO_INDEX_UPLOAD:
            case SYNC_FEATURE_METADATA_VIDEO_THUMB_UPLOAD:
            {
                FeatureSyncStateType_t state;
                u32 uploads_remaining;
                u32 downloads_remaining;
                bool remote_scan_pending;
                bool scan_in_progress;
                rc = SyncFeatureMgr_GetStatus(userId, feature, state,
                        uploads_remaining, downloads_remaining,
                        remote_scan_pending, scan_in_progress);
                if (rc < 0) {
                    summary->set_error(rc);
                } else {
                    summary->set_status(state);
                    if (feature == SYNC_FEATURE_SYNCBOX) {
                        summary->set_uploads_remaining(uploads_remaining);
                        summary->set_downloads_remaining(downloads_remaining);
                        summary->set_remote_scan_pending(remote_scan_pending);
                        summary->set_scan_in_progress(scan_in_progress);
                    }
                }
                break;
            }
            case SYNC_FEATURE_SHARED_FILES_PHOTOS_SHARED_BY_ME:
            case SYNC_FEATURE_SHARED_FILES_PHOTOS_SHARED_WITH_ME:
            default:
                LOG_ERROR("Unknown feature %d", (int)feature);
                summary->set_error(CCD_ERROR_PARAMETER);
                break;
            }
        }
        if(request.get_media_metadata_download_path()) {
            char syncDir[CCD_PATH_MAX_LENGTH];
            DiskCache::getDirectoryForMediaMetadataDownload(user->user_id(),
                                                            sizeof(syncDir),
                                                            syncDir);
            response.set_media_metadata_download_path(syncDir);
        }
        if(request.get_mm_thumb_download_path()) {
            char defaultSyncDir[CCD_PATH_MAX_LENGTH];
            DiskCache::getDirectoryForMediaMetadataDownload(user->user_id(),
                                                            sizeof(defaultSyncDir),
                                                            defaultSyncDir);
            std::string syncDirStr(defaultSyncDir);
            if(user->_cachedData.details().has_mm_thumb_download_path()) {
                syncDirStr = user->_cachedData.details().mm_thumb_download_path();
            }
            response.set_mm_thumb_download_path(syncDirStr);
            if(user->_cachedData.details().has_migrate_mm_thumb_download_path()) {
                const ccd::MediaMetadataThumbMigrateInternal& internalStatus =
                        user->_cachedData.details().migrate_mm_thumb_download_path();
                ccd::MediaMetadataThumbMigrateStatus* migrateStatus =
                        response.mutable_mm_thumb_download_migrate_status();
                migrateStatus->set_mm_src_path(internalStatus.mm_thumb_src_dir());
                migrateStatus->set_mm_dest_path(internalStatus.mm_thumb_dest_dir());
            }
        }
        if(request.get_media_metadata_upload_path()) {
            char syncDir[CCD_PATH_MAX_LENGTH];
            DiskCache::getDirectoryForMediaMetadataUpload(user->user_id(),
                                                          sizeof(syncDir),
                                                          syncDir);
            response.set_media_metadata_upload_path(syncDir);
        }
        if(request.get_media_playlist_path()) {
            char syncDir[CCD_PATH_MAX_LENGTH];
            DiskCache::getDirectoryForMediaMetadataDownload(user->user_id(),
                                                          sizeof(syncDir),
                                                          syncDir);
            response.set_media_playlist_path(
                    std::string(syncDir) + MEDIA_METADATA_SUBDIR_PLAYLISTS);

        }
        if(request.get_notes_sync_settings()) {
            response.mutable_notes_sync_settings()->set_sync_feature_enabled(
                    user->_cachedData.details().enable_notes_sync());
            response.mutable_notes_sync_settings()->set_sync_feature_path(
                    user->_cachedData.details().notes_sync_path());
        }
        if(request.get_notes_sync_path()) {
            char syncDir[CCD_PATH_MAX_LENGTH];
            DiskCache::getDirectoryForNotesSync(user->user_id(), sizeof(syncDir), syncDir);
            response.set_notes_sync_path(syncDir);
        }
        if(request.get_clouddoc_sync()) {
            response.set_clouddoc_sync(user->_cachedData.details().enable_clouddoc_sync());
        }
        if(request.get_camera_roll_download_dirs()) {
            google::protobuf::RepeatedPtrField<ccd::CameraRollDownloadDirSpecInternal> picstream_download_dirs_full_res;
            user->get_camera_download_full_res_dirs(picstream_download_dirs_full_res);
            for(int fullResIter=0;
                fullResIter < picstream_download_dirs_full_res.size();
                ++fullResIter)
            {
                const ccd::CameraRollDownloadDirSpecInternal& fullIter =
                        picstream_download_dirs_full_res.Get(fullResIter);
                ccd::CameraRollDownloadDirSpec* fullResResponse =
                        response.add_camera_roll_full_res_download_dirs();
                fullResResponse->set_dir(fullIter.dir());
                fullResResponse->set_max_size(fullIter.max_size());
                fullResResponse->set_max_files(fullIter.max_files());
                fullResResponse->set_preserve_free_disk_percentage(fullIter.preserve_free_disk_percentage());
                fullResResponse->set_preserve_free_disk_size_bytes(fullIter.preserve_free_disk_size_bytes());
            }
            google::protobuf::RepeatedPtrField<ccd::CameraRollDownloadDirSpecInternal> picstream_download_dirs_low_res;
            user->get_camera_download_low_res_dirs(picstream_download_dirs_low_res);
            for(int lowResIter=0;
                lowResIter < picstream_download_dirs_low_res.size();
                ++lowResIter)
            {
                const ccd::CameraRollDownloadDirSpecInternal& lowIter =
                        picstream_download_dirs_low_res.Get(lowResIter);
                ccd::CameraRollDownloadDirSpec* lowResResponse =
                        response.add_camera_roll_low_res_download_dirs();
                lowResResponse->set_dir(lowIter.dir());
                lowResResponse->set_max_size(lowIter.max_size());
                lowResResponse->set_max_files(lowIter.max_files());
                lowResResponse->set_preserve_free_disk_percentage(lowIter.preserve_free_disk_percentage());
                lowResResponse->set_preserve_free_disk_size_bytes(lowIter.preserve_free_disk_size_bytes());
            }
            google::protobuf::RepeatedPtrField<ccd::CameraRollDownloadDirSpecInternal> picstream_download_dirs_thumb;
            user->get_camera_download_thumb_dirs(picstream_download_dirs_thumb);
            for(int thumbIter=0;
                thumbIter < picstream_download_dirs_thumb.size();
                ++thumbIter)
            {
                const ccd::CameraRollDownloadDirSpecInternal& thumbItem =
                        picstream_download_dirs_thumb.Get(thumbIter);
                ccd::CameraRollDownloadDirSpec* thumbResponse =
                        response.add_camera_roll_thumb_download_dirs();
                thumbResponse->set_dir(thumbItem.dir());
                thumbResponse->set_max_size(thumbItem.max_size());
                thumbResponse->set_max_files(thumbItem.max_files());
                thumbResponse->set_preserve_free_disk_percentage(thumbItem.preserve_free_disk_percentage());
                thumbResponse->set_preserve_free_disk_size_bytes(thumbItem.preserve_free_disk_size_bytes());
            }
        }
        if(request.get_mm_thumb_sync_enabled()) {
            // Populate the list of enabled thumbnail types for which syncing is enabled
            int numDisabled = user->_cachedData.details().mm_thumb_sync_disabled_types_size();
            std::set<SyncFeature_t> enabledList;
            std::set<SyncFeature_t>::const_iterator sf_it;
            enabledList.insert(SYNC_FEATURE_PHOTO_THUMBNAILS);
            enabledList.insert(SYNC_FEATURE_MUSIC_THUMBNAILS);
            enabledList.insert(SYNC_FEATURE_VIDEO_THUMBNAILS);

            for(int i = 0; i < numDisabled; i++) {
                enabledList.erase(user->_cachedData.details().mm_thumb_sync_disabled_types(i));
            }
            // Fun with set theory:  what remains are those still enabled.  
            for(sf_it = enabledList.begin(); sf_it != enabledList.end(); sf_it++) {
                response.add_mm_thumb_sync_enabled_types(*sf_it);
            }
            if(enabledList.size() > 0) {
                response.set_mm_thumb_sync_enabled(true);
            }else{
                response.set_mm_thumb_sync_enabled(false);
            }
        }
        if (request.has_lookup_abs_path()) {
            string absPath;
            u64 localModifyTime;
            string hash;
            int rc = SyncFeatureMgr_LookupAbsPath(user->user_id(),
                    request.lookup_abs_path().dataset_id(),
                    request.lookup_abs_path().component_id(),
                    request.lookup_abs_path().revision(),
                    request.lookup_abs_path().dataset_rel_path(),
                    /*out*/absPath,
                    /*out*/localModifyTime,
                    /*out*/hash);
            response.mutable_lookup_abs_path()->set_err_code(rc);
            if (rc == 0) {
                response.mutable_lookup_abs_path()->set_absolute_path(absPath);
                response.mutable_lookup_abs_path()->set_local_modify_time(localModifyTime);
                response.mutable_lookup_abs_path()->set_hash(hash);
            }
        }
        if(request.get_syncbox_sync_settings()) {
            const CachedUserDetails& cachedDetails = user->_cachedData.details();
            if (cachedDetails.has_syncbox_sync_settings()) {
                ccd::SyncFeatureSettings* sfSettings = response.add_syncbox_sync_settings();
                sfSettings->set_sync_feature_enabled(cachedDetails.syncbox_sync_settings().enable_sync());
                sfSettings->set_sync_feature_path(cachedDetails.syncbox_sync_settings().sync_feature_path());
                // If local state is coherent, use local state. Else use cached infra state.
                if (cachedDetails.syncbox_sync_settings().coherent()) {
                    sfSettings->set_is_archive_storage(cachedDetails.syncbox_sync_settings().is_archive_storage());
                } else {
                    const vplex::vsDirectory::DatasetDetail* syncboxDataset = Util_FindSyncboxArchiveStorageDataset(cachedDetails);
                    sfSettings->set_is_archive_storage(
                            (syncboxDataset != NULL) && Util_IsLocalDeviceArchiveStorage(*syncboxDataset));
                }
            }
        }
    } // release lock

    response.set_is_sync_agent_enabled(true);
 out:
    LOG_CCDI_RESPONSE(response, rv);
    return rv;
}

CCDIError CCDIGetSyncStateNotifications(const ccd::GetSyncStateNotificationsInput& request,
        ccd::GetSyncStateNotificationsOutput& response)
{
    LOG_CCDI_REQUEST(request);
    s32 rv;
    if (request.has_max_count()) {
        GetNotificationsPage(request.max_count(), response);
    } else {
        GetNotifications(response);
    }
    rv = CCD_OK;
    LOG_CCDI_RESPONSE(response, rv);
    return rv;
}

CCDIError CCDIGetSystemState(const ccd::GetSystemStateInput& request, ccd::GetSystemStateOutput& response)
{
    LOG_CCDI_REQUEST(request);
    s32 rv;

//------------------------ Retrieving data with cache lock held
    { // Any data-retrieving function that requires cache lock being held before the function call must be put inside this bracket.
        CacheAutoLock autoLock;
        rv = autoLock.LockForRead();
        if (rv < 0) {
            LOG_ERROR("Failed to obtain lock");
            goto out;
        }
        
        if (request.get_players()) {
            int maxPlayers = Cache_GetMaxPlayers();
            for (int i = 0; i < maxPlayers; i++) {
                CachePlayer* currUser = cache_getUserByPlayerIndex(i);
                CurrentPlayer* curr = response.mutable_players()->add_players();
                if (currUser != NULL) {
                    curr->set_user_id(currUser->user_id());
                    curr->set_username(currUser->username());
                    curr->set_account_id(currUser->account_id());
                } else {
                    curr->set_user_id(0);
                }
            }
        }
        if (request.get_users()) {
            int maxPlayers = Cache_GetMaxPlayers();
            for (int i = 0; i < maxPlayers; i++) {
                CachePlayer* currUser = cache_getUserByPlayerIndex(i);
                if (currUser != NULL) {
                    CurrentUser* curr = response.add_users();
                    curr->set_user_id(currUser->user_id());
                    curr->set_username(currUser->username());
                }
            }
        }
        if (request.get_logged_out_users()) {
            cache_getLoggedOutUsers(*response.mutable_logged_out_users());
        }
        
        if (request.get_background_mode_interval_sec()) {
            response.set_background_mode_interval_sec(cache_getBackgroundModeIntervalSecs());
        }
        
        if(request.get_power_mode()) {
            response.mutable_power_mode_status()->set_power_mode(cache_getPowerMode());
        }
        
        if(request.get_pd_instance_id()) {
            CachePlayer* currUser = cache_getUserByPlayerIndex(0);
            if (currUser) {
                response.set_pd_instance_id_num(currUser->getSession().instance_id());
                
                // For backward compatibility, also set in the string field.
                std::ostringstream oss;
                oss << currUser->getSession().instance_id();
                response.set_pd_instance_id(oss.str());
            }
        }
    } // release read lock

//------------------------ Retrieving data without holding the cache lock
    if (request.get_device_id()) {
        u64 deviceId = 0;
        rv = ESCore_GetDeviceGuid(&deviceId);
        if(rv != 0) {
            LOG_ERROR("ESCore_GetDeviceGuid failed: %d", rv);
            goto out;
        }
        response.set_device_id(deviceId);
    }
    if (request.get_disk_info()) {
        rv = Query_GetFreeDiskSpace(CCDStorage_GetRoot(), *response.mutable_disk_info());
        if (rv < 0) {
            LOG_ERROR("Query_GetFreeDiskSpace returned %d", rv);
            goto out;
        }
    }
    if (request.get_device_locale()) {
        response.set_device_locale("en_US");
    }
    
    if (request.get_network_info()) {
        bool isLocalDeviceStorageNode = false;
        bool hasValidUser = false;
        {
            CacheAutoLock autoLock;
            rv = autoLock.LockForRead();
            if (rv < 0) {
                LOG_ERROR("Failed to obtain lock");
                goto out;
            }
            
            CachePlayer* currUser = cache_getUserByPlayerIndex(0);
            if (currUser) {
                hasValidUser = true;
                isLocalDeviceStorageNode = currUser->isLocalDeviceStorageNode();
            }
        } // release read lock

        if (hasValidUser) {
            response.mutable_network_info()->set_proxy_agent_port((u32)LocalServers_GetHttpService().stream_listening_port());

#if CCD_ENABLE_STORAGE_NODE
            {
                MutexAutoLock lock(LocalServers_GetMutex());
                vss_server* storageNode = LocalServers_getStorageNode();
                if (isLocalDeviceStorageNode && storageNode != NULL) {
                    VPLNet_port_t mediaServerPort = 0, virtualDrivePort = 0;
                    storageNode->getPortNumbers(&virtualDrivePort, &mediaServerPort);
                    if (mediaServerPort != 0) {
                        response.mutable_network_info()->set_media_server_port(mediaServerPort);
                    }
                    if (virtualDrivePort != 0) {
                        response.mutable_network_info()->set_virtual_drive_port(virtualDrivePort);
                    }
                }
            }
#endif
            // This is actually independent from HttpSvc::Ccd,
            // but I'm keeping them together for backward compatibility.
            {
                int port_out = 0;
                ts_ns TS_GetPort(port_out);
                response.mutable_network_info()->set_tunnel_service_port(port_out);
            }
            if (__ccdConfig.enableTs & CONFIG_ENABLE_TS_INIT_TS_EXT) {
                int port_out = 0;
                TSError_t err = TSExtGetPort(port_out);
                if (err != TS_OK) {
                    LOG_ERROR("TSExtGetPort:%d", err);
                } else {
                    response.mutable_network_info()->set_ext_tunnel_service_port(port_out);
                }
            }
        }
    }

    if (request.get_ioac_status()) {
        *response.mutable_ioac_status() = NetMan_GetIoacOverallStatus();
    }

    if (request.get_enable_ioac()) {
        bool enable = false;
        u64 device_id = 0;
        rv = ESCore_GetDeviceGuid(&device_id);
        if (rv != 0) {
            LOG_ERROR("ESCore_GetDeviceGuid failed: %d", rv);
            goto out;
        }
        rv = NetMan_IsUserEnabledIOAC(device_id, enable);
        if (rv != 0) {
            LOG_ERROR("NetMan_IsUserEnabledIOAC failed: %d", rv);
            goto out;
        }
        response.set_enable_ioac(enable);
    }

    if (request.get_ioac_already_in_use()) {
        bool in_use;
        rv = NetMan_IsIOACAlreadyInUse(in_use);
        if (rv != 0) {
            LOG_ERROR("NetMan_IsIOACAlreadyInUse failed: %d", rv);
            goto out;
        }
        response.set_ioac_already_in_use(in_use);
    }

    if (request.get_only_mobile_network_available()) {
        bool onlyMobileNetAvail = false;
        int rc = Cache_GetOnlyMobileNetworkAvailable(onlyMobileNetAvail);
        if(rc != 0) {
            LOG_ERROR("Cache_GetOnlyMobileNetworkAvailable:%d", rc);
        }
        response.set_only_mobile_network_available(onlyMobileNetAvail);
    }

    if (request.get_stream_power_mode()) {
        bool streamPowerMode = false;
        int rc = Cache_GetStreamPowerMode(streamPowerMode);
        if(rc != 0) {
            LOG_ERROR("Cache_GetStreamPowerMode:%d", rc);
        }
        response.set_stream_power_mode(streamPowerMode);
    }
out:
    LOG_CCDI_RESPONSE(response, rv);
    return rv;
}


CCDIError CCDIInfraHttpRequest(const ccd::InfraHttpRequestInput& request, ccd::InfraHttpRequestOutput& response)
{
    LOG_CCDI_REQUEST(request);
    s32 rv;

    CacheAutoLock autoLock;
    rv = autoLock.LockForRead();
    if (rv < 0) {
        LOG_ERROR("Failed to obtain lock");
        goto out;
    }
    else {
        VPLHttp2 handle;
        std::string sessionHandle;
        std::string serviceTicket;
        const char* contentType = NULL;
        CachePlayer* user = NULL;
        if (request.has_user_id()) {
            user = cache_getUserByUserId(request.user_id());
            if (user == NULL) {
                LOG_ERROR("userId "FMT_VPLUser_Id_t" not signed in", request.user_id());
                rv = CCD_ERROR_NOT_SIGNED_IN;
                goto out;
            }

            // Only include the password if it was requested.
            {
                std::ostringstream temp;
                if (request.privileged_operation()) {
                    rv = CCD_ERROR_FEATURE_DISABLED;
                    LOG_ERROR("Cannot request privileged_operation in this configuration!");
                    goto out;
                }
            }

            // Session handle
            {
                std::ostringstream temp1;
                // Infrastructure expects this as a signed value, presumably because Java lacks
                // unsigned types.
                temp1 << static_cast<s64>(user->getSession().session_handle());
                sessionHandle = temp1.str();
            }

            // Service ticket
            // TODO: duplicated in CCDIGetInfraHttpInfo(), refactor.
            {
                char* ticket64;
                // TODO: service ticket should be dynamic, based on which service type was selected.
                rv = Util_EncodeBase64(user->getSession().ops_ticket().data(), user->getSession().ops_ticket().size(),
                        &ticket64, NULL, VPL_FALSE, VPL_FALSE);
                if (rv < 0) {
                    LOG_ERROR("error %d when generating service ticket", rv);
                } else {
                    serviceTicket = ticket64;
                    free(ticket64);
                }
            }
        }

        std::ostringstream tempUrl;
        rv = Query_GetUrlPrefix(tempUrl, request.service(), request.secure(), user);
        if (rv != 0) {
            LOG_ERROR("%s failed: %d", "Query_GetUrlPrefix", rv);
            goto out;
        }
        switch (request.service()) {
        case INFRA_HTTP_SERVICE_OPS:
        case INFRA_HTTP_SERVICE_OPS_CENTRAL:
        case INFRA_HTTP_SERVICE_OPS_REGIONAL:
            tempUrl << "/ops/" << request.url_suffix();
            contentType = "application/x-www-form-urlencoded";
            break;
        case INFRA_HTTP_SERVICE_VCS:
            rv = CCD_ERROR_PARAMETER;
            LOG_ERROR("INFRA_HTTP_SERVICE_VCS service not supported for this CCDI api.");
            goto out;
        default:
            rv = CCD_ERROR_PARAMETER;
            LOG_ERROR("Unknown service: %d", request.service());
            goto out;
        }
        std::string url(tempUrl.str());

        handle.SetUri(url);
        handle.SetTimeout(VPLTime_FromSec(30));

        // Copied everything we need; release lock now.
        autoLock.UnlockNow();

        LOG_INFO("Calling VPLHttp_Request(\"%s\")", url.c_str());

        // Set the HTTP headers.  Note: order is preserved.
        handle.AddRequestHeader("request_locale", "en_us");
        if (contentType != NULL) {
            handle.AddRequestHeader("Content-Type", contentType);
        }
        if (request.has_user_id()) {
            handle.AddRequestHeader("sessionHandle", sessionHandle);
            handle.AddRequestHeader("serviceTicket", serviceTicket);
        }

        int responseCode;

        if (__ccdConfig.debugInfraHttp)
            handle.SetDebug(1);

        if(request.method() == INFRA_HTTP_METHOD_POST){
            rv = handle.Post(request.post_data(), *response.mutable_http_response());
        }else{
            rv = handle.Get(*response.mutable_http_response());
        }

        responseCode = (rv == VPL_OK)?handle.GetStatusCode():CCD_ERROR_HTTP_STATUS;
        response.set_response_code(responseCode);
        if (rv < 0) {
            LOG_ERROR("VPLHttp_Request(\"%s\") returned %d", url.c_str(), rv);
        }
    }
out:
    LOG_CCDI_RESPONSE(response, rv);
    return rv;
}

CCDIError CCDIMSABeginCatalog(const ccd::BeginCatalogInput& request)
{
    LOG_CCDI_REQUEST(request);
#if CCD_ENABLE_MEDIA_SERVER_AGENT
    CCDIError rv = MSABeginCatalog(request);
    if (rv != 0) {
        LOG_WARN("MSABeginCatalog failed: %d", rv);
    }
#else
    CCDIError rv = CCD_ERROR_FEATURE_DISABLED;
#endif
    LOG_CCDI_RESPONSE(ccd::NoParamResponse::default_instance(), rv);
    return rv;
}

CCDIError CCDIMSACommitCatalog(const ccd::CommitCatalogInput& request)
{
    LOG_CCDI_REQUEST(request);
#if CCD_ENABLE_MEDIA_SERVER_AGENT
    CCDIError rv = MSACommitCatalog(request);
    if (rv != 0) {
        LOG_WARN("MSACommitCatalog failed: %d", rv);
    }
#else
    CCDIError rv = CCD_ERROR_FEATURE_DISABLED;
#endif
    LOG_CCDI_RESPONSE(ccd::NoParamResponse::default_instance(), rv);
    return rv;
}

CCDIError CCDIMSAEndCatalog(const ccd::EndCatalogInput& request)
{
    LOG_CCDI_REQUEST(request);
#if CCD_ENABLE_MEDIA_SERVER_AGENT
    CCDIError rv = MSAEndCatalog(request);
    if (rv != 0) {
        LOG_WARN("MSAEndCatalog failed: %d", rv);
    }
#else
    CCDIError rv = CCD_ERROR_FEATURE_DISABLED;
#endif
    LOG_CCDI_RESPONSE(ccd::NoParamResponse::default_instance(), rv);
    return rv;
}

CCDIError CCDIMSABeginMetadataTransaction(const ccd::BeginMetadataTransactionInput& request)
{
    LOG_CCDI_REQUEST(request);
#if CCD_ENABLE_MEDIA_SERVER_AGENT
    CCDIError rv = MSABeginMetadataTransaction(request);
    if (rv != 0) {
        LOG_WARN("MSABeginMetadataTransaction failed: %d", rv);
    }
#else
    CCDIError rv = CCD_ERROR_FEATURE_DISABLED;
#endif
    LOG_CCDI_RESPONSE(ccd::NoParamResponse::default_instance(), rv);
    return rv;
}

CCDIError CCDIMSAUpdateMetadata(const ccd::UpdateMetadataInput& request)
{
    LOG_CCDI_REQUEST(request);
#if CCD_ENABLE_MEDIA_SERVER_AGENT
    CCDIError rv = MSAUpdateMetadata(request);
    if (rv != 0) {
        LOG_WARN("MSAUpdateMetadata failed: %d", rv);
    }
#else
    CCDIError rv = CCD_ERROR_FEATURE_DISABLED;
#endif
    LOG_CCDI_RESPONSE(ccd::NoParamResponse::default_instance(), rv);
    return rv;
}

CCDIError CCDIMSADeleteMetadata(const ccd::DeleteMetadataInput& request)
{
    LOG_CCDI_REQUEST(request);
#if CCD_ENABLE_MEDIA_SERVER_AGENT
    CCDIError rv = MSADeleteMetadata(request);
    if (rv != 0) {
        LOG_WARN("MSADeleteMetadata failed: %d", rv);
    }
#else
    CCDIError rv = CCD_ERROR_FEATURE_DISABLED;
#endif
    LOG_CCDI_RESPONSE(ccd::NoParamResponse::default_instance(), rv);
    return rv;
}

CCDIError CCDIMSACommitMetadataTransaction()
{
    LOG_CCDI_REQUEST(ccd::NoParamRequest::default_instance());
#if CCD_ENABLE_MEDIA_SERVER_AGENT
    CCDIError rv = MSACommitMetadataTransaction();
    if (rv != 0) {
        LOG_WARN("MSACommitMetadataTransaction failed: %d", rv);
    }
#else
    CCDIError rv = CCD_ERROR_FEATURE_DISABLED;
#endif
    LOG_CCDI_RESPONSE(ccd::NoParamResponse::default_instance(), rv);
    return rv;
}

CCDIError CCDIMSAGetMetadataSyncState(media_metadata::GetMetadataSyncStateOutput& response)
{
    LOG_CCDI_REQUEST(ccd::NoParamRequest::default_instance());
#if CCD_ENABLE_MEDIA_SERVER_AGENT
    CCDIError rv = MSAGetMetadataSyncState(response);
    if (rv != 0) {
        LOG_WARN("MSAGetMetadataSyncState failed: %d", rv);
    }
#else
    CCDIError rv = CCD_ERROR_FEATURE_DISABLED;
#endif
    LOG_CCDI_RESPONSE(response, rv);
    return rv;
}

CCDIError CCDIMSADeleteCollection(const ccd::DeleteCollectionInput& request)
{
    LOG_CCDI_REQUEST(request);
#if CCD_ENABLE_MEDIA_SERVER_AGENT
    CCDIError rv = MSADeleteCollection(request);
    if (rv != 0) {
        LOG_WARN("MSADeleteCollection failed: %d", rv);
    }
#else
    CCDIError rv = CCD_ERROR_FEATURE_DISABLED;
#endif
    LOG_CCDI_RESPONSE(ccd::NoParamResponse::default_instance(), rv);
    return rv;
}

CCDIError CCDIMSADeleteCatalog(const ccd::DeleteCatalogInput& request)
{
    LOG_CCDI_REQUEST(request);
#if CCD_ENABLE_MEDIA_SERVER_AGENT
    CCDIError rv = MSADeleteCatalog(request);
    if (rv != 0) {
        LOG_WARN("MSADeleteCatalog failed: %d", rv);
    }
#else
    CCDIError rv = CCD_ERROR_FEATURE_DISABLED;
#endif
    LOG_CCDI_RESPONSE(ccd::NoParamResponse::default_instance(), rv);
    return rv;
}

CCDIError CCDIMSAListCollections(media_metadata::ListCollectionsOutput& response)
{
    LOG_CCDI_REQUEST(ccd::NoParamRequest::default_instance());
#if CCD_ENABLE_MEDIA_SERVER_AGENT
    CCDIError rv = MSAListCollections(response);
    if (rv != 0) {
        LOG_WARN("MSAListCollections failed: %d", rv);
    }
#else
    CCDIError rv = CCD_ERROR_FEATURE_DISABLED;
#endif
    LOG_CCDI_RESPONSE(response, rv);
    return rv;
}

CCDIError CCDIMSAGetCollectionDetails(const ccd::GetCollectionDetailsInput& request,
        ccd::GetCollectionDetailsOutput& response)
{
    LOG_CCDI_REQUEST(request);
#if CCD_ENABLE_MEDIA_SERVER_AGENT
    CCDIError rv = MSAGetCollectionDetails(request, response);
    if (rv != 0) {
        LOG_WARN("MSAGetCollectionDetails failed: %d", rv);
    }
#else
    CCDIError rv = CCD_ERROR_FEATURE_DISABLED;
#endif
    LOG_CCDI_RESPONSE(response, rv);
    return rv;
}

static inline
std::string convertDeviceIdToString(u64 value)
{
    char tempBuf[17];
    snprintf(tempBuf, ARRAY_SIZE_IN_BYTES(tempBuf), "%016"PRIx64, value);
    return std::string(tempBuf);
}
/* Return extension of a path.
 * Examples:
 *   /temp/thumb.jpg  -> "jpg"
 *   /temp/thumb      -> ""
 *   /temp.temp/thumb -> ""
 */
static const string get_extension(const string &path)
{
    string ext;
    size_t pos = path.find_last_of("/.");
    if ((pos != path.npos) && (path[pos] == '.')) {
        ext.assign(path, pos + 1, path.size());
    }
    return ext;
}

static int getUrl(u64 deviceId, const string& objectId, VPLNet_port_t httpPort, int urlFlag, const string& options, string& url)
{
    int rv = 0;

    {
        char* base64EncodedObjId = NULL;
        rv = Util_EncodeBase64(objectId.c_str(), objectId.size(), &base64EncodedObjId, NULL, VPL_FALSE, VPL_TRUE);
        if (rv != 0) {
            LOG_ERROR("%s failed: %d", "Util_EncodeBase64", rv);
            goto out;
        }
        ON_BLOCK_EXIT(free, base64EncodedObjId);

        const char *urlType;
        urlType = (1 == urlFlag)? "c" : "t";
        // NOTE: These all need to stay in sync:
        // - #MMGetDeviceFromUrl()
        // - #MMParseUrl()
        // - #MSAGetObjectMetadata()
        // .

        std::ostringstream urlStrm;
        urlStrm << "http://127.0.0.1:" << httpPort << "/mm/" <<
            convertDeviceIdToString(deviceId) << "/" <<
            urlType << "/" <<
            base64EncodedObjId;
        if (!options.empty()) {
            urlStrm << "/" << options;
        }
        url = urlStrm.str();
    }

out:
    return rv;
}

static int getContentUrl(u64 deviceId, const string& objectId, VPLNet_port_t httpPort, int urlFlag, const string& ext, string& url)
{
    int rv = 0;
    string options = "";

    if (!ext.empty()) {

        char* base64EncodedObjId = NULL;
        rv = Util_EncodeBase64(objectId.c_str(), objectId.size(), &base64EncodedObjId, NULL, VPL_FALSE, VPL_TRUE);
        if (rv != 0) {
            LOG_ERROR("%s failed: %d", "Util_EncodeBase64", rv);
            goto out;
        }
        ON_BLOCK_EXIT(free, base64EncodedObjId);

        std::ostringstream urlStrm;
        urlStrm << base64EncodedObjId;
        options = urlStrm.str();
        options.append(".");
        options.append(ext);
    }

out:
    return getUrl(deviceId, objectId, httpPort, urlFlag, options, url);
}

static int getThumbUrl(u64 deviceId, const string& objectId, VPLNet_port_t httpPort, int urlFlag, const string& collectionId, const string& ext, string& url)
{
    if (ext.empty()) {
        return MM_ERR_NO_THUMBNAIL_EXT;
    }
    if (collectionId.empty()) {
        return MM_ERR_NOT_FOUND;
    }

    char* base64EncodedCollId = NULL;
    int rv = Util_EncodeBase64(collectionId.c_str(), collectionId.size(), &base64EncodedCollId, NULL, VPL_FALSE, VPL_TRUE);
    if (rv != 0) {
        LOG_ERROR("%s failed: %d", "Util_EncodeBase64", rv);
        return rv;
    }
    ON_BLOCK_EXIT(free, base64EncodedCollId);

    string options;
    options.assign(base64EncodedCollId);
    options.append("/");
    options.append(ext);

    return getUrl(deviceId, objectId, httpPort, urlFlag, options, url);
}

CCDIError CCDIMSAGetContentURL(const ccd::MSAGetContentURLInput& request,
        ccd::MSAGetContentURLOutput& response)
{
    LOG_CCDI_REQUEST(request);
#if CCD_ENABLE_STORAGE_NODE
    CCDIError rv = CCD_OK;
    {
        std::string url;
        media_metadata::GetObjectMetadataOutput object_metadata;
        std::string file_ext;
        u64 device_id;

        VPLNet_port_t proxy_agent_http_port;
        {
            ccd::GetSystemStateInput request;
            ccd::GetSystemStateOutput response;
            request.set_get_device_id(true);
            request.set_get_network_info(true);
            rv = CCDIGetSystemState(request, response);
            if (rv != 0) {
                LOG_ERROR("%s failed: %d", "CCDIGetSystemState", rv);
                goto out;
            }
            device_id = response.device_id();
            proxy_agent_http_port = response.network_info().proxy_agent_port();
        }

        rv = MSAGetContentObjectMetadata(request.object_id(), request.collection_id(), request.catalog_type(), object_metadata);
        if (rv != 0) {
            LOG_WARN("MSAGetContentObjectMetadata failed: %d", rv);
            goto out;
        }

        if (request.is_thumb() && object_metadata.has_thumbnail()) {
            file_ext = get_extension(object_metadata.thumbnail());
            rv = getThumbUrl(device_id, request.object_id(), proxy_agent_http_port, 2, request.collection_id(), file_ext, url);
            if (rv) {
                LOG_ERROR("getThumbUrl failed: %d", rv);
                goto out;
            }
            response.set_url(url);

        } else if (!request.is_thumb() && object_metadata.has_absolute_path()) {
            file_ext = get_extension(object_metadata.absolute_path());
            rv = getContentUrl(device_id, request.object_id(), proxy_agent_http_port, 1, file_ext, url);
            if (rv) {
                LOG_ERROR("getContentUrl failed: %d", rv);
                goto out;
            }
            response.set_url(url);

        } else {
            LOG_WARN("Not found.");
            rv = MM_ERR_NOT_FOUND;
            goto out;
        }
    }
out:
#else
    CCDIError rv = CCD_ERROR_FEATURE_DISABLED;
#endif
    LOG_CCDI_RESPONSE(response, rv);
    return rv;
}

CCDIError CCDIMCAQueryMetadataObjects(const ccd::MCAQueryMetadataObjectsInput& request,
                               ccd::MCAQueryMetadataObjectsOutput& response)
{
    LOG_CCDI_REQUEST(request);
    CCDIError rv;
    rv = MCAQueryMetadataObjects(request.cloud_device_id(),
                                 request.filter_field(),
                                 request.search_field(),
                                 request.sort_field(),
                                 *(response.mutable_content_objects()));

    if (rv != 0) {
        LOG_WARN("MCAQueryMetadataObjects failed: %d", rv);
    }
    else {
        if (request.filter_field() == media_metadata::MCA_MDQUERY_MUSICTRACK
         || request.filter_field() == media_metadata::MCA_MDQUERY_MUSICALBUM
         || request.filter_field() == media_metadata::MCA_MDQUERY_PHOTOITEM
         || request.filter_field() == media_metadata::MCA_MDQUERY_PHOTOALBUM
         || request.filter_field() == media_metadata::MCA_MDQUERY_VIDEOITEM) {
            // get url and thumbnail url for these items
            // Query CCDI for the proxy http port number.
            VPLNet_port_t proxyAgentHttpPort;
            {
                ccd::GetSystemStateInput request;
                request.set_get_network_info(true);
                ccd::GetSystemStateOutput response;
                rv = CCDIGetSystemState(request, response);
                if (rv != 0) {
                    LOG_ERROR("%s failed: %d", "CCDIGetSystemState", rv);
                    goto out;
                }
                proxyAgentHttpPort = response.network_info().proxy_agent_port();
            }

            int itemIndex = 0;
            for (; itemIndex<response.content_objects_size(); itemIndex++) {
                media_metadata::MCAMetadataQueryObject* contentObj = response.mutable_content_objects(itemIndex);
                // get extension for music album, video, and photo to generate thumbnail url
                std::string cstrThumbExt;
                std::string cstrContentExt;
                rv = 0;
                if (contentObj->cdo().has_music_album()) {
                    if (contentObj->cdo().music_album().has_album_thumbnail())
                        cstrThumbExt = get_extension(contentObj->cdo().music_album().album_thumbnail());
                    else
                        cstrThumbExt = "";
                }
                else if (contentObj->cdo().has_video_item()) {
                    cstrThumbExt = get_extension(contentObj->cdo().video_item().thumbnail());
                }
                else if (contentObj->cdo().has_photo_item()) {
                    cstrThumbExt = get_extension(contentObj->cdo().photo_item().thumbnail());
                }
                else if (contentObj->cdo().has_photo_album()) {
                    cstrThumbExt = get_extension(contentObj->cdo().photo_album().album_thumbnail());
                }
                else
                    cstrThumbExt = "";

                if (contentObj->cdo().has_music_track()) {
                    cstrContentExt = get_extension(contentObj->cdo().music_track().absolute_path());
                } else if (contentObj->cdo().has_photo_item()) {
                    cstrContentExt = get_extension(contentObj->cdo().photo_item().absolute_path());
                } else if (contentObj->cdo().has_video_item()) {
                    cstrContentExt = get_extension(contentObj->cdo().video_item().absolute_path());
                } else {
                    cstrContentExt = "";
                }

                if (request.filter_field() != media_metadata::MCA_MDQUERY_MUSICALBUM && request.filter_field() != media_metadata::MCA_MDQUERY_PHOTOALBUM) {
                    // get HTTP url to access the content for music track, photo item, and video item
                    string url;
                    rv = getContentUrl(request.cloud_device_id(), contentObj->cdo().object_id(), proxyAgentHttpPort, 1, cstrContentExt, url);
                    if (rv != 0) {
                        LOG_ERROR("getContentUrl() device_id("FMT_VPLUser_Id_t") object_id %s ext %s failed rv %d", request.cloud_device_id(), contentObj->cdo().object_id().c_str(), cstrContentExt.c_str(), rv);
                    }
                    else {
                        contentObj->set_url(url);
                    }
                }
                if (request.filter_field() != media_metadata::MCA_MDQUERY_MUSICTRACK) {
                    // get HTTP url to access the thumbnail for music album, photo item, photo album, and video item
                    if (!cstrThumbExt.empty()) {
                        string thumbnail_url;
                        rv = getThumbUrl(request.cloud_device_id(), contentObj->cdo().object_id(), proxyAgentHttpPort, 2, contentObj->collection_id(), cstrThumbExt, thumbnail_url);
                        if (rv != 0) {
                            LOG_ERROR("getThumbUrl() device_id("FMT_VPLUser_Id_t") object_id %s failed rv %d", request.cloud_device_id(), contentObj->cdo().object_id().c_str(), rv);
                        }
                        else {
                            contentObj->set_thumbnail_url(thumbnail_url);
                            LOG_DEBUG("Thumb URL: %s", thumbnail_url.c_str());
                        }
                    }
                }
                LOG_DEBUG("Found content: %s", contentObj->DebugString().c_str());
            }
        }
    }
 out:
    LOG_CCDI_RESPONSE(response, rv);
    return rv;
}

CCDIError CCDILinkDevice(const ccd::LinkDeviceInput& request)
{
    LOG_CCDI_REQUEST(request);
    int rv = 0;
    UserSession session;
    std::string deviceName;
    std::string deviceClass;
    vplex::vsDirectory::LinkDeviceOutput vsds_response;

    rv = Cache_GetSessionByUser(request.user_id(), session);
    if(rv != 0) {
        LOG_ERROR("Could not get session for user:"FMT_VPLUser_Id_t, request.user_id());
        goto out;
    }

    if(request.has_device_name()){
        deviceName = request.device_name();
    }
    if(request.has_device_class()){
        deviceClass = request.device_class();
    } else {
        deviceClass = DEVICE_CLASS;
    }

    rv = Query_LinkDevice(request.user_id(),
                          session,
                          deviceName,
                          deviceClass,
                          request.os_version(),
                          request.is_acer_device(),
                          request.device_has_camera(),
                          vsds_response);

    if (rv == 0) {
        // TODO: should really be using the activationId instead of user_id, since we release the lock
        //   between steps
        CacheMonitor_MarkLinkedDevicesDirty(request.user_id());
        CacheMonitor_MarkSubscriptionsDirty(request.user_id());
#if CCD_USE_SHARED_CREDENTIALS
        // Store a flag to indicate that this device has been linked.
        const char* credentialsLocation = VPLSharedObject_GetCredentialsLocation();
        // Mark device as linked.
        VPLSharedObject_AddString(credentialsLocation, VPL_SHARED_IS_DEVICE_LINKED_ID, VPL_SHARED_DEVICE_LINKED);
        VPLSharedObject_DeleteObject(credentialsLocation, VPL_SHARED_IS_DEVICE_UNLINKING_ID);
#endif
    } else {
        LOG_ERROR("Query_LinkDevice(user="FMT_VPLUser_Id_t") failed: %d",
                  request.user_id(), rv);
    }
 out:
    LOG_CCDI_RESPONSE(ccd::NoParamResponse::default_instance(), rv);
    return rv;
}

CCDIError CCDIListLinkedDevices(const ccd::ListLinkedDevicesInput& request,
                                ccd::ListLinkedDevicesOutput& response)
{
    LOG_CCDI_REQUEST(request);
    int rv;
    u32 activationId;

    rv = Cache_GetActivationIdForSyncUser(&activationId, request.has_user_id(), request.user_id());
    if (rv != 0) {
        goto out;
    }
    if (!request.only_use_cache()) {
        rv = CacheMonitor_UpdateIfNeeded(activationId, CCD_USER_DATA_UPDATE_DEVICES);
        if (rv != 0) {
            LOG_ERROR("CacheMonitor_UpdateIfNeeded failed: %d", rv);
            goto out;
        }
    }
    // Return the results from the cache.
    {
        CacheAutoLock autoLock;
        rv = autoLock.LockForRead();
        if (rv < 0) {
            LOG_ERROR("Failed to obtain lock");
            goto out;
        }
        CachePlayer* user = cache_getUserByActivationId(activationId);
        if (user == NULL) {
            LOG_INFO("User is no longer logged in");
            rv = CCD_ERROR_NOT_SIGNED_IN;
            goto out;
        }
        const google::protobuf::RepeatedPtrField<vplex::vsDirectory::DeviceInfo>& devices =
                user->_cachedData.details().cached_devices();
        *(response.mutable_linked_devices()) = devices;
        for (int i = 0; i < devices.size(); i++) {
            const vplex::vsDirectory::DeviceInfo& currIn = devices.Get(i);
            bool isStorageNode = user->isDeviceStorageNode(currIn.deviceid());
            u64 localDeviceId = 0;

            if (request.storage_nodes_only() && !isStorageNode) {
                continue;
            }
            ccd::LinkedDeviceInfo* currOut = response.add_devices();
            currOut->set_device_id(currIn.deviceid());
            currOut->set_device_name(currIn.devicename());
            currOut->set_is_storage_node(isStorageNode);
            *(currOut->mutable_connection_status()) = DeviceStateCache_GetDeviceStatus(currIn.deviceid());
            currOut->set_device_class(currIn.deviceclass());
            currOut->set_is_acer(currIn.isacer());
            currOut->set_has_camera(currIn.hascamera());
            currOut->set_os_version(currIn.osversion());
            if ( currIn.has_featuremediaservercapable() ) {
                currOut->set_feature_media_server_capable(currIn.featuremediaservercapable());
            }
            if ( currIn.has_featurevirtdrivecapable() ) {
                currOut->set_feature_virt_drive_capable(currIn.featurevirtdrivecapable());
            }
            if ( currIn.has_featureremotefileaccesscapable() ) {
                currOut->set_feature_remote_file_access_capable(currIn.featureremotefileaccesscapable());
            }
            if ( currIn.has_featurefsdatasettypecapable() ) {
                currOut->set_feature_fsdatasettype_capable(currIn.featurefsdatasettypecapable());
            }
            if ( currIn.has_featuremystorageservercapable() ) {
                currOut->set_feature_my_storage_server_capable(currIn.featuremystorageservercapable());
            }

            rv = ESCore_GetDeviceGuid(&localDeviceId);
            if (rv != 0) {
                LOG_ERROR("ESCore_GetDeviceGuid failed: %d", rv);
            }

            if (localDeviceId == currIn.deviceid()) {
                currOut->set_protocol_version(CCD_PROTOCOL_VERSION);
            } else {
                if (currIn.has_protocolversion()) {
                    currOut->set_protocol_version(currIn.protocolversion());
                } else {
                    currOut->set_protocol_version("0");
                }
            }

            if (currIn.has_buildinfo()) {
                currOut->set_build_info(currIn.buildinfo());
            }

            if (currIn.has_modelnumber()) {
                currOut->set_model_number(currIn.modelnumber());
            } 
        }
    }
out:
    LOG_CCDI_RESPONSE(response, rv);
    return rv;
}

CCDIError CCDIListOwnedDatasets(const ccd::ListOwnedDatasetsInput& request,
                                ccd::ListOwnedDatasetsOutput& response)
{
    LOG_CCDI_REQUEST(request);
    int rv = Cache_ListOwnedDatasets(request.user_id(), response, request.only_use_cache());
    if(rv != 0) {
        LOG_ERROR("listOwnedDatasets failed %d", rv);
        goto out;
    }

 out:
    LOG_CCDI_RESPONSE(response, rv);
    return rv;
}

CCDIError CCDIListSyncSubscriptions(const ccd::ListSyncSubscriptionsInput& request,
                                    ccd::ListSyncSubscriptionsOutput& response)
{
    LOG_CCDI_REQUEST(request);
    int rv;
    u32 activationId;

    rv = Cache_GetActivationIdForSyncUser(&activationId, request.has_user_id(), request.user_id());
    if (rv != 0) {
        goto out;
    }
    if (!request.only_use_cache()) {
        rv = CacheMonitor_UpdateIfNeeded(activationId, CCD_USER_DATA_SUBSCRIPTIONS_ONLY);
        if (rv != 0) {
            LOG_ERROR("CacheMonitor_UpdateIfNeeded failed: %d", rv);
            goto out;
        }
    }
    
    // Return the results from the cache.
    {
        CacheAutoLock autoLock;
        rv = autoLock.LockForRead();
        if (rv < 0) {
            LOG_ERROR("Failed to obtain lock");
            goto out;
        }
        CachePlayer* user = cache_getUserByActivationId(activationId);
        if (user == NULL) {
            rv = CCD_ERROR_NOT_SIGNED_IN;
            goto out;
        }
        response.clear_subs();
        // TODO: deprecated; remove when clients are ready
        response.clear_subscriptions();
        const CachedUserDetails& userDetails = user->_cachedData.details();
        for (int i = 0; i < userDetails.subscriptions_size(); i++) {
            const CachedSubscription& currCached = userDetails.subscriptions(i);
            const vplex::vsDirectory::Subscription& curr = currCached.details();
            *(response.add_subscriptions()) = curr;
            const vplex::vsDirectory::DatasetDetail* currDataset = user->getDatasetDetail(curr.datasetid());
            if (currDataset == NULL) {
                // dataset was not found; it may have been deleted
                LOG_WARN("Dataset was not found for subscription (datasetId="FMTx64")", curr.datasetid());
                // TODO: rescan?
                continue;
            }
            SyncSubscriptionDetail* currResult = response.add_subs();
            *(currResult->mutable_dataset_details()) = *currDataset;

            string absDeviceRoot = currCached.abs_device_root();
#ifdef WIN32
            // Normalize to backslashes.
            for (size_t i = 0; i < absDeviceRoot.size(); i++) {
                if (absDeviceRoot[i] == '/') {
                    absDeviceRoot[i] = '\\';
                }
            }
#endif
            currResult->set_absolute_device_root(absDeviceRoot);
            currResult->set_raw_device_root(curr.deviceroot());
            if(curr.has_filter()) {
                currResult->set_filter(curr.filter());
            }
            if(curr.has_maxsize()) {
                currResult->set_max_size(curr.maxsize());
            }
            if(curr.has_maxfiles()) {
                currResult->set_max_files(curr.maxfiles());
            }
            currResult->set_upload_ok(curr.uploadok());
            currResult->set_download_ok(curr.downloadok());
            currResult->set_upload_delete_ok(curr.uploaddeleteok());
            currResult->set_download_delete_ok(curr.downloaddeleteok());
            currResult->set_dataset_root(curr.datasetroot());
            currResult->set_dataset_location(curr.datasetlocation());
        }
    }
out:
    LOG_CCDI_RESPONSE(response, rv);
    return rv;
}

CCDIError CCDILogin(const LoginInput& request, LoginOutput& response)
{
    LOG_CCDI_REQUEST(request);
    s32 rv = Cache_Login(request, response);
    LOG_CCDI_RESPONSE(response, rv);
    return rv;
}

CCDIError CCDILogout(const ccd::LogoutInput& request)
{
    LOG_CCDI_REQUEST(request);
    int playerIndex = CACHE_PLAYER_INDEX_NOT_SIGNED_IN;
    VPLUser_Id_t userId = VPLUSER_ID_NONE;
    if (request.has_player_index()) {
        playerIndex = request.player_index();
    }
    if (request.has_local_user_id()) {
        userId = request.local_user_id();
    }
    if (!request.has_player_index() && !request.has_local_user_id()) {
        playerIndex = 0;
    }
    s32 rv = Cache_Logout(playerIndex, userId, request.warn_if_no_user(), LOGOUT_REASON_CCDI_LOGOUT);
    LOG_CCDI_RESPONSE(ccd::NoParamResponse::default_instance(), rv);
    return rv;
}

CCDIError CCDIOwnershipSync()
{
    LOG_CCDI_REQUEST(ccd::NoParamRequest::default_instance());
    int rv = CacheMonitor_UpdateIfNeeded(false, 0, CCD_USER_DATA_ALL);
    if (rv != 0) {
        LOG_INFO("%s failed: %d - will continue with cached state", "CacheMonitor_UpdateIfNeeded", rv);
    }

    SyncFeatureMgr_RequestAllRemoteScans();
    rv = SyncFeatureMgr_BlockUntilSyncDone();
    if(rv != 0) {
        LOG_ERROR("SyncFeatureMgr_BlockUntilSyncDone failed:%d", rv);
    }
    LOG_CCDI_RESPONSE(ccd::NoParamResponse::default_instance(), rv);
    return rv;
}

CCDIError CCDIRegisterStorageNode(const ccd::RegisterStorageNodeInput& request)
{
    LOG_CCDI_REQUEST(request);
#if CCD_ENABLE_STORAGE_NODE
    s32 rv;
    StartStorageNodeContext snContext;
    {
        CacheAutoLock autoLock;
        rv = autoLock.LockForWrite();
        if (rv < 0) {
            LOG_ERROR("Failed to obtain lock");
            goto out;
        }
        else {
            CachePlayer* user = cache_getUserByUserId(request.user_id());
            if (user == NULL) {
                LOG_ERROR("userId "FMT_VPLUser_Id_t" not signed in", request.user_id());
                rv = CCD_ERROR_NOT_SIGNED_IN;
                goto out;
            }
            // TODO: Bug 710: performance bottleneck: calling infra with write lock held!
            rv = user->setupStorageNode();
            if (rv != 0) {
                LOG_WARN("setupStorageNode failed: %d", rv);
                goto out;
            }
            LocalServers_PopulateStartStorageNodeContext(*user, snContext);
            CacheMonitor_MarkStorageNodesDirty(user->user_id());
        }
    } // releases cache lock

    ASSERT(!Cache_ThreadHasLock());
    rv = LocalServers_StartStorageNode(snContext);
    if (rv != 0) {
        LOG_WARN("LocalServers_StartStorageNode failed: %d", rv);
        goto out;
    }

out:
#else
    CCDIError rv = CCD_ERROR_FEATURE_DISABLED;
#endif
    LOG_CCDI_RESPONSE(ccd::NoParamResponse::default_instance(), rv);
    return rv;
}

CCDIError CCDIReportLanDevices(const ccd::ReportLanDevicesInput& request)
{
    LOG_CCDI_REQUEST(request);
    s32 rv = 0;
    std::list<ccd::LanDeviceInfo> infos;

    for (int i = 0; i < request.infos_size(); i++) {
        infos.push_back(request.infos(i));
    }
    rv = LanDeviceInfoCache::Instance().reportLanDevices(&infos);
    LOG_CCDI_RESPONSE(ccd::NoParamResponse::default_instance(), rv);
    return rv;
}

CCDIError CCDIListLanDevices(const ccd::ListLanDevicesInput& request, ccd::ListLanDevicesOutput& response)
{
    LOG_CCDI_REQUEST(request);
    s32 rv = 0;
    {
        // Get the user ID and bitmask from the request
        VPLUser_Id_t userId = 0;
        if (request.has_user_id()) {
            userId = request.user_id();
        }
        u32 filterBitMask = 0;
        if (request.has_include_unregistered() && request.include_unregistered()) {
            filterBitMask |= LAN_DEVICE_FILTER_UNREGISTERED;
        }
        if (request.has_include_registered_but_not_linked() && request.include_registered_but_not_linked()) {
            filterBitMask |= LAN_DEVICE_FILTER_REGISTERED_BUT_NOT_LINKED;
        }
        if (request.has_include_linked() && request.include_linked()) {
            filterBitMask |= LAN_DEVICE_FILTER_LINKED;
        }

        std::list<ccd::LanDeviceInfo> infos;
        rv = LanDeviceInfoCache::Instance().listLanDevices(userId, filterBitMask, &infos);
        if (rv < 0) {
            goto out;
        }

        std::list<ccd::LanDeviceInfo>::iterator it;
        for (it = infos.begin(); it != infos.end(); it++) {
            ccd::LanDeviceInfo *currOut = response.add_infos();
            *currOut = *it;
        }
    }
out:
    LOG_CCDI_RESPONSE(response, rv);
    return rv;
}

CCDIError CCDIProbeLanDevices()
{
    LOG_CCDI_REQUEST(ccd::NoParamRequest::default_instance());
    s32 rv = 0;
    ccd::CcdiEvent *event;
    ccd::EventLanDevicesProbeRequest *request;
    VPLTime_t timestamp;

    // Send an event to trigger SDD to probe for devices again
    event = new ccd::CcdiEvent();
    if (event == NULL) {
        LOG_ERROR("Failed to allocate an event for probe request");
        rv = CCD_ERROR_NOMEM;
        goto end;
    }
    request = event->mutable_lan_devices_probe_request();

    timestamp = VPLTime_GetTimeStamp();
    request->set_timestamp(timestamp);

    EventManagerPb_AddEvent(event);

end:
    LOG_CCDI_RESPONSE(ccd::NoParamResponse::default_instance(), rv);
    return rv;
}

CCDIError CCDIListStorageNodeDatasets(ccd::ListStorageNodeDatasetsOutput& response)
{
    LOG_CCDI_REQUEST(ccd::NoParamRequest::default_instance());
#if CCD_ENABLE_STORAGE_NODE
    s32 rv = 0;
    char snRoot[CCD_PATH_MAX_LENGTH];
    std::list<vss_dataset_info_t> dataset_infos;
    std::list<vss_dataset_info_t>::iterator it;

    DiskCache::getPathForStorageNode(sizeof(snRoot), snRoot);

    rv = StorageNode_ListDatasetInfos(snRoot, dataset_infos);
    if (rv != 0) {
        LOG_ERROR("Failed to list dataset infos, rv=%d", rv);
        goto out;
    }

    for (it = dataset_infos.begin(); it != dataset_infos.end(); it++) {
        ccd::DatasetItem *currOut = response.add_datasets();
        currOut->set_user_id(it->user_id);
        currOut->set_dataset_id(it->dataset_id);
    }

 out:
#else
    CCDIError rv = CCD_ERROR_FEATURE_DISABLED;
#endif
    LOG_CCDI_RESPONSE(response, rv);
    return rv;
}

CCDIError CCDIRemoteWakeup(const ccd::RemoteWakeupInput& request)
{
    LOG_CCDI_REQUEST(request);
    CacheAutoLock autoLock;
    s32 rv = autoLock.LockForRead();
    if (rv < 0) {
        LOG_ERROR("Failed to obtain lock");
        goto out;
    }
    else {
        // Check that the specified user is still logged in.
        CachePlayer* player = cache_getUserByUserId(request.user_id());
        if (player == NULL) {
            LOG_ERROR("userId "FMT_VPLUser_Id_t" not signed in", request.user_id());
            rv = CCD_ERROR_NOT_SIGNED_IN;
            goto out;
        }

        if (DeviceStateCache_GetLocalDeviceState() != DEVICE_CONNECTION_ONLINE) {
            rv = CCD_ERROR_LOCAL_DEVICE_OFFLINE;
            goto out;
        }
        rv = ANSConn_WakeDevice(request.device_to_wake());
    }
 out:
    LOG_CCDI_RESPONSE(ccd::NoParamResponse::default_instance(), rv);
    return rv;
}

CCDIError CCDIRenameDataset(const ccd::RenameDatasetInput& request)
{
    LOG_CCDI_REQUEST(request);
    // TODO: impl
    CCDIError rv = CCD_ERROR_NOT_IMPLEMENTED;
    LOG_CCDI_RESPONSE(ccd::NoParamResponse::default_instance(), rv);
    return rv;
}

CCDIError CCDIPrivateMsaDataCommit(const ccd::PrivateMsaDataCommitInput& request)
{
    LOG_CCDI_REQUEST(request);
    int rv;
    {
        if (request.commit_start() == request.commit_end()) {
            LOG_ERROR("Commit start and end cannot be both true or both false");
            rv = CCD_ERROR_PARAMETER;
            goto out;
        }

        bool b_enable = false;
        if(request.commit_start()) {
            b_enable = false;
        } else if(request.commit_end()) {
            b_enable = true;
        }

        if(request.initialize()) {
            /////////////// VSS --> VCS transition: Bug 9901 ///////////////////
            // Bug 9901: VCS Cleanup should be done server-side, not done here.
        }
        rv = SyncFeatureMgr_DisableEnableMetadataUpload(request.user_id(), b_enable);
        if(rv != 0) {
            LOG_ERROR("SyncFeatureMgr_DisableEnableMetadataUpload:%d, user:"FMT_VPLUser_Id_t,
                      rv, request.user_id());
        }
    }
 out:
    LOG_CCDI_RESPONSE(ccd::NoParamResponse::default_instance(), rv);
    return rv;
}

CCDIError CCDISyncOnce(const ccd::SyncOnceInput& request,
                       ccd::SyncOnceOutput& response)
{
    LOG_CCDI_REQUEST(request);
    std::string appId;
    ccd::CcdApp_t appType;
    std::vector<SyncFeature> featuresList;
    u64 userId = 0;
    int rv = CCDI_OK;

    {
        CachePlayer* player;

        CacheAutoLock autoLock;
        rv = autoLock.LockForRead();
        if (rv != 0) {
            LOG_ERROR("Failed to lock, rv = %d", rv);
            goto end;
        }

        player = cache_getSyncUser(request.has_user_id(), request.user_id());
        if (player == NULL) {
            LOG_ERROR("Failed to get user by id, user_id = "FMTu64" ,rv = %d",
                      request.user_id(), rv);
            rv = CCD_ERROR_NOT_SIGNED_IN;
            goto end;
        }
        userId = player->user_id();

#if CCD_SYNC_CONFIGS_ALWAYS_ACTIVE
        LOG_INFO("SyncConfigs all active, sync all media.");
        appType = CCD_APP_ALL_MEDIA;
#else
        rv = Cache_GetForegroundApp(/*out*/ appId,
                                    /*out*/ appType);
        if(rv != 0) {
            LOG_ERROR("Cache_GetForegroundApp:%d", rv);
            goto end;
        }

        if(appId == request.app_id()) {
            LOG_INFO("SyncOnce of %s with type %d", appId.c_str(), appType);
        }else{
            LOG_ERROR("SyncOnce failed: %s appId not fg app %s",
                      request.app_id().c_str(), appId.c_str());
            rv = CCD_ERROR_APP_ID;
            goto end;
        }
#endif
    }

    SyncFeatureMgr_RequestLocalScansForUser(userId);
    SyncFeatureMgr_RequestRemoteScansForUser(userId);
    GetSyncFeaturesFromAppType(appType, /*out*/ featuresList);
    {
#if CCD_ENABLE_SYNCDOWN
        bool notifiedOnce = false;
#endif // CCD_ENABLE_SYNCDOWN
        for(size_t i = 0; i < featuresList.size(); ++i) {
#if CCD_ENABLE_SYNCDOWN
            if (!notifiedOnce) {
                if(featuresList[i].feature == SYNC_FEATURE_PICSTREAM_DOWNLOAD_FULL_RES ||
                   featuresList[i].feature == SYNC_FEATURE_PICSTREAM_DOWNLOAD_LOW_RES)
                {
                    notifiedOnce = true;
                    LOG_INFO("VcsSyncDown synced from SyncOnce");
                    Cache_NotifySyncDownModule(userId, 0, true);
                    continue;
                }
            }
#endif // CCD_ENABLE_SYNCDOWN
        }
#if CCD_ENABLE_SYNCUP
        int rc = SyncUp_NotifyConnectionChange(true);
        if(rc != 0) {
            LOG_WARN("SyncUp_NotifyConnectionChange:%d", rc);
        }
#endif // CCD_ENABLE_SYNCUP
    }

 end:
    LOG_CCDI_RESPONSE(response, rv);
    return rv;
}


CCDIError CCDIUnlinkDevice(const ccd::UnlinkDeviceInput& request)
{
    LOG_CCDI_REQUEST(request);
    int rv = 0;
    UserSession session;
    u64 deviceIdToUnlink;
    u64 localDeviceId;

    rv = Cache_GetSessionByUser(request.user_id(), session);
    if(rv != 0) {
        LOG_ERROR("Could not get session for user:"FMT_VPLUser_Id_t, request.user_id());
        goto out;
    }

    rv = ESCore_GetDeviceGuid(&localDeviceId);
    if (rv != 0) {
        LOG_ERROR("ESCore_GetDeviceGuid failed: %d", rv);
        goto out;
    }

    if (request.has_device_id()) {
        deviceIdToUnlink = request.device_id();
    } else {
        deviceIdToUnlink = localDeviceId;
    }
    if (deviceIdToUnlink == localDeviceId) {
        // "Self Unlinking" case: the user is unlinking the local device, so treat it
        // as explicit Logout.
        LOG_INFO("Self-unlinking detected; logging out user");
#if CCD_USE_SHARED_CREDENTIALS
        // Get 'credentials' location
        const char* credentialsLocation = VPLSharedObject_GetCredentialsLocation();

        // Store a flag to indicate that this device is being unlinked by itself.
        // Since we only check for the existence of the flag, for simplicity's
        // sake we just store the char "2" into the shared location.
        const char* isDeviceUnlinkingFlag = "2";
        VPLSharedObject_AddString(credentialsLocation, VPL_SHARED_IS_DEVICE_UNLINKING_ID, isDeviceUnlinkingFlag);
        // Clear the flag. This device is now being unlinked for all applications on this device.
        VPLSharedObject_AddString(credentialsLocation, VPL_SHARED_IS_DEVICE_LINKED_ID, VPL_SHARED_DEVICE_NOT_LINKED);
#endif
        rv = Cache_Logout_Unlink(request.user_id(), session, deviceIdToUnlink);
        if (rv != 0) {
            LOG_ERROR("Cache_Logout_Unlink(user="FMT_VPLUser_Id_t") failed: %d",
                      request.user_id(), rv);
        }
    } else {
        // Unlinking some other device.
        vplex::vsDirectory::UnlinkDeviceOutput vsds_response;
        rv = Query_UnlinkDevice(request.user_id(),
                                session,
                                deviceIdToUnlink,
                                /*out*/ vsds_response);
        if (rv == 0) {
            // Update linked device state.
            // TODO: Should really be using the activationId instead of user_id, since we release the lock
            //   between steps.
            CacheMonitor_MarkLinkedDevicesDirty(request.user_id());
        } else {
            LOG_ERROR("Query_UnlinkDevice(user="FMT_VPLUser_Id_t") failed: %d",
                      request.user_id(), rv);
        }
    }
 out:
    LOG_CCDI_RESPONSE(ccd::NoParamResponse::default_instance(), rv);
    return rv;
}

CCDIError CCDIUnregisterStorageNode(const ccd::UnregisterStorageNodeInput& request)
{
    LOG_CCDI_REQUEST(request);
#if CCD_ENABLE_STORAGE_NODE
    // TODO: should probably be protected from interleaved login/logout
    s32 rv;
    vplex::vsDirectory::DeleteUserStorageInput vsds_request;
    {
        CacheAutoLock autoLock;
        rv = autoLock.LockForWrite();
        if (rv < 0) {
            LOG_ERROR("Failed to obtain lock");
            goto out;
        }
        CachePlayer *player = cache_getUserByUserId(request.user_id());
        if (player == NULL) {
            LOG_ERROR("userId "FMT_VPLUser_Id_t" not signed in", request.user_id());
            rv = CCD_ERROR_NOT_SIGNED_IN;
            goto out;
        }
        Query_FillInVsdsSession(vsds_request.mutable_session(), player->getSession());
        vsds_request.set_userid(request.user_id());
        if (request.has_device_id()) {
            vsds_request.set_storageclusterid(request.device_id());
        } else {
            u64 thisDeviceId;
            rv = ESCore_GetDeviceGuid(&thisDeviceId);
            if (rv != 0) {
                LOG_ERROR("%s failed: %d", "ESCore_GetDeviceGuid", rv);
                goto out;
            }
            vsds_request.set_storageclusterid(thisDeviceId);
        }
    } // releases cache lock

    LocalServers_StopStorageNode();

    {
        vplex::vsDirectory::DeleteUserStorageOutput vsds_response;
        rv = QUERY_VSDS(VPLVsDirectory_DeleteUserStorage, vsds_request, vsds_response);
        if (rv != 0) {
            goto out;
        }
    }
 out:
#else
    CCDIError rv = CCD_ERROR_FEATURE_DISABLED;
#endif
    LOG_CCDI_RESPONSE(ccd::NoParamResponse::default_instance(), rv);
    return rv;
}

CCDIError CCDIUpdateStorageNode(const ccd::UpdateStorageNodeInput& request)
{
    LOG_CCDI_REQUEST(request);
    s32 rv;

    {
        u64 device_id;
        if (request.has_device_id()) {
            device_id = request.device_id();
        } else {
            rv = ESCore_GetDeviceGuid(&device_id);
            if (rv != 0) {
                LOG_ERROR("%s failed: %d", "ESCore_GetDeviceGuid", rv);
                goto out;
            }
        }

        vplex::vsDirectory::UpdateStorageNodeFeaturesInput vsds_request;
        bool has_remote_work = false;
        if (request.has_feature_media_server_enabled()) {
            vsds_request.set_featuremediaserverenabled(request.feature_media_server_enabled());
            has_remote_work = true;
        }
        if (request.has_feature_virt_drive_enabled()) {
            vsds_request.set_featurevirtdriveenabled(request.feature_virt_drive_enabled());
            has_remote_work = true;
        }
        if (request.has_feature_remote_file_access_enabled()) {
            vsds_request.set_featureremotefileaccessenabled(request.feature_remote_file_access_enabled());
            has_remote_work = true;
        }
        if (request.has_feature_my_storage_server_enabled()) {
            vsds_request.set_featuremystorageserverenabled(request.feature_my_storage_server_enabled());
            has_remote_work = true;
        }
#if CCD_ENABLE_STORAGE_NODE
        if (request.has_add_remotefile_access_control_dir() || 
            request.has_remove_remotefile_access_control_dir()) {
            MutexAutoLock lock(LocalServers_GetMutex());
            {
                CacheAutoLock autoLock;
                rv = autoLock.LockForRead();
                if (rv < 0) {
                    LOG_ERROR("Failed to obtain lock");
                    goto out;
                }
                
                CachePlayer* currUser = cache_getUserByPlayerIndex(0);
                u64 datasetId = 0;
                VPLUser_Id_t userId;
                if (currUser) {
                    userId = currUser->user_id();
                    rv = currUser->getLocalDeviceStorageDatasetId(/*out*/datasetId);
                    if (rv < 0) {
                        LOG_ERROR("getLocalDeviceStorageDatasetId failed");
                        goto out;
                    }
                }
                
                vss_server* storageNode = LocalServers_getStorageNode();
                if (currUser && currUser->isLocalDeviceStorageNode() && storageNode != NULL) {

                    if (request.has_add_remotefile_access_control_dir()) {
                        const ccd::RemoteFileAccessControlDirSpec &dir = request.add_remotefile_access_control_dir();
                        if(dir.has_dir() && dir.has_name())
                            return CCD_ERROR_PARAMETER;
                        rv = storageNode->updateRemoteFileAccessControlDir(userId, datasetId, dir, true);
                    }
                    else if (request.has_remove_remotefile_access_control_dir()) {
                        const ccd::RemoteFileAccessControlDirSpec &dir = request.remove_remotefile_access_control_dir();
                        if(dir.has_dir() && dir.has_name())
                            return CCD_ERROR_PARAMETER;
                        rv = storageNode->updateRemoteFileAccessControlDir(userId, datasetId, dir, false);
                    }

#if defined(WIN32) && !defined(VPL_PLAT_IS_WINRT)
                    //Get the list and save to storage
                    //TODO: do we need mutex here?
                    if(rv == VPL_OK){
                        ccd::RemoteFileAccessControlDirs rfaclDirs;
                        storageNode->getRemoteFileAccessControlDir(rfaclDirs);

                        {
                            char tempFilename[CCD_PATH_MAX_LENGTH];
                            DiskCache::getPathForUserRFAccessControlList(userId, sizeof(tempFilename), tempFilename);
                            ProtobufFileWriter writer;
                            rv = writer.open(tempFilename, CCD_NEW_FILE_MODE);
                            if (rv < 0) {
                                LOG_ERROR("writer.open(%s) returned %d", tempFilename, rv);
                                goto out;
                            }
                            LOG_DEBUG("Serializing to %s", tempFilename);
                            google::protobuf::io::CodedOutputStream tempStream(writer.getOutputStream());
                            if(!rfaclDirs.SerializeToCodedStream(&tempStream)) {
                                LOG_ERROR("Failed to write rfacl to %s", tempFilename);
                                rv = CCD_ERROR_DISK_SERIALIZE;
                                goto out;
                            }
                            LOG_DEBUG("Success serializing to %s", tempFilename);
                        }
                    }else{
                        LOG_ERROR("updateRemoteFileAccessControlDir failed, %d", rv);
                    }
#endif  //#if defined(WIN32) && !defined(VPL_PLAT_IS_WINRT)

                }
            }
        }
#endif  //CCD_ENABLE_STORAGE_NODE
        if ( !has_remote_work ) {
            LOG_INFO("No remote changes requested.");
            rv = 0;
            goto out;
        }

        {
            CacheAutoLock autoLock;
            rv = autoLock.LockForRead();
            if (rv < 0) {
                LOG_ERROR("Failed to obtain lock");
                goto out;
            }

            CachePlayer* user = cache_getUserByUserId(request.user_id());
            if (user == NULL) {
                LOG_ERROR("userId "FMT_VPLUser_Id_t" not signed in", request.user_id());
                rv = CCD_ERROR_NOT_SIGNED_IN;
                goto out;
            }
            Query_FillInVsdsSession(vsds_request.mutable_session(), user->getSession());
            vsds_request.set_userid(request.user_id());
            vsds_request.set_clusterid(device_id);
        } // releases cache lock

        vplex::vsDirectory::UpdateStorageNodeFeaturesOutput vsds_response;
        rv = QUERY_VSDS(VPLVsDirectory_UpdateStorageNodeFeatures, vsds_request, vsds_response);
        if (rv != 0) {
            LOG_ERROR("Failed updating storage node "FMTu64" features: %d",
                device_id, rv);
            goto out;
        }
        CacheMonitor_MarkStorageNodesDirty(request.user_id());
    }
 out:
    LOG_CCDI_RESPONSE(ccd::NoParamResponse::default_instance(), rv);
    return rv;
}

static const char *syncFeatureName(const SyncFeature_t sf)
{
    if(sf == SYNC_FEATURE_PHOTO_THUMBNAILS) return "ph_thumb";
    if(sf == SYNC_FEATURE_MUSIC_THUMBNAILS) return "mu_thumb";
    if(sf == SYNC_FEATURE_VIDEO_THUMBNAILS) return "vi_thumb";
    return "unknown";
}

static int stopThumbnailSyncConfigs(const CachePlayer& user,
                                    u64 mediaMetadataDsetId)
{
    int rv = 0;
    int rc;
    // Requires write lock to make sure the SyncConfig isn't re-enabled in
    // cache_registerSyncConfigs while the SyncConfig is disabled
    ASSERT(Cache_ThreadHasWriteLock());

    LOG_INFO("Removing all thumbnail syncing");
    rc = SyncFeatureMgr_Remove(user.user_id(),
                               mediaMetadataDsetId,
                               SYNC_FEATURE_PHOTO_THUMBNAILS);
    if(rc != 0) {
        LOG_ERROR("SyncFeatureMgr_Remove("FMTu64","FMTu64",ph_thumb):%d",
                  user.user_id(), mediaMetadataDsetId, rc);
        rv = rc;
    }
    LOG_INFO("ph_thumb sync removed("FMTu64","FMTu64")",
             user.user_id(), mediaMetadataDsetId);
    rc = SyncFeatureMgr_Remove(user.user_id(),
                               mediaMetadataDsetId,
                               SYNC_FEATURE_MUSIC_THUMBNAILS);
    if(rc != 0) {
        LOG_ERROR("SyncFeatureMgr_Remove("FMTu64","FMTu64",mu_thumb):%d",
                  user.user_id(), mediaMetadataDsetId, rc);
        rv = rc;
    }
    LOG_INFO("mu_thumb sync removed("FMTu64","FMTu64")",
             user.user_id(), mediaMetadataDsetId);
    rc = SyncFeatureMgr_Remove(user.user_id(),
                               mediaMetadataDsetId,
                               SYNC_FEATURE_VIDEO_THUMBNAILS);
    if(rc != 0) {
        LOG_ERROR("SyncFeatureMgr_Remove("FMTu64","FMTu64",vi_thumb):%d",
                  user.user_id(), mediaMetadataDsetId, rc);
        rv = rc;
    }
    LOG_INFO("vi_thumb sync removed("FMTu64","FMTu64")",
             user.user_id(), mediaMetadataDsetId);

    return rv;
}

static int stopDisabledSyncFeatures(const CachePlayer& user,
                                    u64 mediaMetadataDsetId)
{
    int rv = 0;
    int rc;
    // Requires write lock to make sure the SyncConfig isn't re-enabled in
    // cache_registerSyncConfigs while the SyncConfig is disabled
    ASSERT(Cache_ThreadHasWriteLock());

    // This function shouldn't be used when virtual sync is being used for thumbnail downloads.
    ASSERT(!__ccdConfig.mediaMetadataThumbVirtDownload);

    //
    // Thumbnail syncing can be selectively enabled and disabled by type, so
    // this logic needs to check the disabled list
    //
    std::set<SyncFeature_t> disabledList;
    std::set<SyncFeature_t>::const_iterator sf_it;

    int numEntries = user._cachedData.details().mm_thumb_sync_disabled_types_size();

    for(int i = 0; i < numEntries; i++) {
        disabledList.insert(user._cachedData.details().mm_thumb_sync_disabled_types(i));
    }

    for(sf_it = disabledList.begin(); sf_it != disabledList.end(); sf_it++) {
        // Sanity check
        if(*sf_it != SYNC_FEATURE_PHOTO_THUMBNAILS &&
           *sf_it != SYNC_FEATURE_MUSIC_THUMBNAILS &&
           *sf_it != SYNC_FEATURE_VIDEO_THUMBNAILS) 
        {
            LOG_ERROR("Unexpected SyncFeature %d", *sf_it);
            continue;
        }

        rc = SyncFeatureMgr_Remove(user.user_id(), mediaMetadataDsetId, *sf_it);
        if(rc != 0) {
            LOG_ERROR("SyncFeatureMgr_Remove("FMTu64","FMTu64",%s):%d",
                      user.user_id(), mediaMetadataDsetId, syncFeatureName(*sf_it), rc);
            rv = rc;
        }
        //
        // If disabling thumbnail sync in the non-migrate case, clear the local cached
        // copies since the intent is to conserve local storage on a mobile device.
        // In the migrate case, deleting the "from" copy happens once the migration
        // is complete.
        //
        cache_clearMMCacheByType(user, *sf_it);
        LOG_INFO("%s sync disabled and removed("FMTu64","FMTu64")",
                 syncFeatureName(*sf_it), user.user_id(), mediaMetadataDsetId);
    }

    return rv;
}

CCDIError CCDIUpdateSyncSettings(const ccd::UpdateSyncSettingsInput& request, ccd::UpdateSyncSettingsOutput& response)
{
    LOG_CCDI_REQUEST(request);
    int numFailures = 0;
    int numOperations = 0;
    int rv = CCD_OK;
    bool powerSettingChanged = false;
    bool mm_thumb_migrate_resume = false;
    bool has_mm_enable = false;
    bool has_mm_disable = false;
    s32 createNotesDatasetRv = CCD_ERROR_INTERNAL;
    s32 configureSyncboxRv = CCD_ERROR_INTERNAL;
#if CCD_ENABLE_STORAGE_NODE
    std::string stagingAreaPath;
    u64 syncboxDatasetId = 0;
#endif

    UserSession session;
    u32 activationId = 0;
    int rc;

    rv = Cache_GetActivationIdForSyncUser(&activationId, request.has_user_id(), request.user_id());
    if(rv != 0) {
        LOG_ERROR("Could not get activationId for user:"FMT_VPLUser_Id_t, request.user_id());
        goto out;
    }
    rv = Cache_GetSessionByActivationId(activationId, session);
    if(rv != 0) {
        LOG_ERROR("Could not get session for user:"FMT_VPLUser_Id_t" activationId:%d",
                  request.user_id(), activationId);
        goto out;
    }
    // TODO: for the rest of the function, we should consistently be using the activationId instead of user_id,
    //   since we are not holding the cache lock.

    if(request.has_set_my_device_name()) {
        numOperations++;
        vplex::vsDirectory::SetDeviceNameOutput vsds_response;
        rv = Query_SetDeviceName(request.user_id(),
                                 session,
                                 request.set_my_device_name(),
                                 vsds_response);
        if (rv == 0) {
            // Update linked device state.
            CacheMonitor_MarkLinkedDevicesDirty(request.user_id());
        } else {
            numFailures++;
            LOG_ERROR("Query_SetDeviceName(user="FMT_VPLUser_Id_t") failed: %d",
                      request.user_id(), rv);
        }
        response.set_set_my_device_name_err(rv);
    }

    if(request.has_enable_network_activity()) {
        numOperations++;
        LOG_ERROR("Deprecated enable_network_activity:%d call will continue to work,"
                  " but please stop using it soon.", request.enable_network_activity());
        bool networkEnable;
        Cache_GetDeprecatedNetworkEnable(networkEnable);
        bool changed = (request.enable_network_activity() != networkEnable);
        if(changed) {
            Cache_SetDeprecatedNetworkEnable(request.enable_network_activity());
            powerSettingChanged = true;
        }
        response.set_enable_network_activity_err(0);
    }

    if (request.has_configure_notes_sync() && request.configure_notes_sync().enable_sync_feature()) {
        createNotesDatasetRv = Cache_CreateNotesDatasetIfNeeded(activationId);
    }

    if (request.has_enable_shared_by_me() && request.enable_shared_by_me()) {
        numOperations++;
        int temp_rc = Cache_CreateSbmDatasetIfNeeded(activationId);
        response.set_enable_shared_by_me_err(temp_rc);
        if (temp_rc != 0) {
            numFailures++;
        }
    }

    if (request.has_enable_shared_with_me() && request.enable_shared_with_me()) {
        numOperations++;
        int temp_rc = Cache_CreateSwmDatasetIfNeeded(activationId);
        response.set_enable_shared_with_me_err(temp_rc);
        if (temp_rc != 0) {
            numFailures++;
        }
    }

    if (request.has_configure_syncbox_sync()) {
        if (request.configure_syncbox_sync().enable_sync_feature()) {
            LOG_INFO("Syncbox enable requested");
            if (!request.configure_syncbox_sync().has_set_sync_feature_path()) {
                LOG_ERROR("set_sync_feature_path is required to enable Syncbox.");
                configureSyncboxRv = CCD_ERROR_PARAMETER;
            } else {
                ccd::SyncBoxSettings syncboxSettings;
                configureSyncboxRv = Cache_GetSyncboxSettings(request.user_id(), /*out*/syncboxSettings);
                if (configureSyncboxRv != 0) {
                    LOG_ERROR("Cache_GetSyncboxSettings failed: %d", configureSyncboxRv);
                    goto skip_syncboxdataset_change;
                }
                if (syncboxSettings.enable_sync()) { // Only create syncbox dataset when sync is not currently active.
                    LOG_ERROR("Syncbox sync is enabled. Need to disable first before changing settings");
                    configureSyncboxRv = CCD_ERROR_SYNCBOX_ACTIVE;
                    goto skip_syncboxdataset_change;
                }
                std::string sync_feature_path = Util_CleanupPath(request.configure_syncbox_sync().set_sync_feature_path().c_str());
                {
                    VPLFS_stat_t statBuf;
                    configureSyncboxRv = VPLFS_Stat(sync_feature_path.c_str(), &statBuf);
                    if (configureSyncboxRv != 0) {
                        LOG_ERROR("Cannot verify requested sync folder \"%s\": %d", sync_feature_path.c_str(), configureSyncboxRv);
                        goto skip_syncboxdataset_change;
                    } else if (statBuf.type != VPLFS_TYPE_DIR){
                        LOG_ERROR("Requested sync folder \"%s\" is not a directory: %d", sync_feature_path.c_str(), (int)statBuf.type); 
                        configureSyncboxRv = CCD_ERROR_PATH_NOT_FOUND;
                        goto skip_syncboxdataset_change;
                    } else {
                        // OK
                    }
                }
                if (request.configure_syncbox_sync().is_archive_storage()) {
#if CCD_ENABLE_STORAGE_NODE
                    configureSyncboxRv = Cache_CreateAndAssociateSyncboxDatasetIfNeeded(activationId, syncboxDatasetId, false);
                    // Configure storage node side after dataset is created successfully.
                    if (configureSyncboxRv != 0) {
                        LOG_ERROR("Cache_CreateAndAssociateSyncboxDatasetIfNeeded failed: %d", configureSyncboxRv);
                    } else {
                        MutexAutoLock lock(LocalServers_GetMutex());
                        vss_server* storageNode = LocalServers_getStorageNode();
                        if (storageNode != NULL) {
                            // Create syncbox staging area if it does not exist yet
                            stagingAreaPath = storageNode->getSyncboxArchiveStorageStagingAreaPath(syncboxDatasetId);
                            configureSyncboxRv = Util_CreateDir(stagingAreaPath.c_str());
                            if (configureSyncboxRv != 0) {
                                LOG_ERROR("Syncbox staging area %s creation fail: %d", stagingAreaPath.c_str(), configureSyncboxRv);
                                goto skip_syncboxdataset_change;
                            }
                            storageNode->setSyncboxArchiveStorageParam(syncboxDatasetId, true, sync_feature_path);
                        } else {
                            // Cannot proceed without stagingAreaPath.
                            LOG_ERROR("Storage node is not running.");
                            configureSyncboxRv = CCD_ERROR_NOT_STORAGE_NODE;
                        }
                    }
#else
                    LOG_ERROR("This CCD does not support hosting Archive Storage.");
                    configureSyncboxRv = CCD_ERROR_NOT_STORAGE_NODE;
#endif
                }
            }
        } else {
            LOG_INFO("Syncbox disable requested");
            // If this was an archive storage device, dissociate from Syncbox dataset.
#if CCD_ENABLE_STORAGE_NODE
            ccd::SyncBoxSettings syncboxSettings;
            configureSyncboxRv = Cache_GetSyncboxSettings(request.user_id(), /*out*/ syncboxSettings);
            if (configureSyncboxRv != 0) {
                LOG_WARN("Cache_GetSyncboxSettings failed: %d", configureSyncboxRv);
                goto skip_syncboxdataset_change;
            }
            if (syncboxSettings.is_archive_storage()) {
                configureSyncboxRv = Cache_DissociateSyncboxDatasetIfNeeded(activationId);
                if (configureSyncboxRv != 0) {
                    LOG_ERROR("Cache_DissociateSyncboxDatasetIfNeeded failed: %d", configureSyncboxRv);
                } else {
                    MutexAutoLock lock(LocalServers_GetMutex());
                    vss_server* storageNode = LocalServers_getStorageNode();
                    if (storageNode != NULL) {
                        std::string dummy;
                        storageNode->setSyncboxArchiveStorageParam(0, false, dummy);
                    }
                }
            }
#endif
        }
    }
skip_syncboxdataset_change:


    if (request.has_enable_camera_roll() ||
        request.has_set_max_download_rate_bytes_sec() ||
        request.has_set_max_upload_rate_bytes_sec() ||
        request.has_background_data() ||
        request.has_auto_sync() ||
        request.has_mobile_network_data() ||
        request.remove_camera_roll_upload_dirs_size() > 0 ||
        request.add_camera_roll_upload_dirs_size() > 0 ||
        request.has_trigger_camera_roll_upload_dir() ||
        request.has_add_camera_roll_full_res_download_dir() ||
        request.has_remove_camera_roll_full_res_download_dir() ||
        request.has_add_camera_roll_low_res_download_dir() ||
        request.has_remove_camera_roll_low_res_download_dir() ||
        request.has_add_camera_roll_thumb_download_dir() ||
        request.has_remove_camera_roll_thumb_download_dir() ||
        request.has_enable_global_delete() ||
        request.has_send_file_to_camera_roll() ||
        request.has_configure_notes_sync() ||
        request.has_enable_notes_sync() ||
        request.has_enable_clouddoc_sync() ||
        request.has_migrate_mm_thumb_download_path() ||
        request.has_enable_mm_thumb_sync() ||
        request.enable_mm_thumb_sync_types_size() > 0 ||
        request.has_configure_syncbox_sync()
        )
    {
        CachePlayer* user = NULL;

        CacheAutoLock autoLock;
        rv = autoLock.LockForWrite();
        if (rv < 0) {
            LOG_ERROR("Failed to obtain lock");
        }
        if (rv == 0) {
            user = cache_getUserByActivationId(activationId);
            if (user == NULL) {
                LOG_ERROR("Could not get session for user:"FMT_VPLUser_Id_t, request.user_id());
                rv = CCD_ERROR_NOT_SIGNED_IN;
            }
        }

#if CCD_ENABLE_SYNCDOWN_PICSTREAM
        if(request.has_enable_global_delete()){
            numOperations++;
            if (user != NULL) {
                SyncDown_SetEnableGlobalDelete(request.enable_global_delete());
            }
        }
#endif
        if(request.has_enable_camera_roll()) {
            numOperations++;
            if (user != NULL) {
                rc = Picstream_Enable(request.enable_camera_roll());
                if (rc == CCD_ERROR_NOT_INIT) {
                    // Not an error, we'll just save request to do it when picstream
                    // is enabled.
                    response.set_enable_camera_roll_err(0);
                    user->set_enable_camera_roll_trigger(request.enable_camera_roll());
                }else if (rc != 0) {
                    LOG_ERROR("Picstream_Enable:%d", rc);
                    response.set_enable_camera_roll_err(rc);
                    numFailures++;
                }else{
                    // Successfully set, clear trigger, in case one already exists
                    user->set_enable_camera_roll_trigger(false);
                    response.set_enable_camera_roll_err(0);
                }
#if CCD_ENABLE_SYNCUP_PICSTREAM
                if ((rc == 0 || rc == CCD_ERROR_NOT_INIT) &&  // meaning success cases
                    !request.enable_camera_roll()) {
                    for (int i = 0; i < user->_cachedData.details().datasets_size(); i++) {
                        const vplex::vsDirectory::DatasetDetail &dd = user->_cachedData.details().datasets(i).details();
                        if (dd.datasetname() == "PicStream") {
                            SyncUp_RemoveJobsByDataset(dd.datasetid());
                            break;
                        }
                    }
                }
#endif // CCD_ENABLE_SYNCUP_PICSTREAM
            }
        }

        if(request.has_set_max_download_rate_bytes_sec()) {
            numOperations++;
            response.set_set_max_download_rate_err(CCD_ERROR_NOT_IMPLEMENTED);
            numFailures++;
        }
        if(request.has_set_max_upload_rate_bytes_sec()) {
            numOperations++;
            response.set_set_max_upload_rate_err(CCD_ERROR_NOT_IMPLEMENTED);
            numFailures++;
        }
        if(request.has_background_data()) {
            numOperations++;
            if (user != NULL) {
                rv = CCD_OK;
                if(request.background_data() != user->get_background_data()) {
                    powerSettingChanged = true;
                    user->set_background_data(request.background_data());
                }
            }
            response.set_background_data_err(rv);
            if (rv != 0) {
                numFailures++;
            }
        }
        if(request.has_auto_sync()) {
            numOperations++;
            if (user != NULL) {
                rv = CCD_OK;
                if(request.auto_sync() != user->get_auto_sync()) {
                    powerSettingChanged = true;
                    user->set_auto_sync(request.auto_sync());
                }
            }
            response.set_auto_sync_err(rv);
            if (rv != 0) {
                numFailures++;
            }
        }
        if(request.has_mobile_network_data()) {
            numOperations++;
            if (user != NULL) {
                rv = CCD_OK;
                if(request.mobile_network_data() != user->get_mobile_network_data()) {
                    powerSettingChanged = true;
                    user->set_mobile_network_data(request.mobile_network_data());
                }
            }
            response.set_mobile_network_data_err(rv);
            if (rv != 0) {
                numFailures++;
            }
        }
        if(request.remove_camera_roll_upload_dirs_size()) {
            numOperations++;
            if (user != NULL) {
#if CCD_ENABLE_SYNCUP_PICSTREAM
                u64 datasetId = 0;
                for (int i = 0; i < user->_cachedData.details().datasets_size(); i++) {
                    const vplex::vsDirectory::DatasetDetail &dd = user->_cachedData.details().datasets(i).details();
                    if (dd.datasetname() == "PicStream") {
                        datasetId = dd.datasetid();
                        break;
                    }
                }
                if (!datasetId) {
                    LOG_ERROR("failed to find PicStream dataset");
                }
#endif //CCD_ENABLE_SYNCUP_PICSTREAM
                rv = CCD_OK;
                for(int reqIndex = 0;
                    reqIndex < request.remove_camera_roll_upload_dirs_size();
                    ++reqIndex)
                {
                    std::string toRemove = Util_CleanupPath(request.remove_camera_roll_upload_dirs(reqIndex));
                    u32 index_out;
                    int rc = user->remove_camera_upload_dir(toRemove, index_out);
                    if(rc != 0) {
                        LOG_ERROR("remove_camera_upload_dir:%s, %d",
                                  toRemove.c_str(), index_out);
                        rv = rc;
                        continue;
                    }
                    rc = Picstream_RemoveMonitorDir(index_out);
                    if(rc != 0) {
                        // Not necessarily an error (picstream not init)
                        LOG_WARN("picstream remove:%d, %s, %d",
                                 rc, toRemove.c_str(), index_out);
                        continue;
                    }
#if CCD_ENABLE_SYNCUP_PICSTREAM
                    if (datasetId) {
                        SyncUp_RemoveJobsByDatasetSourcePathPrefix(datasetId, toRemove);
                    }
#endif // CCD_ENABLE_SYNCUP_PICSTREAM
                } // for (reqIndex ..)
            }
            response.set_remove_camera_roll_upload_dirs_err(rv);
            if(rv != 0) {
                numFailures++;
            }
        }
        if(request.add_camera_roll_upload_dirs_size()) {
            numOperations++;
            if (user != NULL) {
                rv = CCD_OK;

                for(int iter = 0;
                    iter < request.add_camera_roll_upload_dirs_size();
                    ++iter)
                {
                    std::string toSet = Util_CleanupPath(request.add_camera_roll_upload_dirs(iter));
                    u32 index_out;

#ifndef CLOUDNODE
                    // Makes sure that the path exists.
                    rc = Util_CreatePath(toSet.c_str(), VPL_TRUE);
                    if(rc != 0) {
                        LOG_ERROR("Could not create path:%s", toSet.c_str());
                        rv = rc;
                    }

                    VPLFS_stat_t statBuf;
                    rc = VPLFS_Stat(toSet.c_str(), &statBuf);
                    if(rc != 0) {
                        LOG_ERROR("add_camera_roll_dir %s statErr:%d",
                                  toSet.c_str(), rc);
                        rv = rc;
                        continue;
                    }else if(statBuf.type != VPLFS_TYPE_DIR){
                        LOG_ERROR("add_camera_roll_dir %s not a directory:%d",
                                  toSet.c_str(), (int)statBuf.type);
                        rv = CCD_ERROR_PATH_NOT_FOUND;
                        continue;
                    }
#endif // CLOUDNODE

                    int rc = user->add_camera_upload_dir(toSet, index_out);
                    if(rc == CCD_ERROR_ALREADY) {
                        LOG_WARN("cameraUploadDir %s has already been added",
                                 toSet.c_str());
                        continue;
                    }else if(rc != 0) {
                        LOG_ERROR("add_camera_upload_dir:%s, %d",
                                  toSet.c_str(), rc);
                        rv = rc;
                        continue;
                    }else{ // rc == 0
                        rc = Picstream_AddMonitorDir(toSet.c_str(), index_out, true);
                        if(rc == 0) {
                            u32 unused;
                            user->clear_camera_upload_never_init(toSet.c_str(),
                                                                 unused);
                        }else if(rc == CCD_ERROR_NOT_INIT){
                            // Not a true error, it's acceptable that
                            // PicStream is not initialized.
                        }else{
                            LOG_ERROR("Picstream_AddMonitorDir0:%d, %s",
                                      rc, toSet.c_str());
                            rv = rc;
                        }
                    }
                }
            }
            response.set_add_camera_roll_upload_dirs_err(rv);
            if(rv != 0) {
                numFailures++;
            }
        }
        if(request.has_trigger_camera_roll_upload_dir()) {
            numOperations++;
            if (user != NULL) {
                rv = CCD_OK;
                std::string trigger_camera_roll_upload_dir =
                        Util_CleanupPath(request.trigger_camera_roll_upload_dir());
                // First check if it already exists, no need to do any work
                u32 index;
                bool unused;
                int rc = user->get_camera_upload_dir(trigger_camera_roll_upload_dir,
                                                     index,
                                                     unused);

                if(rc != 0) {
                    rv = rc;
                    LOG_ERROR("The dir has not been added:%s, %d",
                              trigger_camera_roll_upload_dir.c_str(), rc);
                }else{
                    rc = Picstream_PerformFullSyncDir(user->user_id(), index);
                    if (rc != 0) {
                        LOG_ERROR("Picstream_PerformFullSyncDir:%d", rc);
                        rv = rc;
                    }
                }
            }
            response.set_trigger_camera_roll_upload_dir_err(rv);
            if(rv != 0) {
                numFailures++;
            }
        }
        if(request.has_add_camera_roll_full_res_download_dir()) {
            numOperations++;
            while (user != NULL) { // will not loop, will break out of while loop.
                rv = CCD_OK;
                bool addIt = false, updateIt = false;
                string pathToAdd = Util_CleanupPath(request.add_camera_roll_full_res_download_dir().dir());
#ifndef CLOUDNODE
                // Makes sure that the path exists.
                rc = Util_CreatePath(pathToAdd.c_str(), VPL_TRUE);
                if(rc != 0) {
                    LOG_ERROR("Could not create path:%s", pathToAdd.c_str());
                    rv = rc;
                }

                VPLFS_stat_t statBuf;
                rc = VPLFS_Stat(pathToAdd.c_str(), &statBuf);
                if(rc != 0) {
                    LOG_ERROR("add_camera_roll_full_res_download_dir %s statErr:%d",
                              pathToAdd.c_str(), rc);
                    rv = rc;
                    break;
                }else if(statBuf.type != VPLFS_TYPE_DIR){
                    LOG_ERROR("add_camera_roll_full_res_download_dir %s not a directory:%d",
                              pathToAdd.c_str(), (int)statBuf.type);
                    rv = CCD_ERROR_PATH_NOT_FOUND;
                    break;
                }
#endif // CLOUDNODE
                if(request.add_camera_roll_full_res_download_dir().preserve_free_disk_percentage() > 100) {
                    LOG_ERROR("preserve_free_disk_percentage() is not within 100: %d", request.add_camera_roll_full_res_download_dir().preserve_free_disk_percentage());
                    rv = CCD_ERROR_PARAMETER;
                    break;
                }
                google::protobuf::RepeatedPtrField<ccd::CameraRollDownloadDirSpecInternal> picstream_download_dirs_full_res;
                user->get_camera_download_full_res_dirs(picstream_download_dirs_full_res);
                if (picstream_download_dirs_full_res.size() > 0) {
                    if (pathToAdd == picstream_download_dirs_full_res.Get(0).dir()) {
                        if ((request.add_camera_roll_full_res_download_dir().max_files() !=
                                picstream_download_dirs_full_res.Get(0).max_files()) ||
                            (request.add_camera_roll_full_res_download_dir().max_size() !=
                                    picstream_download_dirs_full_res.Get(0).max_size()) ||
                            (request.add_camera_roll_full_res_download_dir().preserve_free_disk_percentage() !=
                                    picstream_download_dirs_full_res.Get(0).preserve_free_disk_percentage()) ||
                            (request.add_camera_roll_full_res_download_dir().preserve_free_disk_size_bytes() !=
                                    picstream_download_dirs_full_res.Get(0).preserve_free_disk_size_bytes()))
                        {
                            updateIt = true;
                            LOG_INFO("Updating \"%s\"", pathToAdd.c_str());
                        } else {
                            LOG_INFO("Nothing to change");
                        }
                    } else {
                        LOG_WARN("Cannot add \"%s\"; already downloading to \"%s\"", pathToAdd.c_str(),
                                picstream_download_dirs_full_res.Get(0).dir().c_str());
                        rv = CCD_ERROR_TOO_MANY_PATHS;
                    }
                } else {
                    addIt = true;
                    LOG_INFO("Adding \"%s\"", pathToAdd.c_str());
                }
                if (addIt || updateIt) {
                    user->clear_camera_download_full_res_dirs();
                    user->add_camera_download_full_res_dir(pathToAdd,
                                                           request.add_camera_roll_full_res_download_dir().max_size(),
                                                           request.add_camera_roll_full_res_download_dir().max_files(),
                                                           request.add_camera_roll_full_res_download_dir().preserve_free_disk_percentage(),
                                                           request.add_camera_roll_full_res_download_dir().preserve_free_disk_size_bytes());
                    // TODO: Probably don't need to call cache_registerSyncConfigs() here.
                    //   I think it's an artifact from the old SyncAgent-based implementation.
                    cache_registerSyncConfigs(*user);

#if CCD_ENABLE_SYNCDOWN_PICSTREAM
                    if (addIt) {
                        // If a new download dir is set, 
                        // reset the last-checked dataset version and send a dataset content change notification.
                        // This is so that all the files in the dataset will be downloaded to the new download dir.
                        for (int i = 0; i < user->_cachedData.details().datasets_size(); i++) {
                            const vplex::vsDirectory::DatasetDetail &dd = user->_cachedData.details().datasets(i).details();
                            if (dd.datasetname() == "PicStream") {
                                //SyncDown_ResetDatasetLastCheckedVersion(dd.datasetid());
                                if (!dd.suspendedflag()) {
                                    SyncDown_NotifyDatasetContentChange(dd.datasetid(), false, true, FileType_FullRes);
                                } else {
                                    LOG_ERROR("PicStream Dataset ("FMTu64") suspended", dd.datasetid());
                                }
                                break;
                            }
                        }
                    }
#endif // CCD_ENABLE_SYNCDOWN_PICSTREAM
                }
                break;
            }
            response.set_add_camera_roll_full_res_download_dir_err(rv);
            if(rv != 0) {
                numFailures++;
            }
        }
        if(request.has_remove_camera_roll_full_res_download_dir()) {
            numOperations++;
            if (user != NULL) {
                rv = CCD_OK;
                string pathToRemove = Util_CleanupPath(request.remove_camera_roll_full_res_download_dir());
                google::protobuf::RepeatedPtrField<ccd::CameraRollDownloadDirSpecInternal> picstream_download_dirs_full_res;
                user->get_camera_download_full_res_dirs(picstream_download_dirs_full_res);
                if ((picstream_download_dirs_full_res.size() > 0) &&
                    (pathToRemove == picstream_download_dirs_full_res.Get(0).dir()))
                {
                    user->clear_camera_download_full_res_dirs();
                    cache_registerSyncConfigs(*user);
#if CCD_ENABLE_SYNCDOWN_PICSTREAM
                    for (int i = 0; i < user->_cachedData.details().datasets_size(); i++) {
                        const vplex::vsDirectory::DatasetDetail &dd = user->_cachedData.details().datasets(i).details();
                        if (dd.datasetname() == "PicStream") {
                            SyncDown_RemoveJobsByDataset(dd.datasetid());
                            break;
                        }
                    }
#endif // CCD_ENABLE_SYNCDOWN_PICSTREAM
                } else {
                    LOG_WARN("Cannot remove \"%s\"", pathToRemove.c_str());
                    rv = CCD_ERROR_PATH_NOT_FOUND;
                }
            }
            response.set_remove_camera_roll_full_res_download_dir_err(rv);
            if(rv != 0) {
                numFailures++;
            }
        }
        if(request.has_add_camera_roll_low_res_download_dir()) {
            numOperations++;
            while (user != NULL) { // will not loop, will break out of while loop.
                rv = CCD_OK;
                bool addIt = false, updateIt = false;
                string pathToAdd = Util_CleanupPath(request.add_camera_roll_low_res_download_dir().dir());

#ifndef CLOUDNODE
                // Makes sure that the path exists.
                rc = Util_CreatePath(pathToAdd.c_str(), VPL_TRUE);
                if(rc != 0) {
                    LOG_ERROR("Could not create path:%s", pathToAdd.c_str());
                    rv = rc;
                }

                VPLFS_stat_t statBuf;
                rc = VPLFS_Stat(pathToAdd.c_str(), &statBuf);
                if(rc != 0) {
                    LOG_ERROR("add_camera_roll_low_res_download_dir %s statErr:%d",
                              pathToAdd.c_str(), rc);
                    rv = rc;
                    break;
                }else if(statBuf.type != VPLFS_TYPE_DIR){
                    LOG_ERROR("add_camera_roll_low_res_download_dir %s not a directory:%d",
                              pathToAdd.c_str(), (int)statBuf.type);
                    rv = CCD_ERROR_PATH_NOT_FOUND;
                    break;
                }
#endif // CLOUDNODE
                if(request.add_camera_roll_low_res_download_dir().preserve_free_disk_percentage() > 100) {
                    LOG_ERROR("preserve_free_disk_percentage() is not in not within 100: %d", request.add_camera_roll_low_res_download_dir().preserve_free_disk_percentage());
                    rv = CCD_ERROR_PARAMETER;
                    break;
                }
                google::protobuf::RepeatedPtrField<ccd::CameraRollDownloadDirSpecInternal> picstream_download_dirs_low_res;
                user->get_camera_download_low_res_dirs(picstream_download_dirs_low_res);
                if (picstream_download_dirs_low_res.size() > 0) {
                    if (pathToAdd == picstream_download_dirs_low_res.Get(0).dir()) {
                        if ((request.add_camera_roll_low_res_download_dir().max_files() !=
                                picstream_download_dirs_low_res.Get(0).max_files()) ||
                            (request.add_camera_roll_low_res_download_dir().max_size() !=
                                    picstream_download_dirs_low_res.Get(0).max_size()) ||
                            (request.add_camera_roll_low_res_download_dir().preserve_free_disk_percentage() !=
                                    picstream_download_dirs_low_res.Get(0).preserve_free_disk_percentage()) ||
                            (request.add_camera_roll_low_res_download_dir().preserve_free_disk_size_bytes() !=
                                    picstream_download_dirs_low_res.Get(0).preserve_free_disk_size_bytes()))
                        {
                            updateIt = true;
                            LOG_INFO("Updating \"%s\"", pathToAdd.c_str());
                        } else {
                            LOG_INFO("Nothing to change");
                        }
                    } else {
                        LOG_WARN("Cannot add \"%s\"; already downloading to \"%s\"", pathToAdd.c_str(),
                                picstream_download_dirs_low_res.Get(0).dir().c_str());
                        rv = CCD_ERROR_TOO_MANY_PATHS;
                    }
                } else {
                    addIt = true;
                    LOG_INFO("Adding \"%s\"", pathToAdd.c_str());
                }
                if (addIt || updateIt) {
                    user->clear_camera_download_low_res_dirs();
                    user->add_camera_download_low_res_dir(pathToAdd,
                                                          request.add_camera_roll_low_res_download_dir().max_size(),
                                                          request.add_camera_roll_low_res_download_dir().max_files(),
                                                          request.add_camera_roll_low_res_download_dir().preserve_free_disk_percentage(),
                                                          request.add_camera_roll_low_res_download_dir().preserve_free_disk_size_bytes());
                    cache_registerSyncConfigs(*user);

#if CCD_ENABLE_SYNCDOWN_PICSTREAM
                    if (addIt) {
                        // If a new download dir is set, 
                        // reset the last-checked dataset version and send a dataset content change notification.
                        // This is so that all the files in the dataset will be downloaded to the new download dir.
                        for (int i = 0; i < user->_cachedData.details().datasets_size(); i++) {
                            const vplex::vsDirectory::DatasetDetail &dd = user->_cachedData.details().datasets(i).details();
                            if (dd.datasetname() == "PicStream") {
                                //SyncDown_ResetDatasetLastCheckedVersion(dd.datasetid());
                                if (!dd.suspendedflag()) {
                                    SyncDown_NotifyDatasetContentChange(dd.datasetid(), false, true, FileType_LowRes);
                                } else {
                                    LOG_ERROR("PicStream Dataset ("FMTu64") suspended", dd.datasetid());
                                }
                                break;
                            }
                        }
                    }
#endif // CCD_ENABLE_SYNCDOWN_PICSTREAM
                }
                break;
            }
            response.set_add_camera_roll_low_res_download_dir_err(rv);
            if(rv != 0) {
                numFailures++;
            }
        }
        if(request.has_remove_camera_roll_low_res_download_dir()) {
            numOperations++;
            if (user != NULL) {
                rv = CCD_OK;
                string pathToRemove = Util_CleanupPath(request.remove_camera_roll_low_res_download_dir());
                google::protobuf::RepeatedPtrField<ccd::CameraRollDownloadDirSpecInternal> picstream_download_dirs_low_res;
                user->get_camera_download_low_res_dirs(picstream_download_dirs_low_res);
                if ((picstream_download_dirs_low_res.size() > 0) &&
                    (pathToRemove == picstream_download_dirs_low_res.Get(0).dir()))
                {
                    user->clear_camera_download_low_res_dirs();
                    cache_registerSyncConfigs(*user);
#if CCD_ENABLE_SYNCDOWN_PICSTREAM
                    for (int i = 0; i < user->_cachedData.details().datasets_size(); i++) {
                        const vplex::vsDirectory::DatasetDetail &dd = user->_cachedData.details().datasets(i).details();
                        if (dd.datasetname() == "PicStream") {
                            SyncDown_RemoveJobsByDataset(dd.datasetid());
                            break;
                        }
                    }
#endif // CCD_ENABLE_SYNCDOWN_PICSTREAM
                } else {
                    LOG_WARN("Cannot remove \"%s\"", pathToRemove.c_str());
                    rv = CCD_ERROR_PATH_NOT_FOUND;
                }
            }
            response.set_remove_camera_roll_low_res_download_dir_err(rv);
            if(rv != 0) {
                numFailures++;
            }
        }
        if(request.has_add_camera_roll_thumb_download_dir()) {
            numOperations++;
            while (user != NULL) { // will not loop, will break out of while loop.
                rv = CCD_OK;
                bool addIt = false, updateIt = false;
                string pathToAdd = Util_CleanupPath(request.add_camera_roll_thumb_download_dir().dir());

#ifndef CLOUDNODE
                // Makes sure that the path exists.
                rc = Util_CreatePath(pathToAdd.c_str(), VPL_TRUE);
                if(rc != 0) {
                    LOG_ERROR("Could not create path:%s", pathToAdd.c_str());
                    rv = rc;
                }

                VPLFS_stat_t statBuf;
                rc = VPLFS_Stat(pathToAdd.c_str(), &statBuf);
                if(rc != 0) {
                    LOG_ERROR("add_camera_roll_thumb_download_dir %s statErr:%d",
                              pathToAdd.c_str(), rc);
                    rv = rc;
                    break;
                }else if(statBuf.type != VPLFS_TYPE_DIR){
                    LOG_ERROR("add_camera_roll_low_res_download_dir %s not a directory:%d",
                              pathToAdd.c_str(), (int)statBuf.type);
                    rv = CCD_ERROR_PATH_NOT_FOUND;
                    break;
                }
#endif // CLOUDNODE
                if(request.add_camera_roll_thumb_download_dir().preserve_free_disk_percentage() > 100) {
                    LOG_ERROR("preserve_free_disk_percentage() is not in not within 100: %d", request.add_camera_roll_thumb_download_dir().preserve_free_disk_percentage());
                    rv = CCD_ERROR_PARAMETER;
                    break;
                }
                google::protobuf::RepeatedPtrField<ccd::CameraRollDownloadDirSpecInternal> picstream_download_dirs_thumb;
                user->get_camera_download_thumb_dirs(picstream_download_dirs_thumb);
                if (picstream_download_dirs_thumb.size() > 0) {
                    if (pathToAdd == picstream_download_dirs_thumb.Get(0).dir()) {
                        if ((request.add_camera_roll_thumb_download_dir().max_files() !=
                                picstream_download_dirs_thumb.Get(0).max_files()) ||
                            (request.add_camera_roll_thumb_download_dir().max_size() !=
                                    picstream_download_dirs_thumb.Get(0).max_size()) ||
                            (request.add_camera_roll_thumb_download_dir().preserve_free_disk_percentage() !=
                                    picstream_download_dirs_thumb.Get(0).preserve_free_disk_percentage()) ||
                            (request.add_camera_roll_thumb_download_dir().preserve_free_disk_size_bytes() !=
                                    picstream_download_dirs_thumb.Get(0).preserve_free_disk_size_bytes()))
                        {
                            updateIt = true;
                            LOG_INFO("Updating \"%s\"", pathToAdd.c_str());
                        } else {
                            LOG_INFO("Nothing to change");
                        }
                    } else {
                        LOG_WARN("Cannot add \"%s\"; already downloading to \"%s\"", pathToAdd.c_str(),
                                picstream_download_dirs_thumb.Get(0).dir().c_str());
                        rv = CCD_ERROR_TOO_MANY_PATHS;
                    }
                } else {
                    addIt = true;
                    LOG_INFO("Adding \"%s\"", pathToAdd.c_str());
                }
                if (addIt || updateIt) {
                    user->clear_camera_download_thumb_dirs();
                    user->add_camera_download_thumb_dir(pathToAdd,
                                                          request.add_camera_roll_thumb_download_dir().max_size(),
                                                          request.add_camera_roll_thumb_download_dir().max_files(),
                                                          request.add_camera_roll_thumb_download_dir().preserve_free_disk_percentage(),
                                                          request.add_camera_roll_thumb_download_dir().preserve_free_disk_size_bytes());
                    cache_registerSyncConfigs(*user);

#if CCD_ENABLE_SYNCDOWN_PICSTREAM
                    if (addIt) {
                        // If a new download dir is set, 
                        // reset the last-checked dataset version and send a dataset content change notification.
                        // This is so that all the files in the dataset will be downloaded to the new download dir.
                        for (int i = 0; i < user->_cachedData.details().datasets_size(); i++) {
                            const vplex::vsDirectory::DatasetDetail &dd = user->_cachedData.details().datasets(i).details();
                            if (dd.datasetname() == "PicStream") {
                                //SyncDown_ResetDatasetLastCheckedVersion(dd.datasetid());
                                if (!dd.suspendedflag()) {
                                    SyncDown_NotifyDatasetContentChange(dd.datasetid(), false, true, FileType_Thumbnail);
                                } else {
                                    LOG_ERROR("PicStream Dataset ("FMTu64") suspended", dd.datasetid());
                                }
                                break;
                            }
                        }
                    }
#endif // CCD_ENABLE_SYNCDOWN_PICSTREAM
                }
                break;
            }
            response.set_add_camera_roll_thumb_download_dir_err(rv);
            if(rv != 0) {
                numFailures++;
            }
        }
        if(request.has_remove_camera_roll_thumb_download_dir()) {
            numOperations++;
            if (user != NULL) {
                rv = CCD_OK;
                string pathToRemove = Util_CleanupPath(request.remove_camera_roll_thumb_download_dir());
                google::protobuf::RepeatedPtrField<ccd::CameraRollDownloadDirSpecInternal> picstream_download_dirs_thumb;
                user->get_camera_download_thumb_dirs(picstream_download_dirs_thumb);
                if ((picstream_download_dirs_thumb.size() > 0) &&
                    (pathToRemove == picstream_download_dirs_thumb.Get(0).dir()))
                {
                    user->clear_camera_download_thumb_dirs();
                    cache_registerSyncConfigs(*user);
#if CCD_ENABLE_SYNCDOWN_PICSTREAM
                    for (int i = 0; i < user->_cachedData.details().datasets_size(); i++) {
                        const vplex::vsDirectory::DatasetDetail &dd = user->_cachedData.details().datasets(i).details();
                        if (dd.datasetname() == "PicStream") {
                            SyncDown_RemoveJobsByDataset(dd.datasetid());
                            break;
                        }
                    }
#endif // CCD_ENABLE_SYNCDOWN_PICSTREAM
                } else {
                    LOG_WARN("Cannot remove \"%s\"", pathToRemove.c_str());
                    rv = CCD_ERROR_PATH_NOT_FOUND;
                }
            }
            response.set_remove_camera_roll_thumb_download_dir_err(rv);
            if(rv != 0) {
                numFailures++;
            }
        }
        if(request.has_send_file_to_camera_roll()) {
            numOperations++;
            if(user != NULL) {
                rv = CCD_OK;
                std::string fileToSend = Util_CleanupPath(request.send_file_to_camera_roll());
                rv = Picstream_SendToCameraRoll(user->user_id(), fileToSend);
                if(rv != 0) {
                    LOG_ERROR("Picstream_SendToCameraRoll:%d, path(%s), cleanedPath(%s)",
                              rv,
                              request.send_file_to_camera_roll().c_str(),
                              fileToSend.c_str());
                }
            }

            response.set_send_file_to_camera_roll_err(rv);
            if(rv != 0) {
                numFailures++;
            }
        }
        if (request.has_configure_notes_sync()) {
            numOperations++;
            if(user != NULL) {
                if (request.configure_notes_sync().enable_sync_feature()) {
                    // "Enable sync" was requested.
                    if (!request.configure_notes_sync().has_set_sync_feature_path()) {
                        rv = CCD_ERROR_PARAMETER;
                    } else {
                        // If sync is already enabled, but the path has changed, remove Notes sync
                        // so that it will be re-added.
                        if (user->_cachedData.details().enable_notes_sync() &&
                            (request.configure_notes_sync().set_sync_feature_path().compare(user->_cachedData.details().notes_sync_path()) != 0)) {
                            rc = SyncFeatureMgr_Remove(user->user_id(), SYNC_FEATURE_NOTES);
                            if ((rc != 0) && (rc != CCD_ERROR_NOT_FOUND)) {
                                LOG_ERROR("SyncFeatureMgr_Remove("FMTu64",notes):%d",
                                        user->user_id(), rc);
                            }
                        }
                        user->_cachedData.mutable_details()->set_enable_notes_sync(true);
                        // TODO: Should we return an error if the specified path is not
                        //   accessible?
                        user->_cachedData.mutable_details()->set_notes_sync_path(
                                request.configure_notes_sync().set_sync_feature_path());
                        cache_registerSyncConfigs(*user);
                        rv = createNotesDatasetRv;
                    }
                } else {
                    // "Disable sync" was requested.
                    user->_cachedData.mutable_details()->set_enable_notes_sync(false);
                    LOG_INFO("Removing notes sync");
                    rc = SyncFeatureMgr_Remove(user->user_id(), SYNC_FEATURE_NOTES);
                    if ((rc != 0) && (rc != CCD_ERROR_NOT_FOUND)) {
                        LOG_ERROR("SyncFeatureMgr_Remove("FMTu64",notes):%d",
                                user->user_id(), rc);
                        rv = rc;
                    }
                }
            }
            response.set_configure_notes_sync_err(rv);
            if(rv != 0) {
                numFailures++;
            }
        }
        if (request.has_enable_notes_sync()) {
            numOperations++;
            if(user != NULL) {
                rv = CCD_OK;
                user->_cachedData.mutable_details()->set_enable_notes_sync(request.enable_notes_sync());
                LOG_WARN("Client is using deprecated API.  Using default notes sync location.");
                char notesSyncDir[CCD_PATH_MAX_LENGTH];
                DiskCache::getDirectoryForNotesSync(user->user_id(), sizeof(notesSyncDir), notesSyncDir);
                user->_cachedData.mutable_details()->set_notes_sync_path(notesSyncDir);
                cache_registerSyncConfigs(*user);
            }

            response.set_enable_notes_sync_err(rv);
            if(rv != 0) {
                numFailures++;
            }
        }
        if (request.has_configure_syncbox_sync()) {
            numOperations++;
            if(user != NULL) {
                rv = configureSyncboxRv;
                if (rv == 0) {
                    if (request.configure_syncbox_sync().enable_sync_feature()) {
                        bool isArchiveStorage = false;
#if CCD_ENABLE_STORAGE_NODE
                        if (request.configure_syncbox_sync().is_archive_storage()) {
                            isArchiveStorage = true;
                            // Save syncbox archive storage information.
                            user->_cachedData.mutable_details()->mutable_syncbox_sync_settings()->set_syncbox_staging_area_abs_path(stagingAreaPath);
                            user->_cachedData.mutable_details()->mutable_syncbox_sync_settings()->set_syncbox_dataset_id(syncboxDatasetId);
                            LOG_INFO("Will be Syncbox Archive Storage Device, dataset="FMTu64, syncboxDatasetId); 
                        }
#endif
                        user->_cachedData.mutable_details()->mutable_syncbox_sync_settings()->set_enable_sync(true);
                        user->_cachedData.mutable_details()->mutable_syncbox_sync_settings()->set_is_archive_storage(isArchiveStorage);
                        user->_cachedData.mutable_details()->mutable_syncbox_sync_settings()->set_sync_feature_path(
                                request.configure_syncbox_sync().set_sync_feature_path());
                        user->_cachedData.mutable_details()->mutable_syncbox_sync_settings()->set_coherent(true);
                        cache_registerSyncConfigs(*user);
                    } else {
                        // "Disable sync" was requested.
#if CCD_ENABLE_STORAGE_NODE
                        // If this was an archive storage device, dissociate from Syncbox dataset.
                        // Don't clear the is_archive_storage flag until we successfully tell VSDS.
                        if (user->_cachedData.details().syncbox_sync_settings().is_archive_storage()) {
                            user->_cachedData.mutable_details()->mutable_syncbox_sync_settings()->set_is_archive_storage(false);
                            user->_cachedData.mutable_details()->mutable_syncbox_sync_settings()->set_coherent(true);
                        }
#endif

                        LOG_INFO("Removing syncbox sync");
                        rc = SyncFeatureMgr_Remove(user->user_id(), SYNC_FEATURE_SYNCBOX);
                        if ((rc != 0) && (rc != CCD_ERROR_NOT_FOUND)) {
                            LOG_ERROR("SyncFeatureMgr_Remove("FMTu64",syncbox):%d",
                                    user->user_id(), rc);
                            rv = rc;
                        } else {
                            // Do not clear enable_sync if any of the previous steps failed.
                            // App needs to retry calling CCDIUpdateSyncSettings.
                            user->_cachedData.mutable_details()->mutable_syncbox_sync_settings()->set_enable_sync(false);
                        }
                    }
                }
            }
            response.set_configure_syncbox_sync_err(rv);
            if(rv != 0) {
                numFailures++;
            }
        }
        if (request.has_enable_clouddoc_sync()) {
            LOG_INFO("Request has enable_clouddoc_sync val %s", (request.enable_clouddoc_sync() ? "true" : "false"));
            numOperations++;
            if(user != NULL) {
                rv = CCD_OK;
                user->_cachedData.mutable_details()->set_enable_clouddoc_sync(request.enable_clouddoc_sync());
                //cache_registerSyncConfigs(*user);
                if(request.enable_clouddoc_sync()) {
                    // enable docs sync back
                    int err = DocSyncDown_Start(user->user_id());
                    if (err) {
                        LOG_ERROR("Failed to start DocSyncDown: %d", err);
                    }
                    // enable docs upload
                    int rv = DocSNGQueue_Enable(user->user_id());
                    if (rv != 0) {
                        LOG_ERROR("Failed to disable Cloud Doc: %d", rv);
                    }
                } else {
                    // disable docs upload
                    int rv = DocSNGQueue_Disable(true);
                    if (rv != 0) {
                        LOG_ERROR("Failed to disable Cloud Doc: %d", rv);
                    }
                    // disable docs sync back
                    int err = DocSyncDown_Stop(true);
                    if (err) {
                        LOG_ERROR("Failed to stop DocSyncDown: %d", err);
                    }
                }
            }

            response.set_enable_clouddoc_sync_err(rv);
            if(rv != 0) {
                numFailures++;
            }
        }
        if (request.has_migrate_mm_thumb_download_path()) {
            numOperations++;
            if(user != NULL) {
                rv = CCD_OK;
                if(user->_cachedData.mutable_details()->has_migrate_mm_thumb_download_path()) {
                    rv = CCD_ERROR_ALREADY;
                }else{
                    // Request does not have a src_dir.  Fill in current thumbpath.

                    char defaultMediaMetaDownDir[CCD_PATH_MAX_LENGTH];
                    DiskCache::getDirectoryForMediaMetadataDownload(
                            user->user_id(),
                            sizeof(defaultMediaMetaDownDir),
                            defaultMediaMetaDownDir);
                    std::string mm_src_dir(defaultMediaMetaDownDir);
                    if(user->_cachedData.details().has_mm_thumb_download_path()) {
                        mm_src_dir = user->_cachedData.details().mm_thumb_download_path();
                    }

                    std::string mm_dest_dir(defaultMediaMetaDownDir);
                    if(request.migrate_mm_thumb_download_path().has_mm_dest_dir()) {
                        mm_dest_dir = Util_trimTrailingSlashes(
                                request.migrate_mm_thumb_download_path().mm_dest_dir());
                        char userIdStr[32];
                        snprintf(userIdStr, 32, "%016"PRIx64, user->user_id());
                        mm_dest_dir += std::string("/")+userIdStr+std::string("/mm");
                    }

                    if(mm_src_dir == mm_dest_dir) {
                        LOG_ERROR("Attempt to migrate to same dir(%s,%s)",
                                  mm_src_dir.c_str(), mm_dest_dir.c_str());
                        rv = CCD_ERROR_ALREADY;
                    } else {
                        ccd::MediaMetadataThumbMigrateInternal* mmThumbMigrate =
                                user->_cachedData.mutable_details()->mutable_migrate_mm_thumb_download_path();
                        mmThumbMigrate->set_mm_thumb_src_dir(mm_src_dir);
                        mmThumbMigrate->set_mm_thumb_dest_dir(mm_dest_dir);
                        LOG_INFO("Migrate request: %s", mmThumbMigrate->ShortDebugString().c_str());

                        const vplex::vsDirectory::DatasetDetail* mediaMetadataDset =
                                Util_FindMediaMetadataDataset(user->_cachedData.details());
                        if(mediaMetadataDset != NULL) {
                            rc = stopThumbnailSyncConfigs(*user, mediaMetadataDset->datasetid());
                            if(rc != 0) {
                                LOG_WARN("stopThumbnailSyncConfigs("FMTu64","FMTu64"):%d",
                                         user->user_id(), mediaMetadataDset->datasetid(), rc);
                            }
                        }
                    }
                }
                // No matter what, kick off any existing thumb migrate if a request
                // was made.
                mm_thumb_migrate_resume = true;
            }

            response.set_migrate_mm_thumb_download_path_err(rv);
            if(rv != 0) {
                numFailures++;
            }
        }
        if(request.has_enable_mm_thumb_sync()) {
            numOperations++;
            int numEntries = request.enable_mm_thumb_sync_types_size();
            if(user != NULL) {
                rv = CCD_OK;
                if(request.enable_mm_thumb_sync()) {
                    if(numEntries == 0) {
                        // Enable all flavors of thumbnail syncing by clearing the disabled list
                        user->_cachedData.mutable_details()->clear_mm_thumb_sync_disabled_types();
                    }else{
                        // Selectively enable the types specified
                        int numDisabled = user->_cachedData.mutable_details()->mm_thumb_sync_disabled_types_size();
                        LOG_ALWAYS("enable %d thumb types, current disable count %d", numEntries, numDisabled);
                        std::set<SyncFeature_t> disabledList;
                        for(int j = 0; j < numDisabled; j++) {
                            SyncFeature_t disabledType = user->_cachedData.mutable_details()->mm_thumb_sync_disabled_types(j);
                            disabledList.insert(disabledType);
                            LOG_ALWAYS("Current list element %d", disabledType);
                        }

                        for(int i = 0; i < numEntries; i++) {
                            SyncFeature_t enableType = request.enable_mm_thumb_sync_types(i);
                            disabledList.erase(enableType);
                        }
                        // If any sync types were newly re-enabled, clear and reload the disabled list
                        if(numDisabled != disabledList.size()) {
                            user->_cachedData.mutable_details()->clear_mm_thumb_sync_disabled_types();
                            std::set<SyncFeature_t>::const_iterator sf_it;
                            for(sf_it = disabledList.begin(); sf_it != disabledList.end(); sf_it++) {
                                user->_cachedData.mutable_details()->add_mm_thumb_sync_disabled_types(*sf_it);
                                LOG_ALWAYS("After processing: list element %d", *sf_it);
                            }
                        }
                        LOG_ALWAYS("After processing, new disable count "FMTu_size_t, disabledList.size());
                    }
                    has_mm_enable = true;
                }else{
                    if(numEntries == 0) {
                        // This means that the intent is to disable all of them. In case there is a 
                        // partial list, clear it and explicitly add all known types.
                        // FIXME:  this is mildly distasteful, but there are a number of places
                        // in the code that enumerate the list of thumbnail types.  If a new type
                        // is added, we have to find all those places.
                        user->_cachedData.mutable_details()->clear_mm_thumb_sync_disabled_types();
                        user->_cachedData.mutable_details()->add_mm_thumb_sync_disabled_types(SYNC_FEATURE_PHOTO_THUMBNAILS);
                        user->_cachedData.mutable_details()->add_mm_thumb_sync_disabled_types(SYNC_FEATURE_MUSIC_THUMBNAILS);
                        user->_cachedData.mutable_details()->add_mm_thumb_sync_disabled_types(SYNC_FEATURE_VIDEO_THUMBNAILS);
                    }else{
                        // Check whether we need to add any new disabled entries to the current list
                        int numDisabled = user->_cachedData.mutable_details()->mm_thumb_sync_disabled_types_size();
                        std::set<SyncFeature_t> disabledList;
                        for(int j = 0; j < numDisabled; j++) {
                            SyncFeature_t disabledType = user->_cachedData.mutable_details()->mm_thumb_sync_disabled_types(j);
                            disabledList.insert(disabledType);
                            LOG_ALWAYS("Current list element %d", disabledType);
                        }

                        // The std::set elements are unique, so a duplicate insert will fail (but that's ok)
                        for(int i = 0; i < numEntries; i++) {
                            SyncFeature_t enableType = request.enable_mm_thumb_sync_types(i);
                            disabledList.insert(enableType);
                        }
                        if(disabledList.size() != 0) {
                            user->_cachedData.mutable_details()->clear_mm_thumb_sync_disabled_types();
                            std::set<SyncFeature_t>::const_iterator sf_it;
                            for(sf_it = disabledList.begin(); sf_it != disabledList.end(); sf_it++) {
                                user->_cachedData.mutable_details()->add_mm_thumb_sync_disabled_types(*sf_it);
                                LOG_ALWAYS("After processing: list element %d", *sf_it);
                            }
                        }
                        LOG_ALWAYS("After processing, new disable count "FMTu_size_t, disabledList.size());
                    }
                    has_mm_disable = true;
                }
            }
            response.set_enable_mm_thumb_sync_err(rv);
            if(rv != 0) {
                numFailures++;
            }
        }else{
            // Unless enable_mm_thumb_sync is specified, specifying a type list is an error
            if(request.enable_mm_thumb_sync_types_size() > 0) {
                LOG_ERROR("Specified thumb sync type list without enable or disable request");
                rv = CCD_ERROR_PARAMETER;
                response.set_enable_mm_thumb_sync_err(rv);
                numFailures++;
            }
        }

        // If adding a new case here, be sure to also update the big "if" expression above.

        // Don't forget to persist any changes.
        user->writeCachedData(false);

    } // release lock

    if(powerSettingChanged) {
        rv = Cache_UpdatePowerMode(activationId);
        if(rv != 0) {
            LOG_ERROR("Unable to updatePowerMode:%d, activationId:%d",
                      rv, activationId);
        }
    }

    if(mm_thumb_migrate_resume) {
        // Resume any thumbnail migrate, if needed.
        McaMigrateThumb &migrateThumbInstance = getMcaMigrateThumbInstance();
        rc = migrateThumbInstance.McaThumbResumeMigrate(activationId);
        if(rc != 0) {
            LOG_ERROR("McaThumbResumeMigrate(%d):%d", activationId, rc);
        }
    }

    if(has_mm_disable) {
        CacheAutoLock autoLock;
        rc = autoLock.LockForWrite();  // Need to prevent another SyncConfig
                                       // from being started while shutting down.
        if(rc != 0) {
            LOG_ERROR("LockForWrite:%d", rc);
        }
        CachePlayer* user = cache_getUserByActivationId(activationId);
        if(user == NULL) {
            LOG_ERROR("Cannot get user for activationId:%d", activationId);
        } else if (__ccdConfig.mediaMetadataThumbVirtDownload) {
            LOG_INFO("Disable thumbnail downloads");
            cache_registerSyncConfigs(*user);
        } else {
            // Told to disable thumbnail sync (either all or selected types)
            const vplex::vsDirectory::DatasetDetail* mediaMetadataDset =
                    Util_FindMediaMetadataDataset(user->_cachedData.details());
            if(mediaMetadataDset==NULL) {
                LOG_ERROR("No media metadata dataset for ("FMTu64",%d)",
                          user->user_id(), activationId);
            }else{
                rc = stopDisabledSyncFeatures(*user, mediaMetadataDset->datasetid());
                if(rc != 0) {
                    LOG_WARN("stopDisabledSyncFeatures("FMTu64","FMTu64"):%d",
                             user->user_id(), mediaMetadataDset->datasetid(), rc);
                }
            }
        }
    }
    if(has_mm_enable) {
        CacheAutoLock autoLock;
        rc = autoLock.LockForWrite();  // Need to prevent another SyncConfig
                                       // from being started while shutting down.
        if(rc != 0) {
            LOG_ERROR("LockForWrite:%d", rc);
        }
        CachePlayer* user = cache_getUserByActivationId(activationId);
        if(user == NULL) {
            LOG_ERROR("Cannot get user for activationId:%d", activationId);
        } else { 
            // Thumbnail Sync enabled for some or all types
            LOG_INFO("Reenable thumbnail sync");
            cache_registerSyncConfigs(*user);
        }
    }
 out:
    if ((numOperations > 1) && (numFailures > 0)) {
        rv = numFailures;
    }
    LOG_CCDI_RESPONSE(response, rv);
    return rv;
}

CCDIError CCDIUpdateSyncSubscription(const ccd::UpdateSyncSubscriptionInput& request)
{
    LOG_CCDI_REQUEST(request);
    int rv;
    {
        ServiceSessionInfo_t session;
        rv = Cache_GetSessionForVsdsByUser(request.user_id(), session);
        if (rv != 0) {
            LOG_ERROR("Could not get session for user:"FMT_VPLUser_Id_t, request.user_id());
            goto out;
        }

        u64 deviceId;
        if (request.has_device_id()) {
            deviceId = request.device_id();
        } else {
            rv = ESCore_GetDeviceGuid(&deviceId);
            if (rv != 0) {
                LOG_ERROR("ESCore_GetDeviceGuid failed: %d", rv);
                goto out;
            }
        }

        {
            vplex::vsDirectory::UpdateSubscriptionLimitsInput vsds_request;
            Query_FillInVsdsSession(vsds_request.mutable_session(), session);
            vsds_request.set_userid(request.user_id());
            vsds_request.set_deviceid(deviceId);
            vsds_request.set_datasetid(request.dataset_id());

            if(request.has_new_filter() &&
               request.new_filter().size() > 0) {
                vsds_request.set_filter(request.new_filter());
            }
            if(request.has_max_size()) {
                vsds_request.set_maxsize(request.max_size());
            }
            if(request.has_max_files()) {
                vsds_request.set_maxfiles(request.max_files());
            }

            vplex::vsDirectory::UpdateSubscriptionLimitsOutput vsds_response;
            rv = QUERY_VSDS(VPLVsDirectory_UpdateSubscriptionLimits, vsds_request, vsds_response);
            if (rv != 0) {
                LOG_ERROR("VPLVsDirectory_UpdateSubscriptionLimits failed: %d, dataset="FMTx64", user="FMT_VPLUser_Id_t,
                        rv, request.dataset_id(), request.user_id());
            } else {
                // Looks like it succeeded.
                CacheMonitor_MarkSubscriptionsDirty(request.user_id());
            }
        }
    }
out:
    LOG_CCDI_RESPONSE(ccd::NoParamResponse::default_instance(), rv);
    return rv;
}

CCDIError CCDIUpdateAppState(const ccd::UpdateAppStateInput& request,
                             ccd::UpdateAppStateOutput& response)
{
    LOG_CCDI_REQUEST(request);
    s32 rv = CCD_OK;
    int numOperations = 0;
    int numFailures = 0;
    if (request.has_foreground_mode()) {
        numOperations++;
        if(request.app_id().empty()) {
            LOG_ERROR("App Id cannot be empty when setting foreground mode");
            rv = CCD_ERROR_PARAMETER;
            response.set_foreground_mode_err(rv);
            numFailures++;
        }else{
            rv = Cache_SetForegroundMode(request.foreground_mode(),
                                         request.app_id(),
                                         request.app_type());
            if (rv != CCD_OK) {
                response.set_foreground_mode_err(rv);
                numFailures++;
            }
#if CCD_USE_SHARED_CREDENTIALS
            else if (request.foreground_mode()) {
                // Coming to the foreground; check if state was changed while we were suspended.
                
                // Give initial value to avoid crash when first login (No Credential) 
                s32 rc = CCD_OK;

                // Get device credential
                vplex::sharedCredential::DeviceCredential deviceCredential;
                GetDeviceCredential(deviceCredential);
                if (!deviceCredential.has_device_id()) {
                    LOG_INFO("No shared device credentials");
                    if (VirtualDevice_HasCredentials()) {
                        LOG_WARN("Unexpected: shared device credentials were removed!");
                        rc = clearLocalDeviceCredentials();
                        if (rc != CCD_OK) {
                            LOG_ERROR("clearLocalDeviceCredentials failed: %d", rc);
                        }
                    }
                } else {
                    u64 sharedDeviceId = deviceCredential.device_id();
                    u64 currentDeviceId = VirtualDevice_GetDeviceId();
                    LOG_INFO("Shared device credentials are present");
                    if (!VirtualDevice_HasCredentials()) {
                        LOG_INFO("Shared device credentials were added by another CCD instance");
                        rc = VirtualDevice_LoadSharedCredentials(deviceCredential);
                        if (rc != CCD_OK) {
                            LOG_ERROR("VirtualDevice_LoadSharedCredentials failed: %d", rc);
                        }
                    }
                    else if (sharedDeviceId != currentDeviceId) {
                        LOG_WARN("Unexpected: shared device credentials were changed!");
                        rc = clearLocalDeviceCredentials();
                        if (rc != CCD_OK) {
                            LOG_ERROR("clearLocalDeviceCredentials failed: %d", rc);
                        } else {
                            rc = VirtualDevice_LoadSharedCredentials(deviceCredential);
                            if (rc != CCD_OK) {
                                LOG_ERROR("VirtualDevice_LoadSharedCredentials failed: %d", rc);
                            }
                        }
                    }
                }
                
                // Check shared user credentials.
                if (rc == CCD_OK) {
                    LOG_INFO("Trying to retrieve shared user credentials");
                    vplex::sharedCredential::UserCredential userCredential;
                    GetUserCredential(userCredential);

                    if ((userCredential.has_user_name()) && (userCredential.has_ias_output())) {
                        // Check if the device has been linked.
                        LOG_INFO("Trying to retrieve is_device_linked flag");
                        char* isDeviceLinked = NULL;
                        // Get 'credentials' location
                        const char* credentialsLocation = VPLSharedObject_GetCredentialsLocation();
                        VPLSharedObject_GetString(credentialsLocation, VPL_SHARED_IS_DEVICE_LINKED_ID, &isDeviceLinked);
                        ON_BLOCK_EXIT(VPLSharedObject_FreeString, isDeviceLinked);
                        
                        bool deviceHasBeenLinked = false;
                        // If the flag doesn't exist, means the current shared credential was written from older CCD.
                        // Take it as linked.
                        if (isDeviceLinked == NULL)
                        {
                            deviceHasBeenLinked = true;
                        } else {
                            if (strcmp(isDeviceLinked, VPL_SHARED_DEVICE_LINKED) == 0) {
                                deviceHasBeenLinked = true;
                            }
                        }
                        
                        if (deviceHasBeenLinked) {
                            LOG_INFO("Shared user found. Proceed to login");
                            rc = Cache_LoginWithSession(userCredential);
                            if (rc != CCD_OK) {
                                LOG_ERROR("Cache_LoginWithSession failed: %d", rc);
                            }
                        } else {
                            LOG_INFO("Device was not linked. Proceed to logout");
                            int playerindex = 0;
                            VPLUser_Id_t userId = VPLUSER_ID_NONE;
                            rc = Cache_Logout(playerindex, userId, false, LOGOUT_REASON_SHARED_CREDENTIALS_REMOVED);
                            if (rc != CCD_OK) {
                                LOG_ERROR("Cache_Logout failed: %d", rc);
                            }
                        }
                    } else {
                        LOG_INFO("Shared user not found. Proceed to logout");
                        int playerindex = 0;
                        VPLUser_Id_t userId = VPLUSER_ID_NONE;
                        rc = Cache_Logout(playerindex, userId, false, LOGOUT_REASON_SHARED_CREDENTIALS_REMOVED);
                        if (rc != CCD_OK) {
                            LOG_ERROR("Cache_Logout failed: %d", rc);
                        }
                    }
                }
                
            }
#endif
            if(request.foreground_mode()){
                StatMgr_AddEventBegin(request.app_id(), STAT_EVENT_ID_APPFOREGROUND);
            }else{
                StatMgr_AddEventEnd(request.app_id(), STAT_EVENT_ID_APPFOREGROUND);
            }
        }
    }
    if ((numOperations > 1) && (numFailures > 0)) {
        rv = numFailures;
    }
    LOG_CCDI_RESPONSE(response, rv);
    return rv;
}

CCDIError CCDIUpdateSystemState(const ccd::UpdateSystemStateInput& request, ccd::UpdateSystemStateOutput& response)
{
    LOG_CCDI_REQUEST(request);
    s32 rv = CCD_OK;
    int numOperations = 0;
    int numFailures = 0;
    bool powerSettingChanged = false;
    if (request.do_shutdown()) {
        numOperations++;
        LOG_INFO("UpdateSystemState requested shutdown");
        CCDShutdown();
        rv = CCD_OK;
//        if (rv != CCD_OK) {
//            response.set_do_shutdown_err(rv);
//            numFailures++;
//        }
    }

    if (request.report_network_connected()) {
        numOperations++;
        LOG_INFO("A network became connected.");
        ANSConn_ReportNetworkConnected();

        // Report it to tunnel layer too
        LocalServers_ReportNetworkConnected();

        rv = CCD_OK;
    }

    if (request.report_different_network()) {
        numOperations++;
        LOG_INFO("Cache_OnDifferentNetwork");
        Cache_OnDifferentNetwork();
        LOG_INFO("Cache_OnDifferentNetwork done");
    }
    if (request.has_background_mode_interval_sec()) {
        numOperations++;
        rv = Cache_SetBackgroundModeInterval(request.background_mode_interval_sec());
        if (rv != CCD_OK) {
            response.set_background_mode_interval_err(rv);
            numFailures++;
        }else{
            LOG_WARN("ERROR! background_mode_interval_sec is for testing only."
                     "Please DO NOT call this function in production code.  See"
                     "ccdi_rpc.proto for documentation.");
            powerSettingChanged = true;
        }
    }
    if (request.perform_background_tasks()) {
        numOperations++;
        rv = Cache_PerformBackgroundTasks();
        if (rv != CCD_OK) {
            response.set_perform_background_tasks_err(rv);
            numFailures++;
        }
    }
    if (request.log_caches()) {
        numOperations++;
        Cache_LogAllCaches();
        rv = CCD_OK;
    }
    if (request.has_only_mobile_network_available()) {
        numOperations++;
        rv = Cache_SetOnlyMobileNetworkAvailable(request.only_mobile_network_available());
        if(rv != CCD_OK) {
            response.set_only_mobile_network_available_err(rv);
            numFailures++;
        }else{
            powerSettingChanged = true;
        }
    }
    if (request.has_stream_power_mode()) {
        numOperations++;
        rv = Cache_SetStreamPowerMode(request.stream_power_mode());
        if(rv != CCD_OK) {
            response.set_stream_power_mode_err(rv);
            numFailures++;
        }else{
            powerSettingChanged = true;
        }
    }
    if (request.has_enable_ioac()) {
        numOperations++;
        u64 deviceId = 0;
        rv = ESCore_GetDeviceGuid(&deviceId);
        if (rv != 0) {
            LOG_ERROR("ESCore_GetDeviceGuid failed: %d", rv);
            response.set_enable_ioac_err(rv);
            numFailures++;
        } else {
            rv = NetMan_EnableIOAC(deviceId, request.enable_ioac());
            if (rv != 0) {
                LOG_ERROR("Cannot enable IOAC: %d", rv);
                response.set_enable_ioac_err(rv);
                numFailures++;
            }
        }
    }

    if ((numOperations > 1) && (numFailures > 0)) {
        rv = numFailures;
    }

    if(powerSettingChanged) {
        u32 activationId;
        rv = Cache_GetActivationIdForSyncUser(&activationId, false, 0);
        if(rv != 0) {
            LOG_INFO("Could not get activationId.  Acceptable, continuing.");
        }
        rv = Cache_UpdatePowerMode(activationId);
        if(rv != 0) {
            LOG_ERROR("Unable to updatePowerMode:%d, activationId:%d",
                      rv, activationId);
        }
    }
    LOG_CCDI_RESPONSE(response, rv);
    return rv;
}


CCDIError CCDIRemoteSwUpdateMessage(const ccd::RemoteSwUpdateMessageInput& request)
{
    LOG_CCDI_REQUEST(request);
    int rv = 0;
    ccd::GetSystemStateInput            getSystemStateReq; 
    ccd::GetSystemStateOutput           getSystemStateResp; 
    ccd::ListLinkedDevicesInput         listLinkedDevicesReq;
    ccd::ListLinkedDevicesOutput        listLinkedDevicesResp;
    u64                                 userId;
    bool                                found = false;
    bool                                online = false;

    getSystemStateReq.set_get_players(true);
    getSystemStateReq.set_get_device_id(true);
    rv = CCDIGetSystemState(getSystemStateReq, getSystemStateResp);
    if (rv != 0) {
        LOG_ERROR("CCDIGetSystemState failed: %d", rv);
        goto exit;
    }

    userId = getSystemStateResp.players().players(0).user_id(); 

    listLinkedDevicesReq.set_user_id(userId);
    listLinkedDevicesReq.set_only_use_cache(true);
    listLinkedDevicesReq.set_storage_nodes_only(true);

    rv = CCDIListLinkedDevices(listLinkedDevicesReq, listLinkedDevicesResp); 
    if (rv != 0) {
        LOG_ERROR("CCDIListLinkedDevices failed: %d", rv);
        goto exit;
    }

    for (int i = 0; i < listLinkedDevicesResp.devices_size(); i++) {
        if (request.target_device_id() == listLinkedDevicesResp.devices(i).device_id()) {
            found = true;

            if ((listLinkedDevicesResp.devices(i).has_protocol_version()) &&
                (atoi(listLinkedDevicesResp.devices(i).protocol_version().c_str()) >= atoi(CCD_PROTOCOL_VERSION)))
            {
                rv = REMOTE_SWU_ERR_TARGET_UP_TO_DATE;
                LOG_ERROR("Target storage node("FMTu64") up-to-date. Need no update", request.target_device_id());
                goto exit;
            }

            if (listLinkedDevicesResp.devices(i).connection_status().state() == ccd::DEVICE_CONNECTION_ONLINE) {
                online = true;
                break;
            }
        }
    }

    if (!found) {
        rv = REMOTE_SWU_ERR_INVALID_TARGET;
        LOG_ERROR("Target storage node("FMTu64") not found", request.target_device_id());
        goto exit;
    }

    if (!online) {
        rv = REMOTE_SWU_ERR_TARGET_OFFLINE;
        LOG_ERROR("Target storage node("FMTu64") offline", request.target_device_id());
        goto exit;
    }

    rv = ANSConn_SendRemoteSwUpdateRequest(userId, request.target_device_id());

exit:
    LOG_CCDI_RESPONSE(ccd::NoParamResponse::default_instance(), rv);
    return rv;
}


CCDIError CCDIEnableInMemoryLogging()
{
    LOG_CCDI_REQUEST(ccd::NoParamRequest::default_instance());
    s32 rv;

    rv = LOGSetEnableInMemoryLogging(true, __ccdConfig.testInstanceNum);
    if (rv < 0) {
        LOG_ERROR("Failed to enable in-memory logging");
    }

    LOG_CCDI_RESPONSE(ccd::NoParamResponse::default_instance(), rv);
    return rv;
}


CCDIError CCDIDisableInMemoryLogging()
{
    LOG_CCDI_REQUEST(ccd::NoParamRequest::default_instance());
    s32 rv;

    rv = LOGSetEnableInMemoryLogging(false, __ccdConfig.testInstanceNum);
    if (rv < 0) {
        LOG_ERROR("Failed to disable in-memory logging");
    }

    LOG_CCDI_RESPONSE(ccd::NoParamResponse::default_instance(), rv);
    return rv;
}


CCDIError CCDIFlushInMemoryLogs()
{
    LOG_CCDI_REQUEST(ccd::NoParamRequest::default_instance());

    LOGFlushInMemoryLogs();

    LOG_CCDI_RESPONSE(ccd::NoParamResponse::default_instance(), CCD_OK);
    return CCD_OK;
}

CCDIError CCDIRespondToPairingRequest(const ccd::RespondToPairingRequestInput& request)
{
    LOG_CCDI_REQUEST(request);

    int rv = 0;

    vplex::ias::RespondToPairingRequestResponseType rtprResponse;
    vplex::ias::RespondToPairingRequestRequestType rtprRequest;
    Query_SetIasAbstractRequestFields(rtprRequest);
    {
        CacheAutoLock autoLock;
        rv = autoLock.LockForRead();
        if (rv < 0) {
            LOG_ERROR("Failed to obtain lock: %d", rv);
            goto out;
        }

        CachePlayer* user = cache_getUserByUserId(request.user_id());
        if (user == NULL) {
            LOG_ERROR("userId "FMT_VPLUser_Id_t" not signed in", request.user_id());
            rv = CCD_ERROR_NOT_SIGNED_IN;
            goto out;
        }
        u64 deviceId;
        rv = ESCore_GetDeviceGuid(&deviceId);
        if (rv != CCD_OK) {
            LOG_ERROR("Cannot get Device ID: %d", rv);
            goto out;
        }

        rtprRequest.mutable__inherited()->set_sessionhandle(user->getSession().session_handle());
        rtprRequest.mutable__inherited()->set_serviceticket(user->getSession().ias_ticket());
        rtprRequest.mutable__inherited()->set_serviceid("IAS");
        rtprRequest.mutable__inherited()->set_deviceid(deviceId);
    }

    rtprRequest.set_transactionid(request.transaction_id());
    rtprRequest.set_acceptedpairing(request.accepted_pairing() != 0);
    rv = QUERY_IAS(VPLIas_RespondToPairingRequest, rtprRequest, rtprResponse);
    if(rv != CCD_OK) {
        LOG_ERROR("Error in VPLIas_RespondToPairingRequest: %d", rv);
    }
out:
    LOG_CCDI_RESPONSE(ccd::NoParamResponse::default_instance(), rv);
    return rv;
}


CCDIError CCDIRequestPairing(const ccd::RequestPairingInput& request,
    ccd::RequestPairingOutput& response)
{
    LOG_CCDI_REQUEST(request);
    vplex::ias::RequestPairingResponseType rpResponse;
    vplex::ias::RequestPairingRequestType rpRequest;
    Query_SetIasAbstractRequestFields(rpRequest);

    // Note that these 3 fields are optional, but one of them must be set.
    // We will let IAS enforce this though.
    if(request.has_host_hwid())
        rpRequest.set_hosthardwareid(request.host_hwid());
    if(request.has_pin())
        rpRequest.set_pin(request.pin());
    if(request.has_host_deviceid())
        rpRequest.set_hostdeviceid(request.host_deviceid());

    rpRequest.set_devicehardwareid(request.device_hwid());

    for(int i = 0; i < request.pairing_attributes_size(); i++) {
        vplex::ias::StrAttributeType* sat = rpRequest.add_pairingattributes();
        sat->set_attributename(request.pairing_attributes(i).key());
        sat->set_attributevalue(request.pairing_attributes(i).value());
    }

    int rv = QUERY_IAS(VPLIas_RequestPairing, rpRequest, rpResponse);
    if(rv != CCD_OK) {
        LOG_ERROR("Error in VPLIas_RequestPairing: %d", rv);
    } else {
        response.set_pairing_token(rpResponse.pairingtoken());
    }
    LOG_CCDI_RESPONSE(response, rv);
    return rv;
}


CCDIError CCDIRequestPairingPin(const ccd::RequestPairingPinInput& request,
    ccd::RequestPairingPinOutput& response)
{
    LOG_CCDI_REQUEST(request);
    int rv = 0;

    vplex::ias::RequestPairingPinResponseType rppResponse;
    vplex::ias::RequestPairingPinRequestType rppRequest;
    Query_SetIasAbstractRequestFields(rppRequest);
    {
        CacheAutoLock autoLock;
        rv = autoLock.LockForRead();
        if (rv < 0) {
            LOG_ERROR("Failed to obtain lock: %d", rv);
            goto out;
        }

        CachePlayer* user = cache_getUserByUserId(request.user_id());
        if (user == NULL) {
            LOG_ERROR("userId "FMT_VPLUser_Id_t" not signed in", request.user_id());
            rv = CCD_ERROR_NOT_SIGNED_IN;
            goto out;
        }
        u64 deviceId;
        rv = ESCore_GetDeviceGuid(&deviceId);
        if (rv != CCD_OK) {
            LOG_ERROR("Cannot get Device ID: %d", rv);
            goto out;
        }

        rppRequest.mutable__inherited()->set_sessionhandle(user->getSession().session_handle());
        rppRequest.mutable__inherited()->set_serviceticket(user->getSession().ias_ticket());
        rppRequest.mutable__inherited()->set_serviceid("IAS");
        rppRequest.mutable__inherited()->set_deviceid(deviceId);
    }
    
    rv = QUERY_IAS(VPLIas_RequestPairingPin, rppRequest, rppResponse);
    if(rv != CCD_OK) {
        LOG_ERROR("Error in VPLIas_RequestPairingPin: %d", rv);
    } else {
        response.set_pin(rppResponse.pairingpin());
    }
out:
    LOG_CCDI_RESPONSE(response, rv);
    return rv;
}


CCDIError CCDIGetPairingStatus(const ccd::GetPairingStatusInput& request,
    ccd::GetPairingStatusOutput& response)
{
    LOG_CCDI_REQUEST(request);
    vplex::ias::GetPairingStatusResponseType gpsResponse;
    vplex::ias::GetPairingStatusRequestType gpsRequest;
    Query_SetIasAbstractRequestFields(gpsRequest);

    gpsRequest.set_pairingtoken(request.pairing_token());

    int rv = QUERY_IAS(VPLIas_GetPairingStatus, gpsRequest, gpsResponse);
    if(rv != CCD_OK) {
        LOG_ERROR("Error in VPLIas_GetPairingStatus: %d", rv);
    } else {
        // P = REQUESTED.
        // A = ACCEPTED.
        // R = REJECTED.
        response.set_status(gpsResponse.status());
        if(gpsResponse.has_username()) {
            // Returned only if status is ACCEPTED
            response.set_user_name(gpsResponse.username());
        }
    }
    LOG_CCDI_RESPONSE(response, rv);
    return rv;
}

CCDIError CCDIQueryPicStreamObjects(const ccd::CCDIQueryPicStreamObjectsInput& request,
    ccd::CCDIQueryPicStreamObjectsOutput& response)
{
    LOG_CCDI_REQUEST(request);

    int rv = SyncDown_QueryPicStreamItems(request.filter_field(),
                                          request.search_field(),
                                          request.sort_field(),
                                          *(response.mutable_content_objects()));

    if( rv != 0) {
        LOG_WARN("QueryPicStreamItems failed: %d", rv);
    }
    LOG_CCDI_RESPONSE(response, rv);
    return rv;
}

CCDIError CCDISharedFilesStoreFile(const ccd::SharedFilesStoreFileInput& request,
    ccd::SharedFilesStoreFileOutput& response)
{
    LOG_CCDI_REQUEST(request);
    u32 activationId;
    int rv = Cache_GetActivationIdForSyncUser(&activationId,
                                              request.has_user_id(),
                                              request.user_id());
    if (rv != 0) {
        LOG_ERROR("Cache_GetActivationIdForSyncUser("FMTu64"):%d",
                  request.user_id(), rv);
        goto out;
    }
    {
        u64 compId;
        std::string name;
        rv = SharedFiles_StoreFile(activationId,
                                   request.abs_file_path(),
                                   request.opaque_metadata(),
                                   request.abs_preview_path(),
                                   /*OUT*/ compId,
                                   /*OUT*/ name);
        if (rv != 0) {
            LOG_ERROR("SharedFiles_StoreFile(%s,%s):%d",
                      request.abs_file_path().c_str(),
                      request.abs_preview_path().c_str(), rv);
            goto out;
        }
        response.set_comp_id(compId);
        response.set_stored_name(name);
    }
 out:
    LOG_CCDI_RESPONSE(response, rv);
    return rv;
}

CCDIError CCDISharedFilesShareFile(const ccd::SharedFilesShareFileInput& request)
{
    LOG_CCDI_REQUEST(request);

    u32 activationId;
    int rv = Cache_GetActivationIdForSyncUser(&activationId,
                                              request.has_user_id(),
                                              request.user_id());
    if (rv != 0) {
        LOG_ERROR("Cache_GetActivationIdForSyncUser("FMTu64"):%d",
                  request.user_id(), rv);
        goto out;
    }

    {
        std::vector<std::string> recipientEmails;
        for (int index = 0; index < request.recipient_emails_size(); index++)
        {
            recipientEmails.push_back(request.recipient_emails(index));
        }
        rv = SharedFiles_ShareFile(activationId,
                                   request.stored_name(),
                                   request.comp_id(),
                                   recipientEmails);
        if (rv != 0) {
            LOG_ERROR("SharedFiles_ShareFile(%s,"FMTu64"):%d",
                      request.stored_name().c_str(), request.comp_id(), rv);
            goto out;
        }
    }
 out:
    LOG_CCDI_RESPONSE(ccd::NoParamResponse::default_instance(), rv);
    return rv;
}

CCDIError CCDISharedFilesUnshareFile(const ccd::SharedFilesUnshareFileInput& request)
{
    LOG_CCDI_REQUEST(request);
    u32 activationId;
    int rv = Cache_GetActivationIdForSyncUser(&activationId,
                                              request.has_user_id(),
                                              request.user_id());
    if (rv != 0) {
        LOG_ERROR("Cache_GetActivationIdForSyncUser("FMTu64"):%d",
                  request.user_id(), rv);
        goto out;
    }

    {
        std::vector<std::string> recipientEmails;
        for (int index = 0; index < request.recipient_emails_size(); index++)
        {
            recipientEmails.push_back(request.recipient_emails(index));
        }
        rv = SharedFiles_UnshareFile(activationId,
                                   request.stored_name(),
                                   request.comp_id(),
                                   recipientEmails);
        if (rv != 0) {
            LOG_ERROR("SharedFiles_UnshareFile(%s,"FMTu64"):%d",
                      request.stored_name().c_str(), request.comp_id(), rv);
            goto out;
        }
    }
 out:
    LOG_CCDI_RESPONSE(ccd::NoParamResponse::default_instance(), rv);
    return rv;
}

CCDIError CCDISharedFilesDeleteSharedFile(const ccd::SharedFilesDeleteSharedFileInput& request)
{
    LOG_CCDI_REQUEST(request);
    u32 activationId;
    int rv = Cache_GetActivationIdForSyncUser(&activationId,
                                              request.has_user_id(),
                                              request.user_id());
    if (rv != 0) {
        LOG_ERROR("Cache_GetActivationIdForSyncUser("FMTu64"):%d",
                  request.user_id(), rv);
        goto out;
    }

    rv = SharedFiles_DeleteFile(activationId,
                                request.stored_name(),
                                request.comp_id());
    if (rv != 0) {
        LOG_ERROR("SharedFiles_DeleteFile(%s,"FMTu64"):%d",
                  request.stored_name().c_str(), request.comp_id(), rv);
        goto out;
    }
 out:
    LOG_CCDI_RESPONSE(ccd::NoParamResponse::default_instance(), rv);
    return rv;
}

CCDIError CCDISharedFilesQuery(const ccd::SharedFilesQueryInput& request,
    ccd::SharedFilesQueryOutput& response)
{
    LOG_CCDI_REQUEST(request);
    int rv = 0;
    u32 activationId;
    rv = Cache_GetActivationIdForSyncUser(&activationId,
                                          request.has_user_id(),
                                          request.user_id());
    if (rv != 0) {
        LOG_ERROR("Cache_GetActivationIdForSyncUser("FMTu64"):%d",
                  request.user_id(), rv);
        goto out;
    }
    rv = SyncDown_QuerySharedFilesItems(request.sync_feature(),
                                        request.search_field(),
                                        request.sort_field(),
                                        *response.mutable_query_objects());
    if (rv != 0) {
        LOG_ERROR("SyncDown_QuerySharedFilesItems"
                  "(userId:"FMTu64",syncFeat:%d,search:%s,sort:%s):%d",
                  request.user_id(),
                  static_cast<int>(request.sync_feature()),
                  request.search_field().c_str(),
                  request.sort_field().c_str(),
                  rv);
        goto out;
    }
 out:
    LOG_CCDI_RESPONSE(response, rv);
    return rv;
}

CCDIError CCDIRegisterRemoteExecutable(const ccd::RegisterRemoteExecutableInput& request)
{
    LOG_CCDI_REQUEST(request);
#if CCD_ENABLE_STORAGE_NODE
    int rv = CCD_OK;
    CacheAutoLock autoLock;
    CachePlayer* user;

    rv = autoLock.LockForRead();
    if (rv < 0) {
        LOG_ERROR("Failed to obtain lock");
        goto out;
    }

    user = cache_getUserByUserId(request.user_id());
    if (user == NULL) {
        LOG_ERROR("userId "FMT_VPLUser_Id_t" not signed in", request.user_id());
        rv = CCD_ERROR_NOT_SIGNED_IN;
        goto out;
    }

    rv = RemoteExecutableManager_InsertOrUpdateExecutable(
            request.app_key(),
            request.remote_executable_info().name(),
            request.remote_executable_info().absolute_path(),
            request.remote_executable_info().version_num());
    if(rv != CCD_OK) {
        LOG_ERROR("Error in RemoteExecutableManager_InsertOrUpdateExecutable, rv = %d", rv);
    }
out:
#else
    CCDIError rv = CCD_ERROR_FEATURE_DISABLED;
#endif
    LOG_CCDI_RESPONSE(ccd::NoParamResponse::default_instance(), rv);
    return rv;
}

CCDIError CCDIUnregisterRemoteExecutable(const ccd::UnregisterRemoteExecutableInput& request)
{
    LOG_CCDI_REQUEST(request);
#if CCD_ENABLE_STORAGE_NODE
    int rv = CCD_OK;
    CacheAutoLock autoLock;
    CachePlayer* user;

    rv = autoLock.LockForRead();
    if (rv < 0) {
        LOG_ERROR("Failed to obtain lock");
        goto out;
    }

    user = cache_getUserByUserId(request.user_id());
    if (user == NULL) {
        LOG_ERROR("userId "FMT_VPLUser_Id_t" not signed in", request.user_id());
        rv = CCD_ERROR_NOT_SIGNED_IN;
        goto out;
    }

    rv = RemoteExecutableManager_RemoveExecutable(request.app_key(), request.remote_executable_name());
    if(rv != CCD_OK) {
        LOG_ERROR("Error in RemoteExecutableManager_RemoveExecutable, rv = %d", rv);
    }
out:
#else
    CCDIError rv = CCD_ERROR_FEATURE_DISABLED;
#endif
    LOG_CCDI_RESPONSE(ccd::NoParamResponse::default_instance(), rv);
    return rv;
}

CCDIError CCDIListRegisteredRemoteExecutables(const ccd::ListRegisteredRemoteExecutablesInput& request, ccd::ListRegisteredRemoteExecutablesOutput& response)
{
    LOG_CCDI_REQUEST(request);
#if CCD_ENABLE_STORAGE_NODE
    int rv = CCD_OK;
    std::vector<RemoteExecutable> output_remote_executables;
    CacheAutoLock autoLock;
    CachePlayer* user;

    rv = autoLock.LockForRead();
    if (rv < 0) {
        LOG_ERROR("Failed to obtain lock");
        goto out;
    }

    user = cache_getUserByUserId(request.user_id());
    if (user == NULL) {
        LOG_ERROR("userId "FMT_VPLUser_Id_t" not signed in", request.user_id());
        rv = CCD_ERROR_NOT_SIGNED_IN;
        goto out;
    }

    rv = RemoteExecutableManager_ListExecutables(request.app_key(), output_remote_executables);
    if(rv != CCD_OK) {
        LOG_ERROR("Error in RemoteExecutableManager_ListExecutables, rv = %d", rv);
    } else {
        for (unsigned int i = 0; i < output_remote_executables.size(); i++) {
            ccd::RemoteExecutableInfo* registered_remote_executable = response.add_registered_remote_executables();
            registered_remote_executable->set_name(output_remote_executables[i].name);
            registered_remote_executable->set_absolute_path(output_remote_executables[i].absolute_path);
            registered_remote_executable->set_version_num(output_remote_executables[i].version_num);
        }
    }
out:
#else
    CCDIError rv = CCD_ERROR_FEATURE_DISABLED;
#endif
    LOG_CCDI_RESPONSE(response, rv);
    return rv;
}

} // namespace client
} // namespace ccdi
